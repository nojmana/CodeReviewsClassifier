CHANGE-ID,REVISION-ID,FILENAME,CR AUTHOR = PR AUTHOR,DIFF-HUNK,message,purpose
66051792,cb8ac5c78b35d9b7b2680546b01c7664dc4a7c9b,buildenv/jenkins/README.md,False,"@@ -0,0 +1,194 @@
+[Eclipse OpenJ9 Jenkins Builds](https://ci.eclipse.org/openj9/)
+
+This folder contains Jenkins pipeline scripts that are used in the OpenJ9 Jenkins builds.
+
+### Triggering Pull Request Builds from Github
+
+- Current supported PR builds are ""Compile"", ""Compile & Sanity"", or ""Compile & Extended""
+- Current available platforms are Linux s390x and Linux PPCLE
+- OpenJ9 committers can request builds by commenting in a pull request
+- Request a build in a PR by commenting
+    - `Jenkins compile`
+    - `Jenkins test sanity`
+    - `Jenkins test extended`
+- Request a single platform instead of ""all""
+    - `Jenkins test sanity zlinux`
+    - `Jenkins test sanity plinux`
+- You can also request a ""Compile & Sanity"" build from an openj9-openjdk-jdk9 PR or an openj9-omr PR.
+
+##### Dependent Changes
+
+- If you have dependent change(s) in either eclipse/omr, eclipse/openj9-omr, or ibmruntimes/openj9-openjdk-jdk9, you can build & test with all needed changes
+- Request a build by including the PR ref in your trigger comment
+- Ex. Dependent change in OMR Pull Request `#123`
+    - `Jenkins test sanity depends eclipse/omr#123`
+- Ex. Dependent change in OpenJ9-OMR Pull Request `#456`
+    - `Jenkins test sanity depends eclipse/openj9-omr#456`
+- Ex. Dependent change in OpenJDK Pull Request `#789`
+    - `Jenkins test sanity depends ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. Dependent changes in OMR and OpenJDK
+    - `Jenkins test sanity depends eclipse/omr#123 ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. If you have a dependent change and only want one platform, depends comes last
+    - `Jenkins test sanity zlinux depends eclipse/omr#123`
+
+**Note:** Dependent changes can only be requested from an OpenJ9 Pull Request
+
+### Overview of Builds
+
+#### Build
+
+- Build-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Build-linux_390-64_cmprssptrs)
+    - Description:
+        - Compiles on linux_390-64_cmprssptrs
+        - Archives the SDK and test material
+    - Trigger:
+        - This job is used in other pipelines but can be launched manually
+
+- Build-linux_ppc-64_cmprssptrs_le
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_ppc-64_cmprssptrs_le)](https://ci.eclipse.org/openj9/job/Build-linux_ppc-64_cmprssptrs_le)
+    - Description
+        - Compiles on linux_ppc-64_cmprssptrs_le
+        - Archives the SDK and test material",same comment as line 44,same_as
97950113,8a31c328146c377e5ab9633c4e4e55a50a4e976b,buildenv/ansible/roles/openj9-build-environment/tasks/main.yml,True,"@@ -0,0 +1,134 @@
+###############################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+###############################################################################
+---
+- name: Create a build folder
+  file:
+    dest: ""{{ build_dir }}"" 
+    mode: 0755 
+    state: directory
+  tags:
+    - buildenv
+- name: Get Dockerfile for the building environment
+  get_url:
+    dest: ""{{ build_dir }}/Dockerfile-base""
+    url: ""https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/{{ version }}/{{ platform }}/ubuntu16/Dockerfile""
+    mode: 0644
+    validate_certs: no
+  tags:
+    - buildenv
+- name: Build the docker image for the building environment
+  docker_image:
+    path: ""{{ build_dir }}""
+    dockerfile: Dockerfile-base
+    name: ""openj9-{{ version }}-build""
+    tag: ""latest""
+    rm: yes
+    push: no
+  tags:
+    - buildenv
+- name: Create a build result folder
+  file:
+    dest: ""{{ host_dir }}"" 
+    mode: 0755 
+    state: directory
+  tags:
+    - buildenv
+- name: Start the building environment as a docker container 
+  docker_container:
+    name: ""openj9-{{ version }}-build""
+    image: ""openj9-{{ version }}-build:latest""
+    state: started
+    restart: yes # without restart, the container wouldn't be able to touch any file in the host_dir folder
+    interactive: yes # without interactive, the container would be stopped just after it has been started
+    volumes: ""{{ host_dir }}:/root/hostdir""
+  tags:
+    - buildenv
+- name: Get the ansible user
+  command: whoami
+  register: ansible_user
+  tags:
+    - buildenv
+    - build
+- name: Get the ansible uid
+  shell: ""id {{ ansible_user.stdout }} | awk -F'uid=' '{printf \""%d\"", $2}'""
+  register: ansible_uid
+  tags:
+    - buildenv
+- name: Get the ansible group
+  shell: ""groups {{ ansible_user.stdout }} | awk -F' ' '{printf \""%s\"", $3}'""
+  register: ansible_group
+  tags:
+    - buildenv
+    - build
+- name: Get the ansible gid
+  shell: ""id {{ ansible_user.stdout }} | awk -F'gid=' '{printf \""%d\"", $2}'""
+  register: ansible_gid
+  tags:
+    - buildenv
+- name: Add the container to inventory
+  add_host:      
+    name: ""openj9-{{ version }}-build""
+    ansible_connection: docker
+    ansible_user: root
+  changed_when: false
+  tags:
+    - buildenv
+    - build
+- name: Install python to container if there isn''t one",Changed to `name: Install python to the container if there is no one`.,discussion_participation
153579743,ceb4f8ee550dc226da6f35f78d1ef1a9d6ff5717,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/IPC.java,False,"@@ -261,7 +262,8 @@ static private native int createFileWithPermissionsImpl(String path,
 static String getTmpDir() {
 String tmpDir = getTempDirImpl();
 if (null == tmpDir) {
-tmpDir = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(""java.io.tmpdir""); //$NON-NLS-1$
+IPC.logMessage(""Could not get system temporary directory. Trying ""+JAVA_IO_TMPDIR); //$NON-NLS-1$
+tmpDir = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(JAVA_IO_TMPDIR); //$NON-NLS-1$",will this default to /tmp if not set?,discussion_trigger
153781741,bb012f54dd0ac114c5e6c0bbe2a0b3e7ac1d8370,runtime/compiler/p/runtime/PicBuilder.spp,True,"@@ -1017,6 +1023,70 @@ _interpreterUnresolvedStringGlue:
 b.L_patch_dword_load
 endproc._interpreterUnresolvedStringGlue:
 
+#ifdef AIXPPC
+._interpreterUnresolvedConstantDynamicGlue:
+   .function ._interpreterUnresolvedConstantDynamicGlue,startproc._interpreterUnresolvedConstantDynamicGlue,16,0,(endproc._interpreterUnresolvedConstantDynamicGlue-startproc._interpreterUnresolvedConstantDynamicGlue)
+#elif defined(LINUXPPC64)
+FUNC_LABEL(_interpreterUnresolvedConstantDynamicGlue):
+#else
+_interpreterUnresolvedConstantDynamicGlue:
+._interpreterUnresolvedConstantDynamicGlue:
+#endif
+startproc._interpreterUnresolvedConstantDynamicGlue:
+#include ""p/runtime/SaveGPRs.inc""
+mfcr    r0
+stw     r0,-4(J9SP)! Save CR also
+addi    J9SP,J9SP,-(33*ALen)
+mfsprr7, LR! Get the RA in snippet
+laddrRTOC, J9TR_VMThreadRTOCOffset(J9VM_STRUCT)! Restore RTOC
+#ifdef AIXPPC
+laddrr8, TOCjitResolveConstantDynamic(RTOC)! Load descriptor pointer
+laddrr8, 0(r8)! Load the callee address
+#elif defined(LINUXPPC64)
+laddrr8, TOCjitResolveConstantDynamic@toc(RTOC)! Load descriptor pointer
+#if !defined(__LITTLE_ENDIAN__)
+laddrr8, 0(r8)! Load the callee address
+#endif
+#else
+laddrr8, jitResolveConstantDynamic@got(RTOC)! Load the callee address
+#endif
+laddrr3, 1*ALen+4(r7)! Load constant pool literal
+lwzr4, 1*ALen(r7)! Load cp index for this field
+laddrr5, 0(r7)! Load code cache RA
+rlwinmr4, r4, 0, 5, 31! Masking off the flag bits
+addir5, r5, 1! Increament for EX search
+mtsprCTR, r8! Move callee address to CTR
+bcctrlBO_ALWAYS, CR0_LT! Call to resolve: RTOC, r7
+laddrr6, 0(r7)! Load code cache RA
+rlwinm  r17, r3, 0, 31, 31! keep in r17 if r3 last bit is set: <clinit> is being executed
+#ifdef TR_HOST_64BIT
+clrrdi r3, r3, 1                                        ! <clinit> clear up the last bit, which must be zero
+#else
+rlwinm  r3, r3, 0, 0xfffffffe                           ! <clinit> clear up the last bit, which must be zero
+#endif
+cmpicr0, 0, r17, in_clinit! <clinit> is being executed",Looks like all this weird indentation crept in from code that was copied from `_interpreterUnresolvedStringGlue`. I'll go ahead and clean it up a little bit...,discussion_participation
153788545,bb012f54dd0ac114c5e6c0bbe2a0b3e7ac1d8370,runtime/compiler/p/runtime/PicBuilder.spp,True,"@@ -1017,6 +1023,70 @@ _interpreterUnresolvedStringGlue:
 b.L_patch_dword_load
 endproc._interpreterUnresolvedStringGlue:
 
+#ifdef AIXPPC
+._interpreterUnresolvedConstantDynamicGlue:
+   .function ._interpreterUnresolvedConstantDynamicGlue,startproc._interpreterUnresolvedConstantDynamicGlue,16,0,(endproc._interpreterUnresolvedConstantDynamicGlue-startproc._interpreterUnresolvedConstantDynamicGlue)
+#elif defined(LINUXPPC64)
+FUNC_LABEL(_interpreterUnresolvedConstantDynamicGlue):
+#else
+_interpreterUnresolvedConstantDynamicGlue:
+._interpreterUnresolvedConstantDynamicGlue:
+#endif
+startproc._interpreterUnresolvedConstantDynamicGlue:
+#include ""p/runtime/SaveGPRs.inc""
+mfcr    r0
+stw     r0,-4(J9SP)! Save CR also
+addi    J9SP,J9SP,-(33*ALen)
+mfsprr7, LR! Get the RA in snippet
+laddrRTOC, J9TR_VMThreadRTOCOffset(J9VM_STRUCT)! Restore RTOC
+#ifdef AIXPPC
+laddrr8, TOCjitResolveConstantDynamic(RTOC)! Load descriptor pointer
+laddrr8, 0(r8)! Load the callee address
+#elif defined(LINUXPPC64)
+laddrr8, TOCjitResolveConstantDynamic@toc(RTOC)! Load descriptor pointer
+#if !defined(__LITTLE_ENDIAN__)
+laddrr8, 0(r8)! Load the callee address
+#endif
+#else
+laddrr8, jitResolveConstantDynamic@got(RTOC)! Load the callee address
+#endif
+laddrr3, 1*ALen+4(r7)! Load constant pool literal
+lwzr4, 1*ALen(r7)! Load cp index for this field
+laddrr5, 0(r7)! Load code cache RA
+rlwinmr4, r4, 0, 5, 31! Masking off the flag bits
+addir5, r5, 1! Increament for EX search
+mtsprCTR, r8! Move callee address to CTR
+bcctrlBO_ALWAYS, CR0_LT! Call to resolve: RTOC, r7
+laddrr6, 0(r7)! Load code cache RA
+rlwinm  r17, r3, 0, 31, 31! keep in r17 if r3 last bit is set: <clinit> is being executed
+#ifdef TR_HOST_64BIT
+clrrdi r3, r3, 1                                        ! <clinit> clear up the last bit, which must be zero
+#else
+rlwinm  r3, r3, 0, 0xfffffffe                           ! <clinit> clear up the last bit, which must be zero
+#endif
+cmpicr0, 0, r17, in_clinit! <clinit> is being executed","I've replaced all the tabs with spaces for now. I'm still not a big fan of the indentation, but I'm trying to keep it consistent with what's used in the other PicBuilder helpers.",discussion_participation
162897608,37c776acae06555995bf141eb25e5293dacdfa43,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,True,"@@ -11797,6 +11797,338 @@ static TR::Register *inlineEncodeUTF16(TR::Node *node, TR::CodeGenerator *cg)
    return outputLenReg;
    }
 
+static TR::Register *inlineIntrinsicIndexOf(TR::Node *node, bool isLatin1, TR::CodeGenerator *cg)
+   {
+   auto vectorCompareOp = isLatin1 ? TR::InstOpCode::vcmpeubr : TR::InstOpCode::vcmpeuhr;
+   auto scalarLoadOp = isLatin1 ? TR::InstOpCode::lbzx : TR::InstOpCode::lhzx;
+
+   TR::Register *arrObjectAddress = cg->evaluate(node->getChild(1));
+   TR::Register *targetScalar = cg->evaluate(node->getChild(2));
+   TR::Register *startIndex = cg->evaluate(node->getChild(3));
+   TR::Register *endIndex = cg->evaluate(node->getChild(4));
+
+   TR::Register *cr0 = cg->allocateRegister(TR_CCR);
+   TR::Register *cr6 = cg->allocateRegister(TR_CCR);
+
+   TR::Register *zeroRegister = cg->allocateRegister();
+   TR::Register *result = cg->allocateRegister();
+   TR::Register *arrAddress = cg->allocateRegister();
+   TR::Register *currentAddress = cg->allocateRegister();
+   TR::Register *endAddress = cg->allocateRegister();
+
+   TR::Register *targetVector = cg->allocateRegister(TR_VRF);
+   TR::Register *targetVectorNot = cg->allocateRegister(TR_VRF);
+   TR::Register *searchVector = cg->allocateRegister(TR_VRF);
+   TR::Register *permuteVector = cg->allocateRegister(TR_VRF);
+
+   TR_PPCScratchRegisterManager *srm = cg->generateScratchRegisterManager();
+
+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notSmallLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *vectorLoopLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *residueLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notFoundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundExactLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);
+
+   startLabel->setStartInternalControlFlow();
+   endLabel->setEndInternalControlFlow();
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);
+
+   // Special case for empty strings, which always return -1
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, startIndex, endIndex);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   if (!isLatin1)
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, startIndex, startIndex);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, endIndex, endIndex);
+      }
+   else
+      {
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, result, startIndex);
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, endAddress, endIndex);
+      }
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, arrAddress, arrObjectAddress, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());
+
+   // Handle the first character using a simple scalar compare. Otherwise, first character matches
+   // would be slower than the old scalar comparison loop. This is a problem since first character
+   // matches are common in certain contexts, e.g. StringTokenizer where the default first character
+   // to each String.indexOf call is ' ', which is the most common whitespace character.
+      {
+      TR::Register *value = srm->findOrCreateScratchRegister();
+
+      generateTrg1MemInstruction(cg, scalarLoadOp, node, value, new (cg->trHeapMemory()) TR::MemoryReference(arrAddress, result, isLatin1 ? 1 : 2, cg));
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, value, targetScalar);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, foundExactLabel, cr0);
+
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, isLatin1 ? 1 : 2);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, result, endAddress);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+      srm->reclaimScratchRegister(value);
+      }
+
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, zeroRegister, 0);
+
+   // Calculate the actual addresses of the start and end points
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, arrAddress, endAddress);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, currentAddress, arrAddress, result);
+
+   // Splat the value to be compared against and its bitwise complement into two vector registers
+   // for later use
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mtvsrwz, node, targetVector, targetScalar);
+   if (isLatin1)
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vspltb, node, targetVector, targetVector, 7);
+   else
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vsplth, node, targetVector, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vnor, node, targetVectorNot, targetVector, targetVector);
+
+   TR::Register *endVectorAddress = srm->findOrCreateScratchRegister();
+   TR::Register *startVectorAddress = srm->findOrCreateScratchRegister();
+
+   // Calculate the end address for what can be compared using full vector compares. After reaching
+   // this address, the remaining comparisons (if required) will need special handling.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, endVectorAddress, endAddress, 0, CONSTANT64(0xfffffffffffffff0));
+
+   // Check if the entire string is contained within a single 16-byte aligned section. If this
+   // happens, we need to handle that case specially.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, startVectorAddress, currentAddress, 0, CONSTANT64(0xfffffffffffffff0));
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, startVectorAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, notSmallLabel, cr0);
+
+   // If we got here, then the entire string to search is contained within a single 16-byte aligned
+   // vector and the end of the string is not aligned to the end of the vector. We don't know
+   // whether the start of the string is aligned, but we'll assume it isn't since that just results
+   // in a few unnecessary operations producing the correct answer regardless.
+
+   // First, we read in an entire 16-byte aligned vector containing the entire string. Since this
+   // load is done with 16-byte natural alignment, this load can't cross a page boundary and cause
+   // an unexpected page fault. However, this will read some garbage at the start and end of the
+   // vector. Assume that we read n bytes of garbage before the string and m bytes of garbage after
+   // the string.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+      {
+      TR::Register *scratchRegister = srm->findOrCreateScratchRegister();
+
+      // We need to ensure that the garbage we read can't compare as equal to the target value for
+      // obvious reasons. In order to accomplish this, we first rotate forwards by m bytes. This
+      // places all garbage at the beginning of the vector.
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, scratchRegister, endAddress);
+      generateTrg1Src2Instruction(cg, TR::Compiler->target.cpu.isLittleEndian() ? TR::InstOpCode::lvsl : TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+
+      // Next, we shift the vector backwards by (n + m) bytes shifting in the bitwise complement of
+      // the target value. This causes the garbage to end up at the vector register, having been
+      // replaced with a bit pattern that can never compare as equal to the target value.
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, scratchRegister, scratchRegister, currentAddress);
+      if (TR::Compiler->target.cpu.isLittleEndian())
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+         }
+      else
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+         }
+
+      srm->reclaimScratchRegister(scratchRegister);
+
+      // Now the search vector is ready for comparison: none of the garbage can compare as equal to
+      // our target value and the start of the vector is now aligned to the start of the string. So
+      // we can now perform the comparison as normal.
+      generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+      generateLabelInstruction(cg, TR::InstOpCode::b, node, notFoundLabel);
+      }
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notSmallLabel);
+
+   // Check if we already have 16-byte alignment. Vector loads require 16-byte alignment, so if we
+   // aren't properly aligned, we'll need to handle comparisons specially until we achieve 16-byte
+   // alignment.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, startVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, vectorLoopLabel, cr0);
+
+   // We are not on a 16-byte boundary, so we cannot directly load the first 16 bytes of the string
+   // for comparison. Instead, we load the 16 byte vector starting from the 16-byte aligned section
+   // containing the start of the string. Since we have 16-byte natural alignment, this can't cause
+   // an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   // However, before we can run any comparisons on the loaded vector, we must ensure that the extra
+   // garbage read before the start of the string can't match the target character. To do this, we
+   // shift the loaded vector backwards by n bytes shifting in the bitwise complement of the target
+   // character.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   // Now our vector is ready for comparison: no garbage can match the target value and the start of
+   // the vector is now aligned to the start of the string.
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   // If the first vector didn't match, then we can slide right into the standard vectorized loop.
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, startVectorAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, residueLabel, cr0);
+
+   srm->reclaimScratchRegister(startVectorAddress);
+
+   // This is the heart of the vectorized loop, working just like any standard vectorized loop.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, vectorLoopLabel);
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, currentAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, vectorLoopLabel, cr0);
+
+   srm->reclaimScratchRegister(endVectorAddress);
+
+   // Now we're done with the part of the loop which can be handled as a normal vectorized loop. If
+   // there are no more elements to compare, we're done. Otherwise, we need to handle the residue.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, residueLabel);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   // Usually, we would need a residue loop here, but it's safe to read beyond the end of the string
+   // here. Since our load will have 16-byte natural alignment, it can't cross a page boundary and
+   // cause an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   TR::Register *shiftAmount = srm->findOrCreateScratchRegister();
+
+   // Before we can run our comparison, we need to ensure that the garbage from beyond the end of
+   // the string cannot compare as equal to our target value. To do this, we first rotate the vector
+   // forwards by n bytes then shift back by n bytes, shifting in the bitwise complement of the
+   // target value.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, shiftAmount, endAddress);
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   srm->reclaimScratchRegister(shiftAmount);
+
+   // Now we run our comparison as normal
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   srm->donateScratchRegister(targetVector);
+   srm->donateScratchRegister(targetVectorNot);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notFoundLabel);
+
+   // We've looked through the entire string and didn't find our target character, so return the
+   // sentinel value -1
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, result, -1);
+   generateLabelInstruction(cg, TR::InstOpCode::b, node, endLabel);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, foundLabel);
+
+   // We've managed to find a match for the target value in the loaded vector, but we don't yet know
+   // which element of the loaded vector is the first match. The comparison will have set matching
+   // elements in the vector to -1 and non-matching elements to 0. We can find the first matching
+   // element by gathering the first bit of every byte in the vector register...
+
+   // Set permuteVector = 0x000102030405060708090a0b0c0d0e0f
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, zeroRegister);
+
+   // For little-endian, reverse permuteVector so that we can find the first set bit using a count
+   // leading zeroes test instead of a count trailing zeroes test. This is necessary since cnttzw
+   // wasn't introduced until Power 9.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 0x0f);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::vsububm, node, permuteVector, targetVector, permuteVector);
+      }
+
+   // Set permuteVector = 0x00081018202830384048505860687078 (reversed for LE)
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vslb, node, permuteVector, permuteVector, targetVector);
+
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vbpermq, node, searchVector, searchVector, permuteVector);
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mfvsrwz, node, result, searchVector);
+
+   // Then count the number of leading zeroes from the obtained result. This tells us the index (in
+   // bytes) of the first matching element in the vector. Note that there is no way to count leading
+   // zeroes of a half-word, so we count leading zeroes of a word and subtract 16 since the value
+   // we're interested in is in the least significant half-word.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::cntlzw, node, result, result);
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, -16);
+
+   // Finally, combine this with the address of the last vector load to find the address of the
+   // first matching element in the string. Finally, use this to calculate the corresponding index.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, result, currentAddress);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::subf, node, result, arrAddress, result);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, foundExactLabel);
+   if (!isLatin1)
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::srawi, node, result, result, 1);
+
+      {
+      TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 14 + srm->numAvailableRegisters(), cg->trMemory());
+
+      deps->addPostCondition(arrAddress, TR::RealRegister::NoReg);
+      deps->addPostCondition(targetScalar, TR::RealRegister::NoReg);
+      deps->addPostCondition(startIndex, TR::RealRegister::NoReg);
+      deps->addPostCondition(endIndex, TR::RealRegister::NoReg);
+
+      deps->addPostCondition(cr0, TR::RealRegister::cr0);
+      deps->addPostCondition(cr6, TR::RealRegister::cr6);
+
+      deps->addPostCondition(zeroRegister, TR::RealRegister::NoReg);
+      deps->addPostCondition(result, TR::RealRegister::NoReg);
+      deps->addPostCondition(currentAddress, TR::RealRegister::NoReg);
+      deps->addPostCondition(endAddress, TR::RealRegister::NoReg);
+
+      deps->addPostCondition(targetVector, TR::RealRegister::NoReg);
+      deps->addPostCondition(targetVectorNot, TR::RealRegister::NoReg);
+      deps->addPostCondition(searchVector, TR::RealRegister::NoReg);
+      deps->addPostCondition(permuteVector, TR::RealRegister::NoReg);
+","1. My bad, I meant to go through and mark registers as excluding gr0 as necessary before submitting but forgot. Will fix this.
2. I think it should be possible for me to check if `targetScalar`, `startIndex`, or `endIndex` won't be reused by checking the child refcount and donate them to the scratch register manager after use if that holds. I'm not sure whether I can do that for `arrObjectAddress` though, since it's marked as containing a collected reference and I don't know enough about how that works to say whether that would be safe or not.
3. As I've said before, the drop in speedup between 7th and 8th character matches has nothing to do with the new vectorized code becoming slower there and is instead caused by the old code unexpectedly becoming faster.",discussion_participation
162928317,37c776acae06555995bf141eb25e5293dacdfa43,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,True,"@@ -11797,6 +11797,338 @@ static TR::Register *inlineEncodeUTF16(TR::Node *node, TR::CodeGenerator *cg)
    return outputLenReg;
    }
 
+static TR::Register *inlineIntrinsicIndexOf(TR::Node *node, bool isLatin1, TR::CodeGenerator *cg)
+   {
+   auto vectorCompareOp = isLatin1 ? TR::InstOpCode::vcmpeubr : TR::InstOpCode::vcmpeuhr;
+   auto scalarLoadOp = isLatin1 ? TR::InstOpCode::lbzx : TR::InstOpCode::lhzx;
+
+   TR::Register *arrObjectAddress = cg->evaluate(node->getChild(1));
+   TR::Register *targetScalar = cg->evaluate(node->getChild(2));
+   TR::Register *startIndex = cg->evaluate(node->getChild(3));
+   TR::Register *endIndex = cg->evaluate(node->getChild(4));
+
+   TR::Register *cr0 = cg->allocateRegister(TR_CCR);
+   TR::Register *cr6 = cg->allocateRegister(TR_CCR);
+
+   TR::Register *zeroRegister = cg->allocateRegister();
+   TR::Register *result = cg->allocateRegister();
+   TR::Register *arrAddress = cg->allocateRegister();
+   TR::Register *currentAddress = cg->allocateRegister();
+   TR::Register *endAddress = cg->allocateRegister();
+
+   TR::Register *targetVector = cg->allocateRegister(TR_VRF);
+   TR::Register *targetVectorNot = cg->allocateRegister(TR_VRF);
+   TR::Register *searchVector = cg->allocateRegister(TR_VRF);
+   TR::Register *permuteVector = cg->allocateRegister(TR_VRF);
+
+   TR_PPCScratchRegisterManager *srm = cg->generateScratchRegisterManager();
+
+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notSmallLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *vectorLoopLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *residueLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notFoundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundExactLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);
+
+   startLabel->setStartInternalControlFlow();
+   endLabel->setEndInternalControlFlow();
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);
+
+   // Special case for empty strings, which always return -1
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, startIndex, endIndex);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   if (!isLatin1)
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, startIndex, startIndex);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, endIndex, endIndex);
+      }
+   else
+      {
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, result, startIndex);
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, endAddress, endIndex);
+      }
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, arrAddress, arrObjectAddress, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());
+
+   // Handle the first character using a simple scalar compare. Otherwise, first character matches
+   // would be slower than the old scalar comparison loop. This is a problem since first character
+   // matches are common in certain contexts, e.g. StringTokenizer where the default first character
+   // to each String.indexOf call is ' ', which is the most common whitespace character.
+      {
+      TR::Register *value = srm->findOrCreateScratchRegister();
+
+      generateTrg1MemInstruction(cg, scalarLoadOp, node, value, new (cg->trHeapMemory()) TR::MemoryReference(arrAddress, result, isLatin1 ? 1 : 2, cg));
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, value, targetScalar);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, foundExactLabel, cr0);
+
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, isLatin1 ? 1 : 2);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, result, endAddress);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+      srm->reclaimScratchRegister(value);
+      }
+
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, zeroRegister, 0);
+
+   // Calculate the actual addresses of the start and end points
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, arrAddress, endAddress);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, currentAddress, arrAddress, result);
+
+   // Splat the value to be compared against and its bitwise complement into two vector registers
+   // for later use
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mtvsrwz, node, targetVector, targetScalar);
+   if (isLatin1)
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vspltb, node, targetVector, targetVector, 7);
+   else
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vsplth, node, targetVector, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vnor, node, targetVectorNot, targetVector, targetVector);
+
+   TR::Register *endVectorAddress = srm->findOrCreateScratchRegister();
+   TR::Register *startVectorAddress = srm->findOrCreateScratchRegister();
+
+   // Calculate the end address for what can be compared using full vector compares. After reaching
+   // this address, the remaining comparisons (if required) will need special handling.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, endVectorAddress, endAddress, 0, CONSTANT64(0xfffffffffffffff0));
+
+   // Check if the entire string is contained within a single 16-byte aligned section. If this
+   // happens, we need to handle that case specially.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, startVectorAddress, currentAddress, 0, CONSTANT64(0xfffffffffffffff0));
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, startVectorAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, notSmallLabel, cr0);
+
+   // If we got here, then the entire string to search is contained within a single 16-byte aligned
+   // vector and the end of the string is not aligned to the end of the vector. We don't know
+   // whether the start of the string is aligned, but we'll assume it isn't since that just results
+   // in a few unnecessary operations producing the correct answer regardless.
+
+   // First, we read in an entire 16-byte aligned vector containing the entire string. Since this
+   // load is done with 16-byte natural alignment, this load can't cross a page boundary and cause
+   // an unexpected page fault. However, this will read some garbage at the start and end of the
+   // vector. Assume that we read n bytes of garbage before the string and m bytes of garbage after
+   // the string.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+      {
+      TR::Register *scratchRegister = srm->findOrCreateScratchRegister();
+
+      // We need to ensure that the garbage we read can't compare as equal to the target value for
+      // obvious reasons. In order to accomplish this, we first rotate forwards by m bytes. This
+      // places all garbage at the beginning of the vector.
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, scratchRegister, endAddress);
+      generateTrg1Src2Instruction(cg, TR::Compiler->target.cpu.isLittleEndian() ? TR::InstOpCode::lvsl : TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+
+      // Next, we shift the vector backwards by (n + m) bytes shifting in the bitwise complement of
+      // the target value. This causes the garbage to end up at the vector register, having been
+      // replaced with a bit pattern that can never compare as equal to the target value.
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, scratchRegister, scratchRegister, currentAddress);
+      if (TR::Compiler->target.cpu.isLittleEndian())
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+         }
+      else
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+         }
+
+      srm->reclaimScratchRegister(scratchRegister);
+
+      // Now the search vector is ready for comparison: none of the garbage can compare as equal to
+      // our target value and the start of the vector is now aligned to the start of the string. So
+      // we can now perform the comparison as normal.
+      generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+      generateLabelInstruction(cg, TR::InstOpCode::b, node, notFoundLabel);
+      }
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notSmallLabel);
+
+   // Check if we already have 16-byte alignment. Vector loads require 16-byte alignment, so if we
+   // aren't properly aligned, we'll need to handle comparisons specially until we achieve 16-byte
+   // alignment.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, startVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, vectorLoopLabel, cr0);
+
+   // We are not on a 16-byte boundary, so we cannot directly load the first 16 bytes of the string
+   // for comparison. Instead, we load the 16 byte vector starting from the 16-byte aligned section
+   // containing the start of the string. Since we have 16-byte natural alignment, this can't cause
+   // an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   // However, before we can run any comparisons on the loaded vector, we must ensure that the extra
+   // garbage read before the start of the string can't match the target character. To do this, we
+   // shift the loaded vector backwards by n bytes shifting in the bitwise complement of the target
+   // character.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   // Now our vector is ready for comparison: no garbage can match the target value and the start of
+   // the vector is now aligned to the start of the string.
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   // If the first vector didn't match, then we can slide right into the standard vectorized loop.
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, startVectorAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, residueLabel, cr0);
+
+   srm->reclaimScratchRegister(startVectorAddress);
+
+   // This is the heart of the vectorized loop, working just like any standard vectorized loop.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, vectorLoopLabel);
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, currentAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, vectorLoopLabel, cr0);
+
+   srm->reclaimScratchRegister(endVectorAddress);
+
+   // Now we're done with the part of the loop which can be handled as a normal vectorized loop. If
+   // there are no more elements to compare, we're done. Otherwise, we need to handle the residue.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, residueLabel);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   // Usually, we would need a residue loop here, but it's safe to read beyond the end of the string
+   // here. Since our load will have 16-byte natural alignment, it can't cross a page boundary and
+   // cause an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   TR::Register *shiftAmount = srm->findOrCreateScratchRegister();
+
+   // Before we can run our comparison, we need to ensure that the garbage from beyond the end of
+   // the string cannot compare as equal to our target value. To do this, we first rotate the vector
+   // forwards by n bytes then shift back by n bytes, shifting in the bitwise complement of the
+   // target value.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, shiftAmount, endAddress);
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   srm->reclaimScratchRegister(shiftAmount);
+
+   // Now we run our comparison as normal
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   srm->donateScratchRegister(targetVector);
+   srm->donateScratchRegister(targetVectorNot);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notFoundLabel);
+
+   // We've looked through the entire string and didn't find our target character, so return the
+   // sentinel value -1
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, result, -1);
+   generateLabelInstruction(cg, TR::InstOpCode::b, node, endLabel);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, foundLabel);
+
+   // We've managed to find a match for the target value in the loaded vector, but we don't yet know
+   // which element of the loaded vector is the first match. The comparison will have set matching
+   // elements in the vector to -1 and non-matching elements to 0. We can find the first matching
+   // element by gathering the first bit of every byte in the vector register...
+
+   // Set permuteVector = 0x000102030405060708090a0b0c0d0e0f
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, zeroRegister);
+
+   // For little-endian, reverse permuteVector so that we can find the first set bit using a count
+   // leading zeroes test instead of a count trailing zeroes test. This is necessary since cnttzw
+   // wasn't introduced until Power 9.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 0x0f);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::vsububm, node, permuteVector, targetVector, permuteVector);
+      }
+
+   // Set permuteVector = 0x00081018202830384048505860687078 (reversed for LE)
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vslb, node, permuteVector, permuteVector, targetVector);
+
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vbpermq, node, searchVector, searchVector, permuteVector);
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mfvsrwz, node, result, searchVector);
+
+   // Then count the number of leading zeroes from the obtained result. This tells us the index (in
+   // bytes) of the first matching element in the vector. Note that there is no way to count leading
+   // zeroes of a half-word, so we count leading zeroes of a word and subtract 16 since the value
+   // we're interested in is in the least significant half-word.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::cntlzw, node, result, result);
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, -16);
+
+   // Finally, combine this with the address of the last vector load to find the address of the
+   // first matching element in the string. Finally, use this to calculate the corresponding index.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, result, currentAddress);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::subf, node, result, arrAddress, result);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, foundExactLabel);
+   if (!isLatin1)
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::srawi, node, result, result, 1);
+
+      {
+      TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 14 + srm->numAvailableRegisters(), cg->trMemory());
+
+      deps->addPostCondition(arrAddress, TR::RealRegister::NoReg);
+      deps->addPostCondition(targetScalar, TR::RealRegister::NoReg);
+      deps->addPostCondition(startIndex, TR::RealRegister::NoReg);
+      deps->addPostCondition(endIndex, TR::RealRegister::NoReg);
+
+      deps->addPostCondition(cr0, TR::RealRegister::cr0);
+      deps->addPostCondition(cr6, TR::RealRegister::cr6);
+
+      deps->addPostCondition(zeroRegister, TR::RealRegister::NoReg);
+      deps->addPostCondition(result, TR::RealRegister::NoReg);
+      deps->addPostCondition(currentAddress, TR::RealRegister::NoReg);
+      deps->addPostCondition(endAddress, TR::RealRegister::NoReg);
+
+      deps->addPostCondition(targetVector, TR::RealRegister::NoReg);
+      deps->addPostCondition(targetVectorNot, TR::RealRegister::NoReg);
+      deps->addPostCondition(searchVector, TR::RealRegister::NoReg);
+      deps->addPostCondition(permuteVector, TR::RealRegister::NoReg);
+","1 and 2 should be fixed now. As for 3, since the problem seems to be related to something about the scalar version, I think it's out of scope for this work and should be dealt with as an entirely separate matter (if it needs followup at all).",acknowledgement
163012003,37c776acae06555995bf141eb25e5293dacdfa43,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,True,"@@ -11797,6 +11797,338 @@ static TR::Register *inlineEncodeUTF16(TR::Node *node, TR::CodeGenerator *cg)
    return outputLenReg;
    }
 
+static TR::Register *inlineIntrinsicIndexOf(TR::Node *node, bool isLatin1, TR::CodeGenerator *cg)
+   {
+   auto vectorCompareOp = isLatin1 ? TR::InstOpCode::vcmpeubr : TR::InstOpCode::vcmpeuhr;
+   auto scalarLoadOp = isLatin1 ? TR::InstOpCode::lbzx : TR::InstOpCode::lhzx;
+
+   TR::Register *arrObjectAddress = cg->evaluate(node->getChild(1));
+   TR::Register *targetScalar = cg->evaluate(node->getChild(2));
+   TR::Register *startIndex = cg->evaluate(node->getChild(3));
+   TR::Register *endIndex = cg->evaluate(node->getChild(4));
+
+   TR::Register *cr0 = cg->allocateRegister(TR_CCR);
+   TR::Register *cr6 = cg->allocateRegister(TR_CCR);
+
+   TR::Register *zeroRegister = cg->allocateRegister();
+   TR::Register *result = cg->allocateRegister();
+   TR::Register *arrAddress = cg->allocateRegister();
+   TR::Register *currentAddress = cg->allocateRegister();
+   TR::Register *endAddress = cg->allocateRegister();
+
+   TR::Register *targetVector = cg->allocateRegister(TR_VRF);
+   TR::Register *targetVectorNot = cg->allocateRegister(TR_VRF);
+   TR::Register *searchVector = cg->allocateRegister(TR_VRF);
+   TR::Register *permuteVector = cg->allocateRegister(TR_VRF);
+
+   TR_PPCScratchRegisterManager *srm = cg->generateScratchRegisterManager();
+
+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notSmallLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *vectorLoopLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *residueLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notFoundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundExactLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);
+
+   startLabel->setStartInternalControlFlow();
+   endLabel->setEndInternalControlFlow();
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);
+
+   // Special case for empty strings, which always return -1
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, startIndex, endIndex);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   if (!isLatin1)
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, startIndex, startIndex);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, endIndex, endIndex);
+      }
+   else
+      {
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, result, startIndex);
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, endAddress, endIndex);
+      }
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, arrAddress, arrObjectAddress, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());
+
+   // Handle the first character using a simple scalar compare. Otherwise, first character matches
+   // would be slower than the old scalar comparison loop. This is a problem since first character
+   // matches are common in certain contexts, e.g. StringTokenizer where the default first character
+   // to each String.indexOf call is ' ', which is the most common whitespace character.
+      {
+      TR::Register *value = srm->findOrCreateScratchRegister();
+
+      generateTrg1MemInstruction(cg, scalarLoadOp, node, value, new (cg->trHeapMemory()) TR::MemoryReference(arrAddress, result, isLatin1 ? 1 : 2, cg));
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, value, targetScalar);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, foundExactLabel, cr0);
+
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, isLatin1 ? 1 : 2);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, result, endAddress);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+      srm->reclaimScratchRegister(value);
+      }
+
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, zeroRegister, 0);
+
+   // Calculate the actual addresses of the start and end points
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, arrAddress, endAddress);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, currentAddress, arrAddress, result);
+
+   // Splat the value to be compared against and its bitwise complement into two vector registers
+   // for later use
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mtvsrwz, node, targetVector, targetScalar);
+   if (isLatin1)
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vspltb, node, targetVector, targetVector, 7);
+   else
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vsplth, node, targetVector, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vnor, node, targetVectorNot, targetVector, targetVector);
+
+   TR::Register *endVectorAddress = srm->findOrCreateScratchRegister();
+   TR::Register *startVectorAddress = srm->findOrCreateScratchRegister();
+
+   // Calculate the end address for what can be compared using full vector compares. After reaching
+   // this address, the remaining comparisons (if required) will need special handling.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, endVectorAddress, endAddress, 0, CONSTANT64(0xfffffffffffffff0));
+
+   // Check if the entire string is contained within a single 16-byte aligned section. If this
+   // happens, we need to handle that case specially.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, startVectorAddress, currentAddress, 0, CONSTANT64(0xfffffffffffffff0));
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, startVectorAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, notSmallLabel, cr0);
+
+   // If we got here, then the entire string to search is contained within a single 16-byte aligned
+   // vector and the end of the string is not aligned to the end of the vector. We don't know
+   // whether the start of the string is aligned, but we'll assume it isn't since that just results
+   // in a few unnecessary operations producing the correct answer regardless.
+
+   // First, we read in an entire 16-byte aligned vector containing the entire string. Since this
+   // load is done with 16-byte natural alignment, this load can't cross a page boundary and cause
+   // an unexpected page fault. However, this will read some garbage at the start and end of the
+   // vector. Assume that we read n bytes of garbage before the string and m bytes of garbage after
+   // the string.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+      {
+      TR::Register *scratchRegister = srm->findOrCreateScratchRegister();
+
+      // We need to ensure that the garbage we read can't compare as equal to the target value for
+      // obvious reasons. In order to accomplish this, we first rotate forwards by m bytes. This
+      // places all garbage at the beginning of the vector.
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, scratchRegister, endAddress);
+      generateTrg1Src2Instruction(cg, TR::Compiler->target.cpu.isLittleEndian() ? TR::InstOpCode::lvsl : TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+
+      // Next, we shift the vector backwards by (n + m) bytes shifting in the bitwise complement of
+      // the target value. This causes the garbage to end up at the vector register, having been
+      // replaced with a bit pattern that can never compare as equal to the target value.
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, scratchRegister, scratchRegister, currentAddress);
+      if (TR::Compiler->target.cpu.isLittleEndian())
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+         }
+      else
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+         }
+
+      srm->reclaimScratchRegister(scratchRegister);
+
+      // Now the search vector is ready for comparison: none of the garbage can compare as equal to
+      // our target value and the start of the vector is now aligned to the start of the string. So
+      // we can now perform the comparison as normal.
+      generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+      generateLabelInstruction(cg, TR::InstOpCode::b, node, notFoundLabel);
+      }
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notSmallLabel);
+
+   // Check if we already have 16-byte alignment. Vector loads require 16-byte alignment, so if we
+   // aren't properly aligned, we'll need to handle comparisons specially until we achieve 16-byte
+   // alignment.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, startVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, vectorLoopLabel, cr0);
+
+   // We are not on a 16-byte boundary, so we cannot directly load the first 16 bytes of the string
+   // for comparison. Instead, we load the 16 byte vector starting from the 16-byte aligned section
+   // containing the start of the string. Since we have 16-byte natural alignment, this can't cause
+   // an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   // However, before we can run any comparisons on the loaded vector, we must ensure that the extra
+   // garbage read before the start of the string can't match the target character. To do this, we
+   // shift the loaded vector backwards by n bytes shifting in the bitwise complement of the target
+   // character.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   // Now our vector is ready for comparison: no garbage can match the target value and the start of
+   // the vector is now aligned to the start of the string.
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   // If the first vector didn't match, then we can slide right into the standard vectorized loop.
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, startVectorAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, residueLabel, cr0);
+
+   srm->reclaimScratchRegister(startVectorAddress);
+
+   // This is the heart of the vectorized loop, working just like any standard vectorized loop.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, vectorLoopLabel);
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, currentAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, vectorLoopLabel, cr0);
+
+   srm->reclaimScratchRegister(endVectorAddress);
+
+   // Now we're done with the part of the loop which can be handled as a normal vectorized loop. If
+   // there are no more elements to compare, we're done. Otherwise, we need to handle the residue.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, residueLabel);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   // Usually, we would need a residue loop here, but it's safe to read beyond the end of the string
+   // here. Since our load will have 16-byte natural alignment, it can't cross a page boundary and
+   // cause an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   TR::Register *shiftAmount = srm->findOrCreateScratchRegister();
+
+   // Before we can run our comparison, we need to ensure that the garbage from beyond the end of
+   // the string cannot compare as equal to our target value. To do this, we first rotate the vector
+   // forwards by n bytes then shift back by n bytes, shifting in the bitwise complement of the
+   // target value.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, shiftAmount, endAddress);
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   srm->reclaimScratchRegister(shiftAmount);
+
+   // Now we run our comparison as normal
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   srm->donateScratchRegister(targetVector);
+   srm->donateScratchRegister(targetVectorNot);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notFoundLabel);
+
+   // We've looked through the entire string and didn't find our target character, so return the
+   // sentinel value -1
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, result, -1);
+   generateLabelInstruction(cg, TR::InstOpCode::b, node, endLabel);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, foundLabel);
+
+   // We've managed to find a match for the target value in the loaded vector, but we don't yet know
+   // which element of the loaded vector is the first match. The comparison will have set matching
+   // elements in the vector to -1 and non-matching elements to 0. We can find the first matching
+   // element by gathering the first bit of every byte in the vector register...
+
+   // Set permuteVector = 0x000102030405060708090a0b0c0d0e0f
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, zeroRegister);
+
+   // For little-endian, reverse permuteVector so that we can find the first set bit using a count
+   // leading zeroes test instead of a count trailing zeroes test. This is necessary since cnttzw
+   // wasn't introduced until Power 9.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 0x0f);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::vsububm, node, permuteVector, targetVector, permuteVector);
+      }
+
+   // Set permuteVector = 0x00081018202830384048505860687078 (reversed for LE)
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vslb, node, permuteVector, permuteVector, targetVector);
+
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vbpermq, node, searchVector, searchVector, permuteVector);
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mfvsrwz, node, result, searchVector);
+
+   // Then count the number of leading zeroes from the obtained result. This tells us the index (in
+   // bytes) of the first matching element in the vector. Note that there is no way to count leading
+   // zeroes of a half-word, so we count leading zeroes of a word and subtract 16 since the value
+   // we're interested in is in the least significant half-word.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::cntlzw, node, result, result);
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, -16);
+
+   // Finally, combine this with the address of the last vector load to find the address of the
+   // first matching element in the string. Finally, use this to calculate the corresponding index.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, result, currentAddress);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::subf, node, result, arrAddress, result);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, foundExactLabel);
+   if (!isLatin1)
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::srawi, node, result, result, 1);
+
+      {
+      TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 14 + srm->numAvailableRegisters(), cg->trMemory());
+
+      deps->addPostCondition(arrAddress, TR::RealRegister::NoReg);
+      deps->addPostCondition(targetScalar, TR::RealRegister::NoReg);
+      deps->addPostCondition(startIndex, TR::RealRegister::NoReg);
+      deps->addPostCondition(endIndex, TR::RealRegister::NoReg);
+
+      deps->addPostCondition(cr0, TR::RealRegister::cr0);
+      deps->addPostCondition(cr6, TR::RealRegister::cr6);
+
+      deps->addPostCondition(zeroRegister, TR::RealRegister::NoReg);
+      deps->addPostCondition(result, TR::RealRegister::NoReg);
+      deps->addPostCondition(currentAddress, TR::RealRegister::NoReg);
+      deps->addPostCondition(endAddress, TR::RealRegister::NoReg);
+
+      deps->addPostCondition(targetVector, TR::RealRegister::NoReg);
+      deps->addPostCondition(targetVectorNot, TR::RealRegister::NoReg);
+      deps->addPostCondition(searchVector, TR::RealRegister::NoReg);
+      deps->addPostCondition(permuteVector, TR::RealRegister::NoReg);
+","Looked back at the code for `TR_PPCScratchRegisterManager` and it seems I got confused since `srm->stopUsingRegisters()` ignores donated registers but `srm->addScratchRegistersToDependencyList(...)` does not. I'll go ahead and fix that.

As for the 0th child, that child is simply a `JITHelpers` object on which the helper is being called. Its only reason for existing is to be checked against `null` to ensure that untrusted code cannot call these helpers unsafely since they can't get a reference to one.",acknowledgement
163020374,37c776acae06555995bf141eb25e5293dacdfa43,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,True,"@@ -11797,6 +11797,338 @@ static TR::Register *inlineEncodeUTF16(TR::Node *node, TR::CodeGenerator *cg)
    return outputLenReg;
    }
 
+static TR::Register *inlineIntrinsicIndexOf(TR::Node *node, bool isLatin1, TR::CodeGenerator *cg)
+   {
+   auto vectorCompareOp = isLatin1 ? TR::InstOpCode::vcmpeubr : TR::InstOpCode::vcmpeuhr;
+   auto scalarLoadOp = isLatin1 ? TR::InstOpCode::lbzx : TR::InstOpCode::lhzx;
+
+   TR::Register *arrObjectAddress = cg->evaluate(node->getChild(1));
+   TR::Register *targetScalar = cg->evaluate(node->getChild(2));
+   TR::Register *startIndex = cg->evaluate(node->getChild(3));
+   TR::Register *endIndex = cg->evaluate(node->getChild(4));
+
+   TR::Register *cr0 = cg->allocateRegister(TR_CCR);
+   TR::Register *cr6 = cg->allocateRegister(TR_CCR);
+
+   TR::Register *zeroRegister = cg->allocateRegister();
+   TR::Register *result = cg->allocateRegister();
+   TR::Register *arrAddress = cg->allocateRegister();
+   TR::Register *currentAddress = cg->allocateRegister();
+   TR::Register *endAddress = cg->allocateRegister();
+
+   TR::Register *targetVector = cg->allocateRegister(TR_VRF);
+   TR::Register *targetVectorNot = cg->allocateRegister(TR_VRF);
+   TR::Register *searchVector = cg->allocateRegister(TR_VRF);
+   TR::Register *permuteVector = cg->allocateRegister(TR_VRF);
+
+   TR_PPCScratchRegisterManager *srm = cg->generateScratchRegisterManager();
+
+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notSmallLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *vectorLoopLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *residueLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notFoundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundExactLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);
+
+   startLabel->setStartInternalControlFlow();
+   endLabel->setEndInternalControlFlow();
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);
+
+   // Special case for empty strings, which always return -1
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, startIndex, endIndex);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   if (!isLatin1)
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, startIndex, startIndex);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, endIndex, endIndex);
+      }
+   else
+      {
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, result, startIndex);
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, endAddress, endIndex);
+      }
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, arrAddress, arrObjectAddress, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());
+
+   // Handle the first character using a simple scalar compare. Otherwise, first character matches
+   // would be slower than the old scalar comparison loop. This is a problem since first character
+   // matches are common in certain contexts, e.g. StringTokenizer where the default first character
+   // to each String.indexOf call is ' ', which is the most common whitespace character.
+      {
+      TR::Register *value = srm->findOrCreateScratchRegister();
+
+      generateTrg1MemInstruction(cg, scalarLoadOp, node, value, new (cg->trHeapMemory()) TR::MemoryReference(arrAddress, result, isLatin1 ? 1 : 2, cg));
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, value, targetScalar);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, foundExactLabel, cr0);
+
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, isLatin1 ? 1 : 2);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, result, endAddress);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+      srm->reclaimScratchRegister(value);
+      }
+
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, zeroRegister, 0);
+
+   // Calculate the actual addresses of the start and end points
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, arrAddress, endAddress);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, currentAddress, arrAddress, result);
+
+   // Splat the value to be compared against and its bitwise complement into two vector registers
+   // for later use
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mtvsrwz, node, targetVector, targetScalar);
+   if (isLatin1)
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vspltb, node, targetVector, targetVector, 7);
+   else
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vsplth, node, targetVector, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vnor, node, targetVectorNot, targetVector, targetVector);
+
+   TR::Register *endVectorAddress = srm->findOrCreateScratchRegister();
+   TR::Register *startVectorAddress = srm->findOrCreateScratchRegister();
+
+   // Calculate the end address for what can be compared using full vector compares. After reaching
+   // this address, the remaining comparisons (if required) will need special handling.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, endVectorAddress, endAddress, 0, CONSTANT64(0xfffffffffffffff0));
+
+   // Check if the entire string is contained within a single 16-byte aligned section. If this
+   // happens, we need to handle that case specially.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, startVectorAddress, currentAddress, 0, CONSTANT64(0xfffffffffffffff0));
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, startVectorAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, notSmallLabel, cr0);
+
+   // If we got here, then the entire string to search is contained within a single 16-byte aligned
+   // vector and the end of the string is not aligned to the end of the vector. We don't know
+   // whether the start of the string is aligned, but we'll assume it isn't since that just results
+   // in a few unnecessary operations producing the correct answer regardless.
+
+   // First, we read in an entire 16-byte aligned vector containing the entire string. Since this
+   // load is done with 16-byte natural alignment, this load can't cross a page boundary and cause
+   // an unexpected page fault. However, this will read some garbage at the start and end of the
+   // vector. Assume that we read n bytes of garbage before the string and m bytes of garbage after
+   // the string.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+      {
+      TR::Register *scratchRegister = srm->findOrCreateScratchRegister();
+
+      // We need to ensure that the garbage we read can't compare as equal to the target value for
+      // obvious reasons. In order to accomplish this, we first rotate forwards by m bytes. This
+      // places all garbage at the beginning of the vector.
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, scratchRegister, endAddress);
+      generateTrg1Src2Instruction(cg, TR::Compiler->target.cpu.isLittleEndian() ? TR::InstOpCode::lvsl : TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+
+      // Next, we shift the vector backwards by (n + m) bytes shifting in the bitwise complement of
+      // the target value. This causes the garbage to end up at the vector register, having been
+      // replaced with a bit pattern that can never compare as equal to the target value.
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, scratchRegister, scratchRegister, currentAddress);
+      if (TR::Compiler->target.cpu.isLittleEndian())
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+         }
+      else
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+         }
+
+      srm->reclaimScratchRegister(scratchRegister);
+
+      // Now the search vector is ready for comparison: none of the garbage can compare as equal to
+      // our target value and the start of the vector is now aligned to the start of the string. So
+      // we can now perform the comparison as normal.
+      generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+      generateLabelInstruction(cg, TR::InstOpCode::b, node, notFoundLabel);
+      }
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notSmallLabel);
+
+   // Check if we already have 16-byte alignment. Vector loads require 16-byte alignment, so if we
+   // aren't properly aligned, we'll need to handle comparisons specially until we achieve 16-byte
+   // alignment.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, startVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, vectorLoopLabel, cr0);
+
+   // We are not on a 16-byte boundary, so we cannot directly load the first 16 bytes of the string
+   // for comparison. Instead, we load the 16 byte vector starting from the 16-byte aligned section
+   // containing the start of the string. Since we have 16-byte natural alignment, this can't cause
+   // an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   // However, before we can run any comparisons on the loaded vector, we must ensure that the extra
+   // garbage read before the start of the string can't match the target character. To do this, we
+   // shift the loaded vector backwards by n bytes shifting in the bitwise complement of the target
+   // character.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   // Now our vector is ready for comparison: no garbage can match the target value and the start of
+   // the vector is now aligned to the start of the string.
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   // If the first vector didn't match, then we can slide right into the standard vectorized loop.
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, startVectorAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, residueLabel, cr0);
+
+   srm->reclaimScratchRegister(startVectorAddress);
+
+   // This is the heart of the vectorized loop, working just like any standard vectorized loop.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, vectorLoopLabel);
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, currentAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, vectorLoopLabel, cr0);
+
+   srm->reclaimScratchRegister(endVectorAddress);
+
+   // Now we're done with the part of the loop which can be handled as a normal vectorized loop. If
+   // there are no more elements to compare, we're done. Otherwise, we need to handle the residue.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, residueLabel);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   // Usually, we would need a residue loop here, but it's safe to read beyond the end of the string
+   // here. Since our load will have 16-byte natural alignment, it can't cross a page boundary and
+   // cause an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   TR::Register *shiftAmount = srm->findOrCreateScratchRegister();
+
+   // Before we can run our comparison, we need to ensure that the garbage from beyond the end of
+   // the string cannot compare as equal to our target value. To do this, we first rotate the vector
+   // forwards by n bytes then shift back by n bytes, shifting in the bitwise complement of the
+   // target value.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, shiftAmount, endAddress);
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   srm->reclaimScratchRegister(shiftAmount);
+
+   // Now we run our comparison as normal
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   srm->donateScratchRegister(targetVector);
+   srm->donateScratchRegister(targetVectorNot);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notFoundLabel);
+
+   // We've looked through the entire string and didn't find our target character, so return the
+   // sentinel value -1
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, result, -1);
+   generateLabelInstruction(cg, TR::InstOpCode::b, node, endLabel);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, foundLabel);
+
+   // We've managed to find a match for the target value in the loaded vector, but we don't yet know
+   // which element of the loaded vector is the first match. The comparison will have set matching
+   // elements in the vector to -1 and non-matching elements to 0. We can find the first matching
+   // element by gathering the first bit of every byte in the vector register...
+
+   // Set permuteVector = 0x000102030405060708090a0b0c0d0e0f
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, zeroRegister);
+
+   // For little-endian, reverse permuteVector so that we can find the first set bit using a count
+   // leading zeroes test instead of a count trailing zeroes test. This is necessary since cnttzw
+   // wasn't introduced until Power 9.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 0x0f);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::vsububm, node, permuteVector, targetVector, permuteVector);
+      }
+
+   // Set permuteVector = 0x00081018202830384048505860687078 (reversed for LE)
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vslb, node, permuteVector, permuteVector, targetVector);
+
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vbpermq, node, searchVector, searchVector, permuteVector);
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mfvsrwz, node, result, searchVector);
+
+   // Then count the number of leading zeroes from the obtained result. This tells us the index (in
+   // bytes) of the first matching element in the vector. Note that there is no way to count leading
+   // zeroes of a half-word, so we count leading zeroes of a word and subtract 16 since the value
+   // we're interested in is in the least significant half-word.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::cntlzw, node, result, result);
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, -16);
+
+   // Finally, combine this with the address of the last vector load to find the address of the
+   // first matching element in the string. Finally, use this to calculate the corresponding index.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, result, currentAddress);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::subf, node, result, arrAddress, result);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, foundExactLabel);
+   if (!isLatin1)
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::srawi, node, result, result, 1);
+
+      {
+      TR::RegisterDependencyConditions *deps = new (cg->trHeapMemory()) TR::RegisterDependencyConditions(0, 14 + srm->numAvailableRegisters(), cg->trMemory());
+
+      deps->addPostCondition(arrAddress, TR::RealRegister::NoReg);
+      deps->addPostCondition(targetScalar, TR::RealRegister::NoReg);
+      deps->addPostCondition(startIndex, TR::RealRegister::NoReg);
+      deps->addPostCondition(endIndex, TR::RealRegister::NoReg);
+
+      deps->addPostCondition(cr0, TR::RealRegister::cr0);
+      deps->addPostCondition(cr6, TR::RealRegister::cr6);
+
+      deps->addPostCondition(zeroRegister, TR::RealRegister::NoReg);
+      deps->addPostCondition(result, TR::RealRegister::NoReg);
+      deps->addPostCondition(currentAddress, TR::RealRegister::NoReg);
+      deps->addPostCondition(endAddress, TR::RealRegister::NoReg);
+
+      deps->addPostCondition(targetVector, TR::RealRegister::NoReg);
+      deps->addPostCondition(targetVectorNot, TR::RealRegister::NoReg);
+      deps->addPostCondition(searchVector, TR::RealRegister::NoReg);
+      deps->addPostCondition(permuteVector, TR::RealRegister::NoReg);
+",Register dependencies should be fixed now.,acknowledgement
164780495,37c776acae06555995bf141eb25e5293dacdfa43,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,True,"@@ -11797,6 +11797,355 @@ static TR::Register *inlineEncodeUTF16(TR::Node *node, TR::CodeGenerator *cg)
    return outputLenReg;
    }
 
+static TR::Register *inlineIntrinsicIndexOf(TR::Node *node, bool isLatin1, TR::CodeGenerator *cg)
+   {
+   auto vectorCompareOp = isLatin1 ? TR::InstOpCode::vcmpeubr : TR::InstOpCode::vcmpeuhr;
+   auto scalarLoadOp = isLatin1 ? TR::InstOpCode::lbzx : TR::InstOpCode::lhzx;
+
+   TR::Register *arrObjectAddress = cg->evaluate(node->getChild(1));
+   TR::Register *targetScalar = cg->evaluate(node->getChild(2));
+   TR::Register *startIndex = cg->evaluate(node->getChild(3));
+   TR::Register *endIndex = cg->evaluate(node->getChild(4));
+
+   TR::Register *cr0 = cg->allocateRegister(TR_CCR);
+   TR::Register *cr6 = cg->allocateRegister(TR_CCR);
+
+   TR::Register *zeroRegister = cg->allocateRegister();
+   TR::Register *result = cg->allocateRegister();
+   TR::Register *arrAddress = cg->allocateRegister();
+   TR::Register *currentAddress = cg->allocateRegister();
+   TR::Register *endAddress = cg->allocateRegister();
+
+   TR::Register *targetVector = cg->allocateRegister(TR_VRF);
+   TR::Register *targetVectorNot = cg->allocateRegister(TR_VRF);
+   TR::Register *searchVector = cg->allocateRegister(TR_VRF);
+   TR::Register *permuteVector = cg->allocateRegister(TR_VRF);
+
+   TR_PPCScratchRegisterManager *srm = cg->generateScratchRegisterManager();
+
+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notSmallLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *vectorLoopLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *residueLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notFoundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundExactLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);
+
+   startLabel->setStartInternalControlFlow();
+   endLabel->setEndInternalControlFlow();
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);
+
+   // Special case for empty strings, which always return -1
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, startIndex, endIndex);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   if (!isLatin1)
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, startIndex, startIndex);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, endIndex, endIndex);
+      }
+   else
+      {
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, result, startIndex);
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, endAddress, endIndex);
+      }
+
+   if (node->getChild(3)->getReferenceCount() == 1)
+      srm->donateScratchRegister(startIndex);
+   if (node->getChild(4)->getReferenceCount() == 1)
+      srm->donateScratchRegister(endIndex);
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, arrAddress, arrObjectAddress, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());
+   if (node->getChild(1)->getReferenceCount() == 1)
+      srm->donateScratchRegister(arrObjectAddress);
+
+   // Handle the first character using a simple scalar compare. Otherwise, first character matches
+   // would be slower than the old scalar comparison loop. This is a problem since first character
+   // matches are common in certain contexts, e.g. StringTokenizer where the default first character
+   // to each String.indexOf call is ' ', which is the most common whitespace character.
+      {
+      TR::Register *value = srm->findOrCreateScratchRegister();
+
+      generateTrg1MemInstruction(cg, scalarLoadOp, node, value, new (cg->trHeapMemory()) TR::MemoryReference(arrAddress, result, isLatin1 ? 1 : 2, cg));
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, value, targetScalar);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, foundExactLabel, cr0);
+
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, isLatin1 ? 1 : 2);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, result, endAddress);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+      srm->reclaimScratchRegister(value);
+      }
+
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, zeroRegister, 0);
+
+   // Calculate the actual addresses of the start and end points
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, arrAddress, endAddress);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, currentAddress, arrAddress, result);
+
+   // Splat the value to be compared against and its bitwise complement into two vector registers
+   // for later use
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mtvsrwz, node, targetVector, targetScalar);
+   if (node->getChild(2)->getReferenceCount() == 1)
+      srm->donateScratchRegister(targetScalar);
+   if (isLatin1)
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vspltb, node, targetVector, targetVector, 7);
+   else
+      generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::vsplth, node, targetVector, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vnor, node, targetVectorNot, targetVector, targetVector);
+
+   TR::Register *endVectorAddress = srm->findOrCreateScratchRegister();
+   TR::Register *startVectorAddress = srm->findOrCreateScratchRegister();
+
+   // Calculate the end address for what can be compared using full vector compares. After reaching
+   // this address, the remaining comparisons (if required) will need special handling.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, endVectorAddress, endAddress, 0, CONSTANT64(0xfffffffffffffff0));
+
+   // Check if the entire string is contained within a single 16-byte aligned section. If this
+   // happens, we need to handle that case specially.
+   generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rldicr, node, startVectorAddress, currentAddress, 0, CONSTANT64(0xfffffffffffffff0));
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, startVectorAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, notSmallLabel, cr0);
+
+   // If we got here, then the entire string to search is contained within a single 16-byte aligned
+   // vector and the end of the string is not aligned to the end of the vector. We don't know
+   // whether the start of the string is aligned, but we'll assume it isn't since that just results
+   // in a few unnecessary operations producing the correct answer regardless.
+
+   // First, we read in an entire 16-byte aligned vector containing the entire string. Since this
+   // load is done with 16-byte natural alignment, this load can't cross a page boundary and cause
+   // an unexpected page fault. However, this will read some garbage at the start and end of the
+   // vector. Assume that we read n bytes of garbage before the string and m bytes of garbage after
+   // the string.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+      {
+      TR::Register *scratchRegister = srm->findOrCreateScratchRegister();
+
+      // We need to ensure that the garbage we read can't compare as equal to the target value for
+      // obvious reasons. In order to accomplish this, we first rotate forwards by m bytes. This
+      // places all garbage at the beginning of the vector.
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, scratchRegister, endAddress);
+      generateTrg1Src2Instruction(cg, TR::Compiler->target.cpu.isLittleEndian() ? TR::InstOpCode::lvsl : TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+
+      // Next, we shift the vector backwards by (n + m) bytes shifting in the bitwise complement of
+      // the target value. This causes the garbage to end up at the vector register, having been
+      // replaced with a bit pattern that can never compare as equal to the target value.
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, scratchRegister, scratchRegister, currentAddress);
+      if (TR::Compiler->target.cpu.isLittleEndian())
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+         }
+      else
+         {
+         generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, scratchRegister);
+         generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+         }
+
+      srm->reclaimScratchRegister(scratchRegister);
+
+      // Now the search vector is ready for comparison: none of the garbage can compare as equal to
+      // our target value and the start of the vector is now aligned to the start of the string. So
+      // we can now perform the comparison as normal.
+      generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+      generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+      generateLabelInstruction(cg, TR::InstOpCode::b, node, notFoundLabel);
+      }
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notSmallLabel);
+
+   // Check if we already have 16-byte alignment. Vector loads require 16-byte alignment, so if we
+   // aren't properly aligned, we'll need to handle comparisons specially until we achieve 16-byte
+   // alignment.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, startVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, vectorLoopLabel, cr0);
+
+   // We are not on a 16-byte boundary, so we cannot directly load the first 16 bytes of the string
+   // for comparison. Instead, we load the 16 byte vector starting from the 16-byte aligned section
+   // containing the start of the string. Since we have 16-byte natural alignment, this can't cause
+   // an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   // However, before we can run any comparisons on the loaded vector, we must ensure that the extra
+   // garbage read before the start of the string can't match the target character. To do this, we
+   // shift the loaded vector backwards by n bytes shifting in the bitwise complement of the target
+   // character.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, currentAddress);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   // Now our vector is ready for comparison: no garbage can match the target value and the start of
+   // the vector is now aligned to the start of the string.
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   // If the first vector didn't match, then we can slide right into the standard vectorized loop.
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, startVectorAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, residueLabel, cr0);
+
+   srm->reclaimScratchRegister(startVectorAddress);
+
+   // This is the heart of the vectorized loop, working just like any standard vectorized loop.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, vectorLoopLabel);
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, currentAddress, currentAddress, 0x10);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endVectorAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, vectorLoopLabel, cr0);
+
+   srm->reclaimScratchRegister(endVectorAddress);
+
+   // Now we're done with the part of the loop which can be handled as a normal vectorized loop. If
+   // there are no more elements to compare, we're done. Otherwise, we need to handle the residue.
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, residueLabel);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp8, node, cr0, currentAddress, endAddress);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   // Usually, we would need a residue loop here, but it's safe to read beyond the end of the string
+   // here. Since our load will have 16-byte natural alignment, it can't cross a page boundary and
+   // cause an unexpected page fault.
+   generateTrg1MemInstruction(cg, TR::InstOpCode::lvx, node, searchVector, new (cg->trHeapMemory()) TR::MemoryReference(zeroRegister, currentAddress, 16, cg));
+
+   TR::Register *shiftAmount = srm->findOrCreateScratchRegister();
+
+   // Before we can run our comparison, we need to ensure that the garbage from beyond the end of
+   // the string cannot compare as equal to our target value. To do this, we first rotate the vector
+   // forwards by n bytes then shift back by n bytes, shifting in the bitwise complement of the
+   // target value.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::neg, node, shiftAmount, endAddress);
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, targetVectorNot, searchVector, permuteVector);
+      }
+   else
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsr, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, searchVector, permuteVector);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, shiftAmount);
+      generateTrg1Src3Instruction(cg, TR::InstOpCode::vperm, node, searchVector, searchVector, targetVectorNot, permuteVector);
+      }
+
+   srm->reclaimScratchRegister(shiftAmount);
+
+   // Now we run our comparison as normal
+   generateTrg1Src2Instruction(cg, vectorCompareOp, node, searchVector, searchVector, targetVector);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, foundLabel, cr6);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, notFoundLabel);
+
+   // We've looked through the entire string and didn't find our target character, so return the
+   // sentinel value -1
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, result, -1);
+   generateLabelInstruction(cg, TR::InstOpCode::b, node, endLabel);
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, foundLabel);
+
+   // We've managed to find a match for the target value in the loaded vector, but we don't yet know
+   // which element of the loaded vector is the first match. The comparison will have set matching
+   // elements in the vector to -1 and non-matching elements to 0. We can find the first matching
+   // element by gathering the first bit of every byte in the vector register...
+
+   // Set permuteVector = 0x000102030405060708090a0b0c0d0e0f
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::lvsl, node, permuteVector, zeroRegister, zeroRegister);
+
+   // For little-endian, reverse permuteVector so that we can find the first set bit using a count
+   // leading zeroes test instead of a count trailing zeroes test. This is necessary since cnttzw
+   // wasn't introduced until Power 9.
+   if (TR::Compiler->target.cpu.isLittleEndian())
+      {
+      generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 0x0f);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::vsububm, node, permuteVector, targetVector, permuteVector);
+      }
+
+   // Set permuteVector = 0x00081018202830384048505860687078 (reversed for LE)
+   generateTrg1ImmInstruction(cg, TR::InstOpCode::vspltisb, node, targetVector, 3);
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vslb, node, permuteVector, permuteVector, targetVector);
+
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::vbpermq, node, searchVector, searchVector, permuteVector);
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::mfvsrwz, node, result, searchVector);
+
+   // Then count the number of leading zeroes from the obtained result. This tells us the index (in
+   // bytes) of the first matching element in the vector. Note that there is no way to count leading
+   // zeroes of a half-word, so we count leading zeroes of a word and subtract 16 since the value
+   // we're interested in is in the least significant half-word.
+   generateTrg1Src1Instruction(cg, TR::InstOpCode::cntlzw, node, result, result);
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, result, result, -16);
+
+   // Finally, combine this with the address of the last vector load to find the address of the
+   // first matching element in the string. Finally, use this to calculate the corresponding index.
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, result, currentAddress);","I think you've misunderstood the part of the code responsible for loading the first misaligned vector. This is the correct way to calculate the address of the match because the data in `searchVector` has _already_ been shifted backwards by `currentAddress & 0xf` bytes earlier by the code responsible for replacing the garbage loaded before the string data. Because of this, the first byte of `searchVector` corresponds to the byte at `(currentAddress & ~0xf) + (currentAddress & 0xf) = currentAddress` _not_ the first byte that was actually loaded from memory (which would be at `currentAddress & ~0xf`).",change_request
165804088,37c776acae06555995bf141eb25e5293dacdfa43,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,True,"@@ -11797,6 +11797,356 @@ static TR::Register *inlineEncodeUTF16(TR::Node *node, TR::CodeGenerator *cg)
    return outputLenReg;
    }
 
+static TR::Register *inlineIntrinsicIndexOf(TR::Node *node, bool isLatin1, TR::CodeGenerator *cg)
+   {
+   auto vectorCompareOp = isLatin1 ? TR::InstOpCode::vcmpeubr : TR::InstOpCode::vcmpeuhr;
+   auto scalarLoadOp = isLatin1 ? TR::InstOpCode::lbzx : TR::InstOpCode::lhzx;
+
+   TR::Register *arrObjectAddress = cg->evaluate(node->getChild(1));
+   TR::Register *targetScalar = cg->evaluate(node->getChild(2));
+   TR::Register *startIndex = cg->evaluate(node->getChild(3));
+   TR::Register *endIndex = cg->evaluate(node->getChild(4));
+
+   TR::Register *cr0 = cg->allocateRegister(TR_CCR);
+   TR::Register *cr6 = cg->allocateRegister(TR_CCR);
+
+   TR::Register *zeroRegister = cg->allocateRegister();
+   TR::Register *result = cg->allocateRegister();
+   TR::Register *arrAddress = cg->allocateRegister();
+   TR::Register *currentAddress = cg->allocateRegister();
+   TR::Register *endAddress = cg->allocateRegister();
+
+   TR::Register *targetVector = cg->allocateRegister(TR_VRF);
+   TR::Register *targetVectorNot = cg->allocateRegister(TR_VRF);
+   TR::Register *searchVector = cg->allocateRegister(TR_VRF);
+   TR::Register *permuteVector = cg->allocateRegister(TR_VRF);
+
+   TR_PPCScratchRegisterManager *srm = cg->generateScratchRegisterManager();
+
+   TR::LabelSymbol *startLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notSmallLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *vectorLoopLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *residueLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *notFoundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *foundExactLabel = generateLabelSymbol(cg);
+   TR::LabelSymbol *endLabel = generateLabelSymbol(cg);
+
+   startLabel->setStartInternalControlFlow();
+   endLabel->setEndInternalControlFlow();
+
+   generateLabelInstruction(cg, TR::InstOpCode::label, node, startLabel);
+
+   // Special case for empty strings, which always return -1
+   generateTrg1Src2Instruction(cg, TR::InstOpCode::cmp4, node, cr0, startIndex, endIndex);
+   generateConditionalBranchInstruction(cg, TR::InstOpCode::beq, node, notFoundLabel, cr0);
+
+   if (!isLatin1)
+      {
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, result, startIndex, startIndex);
+      generateTrg1Src2Instruction(cg, TR::InstOpCode::add, node, endAddress, endIndex, endIndex);
+      }
+   else
+      {
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, result, startIndex);
+      generateTrg1Src1Instruction(cg, TR::InstOpCode::mr, node, endAddress, endIndex);
+      }
+
+   if (node->getChild(3)->getReferenceCount() == 1)
+      srm->donateScratchRegister(startIndex);
+   if (node->getChild(4)->getReferenceCount() == 1)
+      srm->donateScratchRegister(endIndex);
+
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, arrAddress, arrObjectAddress, TR::Compiler->om.contiguousArrayHeaderSizeInBytes());
+   if (node->getChild(1)->getReferenceCount() == 1)
+      srm->donateScratchRegister(arrObjectAddress);
+
+   // Handle the first character using a simple scalar compare. Otherwise, first character matches
+   // would be slower than the old scalar comparison loop. This is a problem since first character
+   // matches are common in certain contexts, e.g. StringTokenizer where the default first character
+   // to each String.indexOf call is ' ', which is the most common whitespace character.
+      {
+      TR::Register *value = srm->findOrCreateScratchRegister();
+
+      generateTrg1MemInstruction(cg, scalarLoadOp, node, value, new (cg->trHeapMemory()) TR::MemoryReference(arrAddress, result, isLatin1 ? 1 : 2, cg));",Fixed,acknowledgement
201601150,432171ee6b6c4dd2680bb9a93abfc942d25fb27b,runtime/compiler/x/codegen/J9TreeEvaluator.cpp,False,"@@ -7908,42 +7908,47 @@ J9::X86::TreeEvaluator::VMarrayStoreCHKEvaluator(
       // -------------------------------------------------------------------------
       //
       // If the component type is java.lang.Object then the store always succeeds.
+      // On AOT, only do this when using the SVM; otherwise, it's safer to just
+      // skip this check than 1) incorrectly relocate the java/lang/Object class
+      // or 2) crash while trying to relocate.
       //
       // -------------------------------------------------------------------------
-
-      TR_OpaqueClassBlock *objectClass = fej9->getSystemClassFromClassName(""java/lang/Object"", 16);
-
-      if (TR::Compiler->target.is64Bit())
+      if (!cg->needClassAndMethodPointerRelocations() || comp->getOption(TR_UseSymbolValidationManager))
          {
-#ifdef J9VM_INTERP_COMPRESSED_OBJECT_HEADER
-         TR_ASSERT((((uintptr_t)objectClass) >> 32) == 0, ""TR_OpaqueClassBlock must fit on 32 bits when using class pointer compression"");
-         instr = generateRegImmInstruction(CMP4RegImm4, node, destComponentClassReg, (uint32_t) ((uint64_t) objectClass), cg);
+         TR_OpaqueClassBlock *objectClass = fej9->getSystemClassFromClassName(""java/lang/Object"", 16);
+         objectClass = fej9->getArrayClassFromComponentClass(objectClass);","I tried to do the same thing on the Power codegen and, as it turns out, it _is_ possible to fail to find the class for `Object[]`...",discussion_trigger
203833320,993cfe048d2a18f90db763ea2d98dbcacf442baa,runtime/compiler/env/j9method.cpp,True,"@@ -8008,7 +8008,7 @@ TR_J9ByteCodeIlGenerator::runFEMacro(TR::SymbolReference *symRef)
          // Construct the signature string for the array class
          //
          UDATA arity = arrayJ9Class->arity;
-         J9Class *leafClass = arrayJ9Class->leafComponentType;
+         J9Class *leafClass = (J9Class*)fej9->getLeafComponentClassFromArrayClass((TR_OpaqueClassBlock*)arrayJ9Class);",I'm honestly not sure if this ends up getting executed during AOT (I haven't seen it executed myself). I noticed this while fixing the other issue and figured I'd change this to use the front-end API pre-emptively to prevent any unwanted surprises if this ever does end up getting executed during AOT.,discussion_participation
205802303,eb58c32c3a3ed7fd056a0f1f44a8c205aa946cba,runtime/compiler/runtime/RelocationRecord.cpp,True,"@@ -3887,6 +3893,7 @@ TR_RelocationRecordSymbolFromManager::preparePrivateData(TR_RelocationRuntime *r
    {
    TR_RelocationSymbolFromManagerPrivateData *reloPrivateData = &(privateData()->symbolFromManager);
 
+   uint16_t type = reloTarget->loadUnsigned8b(&_record->_type);","It's a remnant of the old way of checking for discontiguous relocations... I meant to remove it before submitting this PR, but I guess I forgot. :sweat_smile: ",discussion_participation
206011101,715b9d327dd9e2b3db61c7aa782aeff88aac3663,runtime/compiler/p/codegen/CallSnippet.cpp,True,"@@ -282,9 +282,13 @@ TR_RuntimeHelper TR::PPCCallSnippet::getInterpretedDispatchHelper(
       isJitInduceOSRCall = true;
       }
 
-   if (methodSymRef->isUnresolved() || comp->compileRelocatableCode()) // KEN
+   bool forceUnresolvedDispatch = fej9->forceUnresolvedDispatch();","Yes, as far as I know they're just two different names for the same query.",discussion_participation
206011755,715b9d327dd9e2b3db61c7aa782aeff88aac3663,runtime/compiler/p/codegen/CallSnippet.cpp,True,"@@ -414,10 +422,18 @@ uint8_t *TR::PPCCallSnippet::emitSnippetBody()
          if (comp->getOption(TR_EnableHCR))
             cg()->jitAddPicToPatchOnClassRedefinition((void *)methodSymbol->getMethodAddress(), (void *)cursor);
 
-         cg()->addExternalRelocation(new (cg()->trHeapMemory()) TR::ExternalRelocation(cursor, (uint8_t *)methodSymRef,
-                                                                                 getNode() ? (uint8_t *)getNode()->getInlinedSiteIndex() : (uint8_t *)-1,
-                                                                                 TR_MethodObject, cg()),
-                                      __FILE__, __LINE__, callNode);
+         if (comp->getOption(TR_UseSymbolValidationManager))","This code can never be reached under AOT if SVM is disabled, as `forceUnresolvedDispatch` will always be true in that case.",discussion_participation
206012258,715b9d327dd9e2b3db61c7aa782aeff88aac3663,runtime/compiler/p/codegen/CallSnippet.cpp,True,"@@ -282,9 +282,13 @@ TR_RuntimeHelper TR::PPCCallSnippet::getInterpretedDispatchHelper(
       isJitInduceOSRCall = true;
       }
 
-   if (methodSymRef->isUnresolved() || comp->compileRelocatableCode()) // KEN
+   bool forceUnresolvedDispatch = fej9->forceUnresolvedDispatch();
+   if (comp->getOption(TR_UseSymbolValidationManager))
+      forceUnresolvedDispatch = false;
+
+   if (methodSymRef->isUnresolved() || forceUnresolvedDispatch) // KEN",Agreed. I'll go ahead and remove that.,acknowledgement
206321761,715b9d327dd9e2b3db61c7aa782aeff88aac3663,runtime/compiler/p/codegen/CallSnippet.cpp,True,"@@ -414,10 +422,18 @@ uint8_t *TR::PPCCallSnippet::emitSnippetBody()
          if (comp->getOption(TR_EnableHCR))
             cg()->jitAddPicToPatchOnClassRedefinition((void *)methodSymbol->getMethodAddress(), (void *)cursor);
 
-         cg()->addExternalRelocation(new (cg()->trHeapMemory()) TR::ExternalRelocation(cursor, (uint8_t *)methodSymRef,
-                                                                                 getNode() ? (uint8_t *)getNode()->getInlinedSiteIndex() : (uint8_t *)-1,
-                                                                                 TR_MethodObject, cg()),
-                                      __FILE__, __LINE__, callNode);
+         if (comp->getOption(TR_UseSymbolValidationManager))","Alright, I'll go ahead and change that",acknowledgement
217939939,69c94a58b4555ae7f4d2116fd834d4e05d4d4cf9,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,True,"@@ -11808,15 +11808,21 @@ static TR::Register *inlineIntrinsicIndexOf(TR::Node *node, bool isLatin1, TR::C
    // to each String.indexOf call is ' ', which is the most common whitespace character.
       {
       TR::Register *value = srm->findOrCreateScratchRegister();
+      TR::Register *zxTargetScalar = srm->findOrCreateScratchRegister();
+
+      // Since we're going to do a load followed immediately by a comparison, we need to ensure that","That's correct. Only the first comparison is done using a 32-bit scalar comparison operator. It doesn't matter what the upper bits of this register are when performing the vector comparison, as they will have been overwritten when the value is splatted into the vector register.",discussion_participation
290588742,35e7503e733a979fbdd4c8ba9edd266cde7066b7,runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp,True,"@@ -407,9 +411,31 @@ void J9::RecognizedCallTransformer::transform(TR::TreeTop* treetop)
       case TR::java_lang_Integer_rotateLeft:
          processIntrinsicFunction(treetop, node, TR::irol);
          break;
+      case TR::java_lang_Integer_rotateRight:
+         {
+         // rotateRight(x, distance) = rotateLeft(x, -distance)
+         TR::Node *distance = TR::Node::create(node, TR::ineg, 1);","This transformation yields the correct result for `distance = INT_MIN`. All the rotates here (both the recognized methods in the JCL and the `lrol`/`irol` instructions) take their second operand modulo the number of bits in the data type being rotated as the distance by which to rotate. For an `INT_MIN` distance, this would result in a rotate by a distance of 0 for both ints and longs, so `rotateRight(x, INT_MIN) = x` and `rotateLeft(x, INT_MIN) = x`. Since `-INT_MIN = INT_MIN` when using `ineg` in our IL, it follows that `rotateRight(x, INT_MIN) = x = rotateLeft(x, INT_MIN) = rotateLeft(x, -INT_MIN)`.",discussion_participation
290665919,35e7503e733a979fbdd4c8ba9edd266cde7066b7,runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp,True,"@@ -367,12 +367,16 @@ bool J9::RecognizedCallTransformer::isInlineable(TR::TreeTop* treetop)
       case TR::java_lang_Class_isAssignableFrom:
          return cg()->supportsInliningOfIsAssignableFrom();
       case TR::java_lang_Integer_rotateLeft:
+      case TR::java_lang_Integer_rotateRight:
+         return TR::Compiler->target.cpu.isX86() || TR::Compiler->target.cpu.isZ() || TR::Compiler->target.cpu.isPower();
       case TR::java_lang_Long_rotateLeft:
+      case TR::java_lang_Long_rotateRight:
+         return TR::Compiler->target.cpu.isX86() || TR::Compiler->target.cpu.isZ() || (TR::Compiler->target.cpu.isPower() && TR::Compiler->target.is64Bit());
       case TR::java_lang_Math_abs_I:
       case TR::java_lang_Math_abs_L:
       case TR::java_lang_Math_abs_F:
       case TR::java_lang_Math_abs_D:
-         return TR::Compiler->target.cpu.isX86() || TR::Compiler->target.cpu.isZ();
+         return true;","As far as I can tell, all codegens (including ARM and AArch64) do currently support `iabs`, `labs`, `fabs`, and `dabs`.",discussion_participation
290723990,35e7503e733a979fbdd4c8ba9edd266cde7066b7,runtime/compiler/optimizer/J9RecognizedCallTransformer.cpp,True,"@@ -367,12 +367,16 @@ bool J9::RecognizedCallTransformer::isInlineable(TR::TreeTop* treetop)
       case TR::java_lang_Class_isAssignableFrom:
          return cg()->supportsInliningOfIsAssignableFrom();
       case TR::java_lang_Integer_rotateLeft:
+      case TR::java_lang_Integer_rotateRight:
+         return TR::Compiler->target.cpu.isX86() || TR::Compiler->target.cpu.isZ() || TR::Compiler->target.cpu.isPower();
       case TR::java_lang_Long_rotateLeft:
+      case TR::java_lang_Long_rotateRight:
+         return TR::Compiler->target.cpu.isX86() || TR::Compiler->target.cpu.isZ() || (TR::Compiler->target.cpu.isPower() && TR::Compiler->target.is64Bit());
       case TR::java_lang_Math_abs_I:
       case TR::java_lang_Math_abs_L:
       case TR::java_lang_Math_abs_F:
       case TR::java_lang_Math_abs_D:
-         return TR::Compiler->target.cpu.isX86() || TR::Compiler->target.cpu.isZ();
+         return true;",Fair point. I've amended this PR to only enable this transformation on Power and it can be enabled on ARM/AArch64 as part of a separate PR at a later date.,discussion_participation
304606482,17f6d7d4f5363ad26a28fe629a35e39fec7d8811,runtime/compiler/codegen/CodeGenPhaseToPerform.hpp,True,"@@ -55,6 +55,7 @@
     RegisterAssigningPhase,
     MapStackPhase,
     PeepholePhase,
+    ExpandInstructionsPhase,","Hmm... You do have a point that we'd be performing unnecessary work by enabling this right now, as no other codegens are looking to use this in the short-term and there's no early out. I do know that Z currently has the [exact same situation](https://github.com/eclipse/omr/blob/148a6b092d75d75b23a00997fddf1fc19fc09f96/compiler/z/codegen/OMRMemoryReference.cpp#L2488-L2528) in their binary encoder that prompted this to be added for Power, so they might end up using this as well at some point but AFAIK there are no immediate plans to do so.

I can fix this by relegating this phase to a Power-specific `CodeGenPhaseToPerform.hpp` file, by adding a codegen flag that causes `CodeGenerator::expandInstructions` to bail early if not set, or by giving `CodeGenerator::expandInstructions` an empty implementation by default and then having it overridden by the Power codegen. What would be your preference here?",discussion_participation
304770552,17f6d7d4f5363ad26a28fe629a35e39fec7d8811,runtime/compiler/codegen/CodeGenPhaseToPerform.hpp,True,"@@ -55,6 +55,7 @@
     RegisterAssigningPhase,
     MapStackPhase,
     PeepholePhase,
+    ExpandInstructionsPhase,",I've opened eclipse/omr#4492 to make this change in OMR. That should hopefully address your concern and this should be ready to go once that merges.,acknowledgement
308557953,06406ad839a432a54f5384514dc1df83c5b88bf1,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,False,"@@ -7397,27 +7202,6 @@ TR::Register *J9::Power::TreeEvaluator::VMnewEvaluator(TR::Node *node, TR::CodeG
    bool isConstantZeroLenArrayAlloc = isConstantLenArrayAlloc && (node->getFirstChild()->getInt() == 0);
    bool canOutlineNew = false;","This variable is no longer needed as all its uses have now been removed, so its declaration here should be removed as well.",change_request
308557953,06406ad839a432a54f5384514dc1df83c5b88bf1,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,False,"@@ -7164,201 +7164,6 @@ static void genZeroInit(TR::CodeGenerator *cg, TR::Node *node, TR::Register *obj
    cg->stopUsingRegister(zeroReg);
    }
 
-TR::Register *outlinedHelperNewEvaluator(TR::Node *node, TR::CodeGenerator *cg)","This function is the only use of the `TR_VariableLenArrayAlloc`, `TR_ConstLenArrayAlloc`, and `TR_ObjAlloc` per-CC snippets. Since they're no longer needed, all the code related to emitting them (`initializeCCPreLoadedArrayAlloc` and `initializeCCPreLoadedObjectAlloc` from `J9PPCSnippet.cpp` are in charge of doing that) and allocating space for them (see Power's implementation of `TR::getCCPreLoadedCodeSize`) should also be removed accordingly.",change_request
309389623,06406ad839a432a54f5384514dc1df83c5b88bf1,runtime/compiler/p/codegen/J9PPCSnippet.cpp,False,"@@ -1846,15 +1846,12 @@ uint32_t TR::getCCPreLoadedCodeSize()
       size += 4 + (linesToLdPrefetch + 1) / 2 * 4 + 1 + (l3SkipLines ? 2 : 0) + (linesToStPrefetch + 1) / 2 * 4;
       }
    size += 3;
-
-      //TR_ObjectAlloc/TR_ConstLenArrayAlloc/TR_VariableLenArrayAlloc/Hybrid arraylets
-      size += (2 + (11 + 11) + 2) + (16 + 14) + 4 + 9 + 4;
-      // If TLH prefetching is done
-      size += 2*5 + 2*5;
-   #if defined(DEBUG)
-      //TR_ObjectAlloc/TR_ConstLenArrayAlloc
-      size += 5 + 8;
-   #endif
+   // If TLH prefetching is done
+   size += 2*5 + 2*5;
+#if defined(DEBUG)
+   //TR_ObjectAlloc/TR_ConstLenArrayAlloc
+   size += 5 + 8;
+#endif","This code should also be removed, as this is all related to calculating the size of the removed snippets.",change_request
309389623,06406ad839a432a54f5384514dc1df83c5b88bf1,runtime/compiler/p/codegen/J9PPCSnippet.cpp,False,"@@ -2411,8 +2408,6 @@ static uint8_t* initializeCCPreLoadedObjectAlloc(uint8_t *buffer, void **CCPreLo
    TR_ASSERT(cg->getBinaryBufferCursor() - entryLabel->getCodeLocation() == helperSize * PPC_INSTRUCTION_LENGTH,
              ""Per-codecache object allocation helper, unexpected size"");
 
-   CCPreLoadedCodeTable[TR_ObjAlloc] = entryLabel->getCodeLocation();","As it stands, all you've removed is the code to put pointers to the snippets in `CCPreLoadedCodeTable`, but the code for the snippets is still being generated and placed in the code cache. You need to remove the `initializeCCPreLoadedObjectAlloc` and `initializeCCPreLoadedArrayAlloc` functions entirely (and the calls to them from `TR::createCCPreLoadedCode`), as they exist only to generate these snippets.",change_request
349423159,cbdc6462a5909b0fbb5b9ab386141d9a74e189f5,runtime/compiler/runtime/J9Profiler.cpp,True,"@@ -980,7 +980,7 @@ TR_ValueProfileInfoManager::getValueInfo(TR_ByteCodeInfo &bcInfo, TR::Compilatio
          info = _jitValueProfileInfo->getValueInfo(bcInfo, comp, kind, ArrayProfiler, true);
       }
 
-   if (external && (!info || info->getTotalFrequency() == 0))
+   if (external && (!info || info->getTotalFrequency() == 0) && kind == AddressInfo)","As far as I can tell, the IProfiler infrastructure doesn't currently provide any interface for figuring out the kind of data it's making available and only seems to be used for addresses at the moment. I'm not particularly familiar with the profiling code, so there might be something I missed there, though.

While I definitely agree that this is a bit of a hack and should be replaced by a better solution, this issue is currently blocking progress on eclipse/omr#4720 since it can cause the creation of invalid, though unreachable, BNDCHK/arraycopy nodes that later cause generation of invalid instructions, which is now a hard error under the new binary encoder. Would you be alright with having this temporary fix merged and an issue opened to document the need for a better solution to this?",discussion_participation
355528524,d7afcfa6a3d8de5e757a6c27b3118f983dcf80c5,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,True,"@@ -13611,7 +13611,7 @@ TR::Register *J9::Power::TreeEvaluator::arraycopyEvaluator(TR::Node *node, TR::C
    if (node->isForwardArrayCopy() && lengthNode->getOpCode().isLoadConst())
       {
       len = (lengthNode->getType().isInt32() ? lengthNode->getInt() : lengthNode->getLongInt());
-      if (len >= 0)
+      if (len >= 0 && len < 0x100000000LL)","Added a comment in 6669a51adbd7ed48a5cb3ad681b52368855aa7af.

As for the non-const (helper call) case, it definitely generates code that doesn't trigger any asserts, but I'm honestly not sure whether it would actually function with such a long length if it were executed as I don't know that anybody has ever bothered to test it. The issue being fixed here definitely shouldn't affect it since it's a helper and not generated by the codegen at all. Generally, AFAIK it's not possible to actually execute an arraycopy node in OpenJ9 that has such a long length as they only arise from the optimizer and are completely unreachable in practice, e.g. as a result of #8530.",discussion_participation
357560256,3e8e33b9cddd9acd57ce063b203bd0031dedc7c5,runtime/compiler/p/codegen/J9PPCSnippet.cpp,True,"@@ -1879,6 +1879,17 @@ uint32_t TR::getCCPreLoadedCodeSize()
 #define CCEYECATCHER(a, b, c, d) (((a) << 24) | ((b) << 16) | ((c) << 8) | ((d) << 0))
 #endif
 
+static void performCCPreLoadedBinaryEncoding(uint8_t *buffer, TR::CodeGenerator *cg)
+   {
+   cg->setBinaryBufferStart(buffer);
+   cg->setBinaryBufferCursor(buffer);
+   for (TR::Instruction *i = cg->getFirstInstruction(); i != NULL; i = i->getNext())
+      {
+      i->estimateBinaryLength(cg->getBinaryBufferCursor() - cg->getBinaryBufferStart());
+      cg->setBinaryBufferCursor(i->generateBinaryEncoding());","I think you're confused about what this code is actually doing... In this case, `estimateBinaryLength` is the method of `TR::Instruction` in charge of _generating_ the binary length estimate and it takes in the current estimated offset into the binary buffer.

In this case, using the actual offset instead of keeping track of an estimate is fine since we don't ever actually use the estimated positions we generate here outside of verifying that the estimates are not violated. It's assumed that all conditional branches within a per-CC helper snippet are within range and the new binary encoder will fail with an assertion if that assumption doesn't hold and an out-of-range branch is encountered.",discussion_participation
361968763,2be432fa892cec0f2f7187f23c6301508524a29a,runtime/compiler/p/runtime/CMakeLists.txt,True,"@@ -58,7 +53,5 @@ j9jit_files(
 p/runtime/Recomp.cpp
 p/runtime/Recompilation.spp
 p/runtime/PPCHWProfiler.cpp
-p/runtime/PPCLMGuardedStorage.cpp
-p/runtime/ebb.spp","Oops, looks like I accidentally removed an extra line here without noticing :sweat_smile:. Should be fixed now.",acknowledgement
385850382,1d3135fe74e3f8579e37b25ced1a43a274623fd8,runtime/compiler/p/codegen/J9UnresolvedDataSnippet.cpp,True,"@@ -66,6 +67,13 @@ J9::Power::UnresolvedDataSnippet::UnresolvedDataSnippet(
    {
    }
 
+uint8_t *J9::Power::UnresolvedDataSnippet::getAddressOfDataReference()
+   {
+   if (self()->getDataReferenceInstruction())","Yes, this currently returns `NULL` on Power. Other codegens do use this, but the Power codegen doesn't ever populate this field.",discussion_participation
385852351,1d3135fe74e3f8579e37b25ced1a43a274623fd8,runtime/compiler/p/codegen/J9UnresolvedDataSnippet.cpp,True,"@@ -66,6 +67,13 @@ J9::Power::UnresolvedDataSnippet::UnresolvedDataSnippet(
    {
    }
 
+uint8_t *J9::Power::UnresolvedDataSnippet::getAddressOfDataReference()
+   {
+   if (self()->getDataReferenceInstruction())
+      return self()->getDataReferenceInstruction()->getBinaryEncoding();","The binary encoding address is not available during instruction expansion, since that runs before binary encoding. This method is later called when populating the snippet after binary encoding is already run, so the binary encoding address _is_ available at that time.",discussion_participation
388265889,263f12d091904bf098ed99a0e7f486e375478fb0,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,False,"@@ -988,8 +988,8 @@ J9::Power::TreeEvaluator::generateFillInDataBlockSequenceForUnresolvedField(TR::
    TR::Register *cndReg = cg->allocateRegister(TR_CCR);
    generateTrg1MemInstruction(cg, TR::InstOpCode::Op_load, node, scratchReg,
                      new (cg->trHeapMemory()) TR::MemoryReference(dataSnippetRegister, offsetInDataBlock, TR::Compiler->om.sizeofReferenceAddress(), cg));
-   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::andi_r, node, scratchReg, scratchReg, cndReg, -1);
-   generateConditionalBranchInstruction(cg, TR::InstOpCode::bne, node, unresolvedLabel, cndReg);
+   generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::cmpi4, node, cndReg, scratchReg, -1);","Since we're reading the value of `scratchReg` as an address-sized value using `Op_load`, shouldn't this be an address-sized compare (i.e. `Op_cmpi`)?",discussion_trigger
418376675,dbc5a34bcce160a6ddf47459cd5b641417f4fb27,runtime/compiler/control/DLLMain.cpp,False,"@@ -204,8 +204,8 @@ IDATA J9VMDllMain(J9JavaVM* vm, IDATA stage, void * reserved)
             //if disableDualTLH is specified, revert back to old semantics.
             // Do not batch clear, JIT has to zeroinit all code on TLH.
             //Non P6, P7 and up are allowed to batch clear however.
-            TR_Processor ptype = TR_J9VMBase::getPPCProcessorType();
-            static bool disableZeroedTLHPages =  disableDualTLH && (((notlhPrefetch >= 0) || (ptype != TR_PPCp6 && ptype != TR_PPCp7)));
+            TR::Compiler->target.cpu.setProcessor(TR_J9VMBase::getPPCProcessorType());
+            bool disableZeroedTLHPages = disableDualTLH && (((notlhPrefetch >= 0) || (!TR::Compiler->target.cpu.is(OMR_PROCESSOR_PPC_P6) && !TR::Compiler->target.cpu.is(OMR_PROCESSOR_PPC_P7))));","Does this work correctly? You seem to be setting the `TR_Processor` returned by `id()`, but then using the Port library's processor enum to perform the check...",discussion_trigger
418376675,dbc5a34bcce160a6ddf47459cd5b641417f4fb27,runtime/compiler/p/codegen/DFPTreeEvaluator.cpp,False,"@@ -109,7 +109,7 @@ static void overlapDFPOperandAndPrecisionLoad(
       TR::CodeGenerator *cg)
    {
    // check for direct move
-   bool p8DirectMoveTest = cg->comp()->target().cpu.id() == TR_PPCp8;
+   bool p8DirectMoveTest = cg->comp()->target().cpu.is(OMR_PROCESSOR_PPC_P8);","This (and the other checks like it) look like they've always been incorrect to me. It looks like we should be checking whether we're _at least_ POWER8 to use the `mtvsr*` instructions instead of whether we're _exactly_ POWER8.

@zl-wang Do you know if this was intentional?",discussion_trigger
418462139,dbc5a34bcce160a6ddf47459cd5b641417f4fb27,runtime/compiler/p/codegen/DFPTreeEvaluator.cpp,False,"@@ -109,7 +109,7 @@ static void overlapDFPOperandAndPrecisionLoad(
       TR::CodeGenerator *cg)
    {
    // check for direct move
-   bool p8DirectMoveTest = cg->comp()->target().cpu.id() == TR_PPCp8;
+   bool p8DirectMoveTest = cg->comp()->target().cpu.is(OMR_PROCESSOR_PPC_P8);",Opened #9698 to track this.,acknowledgement
419197904,5034de8f24977e32951833b9ef985b9149f0a637,runtime/compiler/env/ProcessorDetection.cpp,True,"@@ -269,6 +269,20 @@ TR_Processor mapJ9Processor(J9ProcessorArchitecture j9processor)
       case PROCESSOR_PPC_P9:
          tp = TR_PPCp9;
          break;
+      case PROCESSOR_PPC_P10:
+         // P10 support is not yet well-tested, so it's currently gated behind an environment
+         // variable to prevent it from being used by accident by users who use old versions of
+         // OpenJ9 once P10 chips become available.
+         if (jitConfig)
+            {
+            static bool enableP10 = feGetEnv(""TR_EnableExperimentalPower10Support"");
+            tp = enableP10 ? TR_PPCp10 : TR_PPCp9;","Sorry, I should clarify: by ""older versions"", I'm referring to versions that will be released between when this PR is merged and when the P10 support is fully tested and verified. If a user were to try and use one of those builds on a newer machine with a POWER10 chip, OpenJ9 would recognize it and enable the new features, despite them having not yet undergone testing.",discussion_participation
429667522,992dfa1cb78d16232c9259e55b04d79d84d3687b,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,False,"@@ -6738,8 +6751,16 @@ static void genHeapAlloc(TR::Node *node, TR::Instruction *&iCursor, TR_OpaqueCla
          iCursor = generateTrg1ImmInstruction(cg, TR::InstOpCode::li, node, zeroReg, 0, iCursor);
          if (sizeInReg)
             {
-            iCursor = generateTrg1ImmInstruction(cg, TR::InstOpCode::lis, node, sizeReg, (allocSize >> 16) + ((allocSize & (1 << 15)) ? 1 : 0), iCursor);
-            iCursor = generateTrg1Src1ImmInstruction(cg, TR::InstOpCode::addi, node, sizeReg, sizeReg, allocSize & 0x0000FFFF, iCursor);
+            if (0x00008000 == HI_VALUE(allocSize))
+               {
+               iCursor = generateTrg1ImmInstruction(cg, TR::InstOpCode::lis, node, sizeReg, HI_VALUE(allocSize), iCursor);
+               iCursor = generateTrg1Src1Imm2Instruction(cg, TR::InstOpCode::rlwinm, node, sizeReg, sizeReg, 0, 0xFFFFFFFF, iCursor);","No, we can't do that. As I pointed out previously in https://github.com/eclipse/omr/pull/5213#discussion_r428859832, the assert would not be a false positive in these instances. When using the full 64-bit result (as is done here when running on 64-bit systems), using `-0x8000` instead of `0x8000` will not end up with the correct bit pattern in the register and will result in incorrect behaviour.",
432454882,f1eae47c09f8f44464d7f6f9ae21d9f7b3a3fb61,runtime/compiler/p/codegen/PPCJNILinkage.cpp,False,"@@ -433,8 +433,8 @@ TR::Register *J9::Power::JNILinkage::buildDirectDispatch(TR::Node *callNode)
 
       // push flags: use lis instead of lis/ori pair since this is a constant. Save one instr
       aValue = fej9->constJNICallOutFrameFlags();
-      TR_ASSERT((aValue & ~0x7FFF0000) == 0, ""Length assumption broken."");
-      generateTrg1ImmInstruction(cg(), TR::InstOpCode::lis, callNode, gr11Reg, (aValue>>16)&0x0000FFFF);
+      TR_ASSERT_FATAL((aValue & ~0x7FFF0000) == 0, ""Length assumption broken."");
+      generateTrg1ImmInstruction(cg(), TR::InstOpCode::lis, callNode, gr11Reg, aValue>>16);","This assert does guarantee that the upper bits are unset, but thinking about it, I do agree that the type conversions involved can be a bit unintuitive. This works based on sign-extension to `intptr_t` after negation, so it only works because the upper bit of that mask is set after negating it. Perhaps using `(aValue & ~static_cast<uintptr_t>(0x7FFF0000))` instead would make this more clear?",
448177570,c64a3e8e28fbcd91fd2f8b12cb79ca439d0b0f7e,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,False,"@@ -11685,573 +11685,241 @@ static void inlineArrayCopy_ICF(TR::Node *node, int64_t byteLen, TR::Register *s
    if (byteLen == 0)
       return;
 
-   TR::Compilation *comp = cg->comp();
-   TR::Register *regs[4] = {tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg};
-   TR::Register *fpRegs[4] = {fp1Reg, fp2Reg, fp3Reg, fp4Reg};
-   int32_t groups, residual;
-
-   static bool disableLEArrayCopyInline = (feGetEnv(""TR_disableLEArrayCopyInline"") != NULL);
-   bool supportsLEArrayCopyInline = (comp->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8)) && !disableLEArrayCopyInline && comp->target().cpu.isLittleEndian() && comp->target().cpu.hasFPU() && comp->target().is64Bit();
+   bool postP10CopyInline = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P10) &&
+                            cg->comp()->target().cpu.getPPCSupportsVSX();
 
-   if (comp->target().is64Bit())
+   if (postP10CopyInline)","Considering that it looks like the post-P10 and pre-P10 versions of the inlined arraycopy code aren't actually sharing much code at all, perhaps they should be split into two separate functions?",
448177570,c64a3e8e28fbcd91fd2f8b12cb79ca439d0b0f7e,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,False,"@@ -13458,12 +13148,18 @@ TR::Register *J9::Power::TreeEvaluator::arraycopyEvaluator(TR::Node *node, TR::C
    TR::Register *metaReg = cg->getMethodMetaDataRegister();
 
    // This section calculates the number of dependencies needed by the assembly helpers path.
+   bool postP10Copy = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P10) &&
+                      cg->comp()->target().cpu.getPPCSupportsVSX();
+
    static bool disableVSXArrayCopy = (feGetEnv(""TR_disableVSXArrayCopy"") != NULL);
-   static bool disableLEArrayCopyHelper = (feGetEnv(""TR_disableLEArrayCopyHelper"") != NULL);
-   static bool disableVSXArrayCopyInlining = (feGetEnv(""TR_enableVSXArrayCopyInlining"") == NULL); // Disabling due to a performance regression
+   bool useVSXForCopy  = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8) &&
+                         !disableVSXArrayCopy && cg->comp()->target().cpu.getPPCSupportsVSX();
 
-   bool supportsVSX = (comp->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8)) && !disableVSXArrayCopy && comp->target().cpu.supportsFeature(OMR_FEATURE_PPC_HAS_VSX);
-   bool supportsLEArrayCopy = !disableLEArrayCopyHelper && comp->target().cpu.isLittleEndian() && comp->target().cpu.hasFPU();
+   // VSX supercedes FPU.  No reason to offering disable option on this.
+   //    POWER8 potentially micor-coded unaligned integer accesses in LE mode,","Minor typo:

```suggestion
   //    POWER8 potentially micro-coded unaligned integer accesses in LE mode,
```",
448177570,c64a3e8e28fbcd91fd2f8b12cb79ca439d0b0f7e,runtime/compiler/p/codegen/J9TreeEvaluator.cpp,False,"@@ -13458,12 +13148,18 @@ TR::Register *J9::Power::TreeEvaluator::arraycopyEvaluator(TR::Node *node, TR::C
    TR::Register *metaReg = cg->getMethodMetaDataRegister();
 
    // This section calculates the number of dependencies needed by the assembly helpers path.
+   bool postP10Copy = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P10) &&
+                      cg->comp()->target().cpu.getPPCSupportsVSX();
+
    static bool disableVSXArrayCopy = (feGetEnv(""TR_disableVSXArrayCopy"") != NULL);
-   static bool disableLEArrayCopyHelper = (feGetEnv(""TR_disableLEArrayCopyHelper"") != NULL);
-   static bool disableVSXArrayCopyInlining = (feGetEnv(""TR_enableVSXArrayCopyInlining"") == NULL); // Disabling due to a performance regression
+   bool useVSXForCopy  = cg->comp()->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8) &&
+                         !disableVSXArrayCopy && cg->comp()->target().cpu.getPPCSupportsVSX();
 
-   bool supportsVSX = (comp->target().cpu.isAtLeast(OMR_PROCESSOR_PPC_P8)) && !disableVSXArrayCopy && comp->target().cpu.supportsFeature(OMR_FEATURE_PPC_HAS_VSX);
-   bool supportsLEArrayCopy = !disableLEArrayCopyHelper && comp->target().cpu.isLittleEndian() && comp->target().cpu.hasFPU();
+   // VSX supercedes FPU.  No reason to offering disable option on this.","If I'm reading this correctly, this comment seems to be referring to the removal of the env var checks above? Can you please clarify what this is saying?",
65647111,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,False,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv",Since you're creating the expression yourself I suggest you create the optimal one now rather than relying on the code generator to do any sort of optimization on it. We have multiple code generators and creating trees that then need to be optimized in all of them is not such a good idea.,
101198158,56561125777e2cf9e9b602b0fc8cdacc43d84b57,runtime/makelib/mkconstants.mk.ftl,True,"@@ -33,27 +33,70 @@ ifndef UMA_TARGET_PATH
 endif
 
 # Define all the tool used for compilation and linking.
-<#if uma.spec.tools.interp_gcc.needed>INTERP_GCC=${uma.spec.tools.interp_gcc.name}<#else>#INTERP_GCC not used</#if>
-<#if uma.spec.tools.as.needed>AS=${uma.spec.tools.as.name}<#else># AS not used</#if>
-<#if uma.spec.tools.cc.needed>CC=${uma.spec.tools.cc.name}<#else># CC not used</#if>
-<#if uma.spec.tools.cpp.needed>CPP=${uma.spec.tools.cpp.name}<#else># CPP not used</#if>
-<#if uma.spec.tools.cxx.needed>CXX=${uma.spec.tools.cxx.name}<#else># CXX not used</#if>
-<#if uma.spec.tools.rc.needed>RC=${uma.spec.tools.rc.name}<#else># RC not used</#if>
-<#if uma.spec.tools.link.needed>LINK=${uma.spec.tools.link.name}<#else># LINK not used</#if>
-<#if uma.spec.tools.mt.needed>MT=${uma.spec.tools.mt.name}<#else># MT not used</#if>
-<#if uma.spec.tools.implib.needed>IMPLIB=${uma.spec.tools.implib.name}<#else># IMPLIB not used</#if>
-<#if uma.spec.tools.ar.needed>AR=${uma.spec.tools.ar.name}<#else># AR not used</#if>
-<#if uma.spec.tools.ranlib.needed>RANLIB=${uma.spec.tools.ranlib.name}<#else># RANLIB not used</#if>
-<#if uma.spec.tools.dll_ld.needed>DLL_LD=${uma.spec.tools.dll_ld.name}<#else># DLL_LD not used</#if>
-<#if uma.spec.tools.cxx_dll_ld.needed>CXX_DLL_LD=${uma.spec.tools.cxx_dll_ld.name}<#else># CXX_DLL_LD not used</#if>
-<#if uma.spec.tools.exe_ld.needed>EXE_LD=${uma.spec.tools.exe_ld.name}<#else># EXE_LD not used</#if>
-<#if uma.spec.tools.cxx_exe_ld.needed>CXX_EXE_LD=${uma.spec.tools.cxx_exe_ld.name}<#else># CXX_EXE_LD not used</#if>
-<#if uma.spec.tools.dll_ld.needed>UMA_DLL_LD=$(if $(UMA_IS_C_PLUS_PLUS),$(CXX_DLL_LD),$(DLL_LD))</#if>
-<#if uma.spec.tools.exe_ld.needed>UMA_EXE_LD=$(if $(UMA_IS_C_PLUS_PLUS),$(CXX_EXE_LD),$(EXE_LD))</#if>
+<#if uma.spec.tools.interp_gcc.needed>
+# Order of preference: INTERP_GCC if set, CC if set and not default, otherwise uma.spec.tools.interp_gcc.name","My thinking here is that if a typical user sets `CC` the expectation will be that that everything is built with the requested compiler. If we don't allow `CC` to set `INTERP_GCC` they'll have to dig around to discover what's going on and override it themselves, which is an annoyance I wouldn't want to inflict.

On the flip side anyone who's aware of `INTERP_GCC` can still set it themselves if they override `CC`, although it just occurred to me that they'd have to know what the hardcoded value was, so perhaps another var like `INTERP_GCC_IGNORE_CC` to control this behaviour makes sense, that way you can set your own value or keep the hardcoded value without knowing/caring what it is.",
101778045,209839c5234d3576a3db29c32f66266b884ed489,buildenv/Build_Instructions_V8.md,False,"@@ -304,9 +304,114 @@ OpenJDK  - 27f5b8f based on jdk8u152-b03)
 
 ## Windows
 :ledger:
+The following instructions guide you through the process of building a Windows 64-bit OpenJDK V8 binary that contains Eclipse OpenJ9. This process can be used to build binaries for Windows 7, 8, and 10.
 
-:construction:
-We haven't created a full build process for Windows yet? Watch this space!
+### 1. Prepare your system
+:ledger:
+You must install a number of software dependencies to create a suitable build environment on your system:
+
+- [Cygwin for 64-bit versions of Windows](https://cygwin.com/install.html), which provides a Unix-style command line interface. Install all packages in the `Devel` category. In the `Archive` category, install the packages `zip`, `unzip`, and `cpio`. Install any further package dependencies that are identified by the installer. More information about using Cygwin can be found [here](https://cygwin.com/docs.html).
+- [Windows JDK 7](http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html), which is used as the boot JDK.
+- [Windows SDK 7 Debugging tools](https://www.microsoft.com/download/confirmation.aspx?id=8279).
+- [Microsoft Visual Studio Professional 2010](https://www.visualstudio.com/vs/older-downloads/).
+- [Microsoft Visual Studio 2010 Service Pack 1](https://support.microsoft.com/en-us/help/983509/description-of-visual-studio-2010-service-pack-1)
+- [Freemarker V2.3.8](https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download)
+- [Freetype2 V2.3 or newer](https://www.freetype.org/download.html)
+
+Update your `LIB` and `INCLUDE` environment variables to provide a path to the Windows debugging tools with the following commands:
+
+```
+set INCLUDE =""C:\Program Files\Debugging Tools for Windows (x64)\sdk\inc"";%INCLUDE%
+set LIB=""C:\Program Files\Debugging Tools for Windows (x64)\sdk\lib"";%LIB%;
+```","When I tried to follow these instructions having quotes here, either around just the path being prepended or around the whole thing made OpenJDK's `configure` fail. Getting rid of the quotes made it happy.",
101806170,209839c5234d3576a3db29c32f66266b884ed489,buildenv/Build_Instructions_V8.md,False,"@@ -304,9 +304,114 @@ OpenJDK  - 27f5b8f based on jdk8u152-b03)
 
 ## Windows
 :ledger:
+The following instructions guide you through the process of building a Windows 64-bit OpenJDK V8 binary that contains Eclipse OpenJ9. This process can be used to build binaries for Windows 7, 8, and 10.
 
-:construction:
-We haven't created a full build process for Windows yet? Watch this space!
+### 1. Prepare your system
+:ledger:
+You must install a number of software dependencies to create a suitable build environment on your system:
+
+- [Cygwin for 64-bit versions of Windows](https://cygwin.com/install.html), which provides a Unix-style command line interface. Install all packages in the `Devel` category. In the `Archive` category, install the packages `zip`, `unzip`, and `cpio`. Install any further package dependencies that are identified by the installer. More information about using Cygwin can be found [here](https://cygwin.com/docs.html).
+- [Windows JDK 7](http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html), which is used as the boot JDK.
+- [Windows SDK 7 Debugging tools](https://www.microsoft.com/download/confirmation.aspx?id=8279).
+- [Microsoft Visual Studio Professional 2010](https://www.visualstudio.com/vs/older-downloads/).
+- [Microsoft Visual Studio 2010 Service Pack 1](https://support.microsoft.com/en-us/help/983509/description-of-visual-studio-2010-service-pack-1)
+- [Freemarker V2.3.8](https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download)
+- [Freetype2 V2.3 or newer](https://www.freetype.org/download.html)
+
+Update your `LIB` and `INCLUDE` environment variables to provide a path to the Windows debugging tools with the following commands:
+
+```
+set INCLUDE =""C:\Program Files\Debugging Tools for Windows (x64)\sdk\inc"";%INCLUDE%
+set LIB=""C:\Program Files\Debugging Tools for Windows (x64)\sdk\lib"";%LIB%;
+```
+
+You can download Freemarker and Freetype manually or obtain them using the [wget](http://www.gnu.org/software/wget/faq.html#download) utility. If you choose to use `wget`, follow these steps:
+
+- Open a cygwin64 terminal and change to the `/temp` directory:
+```
+cd /cygdrive/c/temp
+```
+
+- Run the following commands:
+```
+wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+wget http://download.savannah.gnu.org/releases/freetype/freetype-2.5.3.tar.gz
+```
+
+- To unpack the Freemarker and Freetype compressed files, run:
+```
+tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+tar --one-top-level=/cygdrive/c/temp/freetype --strip-components=1 -xzf freetype-2.5.3.tar.gz
+```
+
+- To build the Freetype dynamic and static libraries, open the Visual Studio Command Prompt (VS2010) (see C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Microsoft Visual Studio 2010\Visual Studio Tools) and run:
+```
+cd c:\temp
+msbuild.exe C:/temp/freetype/builds/windows/vc2010/freetype.vcxproj  /p:PlatformToolset=v100  /p:Configuration=""Release Multithreaded""  /p:Platform=x64  /p:ConfigurationType=DynamicLibrary  /p:TargetName=freetype  /p:OutDir=""C:/temp/freetype/lib64/""  /p:IntDir=""C:/temp/freetype/obj64/"" > freetype.log
+msbuild.exe C:/temp/freetype/builds/windows/vc2010/freetype.vcxproj  /p:PlatformToolset=v100  /p:Configuration=""Release Multithreaded""  /p:Platform=x64  /p:ConfigurationType=StaticLibrary  /p:TargetName=freetype  /p:OutDir=""C:/temp/freetype/lib64/""  /p:IntDir=""C:/temp/freetype/obj64/"" >> freetype.log
+```","I noticed that this is how OpenJDK9 builds freetype as well, but it doesn't really do what was intended. This is building both a dynamic library and a static library, and later linking against the static library; the DLL is completely unused. The intention seems to be to build a DLL and the corresponding import library, not a static library. The MSVC linker produces import libraries for DLLs automatically when DLLs export things, but this version of freetype doesn't export any symbols. Looks like it's fixed in later versions and the public API is declared with `__declspec(dllexport)`, but for this one either the source would need to be modified or an exports file declaring some symbols would need to be fed to the linker.",
101966173,209839c5234d3576a3db29c32f66266b884ed489,buildenv/Build_Instructions_V8.md,False,"@@ -304,9 +304,114 @@ OpenJDK  - 27f5b8f based on jdk8u152-b03)
 
 ## Windows
 :ledger:
+The following instructions guide you through the process of building a Windows 64-bit OpenJDK V8 binary that contains Eclipse OpenJ9. This process can be used to build binaries for Windows 7, 8, and 10.
 
-:construction:
-We haven't created a full build process for Windows yet? Watch this space!
+### 1. Prepare your system
+:ledger:
+You must install a number of software dependencies to create a suitable build environment on your system:
+
+- [Cygwin for 64-bit versions of Windows](https://cygwin.com/install.html), which provides a Unix-style command line interface. Install all packages in the `Devel` category. In the `Archive` category, install the packages `zip`, `unzip`, and `cpio`. Install any further package dependencies that are identified by the installer. More information about using Cygwin can be found [here](https://cygwin.com/docs.html).
+- [Windows JDK 7](http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html), which is used as the boot JDK.
+- [Windows SDK 7 Debugging tools](https://www.microsoft.com/download/confirmation.aspx?id=8279).
+- [Microsoft Visual Studio Professional 2010](https://www.visualstudio.com/vs/older-downloads/).
+- [Microsoft Visual Studio 2010 Service Pack 1](https://support.microsoft.com/en-us/help/983509/description-of-visual-studio-2010-service-pack-1)
+- [Freemarker V2.3.8](https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download)
+- [Freetype2 V2.3 or newer](https://www.freetype.org/download.html)
+
+Update your `LIB` and `INCLUDE` environment variables to provide a path to the Windows debugging tools with the following commands:
+
+```
+set INCLUDE =""C:\Program Files\Debugging Tools for Windows (x64)\sdk\inc"";%INCLUDE%
+set LIB=""C:\Program Files\Debugging Tools for Windows (x64)\sdk\lib"";%LIB%;
+```
+
+You can download Freemarker and Freetype manually or obtain them using the [wget](http://www.gnu.org/software/wget/faq.html#download) utility. If you choose to use `wget`, follow these steps:
+
+- Open a cygwin64 terminal and change to the `/temp` directory:
+```
+cd /cygdrive/c/temp
+```
+
+- Run the following commands:
+```
+wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+wget http://download.savannah.gnu.org/releases/freetype/freetype-2.5.3.tar.gz
+```
+
+- To unpack the Freemarker and Freetype compressed files, run:
+```
+tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+tar --one-top-level=/cygdrive/c/temp/freetype --strip-components=1 -xzf freetype-2.5.3.tar.gz
+```
+
+- To build the Freetype dynamic and static libraries, open the Visual Studio Command Prompt (VS2010) (see C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Microsoft Visual Studio 2010\Visual Studio Tools) and run:
+```
+cd c:\temp
+msbuild.exe C:/temp/freetype/builds/windows/vc2010/freetype.vcxproj  /p:PlatformToolset=v100  /p:Configuration=""Release Multithreaded""  /p:Platform=x64  /p:ConfigurationType=DynamicLibrary  /p:TargetName=freetype  /p:OutDir=""C:/temp/freetype/lib64/""  /p:IntDir=""C:/temp/freetype/obj64/"" > freetype.log
+msbuild.exe C:/temp/freetype/builds/windows/vc2010/freetype.vcxproj  /p:PlatformToolset=v100  /p:Configuration=""Release Multithreaded""  /p:Platform=x64  /p:ConfigurationType=StaticLibrary  /p:TargetName=freetype  /p:OutDir=""C:/temp/freetype/lib64/""  /p:IntDir=""C:/temp/freetype/obj64/"" >> freetype.log
+```","Aside from the quotes issue mentioned above that should be changed, yes they work.

There's a bug in the OMR build files that bit me, but it depends on what your `PATH` is set to and I submitted a PR to them to fix that.",
102787878,56561125777e2cf9e9b602b0fc8cdacc43d84b57,runtime/makelib/mkconstants.mk.ftl,True,"@@ -33,27 +33,137 @@ ifndef UMA_TARGET_PATH
 endif
 
 # Define all the tool used for compilation and linking.
-<#if uma.spec.tools.interp_gcc.needed>INTERP_GCC=${uma.spec.tools.interp_gcc.name}<#else>#INTERP_GCC not used</#if>
-<#if uma.spec.tools.as.needed>AS=${uma.spec.tools.as.name}<#else># AS not used</#if>
-<#if uma.spec.tools.cc.needed>CC=${uma.spec.tools.cc.name}<#else># CC not used</#if>
-<#if uma.spec.tools.cpp.needed>CPP=${uma.spec.tools.cpp.name}<#else># CPP not used</#if>
-<#if uma.spec.tools.cxx.needed>CXX=${uma.spec.tools.cxx.name}<#else># CXX not used</#if>
-<#if uma.spec.tools.rc.needed>RC=${uma.spec.tools.rc.name}<#else># RC not used</#if>
-<#if uma.spec.tools.link.needed>LINK=${uma.spec.tools.link.name}<#else># LINK not used</#if>
-<#if uma.spec.tools.mt.needed>MT=${uma.spec.tools.mt.name}<#else># MT not used</#if>
-<#if uma.spec.tools.implib.needed>IMPLIB=${uma.spec.tools.implib.name}<#else># IMPLIB not used</#if>
-<#if uma.spec.tools.ar.needed>AR=${uma.spec.tools.ar.name}<#else># AR not used</#if>
-<#if uma.spec.tools.ranlib.needed>RANLIB=${uma.spec.tools.ranlib.name}<#else># RANLIB not used</#if>
-<#if uma.spec.tools.dll_ld.needed>DLL_LD=${uma.spec.tools.dll_ld.name}<#else># DLL_LD not used</#if>
-<#if uma.spec.tools.cxx_dll_ld.needed>CXX_DLL_LD=${uma.spec.tools.cxx_dll_ld.name}<#else># CXX_DLL_LD not used</#if>
-<#if uma.spec.tools.exe_ld.needed>EXE_LD=${uma.spec.tools.exe_ld.name}<#else># EXE_LD not used</#if>
-<#if uma.spec.tools.cxx_exe_ld.needed>CXX_EXE_LD=${uma.spec.tools.cxx_exe_ld.name}<#else># CXX_EXE_LD not used</#if>
-<#if uma.spec.tools.dll_ld.needed>UMA_DLL_LD=$(if $(UMA_IS_C_PLUS_PLUS),$(CXX_DLL_LD),$(DLL_LD))</#if>
-<#if uma.spec.tools.exe_ld.needed>UMA_EXE_LD=$(if $(UMA_IS_C_PLUS_PLUS),$(CXX_EXE_LD),$(EXE_LD))</#if>
+<#if uma.spec.tools.interp_gcc.needed>
+ifneq (default,$(origin CC))
+  ifndef INTERP_GCC
+    # If the user has overridden CC we'll want to let them know that INTERP_GCC exists.
+    ifndef PRINT_ONCE_INTERP_GCC
+      $(info ****************)
+      $(info *)
+      $(info * CC=$(CC) (overridden), note that this build will also invoke another compiler that can be overridden: INTERP_GCC=${uma.spec.tools.interp_gcc.name})
+      $(info *)
+      $(info ****************)
+      $(shell sleep 5)",Sleep removed.,
109766525,81915844351d0ca8d2aad53bff4e7dfb179f1b26,runtime/compiler/trj9/control/J9Options.cpp,False,"@@ -85,6 +85,9 @@ int32_t J9::Options::_smallMethodBytecodeSizeThresholdForCold = -1; // -1 means
 
 int32_t J9::Options::_countForMethodsCompiledDuringStartup = 10;
 
+int32_t J9::Options::_countForLoopyBootstrapMethods = 3000; // 3000 means disable the feature by default
+int32_t J9::Options::_countForLooplessBootstrapMethods = 3000; // means disable the feature by default","Why does 3000 mean disabled? I'm assuming it's because the default count and bcount are also 3000. The symbolic constants for those values are `TR_DEFAULT_INITIAL_COUNT` and `TR_DEFAULT_INITIAL_BCOUNT` but even then it looks like the actual initial count we go with is determined at run time based on other options (e.g. quickstart), so if the goal is to keep these changes disabled for now by keeping the behaviour the same this might not be sufficient. It seems like these counts shouldn't be statically initialized, they should be initialized with whatever values we decide on for the default counts.",
109766525,81915844351d0ca8d2aad53bff4e7dfb179f1b26,runtime/compiler/trj9/control/HookedByTheJit.cpp,False,"@@ -564,7 +564,11 @@ static void jitHookInitializeSendTarget(J9HookInterface * * hook, UDATA eventNum
          } // if (TR::Options::sharedClassCache())
       if (count == -1) // count didn't change yet
          {
-         count = getCount(romMethod, optionsJIT, optionsAOT);
+         if (!TR::Options::getCountsAreProvidedByUser() &&
+            fe->isClassLibraryMethod((TR_OpaqueMethodBlock *)method))","The description for this change says we want to target ""methods belonging to bootstrap classes that are executed a lot during start-up but to a lesser degree during steady state"" but the check here is `isClassLibraryMethod()` which is basically every method from JCL and J9VM classes (regardless of when and how often it's executed) isn't it? Is there some other logic elsewhere that actually limits the behaviour to what was desired?",
109809767,81915844351d0ca8d2aad53bff4e7dfb179f1b26,runtime/compiler/trj9/control/HookedByTheJit.cpp,False,"@@ -564,7 +564,11 @@ static void jitHookInitializeSendTarget(J9HookInterface * * hook, UDATA eventNum
          } // if (TR::Options::sharedClassCache())
       if (count == -1) // count didn't change yet
          {
-         count = getCount(romMethod, optionsJIT, optionsAOT);
+         if (!TR::Options::getCountsAreProvidedByUser() &&
+            fe->isClassLibraryMethod((TR_OpaqueMethodBlock *)method))","Is there any concern that this could negatively affect programs that make heavy use of the JCL long after startup? E.g. programs that use `java/{util/math/io}` or something of that nature in their primary task? Since the functionality will be disabled until more performance measurements are done I don't think we need an answer to this now, but finding/measuring important programs that go against this assumption is probably a worthwhile data point.",
161260921,8fafd6060a4354bf23d5baed3f0312a1f39c3efe,runtime/compiler/control/CompilationThread.cpp,False,"@@ -501,10 +501,7 @@ bool TR::CompilationInfo::shouldDowngradeCompReq(TR_MethodToBeCompiled *entry)
                  !TR::Options::getCmdLineOptions()->getOption(TR_DisableDowngradeToColdOnVMPhaseStartup))
                )
                {
-#if !defined(J9ZOS390)  // disable for zOS because we don't want to increase CPU time
-               if (!importantMethodForStartup(method))
-#endif","Does removing this mean that on zOS we'll be compiling ""important for start-up"" methods at AOT-warm now, where as before they were compiled at AOT-cold? Since the comment for this `#ifdef` says it's purpose is to reduce CPU consumption perhaps we need someone to clarify exactly what was desired. This patch should result in less CPU consumption when the important for start-up methods are in the cache, but more if they have to be compiled since they're now at a higher opt level.

Is zOS OK with this change or do we really want to maintain the slightly different behaviour for it? Personally I'd prefer it if heuristics were the same on all platforms, it makes life easier for everyone in the long run, but I'm not qualified to comment on zOS issues.

If ""tweaks"" like this need to exist they should be guarded with an option rather than an `#ifdef` since there is really nothing architecture-specific about the heuristic or the tweak and it would make it easier to know that the tweak even exists in the first place.

Any comments @fjeremic and/or @joransiu?",
175029970,72385dbe4db56277fb0f42fe62c9f7da9b7ca569,runtime/compiler/control/CompilationThread.cpp,False,"@@ -4226,7 +4226,7 @@ TR::CompilationInfo::addMethodToBeCompiled(TR::IlGeneratorMethodDetails & detail
    // in which case the compilation is already done and we should not even try to enqueue
 
    // JITaaS: Even if a method is already queued, we plan to recompile it for the new request","Looks like this comment is no longer needed right?

```suggestion
```",
181090794,e44c7f5ae0f4e05b71b5f2456750f99b9ecd4273,runtime/compiler/control/HookedByTheJit.cpp,True,"@@ -4106,7 +4106,9 @@ static void jitHookClassLoad(J9HookInterface * * hookInterface, UDATA eventNum,
          allocFailed = true;
       }
 
-   compInfo->getPersistentInfo()->ensureUnloadedAddressSetsAreInitialized();
+   // In JITaaS server mode unloaded addresses are maintained per client
+   if (compInfo->getPersistentInfo()->getJITaaSMode() != SERVER_MODE)","I checked that the hook was being called on the server and it is unfortunately, presumably because bootstrap classes are still loaded. There are various other JITaaS mode checks in that code so it seems to have been the case all along at least.

Anyway I've moved the check into `ensureUnloadedAddressSetsAreInitialized()` instead to make sure the single persistent instances are never created on the server regardless of where it's called from.",
181595667,e44c7f5ae0f4e05b71b5f2456750f99b9ecd4273,runtime/compiler/runtime/ClassUnloadAssumption.cpp,True,"@@ -1280,6 +1292,23 @@ J9::PersistentInfo::addUnloadedClass(
    }
 
 
+void TR_AddressSet::destroy()
+   {
+   jitPersistentFree(_addressRanges);
+   }
+
+void TR_AddressSet::getRanges(std::vector<TR_AddressRange> &ranges)
+   {
+   ranges.insert(ranges.begin(), _addressRanges, _addressRanges + _numAddressRanges);","It should be since the source iterators are pointers and `std::distance()` can be calculated in constant time, but I've changed the caller to construct the vector with the exact required capacity to avoid even the initial expansion.",
181595718,e44c7f5ae0f4e05b71b5f2456750f99b9ecd4273,runtime/compiler/runtime/ClassUnloadAssumption.cpp,True,"@@ -1280,6 +1292,23 @@ J9::PersistentInfo::addUnloadedClass(
    }
 
 
+void TR_AddressSet::destroy()
+   {
+   jitPersistentFree(_addressRanges);
+   }
+
+void TR_AddressSet::getRanges(std::vector<TR_AddressRange> &ranges)
+   {
+   ranges.insert(ranges.begin(), _addressRanges, _addressRanges + _numAddressRanges);
+   }
+
+void TR_AddressSet::setRanges(std::vector<TR_AddressRange> &ranges)",Done.,
181595935,e44c7f5ae0f4e05b71b5f2456750f99b9ecd4273,runtime/compiler/runtime/ClassUnloadAssumption.cpp,True,"@@ -1280,6 +1292,23 @@ J9::PersistentInfo::addUnloadedClass(
    }
 
 
+void TR_AddressSet::destroy()
+   {
+   jitPersistentFree(_addressRanges);
+   }
+
+void TR_AddressSet::getRanges(std::vector<TR_AddressRange> &ranges)
+   {
+   ranges.insert(ranges.begin(), _addressRanges, _addressRanges + _numAddressRanges);
+   }
+
+void TR_AddressSet::setRanges(std::vector<TR_AddressRange> &ranges)
+   {
+   TR_ASSERT(ranges.size() <= _maxAddressRanges, ""Setting too many ranges"");",Done. The address set is allocated dynamically the first time the server processes unloaded classes for each client. The max size is transmitted from the client together with the initial set of ranges.,
181595948,e44c7f5ae0f4e05b71b5f2456750f99b9ecd4273,runtime/compiler/control/JITaaSCompilationThread.cpp,True,"@@ -2415,20 +2431,35 @@ ClientSessionData::~ClientSessionData()
    _romMapMonitor->destroy();
    _systemClassMapMonitor->destroy();
    _sequencingMonitor->destroy();
+   _unloadedClassAddresses.destroy();
    jitPersistentFree(_vmInfo);
    }
 
 void
-ClientSessionData::processUnloadedClasses(const std::vector<TR_OpaqueClassBlock*> &classes)
+ClientSessionData::processUnloadedClasses(JITaaS::J9ServerStream *stream, const std::vector<TR_OpaqueClassBlock*> &classes)
    {
    if (TR::Options::getVerboseOption(TR_VerboseJITaaS))
       TR_VerboseLog::writeLineLocked(TR_Vlog_JITaaS, ""Server will process a list of %u unloaded classes for clientUID %llu"", (unsigned)classes.size(), (unsigned long long)_clientUID);
+
+   if (_requestUnloadedClasses)
+      {
+      stream->write(JITaaS::J9ServerMessageType::getUnloadedClassRanges, JITaaS::Void());
+      auto unloadedClassRanges = std::get<0>(stream->read<std::vector<TR_AddressRange> >());
+      OMR::CriticalSection getUnloadedClasses(getROMMapMonitor());
+      _unloadedClassAddresses.setRanges(unloadedClassRanges);
+      _requestUnloadedClasses = false;
+      }
+
    OMR::CriticalSection processUnloadedClasses(getROMMapMonitor());
-   for (TR_OpaqueClassBlock *clazz : classes)
+
+   for (auto clazz : classes)
       {
+      _unloadedClassAddresses.add((uintptrj_t)clazz);",Done.,
181595971,e44c7f5ae0f4e05b71b5f2456750f99b9ecd4273,runtime/compiler/runtime/ClassUnloadAssumption.cpp,True,"@@ -1236,9 +1241,16 @@ J9::PersistentInfo::isUnloadedClass(
       void *v,
       bool yesIReallyDontCareAboutHCR)
    {
-   OMR::CriticalSection isUnloadedClass(assumptionTableMutex);
-   bool result = (_unloadedClassAddresses && _unloadedClassAddresses->mayContain((uintptrj_t)v));
-   return result;
+   if (getJITaaSMode() != SERVER_MODE)
+      {
+      OMR::CriticalSection isUnloadedClass(assumptionTableMutex);
+      return _unloadedClassAddresses && _unloadedClassAddresses->mayContain((uintptrj_t)v);
+      }
+   else
+      {
+      OMR::CriticalSection isUnloadedClass(TR::compInfoPT->getClientData()->getROMMapMonitor());",Done.,
181596001,e44c7f5ae0f4e05b71b5f2456750f99b9ecd4273,runtime/compiler/runtime/IProfiler.cpp,True,"@@ -1208,6 +1208,10 @@ TR_IPMethodHashTableEntry::add(TR_OpaqueMethodBlock *caller, TR_OpaqueMethodBloc
 bool
 TR_IProfiler::invalidateEntryIfInconsistent(TR_IPBytecodeHashTableEntry *entry)
    {
+   // Invalid entries are purged elsewhere in JITaaS server mode
+   if (_compInfo->getPersistentInfo()->getJITaaSMode() == SERVER_MODE)",Done.,
181596009,e44c7f5ae0f4e05b71b5f2456750f99b9ecd4273,runtime/compiler/runtime/RuntimeAssumptions.hpp,True,"@@ -229,6 +229,10 @@ class TR_AddressSet
       _maxAddressRanges(maxAddressRanges)
       {}
 
+   void destroy();
+   void getRanges(std::vector<TR_AddressRange> &ranges);
+   void setRanges(std::vector<TR_AddressRange> &ranges);",Done.,
188142259,4926c2031a5fccf7b17924d95fa69ae324bb3326,runtime/compiler/control/CompilationRuntime.hpp,False,"@@ -1115,7 +1120,7 @@ class CompilationInfo
    bool                   _traceCompiling;
 #endif
    int32_t                _compThreadIndex;
-   int32_t                _numDiagnosticThreads;
+   int32_t                _diagnosticThreadIndex;",Are `_diagnosticThreadIndex` and `_compThreadIndex` supposed to be 0-based indices or a count of the number of threads? I see it them being used as both and it is a little confusing.,
195252275,2659a67109d5d77c9efd224878e8028242bb1754,runtime/compiler/codegen/J9AheadOfTimeCompile.cpp,True,"@@ -1742,6 +1750,19 @@ J9::AheadOfTimeCompile::dumpRelocationData()
             }
             break;
 
+         case TR_MethodCallAddress:","Can you clarify why we have methods like `initializeCommonAOTRelocationHeader` and `dumpRelocationHeaderData` that manipulate the entire record, not just the header?

In the previous case I was writing to both a header field and the record's data portion, and in this case I'm dumping the record's data, not the header.",
66046519,86016d5e9d2f52c5d6170f252e283a02d3a6100b,',False,"@@ -0,0 +1,3247 @@
+/*******************************************************************************",Not sure what happened here but it shouldn't be a new file.,
120772656,72cd36c0188ea1e3bdc9893d128d02f6254fbedf,.copyrightignore,False,"@@ -0,0 +1,30 @@
+# *******************************************************************************
+# Copyright (c) 2017, 2018 IBM Corp. and others","Initial date should be the year the file was originally authored, please update to `2018`",
120772656,72cd36c0188ea1e3bdc9893d128d02f6254fbedf,.copyrightignore,False,"@@ -0,0 +1,30 @@
+# *******************************************************************************
+# Copyright (c) 2017, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+# *******************************************************************************
+# TODO README ON COPYRIGHT WHITELIST
+# *******************************************************************************/
+/doc/
+#
+/job
+/*.ignore
+debugtools/**/*.ignore
+buildspecs/*.ignore
+/jobs/pipelines/",Please add a newline at the end of the file,
120772656,72cd36c0188ea1e3bdc9893d128d02f6254fbedf,.copyrightignore,False,"@@ -0,0 +1,30 @@
+# *******************************************************************************
+# Copyright (c) 2017, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+# *******************************************************************************
+# TODO README ON COPYRIGHT WHITELIST",Please fill in this README section on how to use the .copyrightignore file,
121152388,72cd36c0188ea1e3bdc9893d128d02f6254fbedf,.copyrightignore,True,"@@ -0,0 +1,30 @@
+# *******************************************************************************
+# Copyright (c) 2017, 2018 IBM Corp. and others",fixed,
121152445,72cd36c0188ea1e3bdc9893d128d02f6254fbedf,.copyrightignore,True,"@@ -0,0 +1,30 @@
+# *******************************************************************************
+# Copyright (c) 2017, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+# *******************************************************************************
+# TODO README ON COPYRIGHT WHITELIST
+# *******************************************************************************/
+/doc/
+#
+/job
+/*.ignore
+debugtools/**/*.ignore
+buildspecs/*.ignore
+/jobs/pipelines/",fixed,
177508561,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,39 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**# path contains ""jobs"" folder, but not root directory
+#  2./doc#root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore# all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/#pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore#all ignore files only
+#  7.**/jobs/**/pipelines/#directory path contains both jobs and pipelines not root directory
+#  8.*job* all things at contains characters in between stars
+# *******************************************************************************/
+**/jobs/**#comment
+/doc
+*job*
+#*.ignore
+/*.ignore
+/debugtools/**/*.ignore
+**/jobs/**/pipelines/
+**/jobs/pipelines/",I think these were examples just for testing purposes ^ and should be removed.,
177545156,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,True,"@@ -0,0 +1,39 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**# path contains ""jobs"" folder, but not root directory
+#  2./doc#root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore# all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/#pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore#all ignore files only
+#  7.**/jobs/**/pipelines/#directory path contains both jobs and pipelines not root directory
+#  8.*job* all things at contains characters in between stars
+# *******************************************************************************/
+**/jobs/**#comment
+/doc
+*job*
+#*.ignore
+/*.ignore
+/debugtools/**/*.ignore
+**/jobs/**/pipelines/
+**/jobs/pipelines/","Not sure whether you wanted all of them removed but have done so. 
We can add others back if needed.",
178039354,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:",I expect copyrightCheck should be copyrightignore,
178039354,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""",The word `root` is repeated twice,
178039354,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory",example uses `pipelines` while description uses `pipeline`,
178039354,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore  #all ignore files only",example uses `.ignore` while description uses `ignore`,
178039354,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore  #all ignore files only
+#  7.**/jobs/**/pipelines/  #directory path contains both jobs and pipelines not root directory","Examples 1 and 2 quote the directory and file names, the remaining examples do not.",
178039354,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore  #all ignore files only
+#  7.**/jobs/**/pipelines/  #directory path contains both jobs and pipelines not root directory
+#  8.*job*  # all things that contains characters in between stars
+# *******************************************************************************/
+
+.copyrightignore",Why ignore .copyrightignore? It has a copyright.,
178780893,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,True,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:",The .copyrightignore file is used by the copyrightCheck so that statement is correct.,
178782149,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,True,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""",Removed 2nd root,
178782722,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,True,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory",Updated to use `pipelines`,
178783090,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,True,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore  #all ignore files only",Updated to specify `.ignore`,
178784514,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,True,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore  #all ignore files only
+#  7.**/jobs/**/pipelines/  #directory path contains both jobs and pipelines not root directory
+#  8.*job*  # all things that contains characters in between stars
+# *******************************************************************************/
+
+.copyrightignore","OK, will remove the `.copyrightignore` file, but this then leaves the file empty other than the comments. Do you have any files / paths that should be added to ignore.",
178877925,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore  #all ignore files only
+#  7.**/jobs/**/pipelines/  #directory path contains both jobs and pipelines not root directory
+#  8.*job*  # all things that contains characters in between stars
+# *******************************************************************************/
+
+.copyrightignore","> Do you have any files / paths that should be added to ignore.

I believe so, any file that doesn't already have a copyright. I could write/run a little code later to produce a list.",
178898004,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore  #all ignore files only
+#  7.**/jobs/**/pipelines/  #directory path contains both jobs and pipelines not root directory
+#  8.*job*  # all things that contains characters in between stars
+# *******************************************************************************/
+
+.copyrightignore",I'm fine with an initially blank file. Pete or others can add to it in the future but at least the template is there with instructions.,
179050779,e34ab3c4f683be8fe7b399656945e39e7c970496,.copyrightignore,False,"@@ -0,0 +1,34 @@
+# *******************************************************************************
+# Copyright (c) 2018, 2018 IBM Corp. and others
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+# *******************************************************************************/
+#
+# *******************************************************************************
+#  THE FOLLOWING ARE EXAMPLES OF SYNTAXES copyrightCheck SUPPORTS:
+#  1.**/jobs/**  # path contains ""jobs"" folder, but not root directory
+#  2./doc  #root root level directory and file named ""doc""
+#  3./debugtools/**/*.ignore  # all .ignore file in the root directory debugtools
+#  4./*.ignore #all root directory .ignore files
+#  5.**/jobs/pipelines/  #pipeline folder follows closely with jobs not in root directory
+#  6.*.ignore  #all ignore files only
+#  7.**/jobs/**/pipelines/  #directory path contains both jobs and pipelines not root directory
+#  8.*job*  # all things that contains characters in between stars
+# *******************************************************************************/
+
+.copyrightignore","I found 389 OpenJ9 files without a copyright, but since these files tend not to be modified, I don't think there is any rush to add ignores for any of them. I'm happy to deliver a blank file in this PR and modify it later.",
112110384,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,False,"@@ -0,0 +1,26 @@
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047",This isn't reasonable: it will break all other platforms.,
112204322,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,True,"@@ -0,0 +1,26 @@
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047",I don't think this is an issue. As far as I am aware the git-encoding is only recognised and used by the version of git that is available from rocket software. The tests I have done on other platforms as well as the CI job that was run against this PR (on a Linux machine) all worked successfully.,
114551848,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,False,"@@ -0,0 +1,26 @@
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047",I read some more about git attributes: it seems you're right that unknown attributes will just be ignored.,
114551848,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,False,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+sourcetools/objectmodel/schema/*.xsd git-encoding=iso8859-1 working-tree-encoding=ibm-1047",This is redundant - it's just the defauls set above.,
114551848,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,False,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+sourcetools/objectmodel/schema/*.xsd git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# git's files (which MUST be ASCII)
+.gitattributes git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+.gitignore git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+
+# Binary files
+*.jpg git-encoding=BINARY working-tree-encoding=BINARY
+*.png git-encoding=BINARY working-tree-encoding=BINARY
+*.gif git-encoding=BINARY working-tree-encoding=BINARY
+*.zip git-encoding=BINARY working-tree-encoding=BINARY",All text files should have a final newline ('Y' should *not* be the last character).,
114817997,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,True,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+sourcetools/objectmodel/schema/*.xsd git-encoding=iso8859-1 working-tree-encoding=ibm-1047","OK, will try without these.
Not sure why these were added if the default should have set them correctly.
It may be that we just wanted to ensure these were encoded correctly. ",
114833946,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,False,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+sourcetools/objectmodel/schema/*.xsd git-encoding=iso8859-1 working-tree-encoding=ibm-1047","Why do `runtime/gc_glue_java/*.c*` and `runtime/gc_glue_java/*.h*` need special treatment, but not other C/C++ source files? What, if any, changes will be required for OMR?",
122356908,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,False,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1","Why do .cpp/.hpp files in runtime/gc_glue_java need special treatment? Can they not be subject to the default which applies to the other C/C++ source files throughout the rest of the source tree? If there's a good explanation, please add it as a comment in this file; otherwise please remove these redundant lines.",
122356908,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,False,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+#sourcetools/objectmodel/schema/*.xsd git-encoding=iso8859-1 working-tree-encoding=ibm-1047",Please remove this comment.,
122356908,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,False,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+#sourcetools/objectmodel/schema/*.xsd git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# git's files (which MUST be ASCII)
+.gitattributes git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+.gitignore git-encoding=iso8859-1 working-tree-encoding=iso8859-1",Can these not also be subject to the default text file rules above?,
122452429,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,True,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+#sourcetools/objectmodel/schema/*.xsd git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# git's files (which MUST be ASCII)
+.gitattributes git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+.gitignore git-encoding=iso8859-1 working-tree-encoding=iso8859-1",I don't think so. These are set in the default .gitattributes file that we initially got.,
122452494,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,True,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+#sourcetools/objectmodel/schema/*.xsd git-encoding=iso8859-1 working-tree-encoding=ibm-1047","OK, will do.",
122452990,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,True,"@@ -0,0 +1,46 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.java, *.xml, *.properties, git's .gitattributes and .gitignore
+# files to be encoded as EBCDIC.
+# Selected binary files will not be translated at all.
+
+# The default for text files
+* git-encoding=iso8859-1 working-tree-encoding=ibm-1047
+
+# Specific types of files remain as ASCII
+*.xml git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.dtd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+*.xsd git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+buildspecs/* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.h* git-encoding=iso8859-1 working-tree-encoding=iso8859-1
+runtime/gc_glue_java/*.c* git-encoding=iso8859-1 working-tree-encoding=iso8859-1","There must have been a reason these were added. 
Will remove and see whether it still works as expected.",
122575480,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,False,"@@ -0,0 +1,43 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.xml, *.dtd, *.xsd, and others (see below) as well as","When you get to a final set of encoding mappings, could you please update this comment so it is accurate?",
122626444,9d0160901becfde6defa3fc5dcc79bf900575c57,.gitattributes,True,"@@ -0,0 +1,43 @@
+# Copyright (c) 2000, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+
+# This .gitattributes file will cause all text files EXCEPT for
+# *.xml, *.dtd, *.xsd, and others (see below) as well as","Have changed the comment to be generic.  
There is no point listing all the files that are changed as they are specifically listed in the file. 
Hopefully this is the last change that you require and this PR can be OK'ed and Merged.",
210327879,9a620aba81f206e5c50482f020a5f9330e95ac00,.github/ISSUE_TEMPLATE/test-suite-failure.md,False,"@@ -0,0 +1,9 @@
+---
+name: OpenJ9 test suite failure
+about: A failing functionality, system, or JTReg test
+
+---
+
+Public link to the failing test. If the link is internal, instead include which test suite (functionality, system, etc), platform, JDK version, build level.
+
+Output from the failure, including test name.","We may want to wrap some of these in `<!---` and `-->` so they're displayed as comments in case the issue author forgets to delete them. We can also introduce some sections. For example:

---
### Failure link
<!--- Replace this with a link to the failing test case. If the link is internal, instead include which test suite (functionality, system, etc), platform, JDK version, build level. -->

### Output from the failure
<!--- Place the output from the failure, including test name withing the triple back-ticks below -->
```
```

",
212071370,9a620aba81f206e5c50482f020a5f9330e95ac00,.github/ISSUE_TEMPLATE/test-suite-failure.md,True,"@@ -0,0 +1,9 @@
+---
+name: OpenJ9 test suite failure
+about: A failing functionality, system, or JTReg test
+
+---
+
+Public link to the failing test. If the link is internal, instead include which test suite (functionality, system, etc), platform, JDK version, build level.
+
+Output from the failure, including test name.",There is some risk that a user would put text inside the comments. I've added sections and introduced additional formatting.,
414985679,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/NightlyJDK8BuildAndTest.yml,False,"@@ -0,0 +1,51 @@
+###############################################################################
+# Copyright (c) 2020, 2020 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+###############################################################################
+
+name: ""PR build-jdk-openj9 jdk 8""
+on:
+  schedule:
+    - cron:  '30 21 * * 1-5'
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04] #[ubuntu-16.04, macos-10.15]","Since macos-10.15 can't work for jdk8, it needs to be removed.",
415265785,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/NightlyJDK8BuildAndTest.yml,True,"@@ -0,0 +1,51 @@
+###############################################################################
+# Copyright (c) 2020, 2020 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+###############################################################################
+
+name: ""PR build-jdk-openj9 jdk 8""
+on:
+  schedule:
+    - cron:  '30 21 * * 1-5'
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04] #[ubuntu-16.04, macos-10.15]",Updated.,
412811763,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,False,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1",This part should be delivered to the openj9 repo as well.,
412811763,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,False,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1
+      id: buildJDK
+      with: 
+        version: 11
+        usePersonalRepo: true
+    - name: AQA
+      uses: AdoptOpenJDK/run-aqa@v1
+      env:
+        TEST_JDK_HOME: ${{ steps.buildJDK.outputs.BuildJDKDir }}
+      with:
+        build_list: 'functional'
+        target: '_sanity'
+    - uses: actions/upload-artifact@v2
+      if: failure()
+      with:
+        name: test_output
+        path: ./**/test_output_*/",Pls add a new line at the end.,
414537406,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,False,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1","See my comment in issue #9570 - my thought was to have this action live as a standalone repo (like openj9-systemtest or openj9-website) as it may also be used by those who may to verify changes to openj9-omr, openjdk-tests, or the extensions repos.

<img width=""774"" alt=""Screen Shot 2020-05-19 at 10 50 14 AM"" src=""https://user-images.githubusercontent.com/2836948/82342178-501b6f80-99bf-11ea-9ee6-a7638db9ce48.png"">
",
414586426,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,True,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1
+      id: buildJDK
+      with: 
+        version: 11
+        usePersonalRepo: true
+    - name: AQA
+      uses: AdoptOpenJDK/run-aqa@v1
+      env:
+        TEST_JDK_HOME: ${{ steps.buildJDK.outputs.BuildJDKDir }}
+      with:
+        build_list: 'functional'
+        target: '_sanity'
+    - uses: actions/upload-artifact@v2
+      if: failure()
+      with:
+        name: test_output
+        path: ./**/test_output_*/",Done.,
414625452,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,False,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1","The configure step is missing some arguments to be comparable with OpenJ9 builds.
Currently: 
```
if (parseInt(version) > 8)  bootjdkConfigure = `--with-boot-jdk=${workDir}/bootjdk`
bash configure --with-freemarker-jar=${workDir}/freemarker.jar ${bootjdkConfigure}`
```

Linux should also use:
all: `--enable-jitserver --openssl-version=1.1.1g --with-openssl=fetched --enable-cuda --with-cuda=<path>`
8: `--disable-zip-debug-info`

Mac:
all: `--openssl-version=1.1.1g --with-openssl=fetched --enable-openssl-bundling`
8:
`--with-xcode-path=.../Xcode4/Xcode.app --with-openj9-cc=.../clang --with-openj9-cxx=.../clang++ --with-openj9-developer-dir=.../Developer`
`MACOSX_DEPLOYMENT_TARGET=10.9.0 SDKPATH=.../MacOSX10.8.sdk`

Windows:
all: `--openssl-version=1.1.1g --with-openssl=<path> --enable-openssl-bundling --enable-cuda -with-cuda=<path>`
8: `--disable-zip-debug-info --with-freetype-include=.../freetype-2.5.3/include --with-freetype-lib=.../freetype-2.5.3/lib64`
11+: `--with-toolchain-version=2017`",
414932480,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,True,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1","Updated with Linux and Mac. For Windows will update when enabling. 
https://github.com/sophia-guo/build-jdk-openj9/pull/10",
414945938,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,False,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1","`--with-xcode-path=.../Xcode4/Xcode.app --with-openj9-cc=.../clang --with-openj9-cxx=.../clang++ --with-openj9-developer-dir=.../Developer MACOSX_DEPLOYMENT_TARGET=10.9.0 SDKPATH=.../MacOSX10.8.sdk` wasn't meant to be taken literally. The `...` needs to be replaced with a full path. For example, below are the actual commands that OpenJ9 uses, but the paths need to be correct for the machine used to build. Also MACOSX_DEPLOYMENT_TARGET and SDKPATH are environment variables, not configure options. Since JDK8 for Mac needs to build on a older OS version 10.11, probably it can't be built using a github action.

`--with-xcode-path=/Users/jenkins/Xcode4/Xcode.app --with-openj9-cc=/Users/jenkins/Xcode7/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang --with-openj9-cxx=/Users/jenkins/Xcode7/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ --with-openj9-developer-dir=/Users/jenkins/Xcode7/Xcode.app/Contents/Developer`

`SDKPATH=/Users/jenkins/Xcode4/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk`
",
414959217,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,True,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1",macos-10.15 is the only available github-hosted Mac environment for now. And looks like if there will be more Mac versions it will be the newer version. That is saying if we are going to use github-hosted environment there will be no chance to build jdk8 on Mac. Maybe leave those code as comment as TODO.  When there is workable environment we can fix the correct path?,
414985271,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,False,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1",Sounds good.,
415298474,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK11.yml,True,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 11""
+on: # rebuild any PRs and main branch changes
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04, macos-10.15]
+    steps:
+    - uses: sophia-guo/build-jdk-openj9@v1",Updated. https://github.com/sophia-guo/build-jdk-openj9/pull/12,
412314121,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK14.yml,False,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 14""
+on: # rebuild any PRs and main branch changes
+  pull_request:","pull_request:
    branches:
      - master

I know its still a WIP (thanks for getting this together so quickly!), a question: is default to master, or do you have to explicitly state only run this workflow on pull_requests to master (as shown in the snippet above)?",
414579633,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK14.yml,True,"@@ -0,0 +1,29 @@
+name: ""PR build-jdk-openj9 jdk 14""
+on: # rebuild any PRs and main branch changes
+  pull_request:",Updated to nightly as discussed. ,
414946465,eb07f7e02c1140f6e5fe34a53c56cec8fae7a252,.github/workflows/PRTestJDK8.yml,False,"@@ -0,0 +1,51 @@
+###############################################################################
+# Copyright (c) 2020, 2020 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+###############################################################################
+
+name: ""PR build-jdk-openj9 jdk 8""
+on:
+  schedule:
+    - cron:  '30 21 * * 1-5'
+
+jobs:
+  build:
+    runs-on: ${{ matrix.os }}
+    strategy:
+      fail-fast: false
+      matrix:
+        os: [ubuntu-16.04] #[ubuntu-16.04, macos-10.15]",JDK8 only supports building on Mac 10.11,
195102137,8b6343acf6a0829c78ef1201696eb42a7e295180,.gitignore,False,"@@ -1,4 +1,4 @@
-# Copyright (c) 2000, 2018 IBM Corp. and others
+# Copyright (c) 2000, 2019 IBM Corp. and others
 #",can you please revert the changes in this file,
243860204,35dad29d45a8dd3d01514fd827738e6b90866dcc,.gitignore,False,"@@ -43,3 +43,4 @@ com.ibm.jvmti.tests
 # Default test directory (BUILD_ROOT)
 /jvmtest/
 /build/
+.vscode/","Is this directory normally at the root of the working copy? If so, it should be `/.vscode/` here. Please also add a comment so it's clear it's not related to tests.",
244955126,35dad29d45a8dd3d01514fd827738e6b90866dcc,.gitignore,True,"@@ -43,3 +43,4 @@ com.ibm.jvmti.tests
 # Default test directory (BUILD_ROOT)
 /jvmtest/
 /build/
+.vscode/",updated... the tool automatically added it without the `/` which I would have preferred to keep but convention in this file says to add it so I did,
63426489,82d4f8b9d0412ac998164025275446f78ac24762,.travis.yml,False,"@@ -0,0 +1,83 @@
+###############################################################################
+# Copyright (c) 2016, 2017 IBM Corp. and others
+# 
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#      
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#    
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+# 
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+###############################################################################
+os:
+  - linux
+language: cpp
+sudo: false
+#cache: ccache # https://docs.travis-ci.com/user/caching/
+dist: trusty
+addons:
+  apt:
+    packages:
+      - autoconf 
+      - ca-certificates 
+      - ccache 
+      - cpio 
+      - file 
+      - g++-4.8 
+      - gcc-4.8 
+      - git 
+      - git-core 
+      - libasound2-dev 
+      - libcups2-dev 
+      - libelf-dev 
+      - libfreetype6-dev 
+      - libnuma-dev 
+      - libx11-dev 
+      - libxext-dev 
+      - libxrender-dev 
+      - libxt-dev 
+      - libxtst-dev 
+      - make 
+      - openjdk-8-jdk 
+      - pkg-config 
+      - realpath 
+      - ssh 
+      - unzip 
+      - wget 
+      - zip 
+before_install:
+  - jdk_switcher use oraclejdk8
+env:
+  global:
+before_script:
+        #  - ccache -s -z
+  - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+  - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+  - cd ..
+  - git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
+script:
+  # Clear this option so it doesn't interfere with configure detecting the bootjdk
+  - unset _JAVA_OPTIONS
+  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.  
+  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win. 
+  - cd openj9-openjdk-jdk9 && bash ./get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT
+  # Based on https://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/ travis container builds
+  # have 2 cores and 4 gigs of memory.  Attempt to double provision the number of cores for the make...
+  # Limit number of jobs to work around g++ internal compiler error
+  - export UMA_WINDOWS_PARRALLEL_HACK=""-j4""",Is the hack actually misspelled? (Two `R`s),
63429838,82d4f8b9d0412ac998164025275446f78ac24762,.travis.yml,True,"@@ -0,0 +1,83 @@
+###############################################################################
+# Copyright (c) 2016, 2017 IBM Corp. and others
+# 
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#      
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#    
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+# 
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+###############################################################################
+os:
+  - linux
+language: cpp
+sudo: false
+#cache: ccache # https://docs.travis-ci.com/user/caching/
+dist: trusty
+addons:
+  apt:
+    packages:
+      - autoconf 
+      - ca-certificates 
+      - ccache 
+      - cpio 
+      - file 
+      - g++-4.8 
+      - gcc-4.8 
+      - git 
+      - git-core 
+      - libasound2-dev 
+      - libcups2-dev 
+      - libelf-dev 
+      - libfreetype6-dev 
+      - libnuma-dev 
+      - libx11-dev 
+      - libxext-dev 
+      - libxrender-dev 
+      - libxt-dev 
+      - libxtst-dev 
+      - make 
+      - openjdk-8-jdk 
+      - pkg-config 
+      - realpath 
+      - ssh 
+      - unzip 
+      - wget 
+      - zip 
+before_install:
+  - jdk_switcher use oraclejdk8
+env:
+  global:
+before_script:
+        #  - ccache -s -z
+  - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+  - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+  - cd ..
+  - git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
+script:
+  # Clear this option so it doesn't interfere with configure detecting the bootjdk
+  - unset _JAVA_OPTIONS
+  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.  
+  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win. 
+  - cd openj9-openjdk-jdk9 && bash ./get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT
+  # Based on https://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/ travis container builds
+  # have 2 cores and 4 gigs of memory.  Attempt to double provision the number of cores for the make...
+  # Limit number of jobs to work around g++ internal compiler error
+  - export UMA_WINDOWS_PARRALLEL_HACK=""-j4""","Sadly, that matches what's in the tr.source makefiles: https://github.com/eclipse/openj9/blob/master/runtime/tr.source/makefile.ftl 

(edited to add: and in the rest of our code... see https://github.com/eclipse/openj9/search?utf8=?&q=UMA_WINDOWS_PARRALLEL_HACK&type=)",
63430482,82d4f8b9d0412ac998164025275446f78ac24762,.travis.yml,False,"@@ -0,0 +1,83 @@
+###############################################################################
+# Copyright (c) 2016, 2017 IBM Corp. and others
+# 
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#      
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#    
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+# 
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+###############################################################################
+os:
+  - linux
+language: cpp
+sudo: false
+#cache: ccache # https://docs.travis-ci.com/user/caching/
+dist: trusty
+addons:
+  apt:
+    packages:
+      - autoconf 
+      - ca-certificates 
+      - ccache 
+      - cpio 
+      - file 
+      - g++-4.8 
+      - gcc-4.8 
+      - git 
+      - git-core 
+      - libasound2-dev 
+      - libcups2-dev 
+      - libelf-dev 
+      - libfreetype6-dev 
+      - libnuma-dev 
+      - libx11-dev 
+      - libxext-dev 
+      - libxrender-dev 
+      - libxt-dev 
+      - libxtst-dev 
+      - make 
+      - openjdk-8-jdk 
+      - pkg-config 
+      - realpath 
+      - ssh 
+      - unzip 
+      - wget 
+      - zip 
+before_install:
+  - jdk_switcher use oraclejdk8
+env:
+  global:
+before_script:
+        #  - ccache -s -z
+  - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+  - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+  - cd ..
+  - git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
+script:
+  # Clear this option so it doesn't interfere with configure detecting the bootjdk
+  - unset _JAVA_OPTIONS
+  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.  
+  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win. 
+  - cd openj9-openjdk-jdk9 && bash ./get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT
+  # Based on https://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/ travis container builds
+  # have 2 cores and 4 gigs of memory.  Attempt to double provision the number of cores for the make...
+  # Limit number of jobs to work around g++ internal compiler error
+  - export UMA_WINDOWS_PARRALLEL_HACK=""-j4""",![facepalm](https://media.giphy.com/media/3og0INyCmHlNylks9O/giphy.gif),
67490780,b733c4a934c58303fd06b7ccebf7b9053df021fa,.travis.yml,False,"@@ -28,57 +28,61 @@ dist: trusty
 addons:
   apt:
     packages:
-      - autoconf 
-      - ca-certificates 
-      - ccache 
-      - cpio 
-      - file 
-      - g++-4.8 
-      - gcc-4.8 
-      - git 
-      - git-core 
-      - libasound2-dev 
-      - libcups2-dev 
-      - libelf-dev 
-      - libfreetype6-dev 
-      - libnuma-dev 
-      - libx11-dev 
-      - libxext-dev 
-      - libxrender-dev 
-      - libxt-dev 
-      - libxtst-dev 
-      - make 
-      - openjdk-8-jdk 
-      - pkg-config 
-      - realpath 
-      - ssh 
-      - unzip 
-      - wget 
-      - zip 
+      - autoconf
+      - ca-certificates
+      - ccache
+      - cpio
+      - file
+      - g++-4.8
+      - gcc-4.8
+      - git
+      - git-core
+      - libasound2-dev
+      - libcups2-dev
+      - libelf-dev
+      - libfreetype6-dev
+      - libnuma-dev
+      - libx11-dev
+      - libxext-dev
+      - libxrender-dev
+      - libxt-dev
+      - libxtst-dev
+      - make
+      - openjdk-8-jdk
+      - pkg-config
+      - realpath
+      - ssh
+      - unzip
+      - wget
+      - zip
 before_install:
   - jdk_switcher use oraclejdk8
 env:
   global:
 before_script:
-        #  - ccache -s -z
+  # - ccache -s -z
+  # Exit immediately if any unexpected error occurs.
+  - set -e
   - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
   - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
   - cd ..
-  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load
+  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load.
   - git clone --depth 1 https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
 script:
-  # Clear this option so it doesn't interfere with configure detecting the bootjdk
+  # Clear this option so it doesn't interfere with configure detecting the bootjdk.
   - unset _JAVA_OPTIONS
-  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.  
-  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win. 
-  - cd openj9-openjdk-jdk9 && bash ./get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT
-  # Based on https://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/ travis container builds
-  # have 2 cores and 4 gigs of memory.  Attempt to double provision the number of cores for the make...
-  # Limit number of jobs to work around g++ internal compiler error
-  - export UMA_WINDOWS_PARRALLEL_HACK=""-j4""
-  - bash ./configure --with-freemarker-jar=$TRAVIS_BUILD_DIR/freemarker.jar --with-jobs=4 --with-num-cores=4
+  # Exit immediately if any unexpected error occurs.
+  - set -e
+  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.
+  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win.
+  - cd openj9-openjdk-jdk9 && bash get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT",We should stop specifying `-openj9-branch` since we really only care about `-openj9-sha`,
67502472,b733c4a934c58303fd06b7ccebf7b9053df021fa,.travis.yml,False,"@@ -28,57 +28,61 @@ dist: trusty
 addons:
   apt:
     packages:
-      - autoconf 
-      - ca-certificates 
-      - ccache 
-      - cpio 
-      - file 
-      - g++-4.8 
-      - gcc-4.8 
-      - git 
-      - git-core 
-      - libasound2-dev 
-      - libcups2-dev 
-      - libelf-dev 
-      - libfreetype6-dev 
-      - libnuma-dev 
-      - libx11-dev 
-      - libxext-dev 
-      - libxrender-dev 
-      - libxt-dev 
-      - libxtst-dev 
-      - make 
-      - openjdk-8-jdk 
-      - pkg-config 
-      - realpath 
-      - ssh 
-      - unzip 
-      - wget 
-      - zip 
+      - autoconf
+      - ca-certificates
+      - ccache
+      - cpio
+      - file
+      - g++-4.8
+      - gcc-4.8
+      - git
+      - git-core
+      - libasound2-dev
+      - libcups2-dev
+      - libelf-dev
+      - libfreetype6-dev
+      - libnuma-dev
+      - libx11-dev
+      - libxext-dev
+      - libxrender-dev
+      - libxt-dev
+      - libxtst-dev
+      - make
+      - openjdk-8-jdk
+      - pkg-config
+      - realpath
+      - ssh
+      - unzip
+      - wget
+      - zip
 before_install:
   - jdk_switcher use oraclejdk8
 env:
   global:
 before_script:
-        #  - ccache -s -z
+  # - ccache -s -z
+  # Exit immediately if any unexpected error occurs.
+  - set -e
   - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
   - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
   - cd ..
-  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load
+  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load.
   - git clone --depth 1 https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
 script:
-  # Clear this option so it doesn't interfere with configure detecting the bootjdk
+  # Clear this option so it doesn't interfere with configure detecting the bootjdk.
   - unset _JAVA_OPTIONS
-  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.  
-  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win. 
-  - cd openj9-openjdk-jdk9 && bash ./get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT
-  # Based on https://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/ travis container builds
-  # have 2 cores and 4 gigs of memory.  Attempt to double provision the number of cores for the make...
-  # Limit number of jobs to work around g++ internal compiler error
-  - export UMA_WINDOWS_PARRALLEL_HACK=""-j4""
-  - bash ./configure --with-freemarker-jar=$TRAVIS_BUILD_DIR/freemarker.jar --with-jobs=4 --with-num-cores=4
+  # Exit immediately if any unexpected error occurs.
+  - set -e
+  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.
+  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win.
+  - cd openj9-openjdk-jdk9 && bash get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT","I suppose it doesn't really matter. `$TRAVIS_BRANCH=master` and the default is `master` so it doesn't really change anything. If at some point the get_source script changes its default, we would probably want `TRAVIS_BRANCH` instead, although it doesn't really matter because he checkout the SHA anyways.",
102506365,8bf87af8ad477dfbbca6b85d54970f3f20742c05,.travis.yml,False,"@@ -63,8 +63,7 @@ before_script:
   # - ccache -s -z
   # Exit immediately if any unexpected error occurs.
   - set -e
-  - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
-  - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+  - wget https://ci.eclipse.org/openj9/userContent/freemarker.jar",Any reason to remove the version information from the file name?,
102506844,8bf87af8ad477dfbbca6b85d54970f3f20742c05,.travis.yml,True,"@@ -63,8 +63,7 @@ before_script:
   # - ccache -s -z
   # Exit immediately if any unexpected error occurs.
   - set -e
-  - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
-  - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+  - wget https://ci.eclipse.org/openj9/userContent/freemarker.jar","Not really, and I was just thinking of putting that back in to make it obvious.  You're comment seals it.",
158772386,a47e562436e806eb2b6a0987267d9ce98982f87c,.travis.yml,False,"@@ -66,42 +66,9 @@ addons:
       - llvm-3.8-dev
 before_install:
   - jdk_switcher use oraclejdk8
-before_script:
-  - ccache -s -z","The ccache commands were removed, is this intentional?",
158772386,a47e562436e806eb2b6a0987267d9ce98982f87c,.travis.yml,False,"@@ -66,42 +66,9 @@ addons:
       - llvm-3.8-dev
 before_install:
   - jdk_switcher use oraclejdk8
-before_script:
-  - ccache -s -z
-  # Exit immediately if any unexpected error occurs.
-  - set -e
-  - if [ ! `wget https://ci.eclipse.org/openj9/userContent/freemarker-2.3.8.jar -O freemarker.jar` ]; then
-      wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz;
-      tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2;
-    fi
-  - cd ..
-  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load.
-  - git clone --depth 1 https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
 script:
-  # Clear this option so it doesn't interfere with configure detecting the bootjdk.",This comment was lost.,
158772386,a47e562436e806eb2b6a0987267d9ce98982f87c,.travis.yml,False,"@@ -66,42 +66,9 @@ addons:
       - llvm-3.8-dev
 before_install:
   - jdk_switcher use oraclejdk8
-before_script:
-  - ccache -s -z
-  # Exit immediately if any unexpected error occurs.
-  - set -e
-  - if [ ! `wget https://ci.eclipse.org/openj9/userContent/freemarker-2.3.8.jar -O freemarker.jar` ]; then
-      wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz;
-      tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2;
-    fi
-  - cd ..
-  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load.
-  - git clone --depth 1 https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
 script:
-  # Clear this option so it doesn't interfere with configure detecting the bootjdk.
-  - unset _JAVA_OPTIONS
-  # Exit immediately if any unexpected error occurs.
-  - set -e
-  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.",This comment was lost.,
160428623,a47e562436e806eb2b6a0987267d9ce98982f87c,.travis.yml,True,"@@ -66,42 +66,9 @@ addons:
       - llvm-3.8-dev
 before_install:
   - jdk_switcher use oraclejdk8
-before_script:
-  - ccache -s -z
-  # Exit immediately if any unexpected error occurs.
-  - set -e
-  - if [ ! `wget https://ci.eclipse.org/openj9/userContent/freemarker-2.3.8.jar -O freemarker.jar` ]; then
-      wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz;
-      tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2;
-    fi
-  - cd ..
-  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load.
-  - git clone --depth 1 https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
 script:
-  # Clear this option so it doesn't interfere with configure detecting the bootjdk.
-  - unset _JAVA_OPTIONS
-  # Exit immediately if any unexpected error occurs.
-  - set -e
-  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.",Fixed,
163494615,e020fcad8c9f6452139450f802ad7d470b6372a9,.travis.yml,False,"@@ -67,6 +67,7 @@ addons:
 before_install:
   - jdk_switcher use oraclejdk8
 before_script:
+  - ccache -M 1G",Why two ccache lines instead of 1?  Can you add a comment to explain what / why these options are being used?,
163502487,e020fcad8c9f6452139450f802ad7d470b6372a9,.travis.yml,True,"@@ -67,6 +67,7 @@ addons:
 before_install:
   - jdk_switcher use oraclejdk8
 before_script:
+  - ccache -M 1G","I suppose there is no real reason for having them in separate command invocation, other than the fact that they are logically separate actions. The `-M 1G` just sets the max cache size to 1GB (the default is 512MB, and just building the vm once puts the cache usage at 517MB)",
268360159,adb0260647e14187df9a3091265ac3a445475c2e,.travis.yml,False,"@@ -51,6 +51,7 @@ addons:
       - libxtst-dev
       - make
       - nasm
+      - nvidia-cuda-dev",This change doesn't belong in this PR.,
174977347,073ec783d03244781b5612da689ad3ed537e1fda,CMakeLists.txt,False,"@@ -0,0 +1,33 @@
+################################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+################################################################################
+
+cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+
+project(openj9)
+include(FindJava)","What does `FindJava` do?  Is it something we authored?  

The root of my concern is that we want to be able to specify the Java being used to ensure it's the same bootjdk used by the rest of the build.",
175422275,073ec783d03244781b5612da689ad3ed537e1fda,CMakeLists.txt,True,"@@ -0,0 +1,33 @@
+################################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+################################################################################
+
+cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+
+project(openj9)
+include(FindJava)","It is a built in module from cmake. you can point it to a specific java by setting `JAVA_HOME`
https://cmake.org/cmake/help/v3.4/module/FindJava.html",
175963192,073ec783d03244781b5612da689ad3ed537e1fda,CMakeLists.txt,False,"@@ -0,0 +1,33 @@
+################################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+################################################################################
+
+cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+
+project(openj9)
+include(FindJava)",I think this should use the bootjdk as configured in the extension project rather than the default for the build machine.,
178023814,073ec783d03244781b5612da689ad3ed537e1fda,CMakeLists.txt,False,"@@ -0,0 +1,46 @@
+################################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+################################################################################
+
+cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+
+project(openj9)
+
+if(NOT $ENV{BOOT_JDK} STREQUAL """")
+    set(JAVA_HOME $ENV{BOOT_JDK})
+
+    # These variables are consumed when the ""Java"" language is enabled
+    set(CMAKE_Java_COMPILER ${JAVA_HOME}/bin/javac)
+    set(CMAKE_Java_RUNTIME ${JAVA_HOME}/bin/java)
+    set(CMAKE_Java_AR ${JAVA_HOME}/bin/jar)
+
+    set(Java_JAVA_EXECUTABLE ${JAVA_HOME}/bin/java)
+else()
+    message(STATUS ""BOOT_JDK is not set, default jdk will be used"")
+    include(FindJava)",I would rather this errors out than pick a random java,
179402888,073ec783d03244781b5612da689ad3ed537e1fda,CMakeLists.txt,True,"@@ -0,0 +1,46 @@
+################################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+################################################################################
+
+cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+
+project(openj9)
+
+if(NOT $ENV{BOOT_JDK} STREQUAL """")
+    set(JAVA_HOME $ENV{BOOT_JDK})
+
+    # These variables are consumed when the ""Java"" language is enabled
+    set(CMAKE_Java_COMPILER ${JAVA_HOME}/bin/javac)
+    set(CMAKE_Java_RUNTIME ${JAVA_HOME}/bin/java)
+    set(CMAKE_Java_AR ${JAVA_HOME}/bin/jar)
+
+    set(Java_JAVA_EXECUTABLE ${JAVA_HOME}/bin/java)
+else()
+    message(STATUS ""BOOT_JDK is not set, default jdk will be used"")
+    include(FindJava)","Ultimately, this is the same behavior that we have in the [makefiles](https://github.com/eclipse/openj9/blob/01f3a1c977a8fc5b06de4b0dcc4b4745f1796e8b/runtime/buildtools.mk#L49), and in the openjdk [autoconf](https://github.com/ibmruntimes/openj9-openjdk-jdk11/blob/d42cd0d94f7e017c1b3fbcb748cfecce81e15801/make/autoconf/boot-jdk.m4#L43)",
179403982,073ec783d03244781b5612da689ad3ed537e1fda,CMakeLists.txt,False,"@@ -0,0 +1,46 @@
+################################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+################################################################################
+
+cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+
+project(openj9)
+
+if(NOT $ENV{BOOT_JDK} STREQUAL """")
+    set(JAVA_HOME $ENV{BOOT_JDK})
+
+    # These variables are consumed when the ""Java"" language is enabled
+    set(CMAKE_Java_COMPILER ${JAVA_HOME}/bin/javac)
+    set(CMAKE_Java_RUNTIME ${JAVA_HOME}/bin/java)
+    set(CMAKE_Java_AR ${JAVA_HOME}/bin/jar)
+
+    set(Java_JAVA_EXECUTABLE ${JAVA_HOME}/bin/java)
+else()
+    message(STATUS ""BOOT_JDK is not set, default jdk will be used"")
+    include(FindJava)",This code is downstream from the openjdk autoconf.  We should never get here without having set the bootjdk,
181275369,073ec783d03244781b5612da689ad3ed537e1fda,CMakeLists.txt,False,"@@ -0,0 +1,46 @@
+################################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+################################################################################
+
+cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+
+project(openj9)
+
+if(NOT $ENV{BOOT_JDK} STREQUAL """")
+    set(JAVA_HOME $ENV{BOOT_JDK})
+
+    # These variables are consumed when the ""Java"" language is enabled
+    set(CMAKE_Java_COMPILER ${JAVA_HOME}/bin/javac)
+    set(CMAKE_Java_RUNTIME ${JAVA_HOME}/bin/java)
+    set(CMAKE_Java_AR ${JAVA_HOME}/bin/jar)
+
+    set(Java_JAVA_EXECUTABLE ${JAVA_HOME}/bin/java)
+else()
+    message(STATUS ""BOOT_JDK is not set, default jdk will be used"")
+    include(FindJava)","@dnakamura If this gets dealt with, I think it's ready to merge",
182329904,073ec783d03244781b5612da689ad3ed537e1fda,CMakeLists.txt,True,"@@ -0,0 +1,46 @@
+################################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+################################################################################
+
+cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+
+project(openj9)
+
+if(NOT $ENV{BOOT_JDK} STREQUAL """")
+    set(JAVA_HOME $ENV{BOOT_JDK})
+
+    # These variables are consumed when the ""Java"" language is enabled
+    set(CMAKE_Java_COMPILER ${JAVA_HOME}/bin/javac)
+    set(CMAKE_Java_RUNTIME ${JAVA_HOME}/bin/java)
+    set(CMAKE_Java_AR ${JAVA_HOME}/bin/jar)
+
+    set(Java_JAVA_EXECUTABLE ${JAVA_HOME}/bin/java)
+else()
+    message(STATUS ""BOOT_JDK is not set, default jdk will be used"")
+    include(FindJava)",@DanHeidinga  How would you feel about wrapping this behavior up in a flag? ie J9VM_FORCE_JDK_SEARCH or something. I'm thinking of the case of the jit linter. To run properly it needs to generate all the various header files. The easiest way to do that is to just run cmake outside of the full openjdk build. Its not clear what the proper value of BOOT_JDK should be,
182385566,073ec783d03244781b5612da689ad3ed537e1fda,CMakeLists.txt,False,"@@ -0,0 +1,46 @@
+################################################################################
+# Copyright (c) 2018, 2018 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+################################################################################
+
+cmake_minimum_required(VERSION 3.4 FATAL_ERROR)
+
+project(openj9)
+
+if(NOT $ENV{BOOT_JDK} STREQUAL """")
+    set(JAVA_HOME $ENV{BOOT_JDK})
+
+    # These variables are consumed when the ""Java"" language is enabled
+    set(CMAKE_Java_COMPILER ${JAVA_HOME}/bin/javac)
+    set(CMAKE_Java_RUNTIME ${JAVA_HOME}/bin/java)
+    set(CMAKE_Java_AR ${JAVA_HOME}/bin/jar)
+
+    set(Java_JAVA_EXECUTABLE ${JAVA_HOME}/bin/java)
+else()
+    message(STATUS ""BOOT_JDK is not set, default jdk will be used"")
+    include(FindJava)","You raise a good point.  I hadn't thought of the jit linter.

I was about to say it's not unreasonable to force it to pick a JDK but it kind of is.... That extra barrier isn't needed.",
64073939,c3a740a43d04f573dbcbe6c808513d84135608a7,CONTRIBUTING.md,False,"@@ -69,6 +69,10 @@ copying resources into the body of the commit over providing external links.
 Structure large commit messages with headers, references etc. Remember, however,
 that the commit message is always going to be rendered in plain text.
 
+Please add `[skip ci]` to the commit message when the change doesn't require a 
+compilation, such as documentation only changes.  This is required to be good","Maybe ...such as documentation only changes, to avoid unnecessarily wasting the project's build resources.

?",
66222236,ca07097185747535aa4771d4ef7225f52be4486c,CONTRIBUTING.md,False,"@@ -90,7 +90,7 @@ Correct race in frobnicator
 
 This patch eliminates the race condition in issue #1234.
 
-Issue: #1234
+Fixes: #1234",@pshipton unfortunately I don't think this will work. https://help.github.com/articles/closing-issues-using-keywords/ states that the keyword must be followed by the issue number. The colon here will mess this up and GitHub won't recognize it.,
97198289,f03250b724736a61e836f92a9aec5433eaa0bcad,CONTRIBUTING.md,False,"@@ -73,17 +73,11 @@ Please add `[skip ci]` to the commit message when the change doesn't require a
 compilation, such as documentation only changes, to avoid unnecessarily wasting
 the project's build resources.
 
-Use the commit footer to place commit metadata. The footer is the last block of
-contiguous text in the message. It is separated from the body by one or more
-blank lines, and as such cannot contain any blank lines. Lines in the footer are
-of the form:
-
-```
-Key: Value
-```
-
 When a commit has related issues or commits, explain the relation in the message
-body. You should also leave an `Issue` tag in the footer. For example:
+body. When appropriate, use the keywords described in the following help article
+to automatically close issues.
+https://help.github.com/articles/closing-issues-using-keywords/
+For example:
 
 ```
 Correct race in frobnicator ",Change lftm. Although I think the example commit message below is a little silly as it refs the issue # twice.,
97300234,f03250b724736a61e836f92a9aec5433eaa0bcad,CONTRIBUTING.md,False,"@@ -73,17 +73,11 @@ Please add `[skip ci]` to the commit message when the change doesn't require a
 compilation, such as documentation only changes, to avoid unnecessarily wasting
 the project's build resources.
 
-Use the commit footer to place commit metadata. The footer is the last block of
-contiguous text in the message. It is separated from the body by one or more
-blank lines, and as such cannot contain any blank lines. Lines in the footer are
-of the form:
-
-```
-Key: Value
-```
-
 When a commit has related issues or commits, explain the relation in the message
-body. You should also leave an `Issue` tag in the footer. For example:
+body. When appropriate, use the keywords described in the following help article
+to automatically close issues.
+https://help.github.com/articles/closing-issues-using-keywords/
+For example:
 
 ```
 Correct race in frobnicator ",The example is just to demonstrate the different ways of referring to an issue.  Not a best practice :),
126460987,5fa86cae3454d035b4ab6c85b797c07528bcd443,CONTRIBUTING.md,False,"@@ -90,7 +90,9 @@ Fixes: #1234
 Sign off on your commit in the footer. By doing this, you assert original
 authorship of the commit and that you are permitted to contribute it. This can
 be automatically added to your commit by passing `-s` to `git commit`, or by
-manually adding the following line to the footer of the commit.
+manually adding the following line to the footer of the commit. The footer must
+be separated from the preceeding body or header with a blank line, and there must
+not be a blank line following the footer.","`and there must not be a blank line following the footer.`  Isn't this covered by the text a few lines down?

>Remember, if a blank line is found anywhere after the `Signed-off-by` line, the
`Signed-off-by:` will be considered outside of the footer, and will fail the
automated Signed-off-by validation",
126472621,5fa86cae3454d035b4ab6c85b797c07528bcd443,CONTRIBUTING.md,True,"@@ -90,7 +90,9 @@ Fixes: #1234
 Sign off on your commit in the footer. By doing this, you assert original
 authorship of the commit and that you are permitted to contribute it. This can
 be automatically added to your commit by passing `-s` to `git commit`, or by
-manually adding the following line to the footer of the commit.
+manually adding the following line to the footer of the commit. The footer must
+be separated from the preceeding body or header with a blank line, and there must
+not be a blank line following the footer.","Yes, just reinforces the previous sentence. I wanted to keep it concise and simple. I'm actually in favor of removing the ""Remember, if a blank..."" paragraph as it's to verbose. Thoughts?",
126541947,5fa86cae3454d035b4ab6c85b797c07528bcd443,CONTRIBUTING.md,False,"@@ -124,6 +126,7 @@ The guidelines are changed to:
   message.
 
 Closes: #124
+",I don't believe this is necessary - both Closes and Signed off can be part of the footer.,
126585903,5fa86cae3454d035b4ab6c85b797c07528bcd443,CONTRIBUTING.md,True,"@@ -124,6 +126,7 @@ The guidelines are changed to:
   message.
 
 Closes: #124
+",https://github.com/eclipse/openj9/pull/1636#issuecomment-395081510 seems to imply otherwise. @IBMJimmyk can you validate the correctness of your comment?,
126589200,5fa86cae3454d035b4ab6c85b797c07528bcd443,CONTRIBUTING.md,True,"@@ -124,6 +126,7 @@ The guidelines are changed to:
   message.
 
 Closes: #124
+","Actually @DanHeidinga there is a clear example of the check failing in https://github.com/eclipse/openj9/pull/2098. You can see the failure output (https://ci.eclipse.org/openj9/job/PullRequest-SignedOffByCheck-OpenJDK10/244/):

```
13:32:51 ###################################
[Pipeline] echo
13:32:55 FAILURE - The following commits appear to have an incorrect sign-off
[Pipeline] echo
13:33:02 commit afc2c20e928648a6277b2d17f5eebd01b2e75699
13:33:02 Author: Daniel Hong <daniel.hong@live.com>
13:33:02 Date:   Thu May 31 09:55:11 2018 -0400
13:33:02 
13:33:02     Re-enable toLowerCase/toUpperCase acceleration
13:33:02     
13:33:02     Modify API call so that caseConversionHelper recieves
13:33:02     underlying arrays and length of string.
13:33:02     
13:33:02     Closes: #1934
13:33:02     Signed-off-by: Daniel Hong <daniel.hong@live.com>
[Pipeline] echo
13:33:05 ###################################
```

So we do in fact need a new line between the ""Closes"" and ""Signed-off-by"" tags in the footer.",
126592543,5fa86cae3454d035b4ab6c85b797c07528bcd443,CONTRIBUTING.md,True,"@@ -124,6 +126,7 @@ The guidelines are changed to:
   message.
 
 Closes: #124
+",Note the PR referenced has since been fixed up but I've linked the failing job in the above comments. It's easily reproducible as well.,
126605192,5fa86cae3454d035b4ab6c85b797c07528bcd443,CONTRIBUTING.md,False,"@@ -124,6 +126,7 @@ The guidelines are changed to:
   message.
 
 Closes: #124
+",That just means the check we are implementing hasn't been implemented correctly. Its not the Eclipse ip-validation which was failing.,
126616386,5fa86cae3454d035b4ab6c85b797c07528bcd443,CONTRIBUTING.md,True,"@@ -124,6 +126,7 @@ The guidelines are changed to:
   message.
 
 Closes: #124
+",So do we need an issue against our own check to handle this case and close this PR?,
126618847,5fa86cae3454d035b4ab6c85b797c07528bcd443,CONTRIBUTING.md,False,"@@ -124,6 +126,7 @@ The guidelines are changed to:
   message.
 
 Closes: #124
+","There already is an issue open, the check is WIP and being testing on the OpenJ9 repo. 
https://github.com/ibmruntimes/openj9-openjdk-jdk9/issues/58#issuecomment-395229037
https://github.com/eclipse/openj9/pull/1941

Yes I think we can close this PR.",
89608661,5cfc140834498079916142e26a70ba9497ec431d,LICENSE,False,"@@ -577,4 +577,142 @@ be misrepresented as being the original software.
 3. This notice may not be removed or altered from any source
 distribution.
 
+H. stddef.h
+stddef.h is derived from the the same file in the musl project
+http://www.musl-libc.org/ which is licensed as follows.
+
+musl as a whole is licensed under the following standard MIT license:
+
+----------------------------------------------------------------------
+Copyright � 2005-2014 Rich Felker, et al.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+""Software""), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------
+","I don't think we need to add anything below here, the requirement is only to add the above copyright and permission notice.",
89617102,5cfc140834498079916142e26a70ba9497ec431d,LICENSE,False,"@@ -577,4 +577,142 @@ be misrepresented as being the original software.
 3. This notice may not be removed or altered from any source
 distribution.
 
+H. stddef.h","Please just call it musl and only include below what is between the horizontal lines, but remove the lines.",
89851341,5cfc140834498079916142e26a70ba9497ec431d,LICENSE,True,"@@ -577,4 +577,142 @@ be misrepresented as being the original software.
 3. This notice may not be removed or altered from any source
 distribution.
 
+H. stddef.h
+stddef.h is derived from the the same file in the musl project
+http://www.musl-libc.org/ which is licensed as follows.
+
+musl as a whole is licensed under the following standard MIT license:
+
+----------------------------------------------------------------------
+Copyright � 2005-2014 Rich Felker, et al.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+""Software""), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------
+",Done.,
89851721,5cfc140834498079916142e26a70ba9497ec431d,LICENSE,True,"@@ -577,4 +577,142 @@ be misrepresented as being the original software.
 3. This notice may not be removed or altered from any source
 distribution.
 
+H. stddef.h",Done.,
89853483,5cfc140834498079916142e26a70ba9497ec431d,LICENSE,True,"@@ -577,4 +577,142 @@ be misrepresented as being the original software.
 3. This notice may not be removed or altered from any source
 distribution.
 
+H. stddef.h
+stddef.h is derived from the the same file in the musl project
+http://www.musl-libc.org/ which is licensed as follows.
+
+musl as a whole is licensed under the following standard MIT license:
+
+----------------------------------------------------------------------
+Copyright � 2005-2014 Rich Felker, et al.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+""Software""), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------
+",Done.,
89853574,5cfc140834498079916142e26a70ba9497ec431d,LICENSE,True,"@@ -577,4 +577,142 @@ be misrepresented as being the original software.
 3. This notice may not be removed or altered from any source
 distribution.
 
+H. stddef.h",Done,
328569488,8f1c520c252180ebcfdbfcab4986b2fd3a514330,README.fr.md,True,"@@ -0,0 +1,117 @@
+<!--
+Copyright (c) 2017, 2019 IBM Corp. and others
+
+Ce programme et le mat�riel d'accompagnement sont disponibles sous","The license shouldn't be translated, it should remain in English.",
64926782,ddfed8526053edfb96a89b03d07a891253f6d9a8,test/OpenJ9_Jsr_292_API/src/com/ibm/j9/jsr292/ChildCustomClassLoader.java,False,"@@ -0,0 +1,60 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package com.ibm.j9.jsr292;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Helper class loader used in JSR 292 tests for MethodHandles.Lookup API 
+ */
+public class ChildCustomClassLoader extends ParentCustomClassLoader {","The implementation of this is identical to the ParentCustomClassLoader with only the name used in `loadClass` being different.

Is there a reason to duplicate the class and the implementations of each method?
",
64926782,ddfed8526053edfb96a89b03d07a891253f6d9a8,test/OpenJ9_Jsr_292_API/src/com/ibm/j9/jsr292/ChildCustomClassLoader.java,False,"@@ -0,0 +1,60 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package com.ibm.j9.jsr292;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Helper class loader used in JSR 292 tests for MethodHandles.Lookup API 
+ */
+public class ChildCustomClassLoader extends ParentCustomClassLoader {","A single CustomClassLoader would be sufficient if passed 1) its parent & 2) the name of the ""special class"" to check in `loadClass`.",
65000600,ddfed8526053edfb96a89b03d07a891253f6d9a8,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -57,6 +57,10 @@
 import sun.reflect.CallerSensitive;
 /*[ENDIF]*/
 
+/*[IF Sidecar19-SE-B175]",Fixed.,
65002655,ddfed8526053edfb96a89b03d07a891253f6d9a8,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -149,7 +157,11 @@
 static final int VARARGS = 0x80;
 
 /* single cached value of public Lookup object */
+/*[IF Sidecar19-SE-B175]",The reason is that a couple of methods related to module (e.g. Module.isExported()) are missing in the current build with b148.  Choosing the latest level is a safe way to ensure all methods of Module are handy for use in our code as we have no idea when they are provided.,
65010593,ddfed8526053edfb96a89b03d07a891253f6d9a8,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -906,7 +918,36 @@ public MethodHandle findStaticSetter(Class<?> clazz, String fieldName, Class<?>
 /*[IF ]*/
 /* If the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.) */
 /*[ENDIF]*/
+/*[IF !Sidecar19-SE-B175]
 int newAccessMode = accessMode & ~PROTECTED;
+/*[ELSE]*/
+/* The UNCONDITIONAL bit is discarded if the new lookup class differs from the old one in Java 9 */
+int newAccessMode = accessMode & ~UNCONDITIONAL;
+
+/* There are 3 cases to be addressed for the new lookup class from a different module:
+ * 1) There is no access if the package containing the new lookup class is not exported to 
+ *    the package containing the old one.
+ * 2) There is no access if the old lookup class is in a named module
+ *    Note: The public access will be reserved if the old lookup class is a public lookup.
+ * 3) The MODULE access is removed if the old lookup class is in an unnamed module.
+ */
+Module accessClassModule = accessClass.getModule();
+Module lookupClassModule = lookupClass.getModule();
+
+if (!Objects.equals(accessClassModule, lookupClassModule)) {
+if (!lookupClassModule.isExported(lookupClass.getPackageName(), accessClassModule)) {","Unfortunately this is not documented in the API Spec but it was detected in failing JCK tests.
This check is based on the explanation of Accessibility for the Module System at http://openjdk.java.net/projects/jigsaw/spec/sotms/

2.4  Accessibility
...
Thus, even when a type is declared public, if its package is not exported in the declaration of its module then it will only be accessible to code in that module.",
65012708,ddfed8526053edfb96a89b03d07a891253f6d9a8,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -1345,12 +1395,27 @@ public String toString() {
 case PUBLIC:
 toString += ""/public""; //$NON-NLS-1$
 break;
+/*[IF Sidecar19-SE-B175]
+case PUBLIC | UNCONDITIONAL:
+toString += ""/publicLookup""; //$NON-NLS-1$
+break;
+case PUBLIC | MODULE:
+toString += ""/module""; //$NON-NLS-1$
+break;
+case PUBLIC | PACKAGE | MODULE:
+toString += ""/package""; //$NON-NLS-1$
+break;
+case PUBLIC | PACKAGE | PRIVATE | MODULE:
+toString += ""/private""; //$NON-NLS-1$
+break;
+/*[ELSE]*/
 case PUBLIC | PACKAGE:
 toString += ""/package""; //$NON-NLS-1$
 break;
 case PUBLIC | PACKAGE | PRIVATE:
 toString += ""/private""; //$NON-NLS-1$
 break;
+/*[ENDIF] Sidecar19-SE-B175*/","the API document at http://download.java.net/java/jdk9/docs/api/java/lang/invoke
/MethodHandles.Lookup.html#toString--  says:
....
If none of the above cases apply, it is the case that full access (public, module, package, private, and protected) is allowed. In this case, no suffix is added.
<------ So there is no need to throw exception or assertion in this default case.

",
65013483,ddfed8526053edfb96a89b03d07a891253f6d9a8,test/Jsr292/src/com/ibm/j9/jsr292/LookupInTests.java,True,"@@ -61,13 +71,11 @@
  */
 @Test(groups = { ""level.extended"" })
 public void testPublicLookup() throws Throwable {
-Lookup publicLookup = MethodHandles.publicLookup();
-assertClassAndMode( publicLookup, Object.class, MethodHandles.Lookup.PUBLIC );
+assertClassAndMode(localPublicLookup, Object.class, MethodHandles.Lookup.PUBLIC);
+Assert.assertEquals(localPublicLookup.lookupModes(), MethodHandles.Lookup.PUBLIC);",test/Jsr292/src/com/ibm/j9/jsr292/LookupInTests.java only works for Java 8 (829) and Java 9 with b148 in which case there is no UNCONDITIONAL bit added.  The test cases with MODULE/UNCONDITIONAL bit updated were placed at test/OpenJ9_Jsr_292_API/src/com/ibm/j9/jsr292/LookupInTests.java,
65013556,ddfed8526053edfb96a89b03d07a891253f6d9a8,test/Jsr292/src/com/ibm/j9/jsr292/LookupInTests.java,True,"@@ -61,13 +71,11 @@
  */
 @Test(groups = { ""level.extended"" })
 public void testPublicLookup() throws Throwable {
-Lookup publicLookup = MethodHandles.publicLookup();
-assertClassAndMode( publicLookup, Object.class, MethodHandles.Lookup.PUBLIC );
+assertClassAndMode(localPublicLookup, Object.class, MethodHandles.Lookup.PUBLIC);
+Assert.assertEquals(localPublicLookup.lookupModes(), MethodHandles.Lookup.PUBLIC);
 
-AssertJUnit.assertEquals( publicLookup.lookupModes(), MethodHandles.Lookup.PUBLIC );
-
-Lookup newLookup = publicLookup.in( int[].class );
-assertClassAndMode( newLookup, int[].class, publicLookup.lookupModes() ) ;
+Lookup newLookup = localPublicLookup.in(int[].class);
+assertClassAndMode(newLookup, int[].class, localPublicLookup.lookupModes());",Already explained as above,
65013639,ddfed8526053edfb96a89b03d07a891253f6d9a8,test/Jsr292/src/com/ibm/j9/jsr292/LookupInTests.java,True,"@@ -356,22 +345,21 @@ public void testLookup_ProtectedInnerClassLookup_Subclass() throws Throwable {
  */
 @Test(groups = { ""level.extended"" })
 public void testLookup_ProtectedInnerClassLookup_SamePackage() throws Throwable {
-Lookup lookup = SamePackageExample2.getLookup();
-Lookup inObj = lookup.in( SamePackageInnerClass_Protected.class );
-assertClassAndMode( inObj, SamePackageInnerClass_Protected.class, PUBLIC_PACKAGE_MODE );
+Lookup inObj = samePackageExample2Lookup.in(SamePackageInnerClass_Protected.class);
+assertClassAndMode(inObj, SamePackageInnerClass_Protected.class, PUBLIC_PACKAGE_MODE);
 }
 
 /**
  * Validates access restrictions stored in a new Lookup object created from an old Lookup object
  * where the new lookup class is a protected inner class inside a top level class belonging to a different 
  * package than the old lookup class.
+ * Note: a protected class is treated as public during compilation",Updated the misleading comments.,
65017143,ddfed8526053edfb96a89b03d07a891253f6d9a8,test/OpenJ9_Jsr_292_API/src/com/ibm/j9/jsr292/LookupInTests.java,True,"@@ -0,0 +1,616 @@
+/*******************************************************************************","We need to call a few methods of Module (e.g. isExported) which are missing in the current build with b148. So the easiest way for us is to ensure the new code only works on openj9 (e.g. b175) rather then the current build (b148).

To get all existing cases work on Java 8/b148,  all these tests in the original LookupInTests.java plus the required files were copied to a new test project called OpenJ9_Jsr_292_API as suggested by the FVT team. 

As a result, test/Jsr292/src/com/ibm/j9/jsr292/LookupInTests.java only work for Java 8 (829) and Java 9 with b148, while test/OpenJ9_Jsr_292_API/src/com/ibm/j9/jsr292/LookupInTests.java only work on openJ9.

The only difference of these two files is that all Module related test cases in OpenJ9_Jsr_292_API were updated to support MODULE/UNCONDITIONAL bit.",
65019162,ddfed8526053edfb96a89b03d07a891253f6d9a8,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -906,7 +918,36 @@ public MethodHandle findStaticSetter(Class<?> clazz, String fieldName, Class<?>
 /*[IF ]*/
 /* If the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.) */
 /*[ENDIF]*/
+/*[IF !Sidecar19-SE-B175]
 int newAccessMode = accessMode & ~PROTECTED;
+/*[ELSE]*/
+/* The UNCONDITIONAL bit is discarded if the new lookup class differs from the old one in Java 9 */
+int newAccessMode = accessMode & ~UNCONDITIONAL;
+
+/* There are 3 cases to be addressed for the new lookup class from a different module:
+ * 1) There is no access if the package containing the new lookup class is not exported to 
+ *    the package containing the old one.
+ * 2) There is no access if the old lookup class is in a named module
+ *    Note: The public access will be reserved if the old lookup class is a public lookup.
+ * 3) The MODULE access is removed if the old lookup class is in an unnamed module.
+ */
+Module accessClassModule = accessClass.getModule();
+Module lookupClassModule = lookupClass.getModule();
+
+if (!Objects.equals(accessClassModule, lookupClassModule)) {
+if (!lookupClassModule.isExported(lookupClass.getPackageName(), accessClassModule)) {
+newAccessMode = NO_ACCESS;
+} else if (accessClassModule.isNamed()) {
+if ((PUBLIC | UNCONDITIONAL) == accessMode) {",Comment added and code updated to directly check against PUBLIC_LOOKUP object (already verified in tests),
65020031,ddfed8526053edfb96a89b03d07a891253f6d9a8,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -906,7 +918,36 @@ public MethodHandle findStaticSetter(Class<?> clazz, String fieldName, Class<?>
 /*[IF ]*/
 /* If the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.) */
 /*[ENDIF]*/
+/*[IF !Sidecar19-SE-B175]
 int newAccessMode = accessMode & ~PROTECTED;
+/*[ELSE]*/
+/* The UNCONDITIONAL bit is discarded if the new lookup class differs from the old one in Java 9 */
+int newAccessMode = accessMode & ~UNCONDITIONAL;
+
+/* There are 3 cases to be addressed for the new lookup class from a different module:
+ * 1) There is no access if the package containing the new lookup class is not exported to 
+ *    the package containing the old one.
+ * 2) There is no access if the old lookup class is in a named module
+ *    Note: The public access will be reserved if the old lookup class is a public lookup.
+ * 3) The MODULE access is removed if the old lookup class is in an unnamed module.
+ */
+Module accessClassModule = accessClass.getModule();
+Module lookupClassModule = lookupClass.getModule();
+
+if (!Objects.equals(accessClassModule, lookupClassModule)) {
+if (!lookupClassModule.isExported(lookupClass.getPackageName(), accessClassModule)) {
+newAccessMode = NO_ACCESS;
+} else if (accessClassModule.isNamed()) {
+if ((PUBLIC | UNCONDITIONAL) == accessMode) {",Only a public lookup object holds PUBLIC | UNCONDITIONAL bit so checking these two bits should be sufficient but it never hurts to change to only check whether it is a public lookup.,
65021583,ddfed8526053edfb96a89b03d07a891253f6d9a8,test/OpenJ9_Jsr_292_API/src/com/ibm/j9/jsr292/ChildCustomClassLoader.java,True,"@@ -0,0 +1,60 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package com.ibm.j9.jsr292;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * Helper class loader used in JSR 292 tests for MethodHandles.Lookup API 
+ */
+public class ChildCustomClassLoader extends ParentCustomClassLoader {","All these files were directly copied from the original jsr292 directory without any changes.
So agreed and updated to use CustomClassLoader to avoid redundancy. 

I prefer not to change the same files in the original jsr292 directory (for java 8 and java 9 with b148) as these files are used by other tests which are irrelevant to our code.",
65407485,a3a3dd6843abd6770d16b4935deb07b17209311f,buildenv/jenkins/omrMirror,False,"@@ -54,7 +55,22 @@ pipeline {
                                         returnStdout: true
                                     ).trim()
                                 currentBuild.description = ""${LAST_COMMIT}""
+
+                                current_sha = sh (
+                                        script: 'git rev-parse --short HEAD',
+                                        returnStdout: true
+                                    ).trim()
+                            }
+
+                            // if there were changes, launch an acceptance build
+                            step([$class: 'CopyArtifact', optional: true, fingerprintArtifacts: true, projectName: 'Mirror-OMR-to-OpenJ9-OMR'])
+                            def default_sha = [omr_sha: 'Default']
+                            def previous = readProperties defaults: default_sha, file: ""${ARCHIVE_FILE}""
+                            if ( previous.omr_sha != current_sha ) {
+                                build job: 'Pipeline-OMR-Acceptance', propagate: false, wait: false
                             }
+                            writeFile file: ""${ARCHIVE_FILE}"", text: ""omr_sha=${current_sha}""","Shouldn't this be inside the if block?  As I read it now (and please correct me if I'm wrong), it will always write the file.",
65408580,a3a3dd6843abd6770d16b4935deb07b17209311f,buildenv/jenkins/omrMirror,True,"@@ -54,7 +55,22 @@ pipeline {
                                         returnStdout: true
                                     ).trim()
                                 currentBuild.description = ""${LAST_COMMIT}""
+
+                                current_sha = sh (
+                                        script: 'git rev-parse --short HEAD',
+                                        returnStdout: true
+                                    ).trim()
+                            }
+
+                            // if there were changes, launch an acceptance build
+                            step([$class: 'CopyArtifact', optional: true, fingerprintArtifacts: true, projectName: 'Mirror-OMR-to-OpenJ9-OMR'])
+                            def default_sha = [omr_sha: 'Default']
+                            def previous = readProperties defaults: default_sha, file: ""${ARCHIVE_FILE}""
+                            if ( previous.omr_sha != current_sha ) {
+                                build job: 'Pipeline-OMR-Acceptance', propagate: false, wait: false
                             }
+                            writeFile file: ""${ARCHIVE_FILE}"", text: ""omr_sha=${current_sha}""","Becasue the job every 15 minutes, and becasue the `CopyArtifact` step pulls the artifact from the last successful build, we need to archive the artifact every build.
Although, I suppose if we don't have no new content there is no need to overwrite the file with the same SHA. The only other case would be if we failed to fetch the previous artifact, then we would get the default values, in which case we would have ""new content"" and we would write the file.
So I think you are correct we should be safe to move it inside the `if`",
65408975,a3a3dd6843abd6770d16b4935deb07b17209311f,buildenv/jenkins/omrMirror,True,"@@ -54,7 +55,22 @@ pipeline {
                                         returnStdout: true
                                     ).trim()
                                 currentBuild.description = ""${LAST_COMMIT}""
+
+                                current_sha = sh (
+                                        script: 'git rev-parse --short HEAD',
+                                        returnStdout: true
+                                    ).trim()
+                            }
+
+                            // if there were changes, launch an acceptance build
+                            step([$class: 'CopyArtifact', optional: true, fingerprintArtifacts: true, projectName: 'Mirror-OMR-to-OpenJ9-OMR'])
+                            def default_sha = [omr_sha: 'Default']
+                            def previous = readProperties defaults: default_sha, file: ""${ARCHIVE_FILE}""
+                            if ( previous.omr_sha != current_sha ) {
+                                build job: 'Pipeline-OMR-Acceptance', propagate: false, wait: false
                             }
+                            writeFile file: ""${ARCHIVE_FILE}"", text: ""omr_sha=${current_sha}""",Updated commit,
65417248,a3a3dd6843abd6770d16b4935deb07b17209311f,buildenv/jenkins/omrMirror,False,"@@ -24,9 +24,10 @@ pipeline {
     agent {label 'master'}
 
     environment {
-        HTTP        = 'https://'
-        SRC_REPO    = 'github.com/eclipse/omr.git'
-        TARGET_REPO = 'github.com/eclipse/openj9-omr.git'
+        HTTP         = 'https://'
+        SRC_REPO     = 'github.com/eclipse/omr.git'
+        TARGET_REPO  = 'github.com/eclipse/openj9-omr.git'","This code change bothered me earlier as I couldn't figure out why it was showing up as a change.... and the answer is whitespace.  This is one of the big reasons why I'm strongly opposed to this kind of formatting.

Rather than this appearing as a single line of change - easy to review, easy to tell why it changed - it now looks like all 4 lines were modified.

I'm not going to say it has to be changed, but will ask that this kind of alignment is avoided in future commits",
62941283,6719fa710313e4a775b69e8133b7e34d7c9a9c04,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/AttachHandler.java,False,"@@ -102,6 +102,12 @@
 private static String nameProperty;
 private static String pidProperty;
 private static int numberOfTargets;
+/*[IF Sidecar19-SE]*/
+/*[PR 132828 don't allow VM to attach to itself unless explicitly enabled ]*/",This is likely an internal ticket number - can you remove it and add any necessary context to the code or the PR?,
62942260,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/playlist.xml,False,"@@ -181,4 +181,28 @@
 <subset>SE90</subset>
 </subsets>
 </test>
+
+<test>
+<featureIds>
+<featureId>113813</featureId>",What does this featureId mean?,
63641653,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/playlist.xml,True,"@@ -181,4 +181,28 @@
 <subset>SE90</subset>
 </subsets>
 </test>
+
+<test>
+<featureIds>
+<featureId>113813</featureId>",This is the Jazz work item for the refactoring of the Attach API.,
63645801,6719fa710313e4a775b69e8133b7e34d7c9a9c04,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/AttachHandler.java,True,"@@ -102,6 +102,12 @@
 private static String nameProperty;
 private static String pidProperty;
 private static int numberOfTargets;
+/*[IF Sidecar19-SE]*/
+/*[PR 132828 don't allow VM to attach to itself unless explicitly enabled ]*/",Fixed.,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,jcl/src/jdk.attach/share/classes/com/ibm/tools/attach/attacher/OpenJ9VirtualMachine.java,False,"@@ -397,18 +399,26 @@ private void tryAttachTarget(int timeout) throws IOException,
  * to attach
  */
 /*[MSG ""K0457"", ""Target no longer available""]*/
-AttachNotSupportedException exc = new AttachNotSupportedException(com.ibm.oti.util.Msg.getString(""K0457"")); //$NON-NLS-1$
+AttachNotSupportedException exc = new AttachNotSupportedException(getString(""K0457"")); //$NON-NLS-1$
 exc.initCause(e);
 throw exc;
 }
 
 if (descriptor.id().equals(AttachHandler.getVmId())) {
+/*[IF Sidecar19-SE]*/
+String allowattachselfValue = AttachHandler.allowAttachSelf;",I'm not a fan of this mixed all lower case with camelCase.  Can this be named `allowAttachSelfValue` for better readability?,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/playlist.xml,False,"@@ -181,4 +181,28 @@
 <subset>SE90</subset>
 </subsets>
 </test>
+
+<test>
+<featureIds>
+<featureId>113813</featureId>",Please use an OpenJ9 issue number rather than a internal Jazz #.,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/SelfAttacher.java,False,"@@ -0,0 +1,64 @@
+/*******************************************************************************
+ * Copyright (c) 2015, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.IOException;
+import java.util.Properties;
+
+import com.sun.tools.attach.AttachNotSupportedException;
+import com.sun.tools.attach.VirtualMachine;
+import com.sun.tools.attach.VirtualMachineDescriptor;
+
+public class SelfAttacher {
+
+static final int ATTACH_ERROR_CODE = 10;
+static final int ATTACH_NOT_SUPPORTED_CODE = 11;
+static final int ATTACH_SELF_IOEXCEPTION_CODE = 12;
+static final int ATTACH_SELF_API_SUCCEEDED_CODE = 13;
+public static void main(String[] args) {
+try {
+String myId = VmIdGetter.getVmId();
+System.err.println(""myId=""+myId);
+boolean found = false;
+for (int i = 0; i <10 && !found; ++i) {
+Thread.sleep(100);
+for (VirtualMachineDescriptor v: VirtualMachine.list()) {
+if (v.id().equals(myId)) {
+found = true;
+break;
+}
+}
+}
+VirtualMachine vm = VirtualMachine.attach(myId);
+Properties props = vm.getSystemProperties();
+props.list(System.out);
+} catch (AttachNotSupportedException e) {
+e.printStackTrace();",Should the test be printing this unconditionally or should it be using an existing logger framework?,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/SelfAttacher.java,False,"@@ -0,0 +1,64 @@
+/*******************************************************************************
+ * Copyright (c) 2015, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.IOException;
+import java.util.Properties;
+
+import com.sun.tools.attach.AttachNotSupportedException;
+import com.sun.tools.attach.VirtualMachine;
+import com.sun.tools.attach.VirtualMachineDescriptor;
+
+public class SelfAttacher {
+
+static final int ATTACH_ERROR_CODE = 10;
+static final int ATTACH_NOT_SUPPORTED_CODE = 11;
+static final int ATTACH_SELF_IOEXCEPTION_CODE = 12;
+static final int ATTACH_SELF_API_SUCCEEDED_CODE = 13;
+public static void main(String[] args) {
+try {
+String myId = VmIdGetter.getVmId();
+System.err.println(""myId=""+myId);
+boolean found = false;
+for (int i = 0; i <10 && !found; ++i) {",Is there no better way to get a VIrtualMachine id?  Something without looping?,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.",Why was it copied?  Is there a way to avoid duplicating the code?,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")",We shouldn't be using SuppressWarnings.  Please fix the NLS issues.,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";",Can you group the static finals with the other static finals?  It makes it easier to see what the actual mutable state is.,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();",Please remove the `tgt` short form as the code uses a mix of that and `target`.   Using one consistently is better and the full word is better for readability,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {","Why use `ready()` here?  It returns false on an empty stream or if the read implementation might block.
I could see a single `ready()` call and then use `readLine()` to loop... am I missing something here?",
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);",Does this need to be wrapped in a `verbose` test?  Won't the logger.debug call determine whether it should be printed or not based on the configured logging level?,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,","This really needs some comments to walk a reader of the code through.  I'm not sure what `sidecar` is, or why this code is structured the way it is.  Aim to make it obvious for a reader (or person debugging) to understand the code - especially as that may be future you a few months down the line =)",
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,
+String myDisplayName, List<String> vmArgs,
+List<String> appArgs) {
+List<String> argBuffer = new ArrayList<String>();
+String[] args = {};
+this.displayName = myDisplayName;
+Runtime me = Runtime.getRuntime();
+char fs = File.separatorChar;
+String javaExec = System.getProperty(""java.home"") + fs + ""bin"" + fs
++ ""java"";
+logger.debug(""javaExec=""+javaExec);
+String sideCar = System.getProperty(""java.sidecar"");
+String myClasspath = System.getProperty(""java.class.path"");
+argBuffer.add(javaExec);
+argBuffer.add(""-Dcom.ibm.tools.attach.enable=yes"");
+if (doLogging) {
+argBuffer.add(""-Dcom.ibm.tools.attach.logging=yes"");
+}
+if (null != tgtId) {
+argBuffer.add(""-Dcom.ibm.tools.attach.id="" + tgtId);
+}
+if (null != myDisplayName) {
+argBuffer.add(""-Dcom.ibm.tools.attach.displayName="" + myDisplayName);
+}
+argBuffer.add(""-classpath"");
+argBuffer.add(myClasspath);
+if ((null != sideCar) && (sideCar.length() > 0)) {
+String sidecarArgs[] = sideCar.split("" +"");
+for (String s : sidecarArgs) {
+argBuffer.add(s);
+}
+}
+if (null != vmArgs) {
+argBuffer.addAll(vmArgs);
+}
+argBuffer.add(cmdName);
+if (null != appArgs) {
+argBuffer.addAll(appArgs);
+}
+Process target = null;
+args = new String[argBuffer.size()];
+argBuffer.toArray(args);
+if (verbose) {
+System.out.print(""\n"");
+for (int i = 0; i < args.length; ++i) {
+System.out.print(args[i] + "" "");
+}
+System.out.print(""\n"");
+}
+try {
+target = me.exec(args);
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+this.targetIn = target.getOutputStream();
+InputStream targetOut = target.getInputStream();
+InputStream targetErr = target.getErrorStream();
+targetInWriter = new BufferedWriter(new OutputStreamWriter(targetIn));
+targetOutReader = new BufferedReader(new InputStreamReader(targetOut));
+targetErrReader = new BufferedReader(new InputStreamReader(targetErr));
+try {
+targetInWriter.write(TargetManager.TARGETVM_START + '\n');
+targetInWriter.flush();
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+return target;
+}
+
+static void listIpcDir() {",Can you add javadoc for each of these methods?  It looks like this method tries to recursively list all the files and directories under the java.io.tmpdir to the logger.debug() output.  Should it only be called if the logger.debug() level is enabled?,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,
+String myDisplayName, List<String> vmArgs,
+List<String> appArgs) {
+List<String> argBuffer = new ArrayList<String>();
+String[] args = {};
+this.displayName = myDisplayName;
+Runtime me = Runtime.getRuntime();
+char fs = File.separatorChar;
+String javaExec = System.getProperty(""java.home"") + fs + ""bin"" + fs
++ ""java"";
+logger.debug(""javaExec=""+javaExec);
+String sideCar = System.getProperty(""java.sidecar"");
+String myClasspath = System.getProperty(""java.class.path"");
+argBuffer.add(javaExec);
+argBuffer.add(""-Dcom.ibm.tools.attach.enable=yes"");
+if (doLogging) {
+argBuffer.add(""-Dcom.ibm.tools.attach.logging=yes"");
+}
+if (null != tgtId) {
+argBuffer.add(""-Dcom.ibm.tools.attach.id="" + tgtId);
+}
+if (null != myDisplayName) {
+argBuffer.add(""-Dcom.ibm.tools.attach.displayName="" + myDisplayName);
+}
+argBuffer.add(""-classpath"");
+argBuffer.add(myClasspath);
+if ((null != sideCar) && (sideCar.length() > 0)) {
+String sidecarArgs[] = sideCar.split("" +"");
+for (String s : sidecarArgs) {
+argBuffer.add(s);
+}
+}
+if (null != vmArgs) {
+argBuffer.addAll(vmArgs);
+}
+argBuffer.add(cmdName);
+if (null != appArgs) {
+argBuffer.addAll(appArgs);
+}
+Process target = null;
+args = new String[argBuffer.size()];
+argBuffer.toArray(args);
+if (verbose) {
+System.out.print(""\n"");
+for (int i = 0; i < args.length; ++i) {
+System.out.print(args[i] + "" "");
+}
+System.out.print(""\n"");
+}
+try {
+target = me.exec(args);
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+this.targetIn = target.getOutputStream();
+InputStream targetOut = target.getInputStream();
+InputStream targetErr = target.getErrorStream();
+targetInWriter = new BufferedWriter(new OutputStreamWriter(targetIn));
+targetOutReader = new BufferedReader(new InputStreamReader(targetOut));
+targetErrReader = new BufferedReader(new InputStreamReader(targetErr));
+try {
+targetInWriter.write(TargetManager.TARGETVM_START + '\n');
+targetInWriter.flush();
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+return target;
+}
+
+static void listIpcDir() {
+String tmpdir = System.getProperty(""java.io.tmpdir"")
++ File.separatorChar + DEFAULT_IPC_DIR;
+logger.debug(""DEBUG:"" + tmpdir);
+File ipcDir = new File(tmpdir);
+if (ipcDir.exists()) {
+listRecursive(System.getProperty(""java.io.tmpdir""), ipcDir);
+}
+}
+
+static void listRecursive(String prefix, File root) {
+String myPath = prefix + ""/"" + root.getName();
+logger.debug(myPath);
+if (root.isDirectory()) {
+File[] children = root.listFiles();
+if (null != children) {
+for (File c : children) {
+listRecursive(myPath, c);
+}
+}
+}
+}
+
+protected int terminateTarget() {
+int rc = -1;
+if (!active) {
+return 0;
+}
+active = false;
+try {
+targetInWriter.write(TargetManager.TARGETVM_STOP + '\n');
+try {
+targetInWriter.flush();
+} catch (IOException e) {
+/* ignore it */
+}
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if ((null != currentLine) &&
+!currentLine.startsWith(""JVMJ9VM082E Unable to switch to IFA processor"")) {
+errOutput += currentLine + ""\n"";
+}
+}
+while (targetOutReader.ready()) {",I don't think this is the right code.   I would expect a loop while readLine() is not returning null.,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,
+String myDisplayName, List<String> vmArgs,
+List<String> appArgs) {
+List<String> argBuffer = new ArrayList<String>();
+String[] args = {};
+this.displayName = myDisplayName;
+Runtime me = Runtime.getRuntime();
+char fs = File.separatorChar;
+String javaExec = System.getProperty(""java.home"") + fs + ""bin"" + fs
++ ""java"";
+logger.debug(""javaExec=""+javaExec);
+String sideCar = System.getProperty(""java.sidecar"");
+String myClasspath = System.getProperty(""java.class.path"");
+argBuffer.add(javaExec);
+argBuffer.add(""-Dcom.ibm.tools.attach.enable=yes"");
+if (doLogging) {
+argBuffer.add(""-Dcom.ibm.tools.attach.logging=yes"");
+}
+if (null != tgtId) {
+argBuffer.add(""-Dcom.ibm.tools.attach.id="" + tgtId);
+}
+if (null != myDisplayName) {
+argBuffer.add(""-Dcom.ibm.tools.attach.displayName="" + myDisplayName);
+}
+argBuffer.add(""-classpath"");
+argBuffer.add(myClasspath);
+if ((null != sideCar) && (sideCar.length() > 0)) {
+String sidecarArgs[] = sideCar.split("" +"");
+for (String s : sidecarArgs) {
+argBuffer.add(s);
+}
+}
+if (null != vmArgs) {
+argBuffer.addAll(vmArgs);
+}
+argBuffer.add(cmdName);
+if (null != appArgs) {
+argBuffer.addAll(appArgs);
+}
+Process target = null;
+args = new String[argBuffer.size()];
+argBuffer.toArray(args);
+if (verbose) {
+System.out.print(""\n"");
+for (int i = 0; i < args.length; ++i) {
+System.out.print(args[i] + "" "");
+}
+System.out.print(""\n"");
+}
+try {
+target = me.exec(args);
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+this.targetIn = target.getOutputStream();
+InputStream targetOut = target.getInputStream();
+InputStream targetErr = target.getErrorStream();
+targetInWriter = new BufferedWriter(new OutputStreamWriter(targetIn));
+targetOutReader = new BufferedReader(new InputStreamReader(targetOut));
+targetErrReader = new BufferedReader(new InputStreamReader(targetErr));
+try {
+targetInWriter.write(TargetManager.TARGETVM_START + '\n');
+targetInWriter.flush();
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+return target;
+}
+
+static void listIpcDir() {
+String tmpdir = System.getProperty(""java.io.tmpdir"")
++ File.separatorChar + DEFAULT_IPC_DIR;
+logger.debug(""DEBUG:"" + tmpdir);
+File ipcDir = new File(tmpdir);
+if (ipcDir.exists()) {
+listRecursive(System.getProperty(""java.io.tmpdir""), ipcDir);
+}
+}
+
+static void listRecursive(String prefix, File root) {
+String myPath = prefix + ""/"" + root.getName();
+logger.debug(myPath);
+if (root.isDirectory()) {
+File[] children = root.listFiles();
+if (null != children) {
+for (File c : children) {
+listRecursive(myPath, c);
+}
+}
+}
+}
+
+protected int terminateTarget() {
+int rc = -1;
+if (!active) {
+return 0;
+}
+active = false;
+try {
+targetInWriter.write(TargetManager.TARGETVM_STOP + '\n');
+try {
+targetInWriter.flush();
+} catch (IOException e) {
+/* ignore it */
+}
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if ((null != currentLine) &&
+!currentLine.startsWith(""JVMJ9VM082E Unable to switch to IFA processor"")) {
+errOutput += currentLine + ""\n"";
+}
+}
+while (targetOutReader.ready()) {
+String currentLine = targetOutReader.readLine();
+if (null != currentLine) {
+outOutput += currentLine + ""\n"";
+}
+}
+rc = proc.waitFor();
+proc.destroy();
+} catch (IOException e) { 
+/* target closed the streams */
+} catch (InterruptedException e) {
+e.printStackTrace();
+rc = -1;
+} finally {
+try {
+/* get anything that may have been in the buffers */
+while (targetErrReader.ready()) {",same as above and in other places using ready().,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TestAttachAPI.java,False,"@@ -0,0 +1,104 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+
+package org.openj9.test.java9AttachAPI;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+import static org.openj9.test.java9AttachAPI.SelfAttacher.ATTACH_SELF_API_SUCCEEDED_CODE;
+import static org.openj9.test.java9AttachAPI.SelfAttacher.ATTACH_SELF_IOEXCEPTION_CODE;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+import org.testng.log4testng.Logger;
+
+/**
+ * This test must be invoked via testng.  Running the main method will return only the status of the attach API.
+ *
+ */
+@SuppressWarnings({""nls"",""boxing""})",Please don't use SuppressWarnings.,
64649361,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src_latest/org/openj9/test/java9AttachAPI/VmIdGetter.java,False,"@@ -0,0 +1,30 @@
+/* Copyright (c) 2015, 2017 IBM Corp. and others",Can you explain the difference between src_latest and src_current?  I'm not aware of why there are two...,
64920218,6719fa710313e4a775b69e8133b7e34d7c9a9c04,jcl/src/jdk.attach/share/classes/com/ibm/tools/attach/attacher/OpenJ9VirtualMachine.java,True,"@@ -397,18 +399,26 @@ private void tryAttachTarget(int timeout) throws IOException,
  * to attach
  */
 /*[MSG ""K0457"", ""Target no longer available""]*/
-AttachNotSupportedException exc = new AttachNotSupportedException(com.ibm.oti.util.Msg.getString(""K0457"")); //$NON-NLS-1$
+AttachNotSupportedException exc = new AttachNotSupportedException(getString(""K0457"")); //$NON-NLS-1$
 exc.initCause(e);
 throw exc;
 }
 
 if (descriptor.id().equals(AttachHandler.getVmId())) {
+/*[IF Sidecar19-SE]*/
+String allowattachselfValue = AttachHandler.allowAttachSelf;","Done, though I inserted an underscore before ""value"" to indicate that it's the value of allowAttachSelf.",
64925065,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/SelfAttacher.java,True,"@@ -0,0 +1,64 @@
+/*******************************************************************************
+ * Copyright (c) 2015, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.IOException;
+import java.util.Properties;
+
+import com.sun.tools.attach.AttachNotSupportedException;
+import com.sun.tools.attach.VirtualMachine;
+import com.sun.tools.attach.VirtualMachineDescriptor;
+
+public class SelfAttacher {
+
+static final int ATTACH_ERROR_CODE = 10;
+static final int ATTACH_NOT_SUPPORTED_CODE = 11;
+static final int ATTACH_SELF_IOEXCEPTION_CODE = 12;
+static final int ATTACH_SELF_API_SUCCEEDED_CODE = 13;
+public static void main(String[] args) {
+try {
+String myId = VmIdGetter.getVmId();
+System.err.println(""myId=""+myId);
+boolean found = false;
+for (int i = 0; i <10 && !found; ++i) {","Playlist: updated.

SelfAttacher:
This isn't to get the vmID.  It's cycling waiting for the attach API to initialize.  There is OpenJ9 internal API to do that, but it's not portable.",
64929384,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/SelfAttacher.java,True,"@@ -0,0 +1,64 @@
+/*******************************************************************************
+ * Copyright (c) 2015, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.IOException;
+import java.util.Properties;
+
+import com.sun.tools.attach.AttachNotSupportedException;
+import com.sun.tools.attach.VirtualMachine;
+import com.sun.tools.attach.VirtualMachineDescriptor;
+
+public class SelfAttacher {
+
+static final int ATTACH_ERROR_CODE = 10;
+static final int ATTACH_NOT_SUPPORTED_CODE = 11;
+static final int ATTACH_SELF_IOEXCEPTION_CODE = 12;
+static final int ATTACH_SELF_API_SUCCEEDED_CODE = 13;
+public static void main(String[] args) {
+try {
+String myId = VmIdGetter.getVmId();
+System.err.println(""myId=""+myId);
+boolean found = false;
+for (int i = 0; i <10 && !found; ++i) {
+Thread.sleep(100);
+for (VirtualMachineDescriptor v: VirtualMachine.list()) {
+if (v.id().equals(myId)) {
+found = true;
+break;
+}
+}
+}
+VirtualMachine vm = VirtualMachine.attach(myId);
+Properties props = vm.getSystemProperties();
+props.list(System.out);
+} catch (AttachNotSupportedException e) {
+e.printStackTrace();","SelfAttacher is run as a child process whose stdout and stderr are captured by the TargetManager which can log it, though I don't bother doing so in this test.",
64930327,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")",Fixed.,
64937548,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.","The original TargetManager is in Java8AndUp, which shares no OpenJ9 test code with Java9AndUp.  Maybe @smlambert or @llxia can suggest a better mechanism.",
64937627,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();",Done.,
64937783,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";",Done,
64948965,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {","The intent is to grab as much of stderr as possible without blocking, in case the stdout closed but stderr stayed open.  Comment added.",
64957406,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,","> especially as that may be future you a few months down the line =)
I wrote this 9 years ago :-).

Done.  Let me know if you want more.",
64958354,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,
+String myDisplayName, List<String> vmArgs,
+List<String> appArgs) {
+List<String> argBuffer = new ArrayList<String>();
+String[] args = {};
+this.displayName = myDisplayName;
+Runtime me = Runtime.getRuntime();
+char fs = File.separatorChar;
+String javaExec = System.getProperty(""java.home"") + fs + ""bin"" + fs
++ ""java"";
+logger.debug(""javaExec=""+javaExec);
+String sideCar = System.getProperty(""java.sidecar"");
+String myClasspath = System.getProperty(""java.class.path"");
+argBuffer.add(javaExec);
+argBuffer.add(""-Dcom.ibm.tools.attach.enable=yes"");
+if (doLogging) {
+argBuffer.add(""-Dcom.ibm.tools.attach.logging=yes"");
+}
+if (null != tgtId) {
+argBuffer.add(""-Dcom.ibm.tools.attach.id="" + tgtId);
+}
+if (null != myDisplayName) {
+argBuffer.add(""-Dcom.ibm.tools.attach.displayName="" + myDisplayName);
+}
+argBuffer.add(""-classpath"");
+argBuffer.add(myClasspath);
+if ((null != sideCar) && (sideCar.length() > 0)) {
+String sidecarArgs[] = sideCar.split("" +"");
+for (String s : sidecarArgs) {
+argBuffer.add(s);
+}
+}
+if (null != vmArgs) {
+argBuffer.addAll(vmArgs);
+}
+argBuffer.add(cmdName);
+if (null != appArgs) {
+argBuffer.addAll(appArgs);
+}
+Process target = null;
+args = new String[argBuffer.size()];
+argBuffer.toArray(args);
+if (verbose) {
+System.out.print(""\n"");
+for (int i = 0; i < args.length; ++i) {
+System.out.print(args[i] + "" "");
+}
+System.out.print(""\n"");
+}
+try {
+target = me.exec(args);
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+this.targetIn = target.getOutputStream();
+InputStream targetOut = target.getInputStream();
+InputStream targetErr = target.getErrorStream();
+targetInWriter = new BufferedWriter(new OutputStreamWriter(targetIn));
+targetOutReader = new BufferedReader(new InputStreamReader(targetOut));
+targetErrReader = new BufferedReader(new InputStreamReader(targetErr));
+try {
+targetInWriter.write(TargetManager.TARGETVM_START + '\n');
+targetInWriter.flush();
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+return target;
+}
+
+static void listIpcDir() {","> Can you add javadoc for each of these methods? 
Done.  Let me know if you want more explanation.

>It looks like this method tries to recursively list all the files and directories under the java.io.tmpdir to the logger.debug() output. Should it only be called if the logger.debug() level is enabled?
Actually, it lists the contents of /tmp/.com_ibm_tools_attach, which will be a few files for each Java process.  This method is mostly for post-failure analysis.",
64958660,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,
+String myDisplayName, List<String> vmArgs,
+List<String> appArgs) {
+List<String> argBuffer = new ArrayList<String>();
+String[] args = {};
+this.displayName = myDisplayName;
+Runtime me = Runtime.getRuntime();
+char fs = File.separatorChar;
+String javaExec = System.getProperty(""java.home"") + fs + ""bin"" + fs
++ ""java"";
+logger.debug(""javaExec=""+javaExec);
+String sideCar = System.getProperty(""java.sidecar"");
+String myClasspath = System.getProperty(""java.class.path"");
+argBuffer.add(javaExec);
+argBuffer.add(""-Dcom.ibm.tools.attach.enable=yes"");
+if (doLogging) {
+argBuffer.add(""-Dcom.ibm.tools.attach.logging=yes"");
+}
+if (null != tgtId) {
+argBuffer.add(""-Dcom.ibm.tools.attach.id="" + tgtId);
+}
+if (null != myDisplayName) {
+argBuffer.add(""-Dcom.ibm.tools.attach.displayName="" + myDisplayName);
+}
+argBuffer.add(""-classpath"");
+argBuffer.add(myClasspath);
+if ((null != sideCar) && (sideCar.length() > 0)) {
+String sidecarArgs[] = sideCar.split("" +"");
+for (String s : sidecarArgs) {
+argBuffer.add(s);
+}
+}
+if (null != vmArgs) {
+argBuffer.addAll(vmArgs);
+}
+argBuffer.add(cmdName);
+if (null != appArgs) {
+argBuffer.addAll(appArgs);
+}
+Process target = null;
+args = new String[argBuffer.size()];
+argBuffer.toArray(args);
+if (verbose) {
+System.out.print(""\n"");
+for (int i = 0; i < args.length; ++i) {
+System.out.print(args[i] + "" "");
+}
+System.out.print(""\n"");
+}
+try {
+target = me.exec(args);
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+this.targetIn = target.getOutputStream();
+InputStream targetOut = target.getInputStream();
+InputStream targetErr = target.getErrorStream();
+targetInWriter = new BufferedWriter(new OutputStreamWriter(targetIn));
+targetOutReader = new BufferedReader(new InputStreamReader(targetOut));
+targetErrReader = new BufferedReader(new InputStreamReader(targetErr));
+try {
+targetInWriter.write(TargetManager.TARGETVM_START + '\n');
+targetInWriter.flush();
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+return target;
+}
+
+static void listIpcDir() {
+String tmpdir = System.getProperty(""java.io.tmpdir"")
++ File.separatorChar + DEFAULT_IPC_DIR;
+logger.debug(""DEBUG:"" + tmpdir);
+File ipcDir = new File(tmpdir);
+if (ipcDir.exists()) {
+listRecursive(System.getProperty(""java.io.tmpdir""), ipcDir);
+}
+}
+
+static void listRecursive(String prefix, File root) {
+String myPath = prefix + ""/"" + root.getName();
+logger.debug(myPath);
+if (root.isDirectory()) {
+File[] children = root.listFiles();
+if (null != children) {
+for (File c : children) {
+listRecursive(myPath, c);
+}
+}
+}
+}
+
+protected int terminateTarget() {
+int rc = -1;
+if (!active) {
+return 0;
+}
+active = false;
+try {
+targetInWriter.write(TargetManager.TARGETVM_STOP + '\n');
+try {
+targetInWriter.flush();
+} catch (IOException e) {
+/* ignore it */
+}
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if ((null != currentLine) &&
+!currentLine.startsWith(""JVMJ9VM082E Unable to switch to IFA processor"")) {
+errOutput += currentLine + ""\n"";
+}
+}
+while (targetOutReader.ready()) {","As mentioned above, I don't want readline() to block.",
64958862,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TestAttachAPI.java,True,"@@ -0,0 +1,104 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+
+package org.openj9.test.java9AttachAPI;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.fail;
+import static org.openj9.test.java9AttachAPI.SelfAttacher.ATTACH_SELF_API_SUCCEEDED_CODE;
+import static org.openj9.test.java9AttachAPI.SelfAttacher.ATTACH_SELF_IOEXCEPTION_CODE;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+import org.testng.log4testng.Logger;
+
+/**
+ * This test must be invoked via testng.  Running the main method will return only the status of the attach API.
+ *
+ */
+@SuppressWarnings({""nls"",""boxing""})",Okay.,
64959384,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src_latest/org/openj9/test/java9AttachAPI/VmIdGetter.java,True,"@@ -0,0 +1,30 @@
+/* Copyright (c) 2015, 2017 IBM Corp. and others",This is a kludge to handle the API differences between the two JCL versions in the builds.,
64966420,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,
+String myDisplayName, List<String> vmArgs,
+List<String> appArgs) {
+List<String> argBuffer = new ArrayList<String>();
+String[] args = {};
+this.displayName = myDisplayName;
+Runtime me = Runtime.getRuntime();
+char fs = File.separatorChar;
+String javaExec = System.getProperty(""java.home"") + fs + ""bin"" + fs
++ ""java"";
+logger.debug(""javaExec=""+javaExec);
+String sideCar = System.getProperty(""java.sidecar"");
+String myClasspath = System.getProperty(""java.class.path"");
+argBuffer.add(javaExec);
+argBuffer.add(""-Dcom.ibm.tools.attach.enable=yes"");
+if (doLogging) {
+argBuffer.add(""-Dcom.ibm.tools.attach.logging=yes"");
+}
+if (null != tgtId) {
+argBuffer.add(""-Dcom.ibm.tools.attach.id="" + tgtId);
+}
+if (null != myDisplayName) {
+argBuffer.add(""-Dcom.ibm.tools.attach.displayName="" + myDisplayName);
+}
+argBuffer.add(""-classpath"");
+argBuffer.add(myClasspath);
+if ((null != sideCar) && (sideCar.length() > 0)) {
+String sidecarArgs[] = sideCar.split("" +"");
+for (String s : sidecarArgs) {
+argBuffer.add(s);
+}
+}
+if (null != vmArgs) {
+argBuffer.addAll(vmArgs);
+}
+argBuffer.add(cmdName);
+if (null != appArgs) {
+argBuffer.addAll(appArgs);
+}
+Process target = null;
+args = new String[argBuffer.size()];
+argBuffer.toArray(args);
+if (verbose) {
+System.out.print(""\n"");
+for (int i = 0; i < args.length; ++i) {
+System.out.print(args[i] + "" "");
+}
+System.out.print(""\n"");
+}
+try {
+target = me.exec(args);
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+this.targetIn = target.getOutputStream();
+InputStream targetOut = target.getInputStream();
+InputStream targetErr = target.getErrorStream();
+targetInWriter = new BufferedWriter(new OutputStreamWriter(targetIn));
+targetOutReader = new BufferedReader(new InputStreamReader(targetOut));
+targetErrReader = new BufferedReader(new InputStreamReader(targetErr));
+try {
+targetInWriter.write(TargetManager.TARGETVM_START + '\n');
+targetInWriter.flush();
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+return target;
+}
+
+static void listIpcDir() {
+String tmpdir = System.getProperty(""java.io.tmpdir"")
++ File.separatorChar + DEFAULT_IPC_DIR;
+logger.debug(""DEBUG:"" + tmpdir);
+File ipcDir = new File(tmpdir);
+if (ipcDir.exists()) {
+listRecursive(System.getProperty(""java.io.tmpdir""), ipcDir);
+}
+}
+
+static void listRecursive(String prefix, File root) {
+String myPath = prefix + ""/"" + root.getName();
+logger.debug(myPath);
+if (root.isDirectory()) {
+File[] children = root.listFiles();
+if (null != children) {
+for (File c : children) {
+listRecursive(myPath, c);
+}
+}
+}
+}
+
+protected int terminateTarget() {
+int rc = -1;
+if (!active) {
+return 0;
+}
+active = false;
+try {
+targetInWriter.write(TargetManager.TARGETVM_STOP + '\n');
+try {
+targetInWriter.flush();
+} catch (IOException e) {
+/* ignore it */
+}
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if ((null != currentLine) &&
+!currentLine.startsWith(""JVMJ9VM082E Unable to switch to IFA processor"")) {
+errOutput += currentLine + ""\n"";
+}
+}
+while (targetOutReader.ready()) {
+String currentLine = targetOutReader.readLine();
+if (null != currentLine) {
+outOutput += currentLine + ""\n"";
+}
+}
+rc = proc.waitFor();
+proc.destroy();
+} catch (IOException e) { 
+/* target closed the streams */
+} catch (InterruptedException e) {
+e.printStackTrace();
+rc = -1;
+} finally {
+try {
+/* get anything that may have been in the buffers */
+while (targetErrReader.ready()) {",See above.,
64982173,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,False,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,
+String myDisplayName, List<String> vmArgs,
+List<String> appArgs) {
+List<String> argBuffer = new ArrayList<String>();
+String[] args = {};
+this.displayName = myDisplayName;
+Runtime me = Runtime.getRuntime();
+char fs = File.separatorChar;
+String javaExec = System.getProperty(""java.home"") + fs + ""bin"" + fs
++ ""java"";
+logger.debug(""javaExec=""+javaExec);
+String sideCar = System.getProperty(""java.sidecar"");
+String myClasspath = System.getProperty(""java.class.path"");
+argBuffer.add(javaExec);
+argBuffer.add(""-Dcom.ibm.tools.attach.enable=yes"");
+if (doLogging) {
+argBuffer.add(""-Dcom.ibm.tools.attach.logging=yes"");
+}
+if (null != tgtId) {
+argBuffer.add(""-Dcom.ibm.tools.attach.id="" + tgtId);
+}
+if (null != myDisplayName) {
+argBuffer.add(""-Dcom.ibm.tools.attach.displayName="" + myDisplayName);
+}
+argBuffer.add(""-classpath"");
+argBuffer.add(myClasspath);
+if ((null != sideCar) && (sideCar.length() > 0)) {
+String sidecarArgs[] = sideCar.split("" +"");
+for (String s : sidecarArgs) {
+argBuffer.add(s);
+}
+}
+if (null != vmArgs) {
+argBuffer.addAll(vmArgs);
+}
+argBuffer.add(cmdName);
+if (null != appArgs) {
+argBuffer.addAll(appArgs);
+}
+Process target = null;
+args = new String[argBuffer.size()];
+argBuffer.toArray(args);
+if (verbose) {
+System.out.print(""\n"");
+for (int i = 0; i < args.length; ++i) {
+System.out.print(args[i] + "" "");
+}
+System.out.print(""\n"");
+}
+try {
+target = me.exec(args);
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+this.targetIn = target.getOutputStream();
+InputStream targetOut = target.getInputStream();
+InputStream targetErr = target.getErrorStream();
+targetInWriter = new BufferedWriter(new OutputStreamWriter(targetIn));
+targetOutReader = new BufferedReader(new InputStreamReader(targetOut));
+targetErrReader = new BufferedReader(new InputStreamReader(targetErr));
+try {
+targetInWriter.write(TargetManager.TARGETVM_START + '\n');
+targetInWriter.flush();
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+return target;
+}
+
+static void listIpcDir() {
+String tmpdir = System.getProperty(""java.io.tmpdir"")
++ File.separatorChar + DEFAULT_IPC_DIR;
+logger.debug(""DEBUG:"" + tmpdir);
+File ipcDir = new File(tmpdir);
+if (ipcDir.exists()) {
+listRecursive(System.getProperty(""java.io.tmpdir""), ipcDir);
+}
+}
+
+static void listRecursive(String prefix, File root) {
+String myPath = prefix + ""/"" + root.getName();
+logger.debug(myPath);
+if (root.isDirectory()) {
+File[] children = root.listFiles();
+if (null != children) {
+for (File c : children) {
+listRecursive(myPath, c);
+}
+}
+}
+}
+
+protected int terminateTarget() {
+int rc = -1;
+if (!active) {
+return 0;
+}
+active = false;
+try {
+targetInWriter.write(TargetManager.TARGETVM_STOP + '\n');
+try {
+targetInWriter.flush();
+} catch (IOException e) {
+/* ignore it */
+}
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if ((null != currentLine) &&
+!currentLine.startsWith(""JVMJ9VM082E Unable to switch to IFA processor"")) {
+errOutput += currentLine + ""\n"";
+}
+}
+while (targetOutReader.ready()) {",I don't think this actually stops readline from blocking - the stream is ready as soon as there are characters available.,
65000656,6719fa710313e4a775b69e8133b7e34d7c9a9c04,test/Java9andUp/src/org/openj9/test/java9AttachAPI/TargetManager.java,True,"@@ -0,0 +1,339 @@
+/*******************************************************************************
+ * Copyright (c) 2001, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.java9AttachAPI;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.testng.log4testng.Logger;
+
+/* This is was copied from org.openj9.test.attachAPI.TargetManager in Java8AndUp.
+ * Unnecessary code has been trimmed.
+ */
+@SuppressWarnings(""nls"")
+class TargetManager {
+private static Logger logger = Logger.getLogger(TargetManager.class);
+public static final String VMID_PREAMBLE = ""vmid="";
+public static final String STATUS_PREAMBLE = ""status="";
+public static final String STATUS_INIT_SUCESS = ""init_success"";
+public static final String STATUS_INIT_FAIL = ""attach_init_fail"";
+
+String targetId, displayName;
+private Process proc;
+private BufferedWriter targetInWriter;
+private BufferedReader targetOutReader;
+private BufferedReader targetErrReader;
+private OutputStream targetIn;
+String errOutput = """";
+String outOutput = """";
+private String targetVmid;
+public static final String TARGETVM_START = ""targetvm_start"";
+public static final String TARGETVM_STOP = ""targetvm_stop"";
+static boolean verbose = false;
+private static boolean doLogging = false;
+private static final String DEFAULT_IPC_DIR = "".com_ibm_tools_attach"";
+public TargetStatus targetVmStatus;
+private boolean active = true;
+
+public TargetStatus getTargetVmStatus() {
+return targetVmStatus;
+}
+
+public enum TargetStatus {
+INIT_SUCCESS, INIT_FAILURE
+}
+
+public static void setVerbose(boolean v) {
+verbose = v;
+}
+
+public BufferedWriter getTargetInWriter() {
+return targetInWriter;
+}
+
+public BufferedReader getTargetOutReader() {
+return targetOutReader;
+}
+
+public BufferedReader getTargetErrReader() {
+return targetErrReader;
+}
+
+public TargetManager(String cmdName, String targetId) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, null);
+}
+
+/*
+ * target must print the PID on one line, other information on following
+ * line(s) (if any), the initialization status on the final line.
+ */
+public TargetStatus readTargetStatus() {
+TargetStatus tgtStatus = TargetStatus.INIT_FAILURE;
+StringBuffer targetLog = new StringBuffer();
+try {
+boolean done = false;
+do {
+String tgtOutput = targetOutReader.readLine();
+if (null != tgtOutput) {
+targetLog.append(tgtOutput);
+targetLog.append('\n');
+} else {
+logger.debug(""TargetVM stdout closed unexpectedly"");
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if (null != currentLine) {
+logger.error(currentLine + ""\n"");
+}
+}
+tgtStatus = TargetStatus.INIT_FAILURE;
+break;
+}
+if (verbose) {
+logger.debug(""TargetVM output: "" + tgtOutput);
+}
+if (tgtOutput.startsWith(VMID_PREAMBLE)) {
+setTargetVmid(tgtOutput.substring(VMID_PREAMBLE.length()));
+}
+if (tgtOutput.startsWith(STATUS_PREAMBLE)) {
+String statusString = tgtOutput.substring(STATUS_PREAMBLE
+.length());
+if (statusString.equals(STATUS_INIT_FAIL)) {
+tgtStatus = TargetStatus.INIT_FAILURE;
+} else if (statusString.equals(STATUS_INIT_SUCESS)) {
+tgtStatus = TargetStatus.INIT_SUCCESS;
+}
+done = true;
+}
+} while (!done);
+} catch (IOException e) {
+e.printStackTrace();
+}
+if (TargetStatus.INIT_SUCCESS != tgtStatus) {
+logger.debug(""TargetVM initialization failed with status ""+tgtStatus.toString()+""\nTarget output:\n""+targetLog.toString());
+}
+return tgtStatus;
+}
+
+public TargetManager(String cmdName) {
+this.proc = launchTarget(cmdName, null, null, null, null);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, null, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, null, vmArgs, appArgs);
+}
+
+public TargetManager(String cmdName, String targetId, String displayName,
+List<String> vmArgs, List<String> appArgs) {
+this.targetId = targetId;
+this.proc = launchTarget(cmdName, targetId, displayName, vmArgs,
+appArgs);
+}
+
+int waitFor() throws InterruptedException {
+return proc.waitFor();
+}
+
+/**
+ * launch a TargetVM process
+ * 
+ * @return launched process
+ */
+private Process launchTarget(String cmdName, String tgtId,
+String myDisplayName, List<String> vmArgs,
+List<String> appArgs) {
+List<String> argBuffer = new ArrayList<String>();
+String[] args = {};
+this.displayName = myDisplayName;
+Runtime me = Runtime.getRuntime();
+char fs = File.separatorChar;
+String javaExec = System.getProperty(""java.home"") + fs + ""bin"" + fs
++ ""java"";
+logger.debug(""javaExec=""+javaExec);
+String sideCar = System.getProperty(""java.sidecar"");
+String myClasspath = System.getProperty(""java.class.path"");
+argBuffer.add(javaExec);
+argBuffer.add(""-Dcom.ibm.tools.attach.enable=yes"");
+if (doLogging) {
+argBuffer.add(""-Dcom.ibm.tools.attach.logging=yes"");
+}
+if (null != tgtId) {
+argBuffer.add(""-Dcom.ibm.tools.attach.id="" + tgtId);
+}
+if (null != myDisplayName) {
+argBuffer.add(""-Dcom.ibm.tools.attach.displayName="" + myDisplayName);
+}
+argBuffer.add(""-classpath"");
+argBuffer.add(myClasspath);
+if ((null != sideCar) && (sideCar.length() > 0)) {
+String sidecarArgs[] = sideCar.split("" +"");
+for (String s : sidecarArgs) {
+argBuffer.add(s);
+}
+}
+if (null != vmArgs) {
+argBuffer.addAll(vmArgs);
+}
+argBuffer.add(cmdName);
+if (null != appArgs) {
+argBuffer.addAll(appArgs);
+}
+Process target = null;
+args = new String[argBuffer.size()];
+argBuffer.toArray(args);
+if (verbose) {
+System.out.print(""\n"");
+for (int i = 0; i < args.length; ++i) {
+System.out.print(args[i] + "" "");
+}
+System.out.print(""\n"");
+}
+try {
+target = me.exec(args);
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+this.targetIn = target.getOutputStream();
+InputStream targetOut = target.getInputStream();
+InputStream targetErr = target.getErrorStream();
+targetInWriter = new BufferedWriter(new OutputStreamWriter(targetIn));
+targetOutReader = new BufferedReader(new InputStreamReader(targetOut));
+targetErrReader = new BufferedReader(new InputStreamReader(targetErr));
+try {
+targetInWriter.write(TargetManager.TARGETVM_START + '\n');
+targetInWriter.flush();
+} catch (IOException e) {
+e.printStackTrace();
+return null;
+}
+return target;
+}
+
+static void listIpcDir() {
+String tmpdir = System.getProperty(""java.io.tmpdir"")
++ File.separatorChar + DEFAULT_IPC_DIR;
+logger.debug(""DEBUG:"" + tmpdir);
+File ipcDir = new File(tmpdir);
+if (ipcDir.exists()) {
+listRecursive(System.getProperty(""java.io.tmpdir""), ipcDir);
+}
+}
+
+static void listRecursive(String prefix, File root) {
+String myPath = prefix + ""/"" + root.getName();
+logger.debug(myPath);
+if (root.isDirectory()) {
+File[] children = root.listFiles();
+if (null != children) {
+for (File c : children) {
+listRecursive(myPath, c);
+}
+}
+}
+}
+
+protected int terminateTarget() {
+int rc = -1;
+if (!active) {
+return 0;
+}
+active = false;
+try {
+targetInWriter.write(TargetManager.TARGETVM_STOP + '\n');
+try {
+targetInWriter.flush();
+} catch (IOException e) {
+/* ignore it */
+}
+while (targetErrReader.ready()) {
+String currentLine = targetErrReader.readLine();
+if ((null != currentLine) &&
+!currentLine.startsWith(""JVMJ9VM082E Unable to switch to IFA processor"")) {
+errOutput += currentLine + ""\n"";
+}
+}
+while (targetOutReader.ready()) {","The readline() will block until there is a newline, but the target process emits complete lines, so any blocking will be brief.  The purpose of the code was to handle the case where stdout would close and stderr was still open but not receiving anything.",
65561812,ca6d839669d5713aca4568b44168a77debd44b62,runtime/tr.source/trj9/env/PersistentCHTable.cpp,False,"@@ -75,34 +75,16 @@ TR_PersistentCHTable::commitSideEffectGuards(TR::Compilation *comp)
 
    for (TR_ClassLoadCheck * clc = comp->getClassesThatShouldNotBeLoaded()->getFirst(); clc; clc = clc->getNext())
       {
-      for (int32_t i = 0; i < CLASSHASHTABLE_SIZE; ++i)
+      TR_OpaqueClassBlock *clazz = comp->fej9()->getClassFromSignature(clc->_name, clc->_length, comp->getCurrentMethod());",Is ClassesThatShouldNotBeLoaded normalized so there is only one entry per class? If it is then this is fine. If there are duplicates we may need to cache the lookup result since the name lookup can be expensive.,
65574888,ca6d839669d5713aca4568b44168a77debd44b62,runtime/tr.source/trj9/env/PersistentCHTable.cpp,True,"@@ -75,34 +75,16 @@ TR_PersistentCHTable::commitSideEffectGuards(TR::Compilation *comp)
 
    for (TR_ClassLoadCheck * clc = comp->getClassesThatShouldNotBeLoaded()->getFirst(); clc; clc = clc->getNext())
       {
-      for (int32_t i = 0; i < CLASSHASHTABLE_SIZE; ++i)
+      TR_OpaqueClassBlock *clazz = comp->fej9()->getClassFromSignature(clc->_name, clc->_length, comp->getCurrentMethod());","Currently, all optimizations that add to `ClassesThatShouldNotBeLoaded` will ensure duplicates are not added.",
65330523,e39ecfba34f966f1fb89ace77c6827d20fa7a907,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -197,6 +197,12 @@ static long getValueFieldOffset() {
 }
 }
 }
+
+/**
+ * This is a System property to enable copying of the underlying value array in {@link #String.substring(int)} and 
+ * {@link #String.substring(int, int)} if the offset is zero.
+ */
+static boolean enableCopyInSubstringWhenOffsetIsZero;",We get more streamlined code if we capture `enableSharingInSubstringWhenOffsetIsZero' in that it doesn't need to be negated in every use case.,
65335440,e39ecfba34f966f1fb89ace77c6827d20fa7a907,jcl/src/java.base/share/classes/java/lang/System.java,False,"@@ -167,6 +167,13 @@ static void afterClinitInitialization() {
 unsafe.putObject(unsafe.staticFieldBase(f2), unsafe.staticFieldOffset(f2), com.ibm.jit.JITHelpers.getHelpers());
 } catch (NoSuchFieldException e) { }
 
+/**
+ * When the System Property == true, then enable copying in String.substring(int) and String.substring(int, int)
+ * methods whenever offset is zero. Otherwise, disable copy.
+ */
+String enableCopyInSubstringWhenOffsetIsZeroProperty = internalGetProperties().getProperty(""java.lang.string.substring.copy.offset.zero""); //$NON-NLS-1$
+String.enableCopyInSubstringWhenOffsetIsZero = enableCopyInSubstringWhenOffsetIsZeroProperty != null && !enableCopyInSubstringWhenOffsetIsZeroProperty.equalsIgnoreCase(""false""); //$NON-NLS-1$","This becomes
```
enableSharingInSubstringWhenOffsetIsZero = enableCopyInSubstringWhenOffsetIsZeroProperty == null || enableCopyInSubstringWhenOffsetIsZeroProperty.equalsIgnoreCase(""false"");
```",
65373219,e39ecfba34f966f1fb89ace77c6827d20fa7a907,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -197,6 +197,12 @@ static long getValueFieldOffset() {
 }
 }
 }
+
+/**
+ * This is a System property to enable copying of the underlying value array in {@link #String.substring(int)} and 
+ * {@link #String.substring(int, int)} if the offset is zero.
+ */
+static boolean enableCopyInSubstringWhenOffsetIsZero;",Fixed in a44d52e.,
65373312,e39ecfba34f966f1fb89ace77c6827d20fa7a907,jcl/src/java.base/share/classes/java/lang/System.java,True,"@@ -167,6 +167,13 @@ static void afterClinitInitialization() {
 unsafe.putObject(unsafe.staticFieldBase(f2), unsafe.staticFieldOffset(f2), com.ibm.jit.JITHelpers.getHelpers());
 } catch (NoSuchFieldException e) { }
 
+/**
+ * When the System Property == true, then enable copying in String.substring(int) and String.substring(int, int)
+ * methods whenever offset is zero. Otherwise, disable copy.
+ */
+String enableCopyInSubstringWhenOffsetIsZeroProperty = internalGetProperties().getProperty(""java.lang.string.substring.copy.offset.zero""); //$NON-NLS-1$
+String.enableCopyInSubstringWhenOffsetIsZero = enableCopyInSubstringWhenOffsetIsZeroProperty != null && !enableCopyInSubstringWhenOffsetIsZeroProperty.equalsIgnoreCase(""false""); //$NON-NLS-1$","Fixed in a44d52e. Though it should be `...equalsIgnoreCase(""true"")`, right?",
65379985,e39ecfba34f966f1fb89ace77c6827d20fa7a907,jcl/src/java.base/share/classes/java/lang/System.java,False,"@@ -167,6 +167,13 @@ static void afterClinitInitialization() {
 unsafe.putObject(unsafe.staticFieldBase(f2), unsafe.staticFieldOffset(f2), com.ibm.jit.JITHelpers.getHelpers());
 } catch (NoSuchFieldException e) { }
 
+/**
+ * When the System Property == true, then enable copying in String.substring(int) and String.substring(int, int)
+ * methods whenever offset is zero. Otherwise, disable copy.
+ */
+String enableCopyInSubstringWhenOffsetIsZeroProperty = internalGetProperties().getProperty(""java.lang.string.substring.copy.offset.zero""); //$NON-NLS-1$
+String.enableCopyInSubstringWhenOffsetIsZero = enableCopyInSubstringWhenOffsetIsZeroProperty != null && !enableCopyInSubstringWhenOffsetIsZeroProperty.equalsIgnoreCase(""false""); //$NON-NLS-1$","equalsIgnoreCase(""false"") is correct because ""true"" or other values mean to enable copy.",
65560774,e39ecfba34f966f1fb89ace77c6827d20fa7a907,jcl/src/java.base/share/classes/java/lang/System.java,True,"@@ -167,6 +167,13 @@ static void afterClinitInitialization() {
 unsafe.putObject(unsafe.staticFieldBase(f2), unsafe.staticFieldOffset(f2), com.ibm.jit.JITHelpers.getHelpers());
 } catch (NoSuchFieldException e) { }
 
+/**
+ * When the System Property == true, then enable copying in String.substring(int) and String.substring(int, int)
+ * methods whenever offset is zero. Otherwise, disable copy.
+ */
+String enableCopyInSubstringWhenOffsetIsZeroProperty = internalGetProperties().getProperty(""java.lang.string.substring.copy.offset.zero""); //$NON-NLS-1$
+String.enableCopyInSubstringWhenOffsetIsZero = enableCopyInSubstringWhenOffsetIsZeroProperty != null && !enableCopyInSubstringWhenOffsetIsZeroProperty.equalsIgnoreCase(""false""); //$NON-NLS-1$","@pshipton this is the intent though. `String.enableSharingInSubstringWhenOffsetIsZero` should be `true` by default. The system property is only provided as a fallback in case users experience OOM issues in very rare cases outlined in the commit description.

The intent of this change is not to alter the current behavior of any of the APIs, but to simply provide an alternative if a user does encounter issues described.",
65628597,ca6d839669d5713aca4568b44168a77debd44b62,runtime/tr.source/trj9/env/PersistentCHTable.cpp,False,"@@ -75,34 +75,16 @@ TR_PersistentCHTable::commitSideEffectGuards(TR::Compilation *comp)
 
    for (TR_ClassLoadCheck * clc = comp->getClassesThatShouldNotBeLoaded()->getFirst(); clc; clc = clc->getNext())
       {
-      for (int32_t i = 0; i < CLASSHASHTABLE_SIZE; ++i)
+      TR_OpaqueClassBlock *clazz = comp->fej9()->getClassFromSignature(clc->_name, clc->_length, comp->getCurrentMethod());",Ok then this looks ok,
65606954,c7ddc3a8a14e31b26d7777169be7358a803ea33f,runtime/buildtools.mk,False,"@@ -89,6 +89,10 @@ findAllFiles = \
 $(foreach i,$(wildcard $1/*),$(call findAllFiles,$i,$2)) \
 $(wildcard $1/$2)
 
+# convert $1 Cygwin path to Windows path with regular slashes
+convertUnixToWinPath = \
+$(if $(findstring CYGWIN,$(OS)), $(foreach f,$1,$(shell cygpath -m $f)),$1)",cygpath can convert all paths in a single invocation: `foreach` is not needed.,
65608298,c7ddc3a8a14e31b26d7777169be7358a803ea33f,runtime/buildtools.mk,False,"@@ -110,7 +114,7 @@ NLS_NLSTOOL := $(JAVA) -cp sourcetools/lib/j9nls.jar com.ibm.oti.NLSTool.J9NLS
 nls : buildtools
 $(NLS_NLSTOOL) $(NLS_OPTIONS)
 
-HOOK_DEFINITION_FILES := $(strip $(call findAllFiles,.,*.hdf))
+HOOK_DEFINITION_FILES := $(call convertUnixToWinPath,$(strip $(call findAllFiles,.,*.hdf)))",This shouldn't be necessary (nor have any effect): all the files should be of the form `./subdir/xxx.hdf`.,
65629515,c7ddc3a8a14e31b26d7777169be7358a803ea33f,runtime/buildtools.mk,True,"@@ -110,7 +114,7 @@ NLS_NLSTOOL := $(JAVA) -cp sourcetools/lib/j9nls.jar com.ibm.oti.NLSTool.J9NLS
 nls : buildtools
 $(NLS_NLSTOOL) $(NLS_OPTIONS)
 
-HOOK_DEFINITION_FILES := $(strip $(call findAllFiles,.,*.hdf))
+HOOK_DEFINITION_FILES := $(call convertUnixToWinPath,$(strip $(call findAllFiles,.,*.hdf)))","@keithc-ca removed unnecessary convert function, thx.",
65631368,c7ddc3a8a14e31b26d7777169be7358a803ea33f,sourcetools/buildj9tools.mk,False,"@@ -34,7 +34,8 @@ DEST_DIR    := lib
 EMPTY       :=
 LIB_DIR     := lib
 OS          := $(shell uname)
-PATH_SEP    := $(if $(findstring Windows,$(OS)),;,:)
+PATH_SEP    := $(if $(or $(findstring Windows,$(OS)),$(findstring CYGWIN,$(OS))),;,:)
+",Can you remove this added (blank) line?,
65641132,c7ddc3a8a14e31b26d7777169be7358a803ea33f,sourcetools/buildj9tools.mk,True,"@@ -34,7 +34,8 @@ DEST_DIR    := lib
 EMPTY       :=
 LIB_DIR     := lib
 OS          := $(shell uname)
-PATH_SEP    := $(if $(findstring Windows,$(OS)),;,:)
+PATH_SEP    := $(if $(or $(findstring Windows,$(OS)),$(findstring CYGWIN,$(OS))),;,:)
+","done, thx",
65746377,ddfed8526053edfb96a89b03d07a891253f6d9a8,test/OpenJ9_Jsr_292_API/src/com/ibm/j9/jsr292/LookupInTests.java,False,"@@ -0,0 +1,616 @@
+/*******************************************************************************","I thought that we had some other test examples where there were differences between 829 and OpenJ9, where we moved the common code out for reuse by both to minimize duplication (like in Java8andUp).  @renfeiw is there an opportunity to do similar with this code to avoid bloating the repo with lots of duplication?",
65903887,ddfed8526053edfb96a89b03d07a891253f6d9a8,test/OpenJ9_Jsr_292_API/src/com/ibm/j9/jsr292/LookupInTests.java,False,"@@ -0,0 +1,616 @@
+/*******************************************************************************","We don't have a better way for this case right now. If we want share the same file without referencing across java projects, we need to place the new tests into the existing Jsr292 project. However, the Jsr292 project is excluded from openj9 currently. So the added tests will be excluded as well. We are working on a better way to exclude test, with that in place we will be able to handle this case in the future. ",
65652184,50fa0cb4981e49c3897bd88fa74367facd96c485,runtime/oti/jitprotos.h,False,"@@ -173,7 +173,12 @@ void J9FASTCALL fast_jitVolatileWriteDouble(J9VMThread *currentThread, U_64 *add
 #endif /* !J9VM_ENV_DATA64 */
 void J9FASTCALL fast_jitCheckIfFinalizeObject(J9VMThread *currentThread, j9object_t object);
 void J9FASTCALL fast_jitCollapseJNIReferenceFrame(J9VMThread *currentThread);
+#ifdef J9VM_ARCH_X86
+// TODO Will be cleaned once all platforms adopt the correct parameter order",This is definitely not allowed - no // comments in .h files.,
66049218,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -565,75 +491,71 @@ public void test_asSpreader_CrossPackage_Virtual() throws Throwable{
 public void test_asSpreader_CrossPackage_Static() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
 mh = mh.asSpreader(int[].class, 2);
-AssertJUnit.assertEquals(MethodType.methodType(int.class,int[].class),mh.type());
-AssertJUnit.assertEquals(5,(int)mh.invokeExact(new int[] {3,2}));
+Assert.assertEquals(mh.type(), MethodType.methodType(int.class,int[].class));
+Assert.assertEquals((int)mh.invokeExact(new int[] {3,2}), 5);
 }
 
 /**
  * Negative test : asSpreader test using cross package virtual method with a wrong method type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Virtual_WrongType() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findVirtual(PackageExamples.class,""addPublic"",MethodType.methodType(int.class,int.class,int.class));
 PackageExamples g = new PackageExamples();
 mh = mh.bindTo(g);
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asSpreader(String[].class, 2);
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asSpreader(String[].class, 2);
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the wrong method type"");
 }
 
 /**
  * Negative test : asSpreader test using a cross-package static method and wrong method type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = IllegalArgumentException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Static_WrongType() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
 mh = mh.asSpreader(int[].class, 2);
-boolean illegalArgumentExceptionThrown = false; 
-
-try {
-mh = mh.asSpreader(String[].class, 2);
-}
-catch(IllegalArgumentException e) {
-illegalArgumentExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(illegalArgumentExceptionThrown);
+mh = mh.asSpreader(String[].class, 2);
+Assert.fail(""The test case failed to throw an IllegalArgumentException in the case of the wrong method type"");
 }
 
 /**
  * Negative test : asSpreader test using cross package static method and a wrong argument count
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = IllegalArgumentException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Static_WrongArgCount() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
-
-boolean illegalArgumentException = false; 
-
-try {
-mh = mh.asSpreader(int[].class, 3);
-}
-catch(IllegalArgumentException e) {
-illegalArgumentException = true;
-}
-
-AssertJUnit.assertTrue(illegalArgumentException);
+mh = mh.asSpreader(int[].class, 3);
+Assert.fail(""The test case failed to throw an IllegalArgumentException in the case of the wrong argument count"");
 }
 
 /******************************
  * Tests for MethodHandle arity
  * ****************************/
 /**
+ * Create MethodHandle with highest possible arity and use findConstructor (253)
+ * @throws Throwable
+ */
+@Test(groups = { ""level.extended"" })
+public void test_findConstructor_ArityLimit() throws Throwable {
+MethodHandle mh = null;",nitpick - why assign null here to assign it's real value on the next line?,
66049218,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -1024,33 +902,25 @@ public void test_asFixedArity_SamePackage_Static() throws Throwable {
 mh = mh.asVarargsCollector(String[].class);
 MethodHandle mhFix = mh.asFixedArity();
 
-AssertJUnit.assertFalse(mhFix.isVarargsCollector());
-AssertJUnit.assertEquals(5,mhFix.invoke(new String[]{""a"",""b"",""c"",""d"",""e""}));
+Assert.assertFalse(mhFix.isVarargsCollector());
+Assert.assertEquals(mhFix.invoke(new String[]{""a"",""b"",""c"",""d"",""e""}), 5);
 }
 
 /**
  * Negative test : asFixedArity test using variable input
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_asFixedArity_SamePackage_Static_VarialbeInput() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(SamePackageExample.class, ""getLengthStatic"", MethodType.methodType(int.class,String[].class));
 mh = mh.asVarargsCollector(String[].class);
 
 MethodHandle mhFix = mh.asFixedArity();
 
-AssertJUnit.assertFalse(mhFix.isVarargsCollector());
-
-boolean wmtThrown = false;
-
-try {
-AssertJUnit.assertEquals(5,mhFix.invoke(""a"",""b"",""c"",""d"",""e""));
-}
-catch(WrongMethodTypeException e) {
-wmtThrown = true;
-}
+Assert.assertFalse(mhFix.isVarargsCollector());
 
-AssertJUnit.assertTrue(wmtThrown);
+Assert.assertEquals(mhFix.invoke(""a"",""b"",""c"",""d"",""e""), 5);","If this is expected to throw, it doesn't need the `Assert.assertEquals`.  The `mhFix.invoke` is sufficient.",
66049218,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -1090,33 +960,26 @@ public void test_invokeWithArguments_List_SamePackage_Virtual() throws Throwable
 l.add(1);
 l.add(2);
 
-AssertJUnit.assertEquals(3,(int)mh.invokeWithArguments(l));
+Assert.assertEquals((int)mh.invokeWithArguments(l), 3);
 }
 
 /**
  * Negative test : invokeWithArgument(List<?>) test with mismatched number of argument passed in argument list
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_invokeWithArguments_List_SamePackage_Virtual_WrongArgCount() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findVirtual(SamePackageExample.class, ""addPublic"", MethodType.methodType(int.class,int.class,int.class));
 SamePackageExample g = new SamePackageExample();
 mh = mh.bindTo(g);
-boolean wmtThrown = false;
 
 List<Integer> l = new ArrayList<Integer>();
 l.add(1);
 l.add(2);
 l.add(3);
 
-try {
-AssertJUnit.assertEquals(6,(int)mh.invokeWithArguments(l));
-}
-catch(WrongMethodTypeException e) {
-wmtThrown = true;
-}
-
-AssertJUnit.assertTrue(wmtThrown);
+Assert.assertEquals((int)mh.invokeWithArguments(l), 6);",The `assertEquals` is unnecessary here.,
66049218,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -1163,23 +1026,20 @@ public void test_invokeWithArguments_List_CrossPackage_Static() throws Throwable
 l.add(1);
 l.add(2);
 
-AssertJUnit.assertEquals(3,(int)mh.invokeWithArguments(l));
+Assert.assertEquals((int)mh.invokeWithArguments(l), 3);
 }
 
 
 /****************************************
  * Tests for invokeWithArguments(Object...)
  * **************************************/
 
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_invokeWithArguments_WMT_NULL_args()  throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findVirtual(Object.class, ""toString"", MethodType.methodType(String.class));
-try {
-mh.invokeWithArguments(""receiver"", null, null);
-Assert.fail(""Should have thrown WMT"");
-} catch(WrongMethodTypeException e) {
-
-}
+mh.invokeWithArguments(""receiver"", null, null);
+Assert.fail(""Should have thrown WMT"");
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of null arguments"");",Two fail calls back to back,
66049218,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -1203,30 +1063,22 @@ public void test_invokeWithArguments_VarargsObj_SamePackage_Virtual_VarargsMetho
 MethodHandle mh = MethodHandles.lookup().findVirtual(SamePackageExample.class, ""addPublicVariableArity"", MethodType.methodType(int.class,Object[].class));
 SamePackageExample g = new SamePackageExample();
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
+Assert.assertTrue(mh.isVarargsCollector());
 
-AssertJUnit.assertEquals(9,mh.invokeWithArguments(g, 1, 2, 2, 2, 2));
+Assert.assertEquals(mh.invokeWithArguments(g, 1, 2, 2, 2, 2), 9);
 }
 
 /**
  * Negative test : invokeWithArguments(Object... args) with wrong argument type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_invokeWithArguments_VarargsObj_SamePackage_Virtual_WrongArgCount() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findVirtual(SamePackageExample.class, ""addPublic"", MethodType.methodType(int.class,int.class,int.class));
 SamePackageExample g = new SamePackageExample();
 mh = mh.bindTo(g);
-boolean wmtThrown = false;
-
-try {
-AssertJUnit.assertEquals(6,(int)mh.invokeWithArguments(1,2,3));
-}
-catch(WrongMethodTypeException e) {
-wmtThrown = true;
-}
-
-AssertJUnit.assertTrue(wmtThrown);
+Assert.assertEquals((int)mh.invokeWithArguments(1,2,3), 6);",The assertEquals isn't required here.,
66049218,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -1273,35 +1125,27 @@ public void test_invokeWithArguments_VarargsObj_CrossPackage_Static() throws Thr
 l[0] = 1;
 l[1] = 2;
 
-AssertJUnit.assertEquals(3,(int)mh.invokeWithArguments(l));
+Assert.assertEquals((int)mh.invokeWithArguments(l), 3);
 }
 
 /**
  * invokeWithArguments(Object... args) test with Corner case of 0 length array
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_invokeWithArguments_VarargsObj_CrossPackage_Static_ZeroLengthArray() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(SamePackageExample.class, ""returnOne"", MethodType.methodType(String.class));
 
 Object [] l = new Object[0];
 
-AssertJUnit.assertEquals(""1"",(String)mh.invokeWithArguments(l));
+Assert.assertEquals((String)mh.invokeWithArguments(l), ""1"");
 
 MethodHandle mh2 = MethodHandles.lookup().findStatic(SamePackageExample.class, ""addPublicStatic"", MethodType.methodType(int.class,int.class,int.class));
 
 Object [] l2 = new Object[0];
 
-boolean wrongMethodTypeExceptionThrown = false;
-
-try {
-AssertJUnit.assertEquals(0,(int)mh2.invokeWithArguments(l2));
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+Assert.assertEquals((int)mh2.invokeWithArguments(l2), 0);",The assertEquals is unnecessary here.,
66049218,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -1518,116 +1338,76 @@ public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_RT_int_to_long() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
+Assert.assertTrue(mh.isVarargsCollector());
 
 mh = mh.asType(MethodType.methodType(long.class,int[].class));
 
-AssertJUnit.assertFalse(mh.isVarargsCollector());  
+Assert.assertFalse(mh.isVarargsCollector());  
 }
 
 /**
  * Ensure that an asVarargsCollector handle that has been asTyped() to a different type no longer remains asVarargsCollector type
  * Negative test : Change type of argument from int --> double : This is an invalid conversion
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_double() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
-
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asType(MethodType.methodType(int.class,double.class));
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
+Assert.assertTrue(mh.isVarargsCollector());
 
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asType(MethodType.methodType(int.class,double.class));
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the invalid type conversion from int to double"");
 }
 
     /**
      * Tests bindTo by binding non-null and null objects to a MethodHandle
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = NullPointerException.class, groups = { ""level.extended"" })
 public void testBindTo() throws Throwable {
         MethodHandle handle = SamePackageExample.getLookup().findSpecial(SamePackageExample.class, ""isReceiverNull"", MethodType.methodType(boolean.class), SamePackageExample.class);
         
-        AssertJUnit.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
-        
-        boolean npeThrownWhenNullIsPassedInBindTo = false;
+        Assert.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
         
-        try{
-        boolean b = (boolean)(handle.bindTo(null).invokeExact());
-        }
-        catch(NullPointerException e) {
-        npeThrownWhenNullIsPassedInBindTo = true;
-        }
-        AssertJUnit.assertTrue(npeThrownWhenNullIsPassedInBindTo);
+        boolean b = (boolean)(handle.bindTo(null).invokeExact());
+        Assert.fail(""The test case failed to throw an NullPointerException in the case of null objects"");
     }
     
     /**
      * Negative test for invoke
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = { NumberFormatException.class, WrongMethodTypeException.class }, groups = { ""level.extended"" })
 public void test_Invoke() throws Throwable {
     MethodHandle handle = MethodHandles.lookup().findStatic(Integer.class, ""parseInt"", MethodType.methodType(int.class,String.class));
-    boolean nfeHit = false;
-    boolean wmtHit = false;
     
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(""s""));
-    }
-    catch(NumberFormatException e) {
-    nfeHit = true;
-    }
+    Assert.assertEquals(handle.invoke(""s""), 5);
+    Assert.fail(""The test case failed to throw an NumberFormatException"");
     
-    AssertJUnit.assertTrue(nfeHit);
-    
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(5));
-    }
-    catch(WrongMethodTypeException e) {
-    wmtHit = true;
-    }
-    
-    AssertJUnit.assertTrue(wmtHit);
+    Assert.assertEquals(handle.invoke(5), 5);","This will need to be split into it's own test.  Otherwise, this will never be executed as the previous one will throw.",
66049218,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -1518,116 +1338,76 @@ public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_RT_int_to_long() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
+Assert.assertTrue(mh.isVarargsCollector());
 
 mh = mh.asType(MethodType.methodType(long.class,int[].class));
 
-AssertJUnit.assertFalse(mh.isVarargsCollector());  
+Assert.assertFalse(mh.isVarargsCollector());  
 }
 
 /**
  * Ensure that an asVarargsCollector handle that has been asTyped() to a different type no longer remains asVarargsCollector type
  * Negative test : Change type of argument from int --> double : This is an invalid conversion
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_double() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
-
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asType(MethodType.methodType(int.class,double.class));
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
+Assert.assertTrue(mh.isVarargsCollector());
 
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asType(MethodType.methodType(int.class,double.class));
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the invalid type conversion from int to double"");
 }
 
     /**
      * Tests bindTo by binding non-null and null objects to a MethodHandle
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = NullPointerException.class, groups = { ""level.extended"" })
 public void testBindTo() throws Throwable {
         MethodHandle handle = SamePackageExample.getLookup().findSpecial(SamePackageExample.class, ""isReceiverNull"", MethodType.methodType(boolean.class), SamePackageExample.class);
         
-        AssertJUnit.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
-        
-        boolean npeThrownWhenNullIsPassedInBindTo = false;
+        Assert.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
         
-        try{
-        boolean b = (boolean)(handle.bindTo(null).invokeExact());
-        }
-        catch(NullPointerException e) {
-        npeThrownWhenNullIsPassedInBindTo = true;
-        }
-        AssertJUnit.assertTrue(npeThrownWhenNullIsPassedInBindTo);
+        boolean b = (boolean)(handle.bindTo(null).invokeExact());
+        Assert.fail(""The test case failed to throw an NullPointerException in the case of null objects"");
     }
     
     /**
      * Negative test for invoke
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = { NumberFormatException.class, WrongMethodTypeException.class }, groups = { ""level.extended"" })
 public void test_Invoke() throws Throwable {
     MethodHandle handle = MethodHandles.lookup().findStatic(Integer.class, ""parseInt"", MethodType.methodType(int.class,String.class));
-    boolean nfeHit = false;
-    boolean wmtHit = false;
     
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(""s""));
-    }
-    catch(NumberFormatException e) {
-    nfeHit = true;
-    }
+    Assert.assertEquals(handle.invoke(""s""), 5);",`assertEquals` not required here/,
66049218,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -1518,116 +1338,76 @@ public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_RT_int_to_long() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
+Assert.assertTrue(mh.isVarargsCollector());
 
 mh = mh.asType(MethodType.methodType(long.class,int[].class));
 
-AssertJUnit.assertFalse(mh.isVarargsCollector());  
+Assert.assertFalse(mh.isVarargsCollector());  
 }
 
 /**
  * Ensure that an asVarargsCollector handle that has been asTyped() to a different type no longer remains asVarargsCollector type
  * Negative test : Change type of argument from int --> double : This is an invalid conversion
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_double() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
-
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asType(MethodType.methodType(int.class,double.class));
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
+Assert.assertTrue(mh.isVarargsCollector());
 
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asType(MethodType.methodType(int.class,double.class));
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the invalid type conversion from int to double"");
 }
 
     /**
      * Tests bindTo by binding non-null and null objects to a MethodHandle
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = NullPointerException.class, groups = { ""level.extended"" })
 public void testBindTo() throws Throwable {
         MethodHandle handle = SamePackageExample.getLookup().findSpecial(SamePackageExample.class, ""isReceiverNull"", MethodType.methodType(boolean.class), SamePackageExample.class);
         
-        AssertJUnit.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
-        
-        boolean npeThrownWhenNullIsPassedInBindTo = false;
+        Assert.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
         
-        try{
-        boolean b = (boolean)(handle.bindTo(null).invokeExact());
-        }
-        catch(NullPointerException e) {
-        npeThrownWhenNullIsPassedInBindTo = true;
-        }
-        AssertJUnit.assertTrue(npeThrownWhenNullIsPassedInBindTo);
+        boolean b = (boolean)(handle.bindTo(null).invokeExact());
+        Assert.fail(""The test case failed to throw an NullPointerException in the case of null objects"");
     }
     
     /**
      * Negative test for invoke
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = { NumberFormatException.class, WrongMethodTypeException.class }, groups = { ""level.extended"" })
 public void test_Invoke() throws Throwable {
     MethodHandle handle = MethodHandles.lookup().findStatic(Integer.class, ""parseInt"", MethodType.methodType(int.class,String.class));
-    boolean nfeHit = false;
-    boolean wmtHit = false;
     
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(""s""));
-    }
-    catch(NumberFormatException e) {
-    nfeHit = true;
-    }
+    Assert.assertEquals(handle.invoke(""s""), 5);
+    Assert.fail(""The test case failed to throw an NumberFormatException"");
     
-    AssertJUnit.assertTrue(nfeHit);
-    
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(5));
-    }
-    catch(WrongMethodTypeException e) {
-    wmtHit = true;
-    }
-    
-    AssertJUnit.assertTrue(wmtHit);
+    Assert.assertEquals(handle.invoke(5), 5);
+    Assert.fail(""The test case failed to throw an WrongMethodTypeException"");
+
     }
     
 /**
  * Negative test for invokeExcat
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = { WrongMethodTypeException.class, WrongMethodTypeException.class }, groups = { ""level.extended"" })
 public void test_InvokeExact() throws Throwable {
 MethodHandle mh  = MethodHandles.lookup().findVirtual(SamePackageExample.class,""arrayToString"",MethodType.methodType(String.class,Object[].class));
 SamePackageExample g = new SamePackageExample();
 mh = mh.bindTo(g);
-boolean wmtHit = false;
-try{
-AssertJUnit.assertEquals(""[a,b]"",(String)mh.invokeExact(""a"",""b""));
-}
-catch(WrongMethodTypeException e) {
-wmtHit = true;
-}
 
-AssertJUnit.assertTrue(wmtHit);
+Assert.assertEquals((String)mh.invokeExact(""a"",""b""), ""[a,b]"");
+Assert.fail(""The test case failed to throw an WrongMethodTypeException"");",Everything after this is dead code.  Can you split it into another test?,
66184162,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -565,75 +491,71 @@ public void test_asSpreader_CrossPackage_Virtual() throws Throwable{
 public void test_asSpreader_CrossPackage_Static() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
 mh = mh.asSpreader(int[].class, 2);
-AssertJUnit.assertEquals(MethodType.methodType(int.class,int[].class),mh.type());
-AssertJUnit.assertEquals(5,(int)mh.invokeExact(new int[] {3,2}));
+Assert.assertEquals(mh.type(), MethodType.methodType(int.class,int[].class));
+Assert.assertEquals((int)mh.invokeExact(new int[] {3,2}), 5);
 }
 
 /**
  * Negative test : asSpreader test using cross package virtual method with a wrong method type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Virtual_WrongType() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findVirtual(PackageExamples.class,""addPublic"",MethodType.methodType(int.class,int.class,int.class));
 PackageExamples g = new PackageExamples();
 mh = mh.bindTo(g);
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asSpreader(String[].class, 2);
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asSpreader(String[].class, 2);
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the wrong method type"");
 }
 
 /**
  * Negative test : asSpreader test using a cross-package static method and wrong method type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = IllegalArgumentException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Static_WrongType() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
 mh = mh.asSpreader(int[].class, 2);
-boolean illegalArgumentExceptionThrown = false; 
-
-try {
-mh = mh.asSpreader(String[].class, 2);
-}
-catch(IllegalArgumentException e) {
-illegalArgumentExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(illegalArgumentExceptionThrown);
+mh = mh.asSpreader(String[].class, 2);
+Assert.fail(""The test case failed to throw an IllegalArgumentException in the case of the wrong method type"");
 }
 
 /**
  * Negative test : asSpreader test using cross package static method and a wrong argument count
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = IllegalArgumentException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Static_WrongArgCount() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
-
-boolean illegalArgumentException = false; 
-
-try {
-mh = mh.asSpreader(int[].class, 3);
-}
-catch(IllegalArgumentException e) {
-illegalArgumentException = true;
-}
-
-AssertJUnit.assertTrue(illegalArgumentException);
+mh = mh.asSpreader(int[].class, 3);
+Assert.fail(""The test case failed to throw an IllegalArgumentException in the case of the wrong argument count"");
 }
 
 /******************************
  * Tests for MethodHandle arity
  * ****************************/
 /**
+ * Create MethodHandle with highest possible arity and use findConstructor (253)
+ * @throws Throwable
+ */
+@Test(groups = { ""level.extended"" })
+public void test_findConstructor_ArityLimit() throws Throwable {
+MethodHandle mh = null;",Not sure why the original test case was written in this way. Already fixed.,
66184602,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -1024,33 +902,25 @@ public void test_asFixedArity_SamePackage_Static() throws Throwable {
 mh = mh.asVarargsCollector(String[].class);
 MethodHandle mhFix = mh.asFixedArity();
 
-AssertJUnit.assertFalse(mhFix.isVarargsCollector());
-AssertJUnit.assertEquals(5,mhFix.invoke(new String[]{""a"",""b"",""c"",""d"",""e""}));
+Assert.assertFalse(mhFix.isVarargsCollector());
+Assert.assertEquals(mhFix.invoke(new String[]{""a"",""b"",""c"",""d"",""e""}), 5);
 }
 
 /**
  * Negative test : asFixedArity test using variable input
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_asFixedArity_SamePackage_Static_VarialbeInput() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(SamePackageExample.class, ""getLengthStatic"", MethodType.methodType(int.class,String[].class));
 mh = mh.asVarargsCollector(String[].class);
 
 MethodHandle mhFix = mh.asFixedArity();
 
-AssertJUnit.assertFalse(mhFix.isVarargsCollector());
-
-boolean wmtThrown = false;
-
-try {
-AssertJUnit.assertEquals(5,mhFix.invoke(""a"",""b"",""c"",""d"",""e""));
-}
-catch(WrongMethodTypeException e) {
-wmtThrown = true;
-}
+Assert.assertFalse(mhFix.isVarargsCollector());
 
-AssertJUnit.assertTrue(wmtThrown);
+Assert.assertEquals(mhFix.invoke(""a"",""b"",""c"",""d"",""e""), 5);",Agreed and fixed.,
66188072,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -1090,33 +960,26 @@ public void test_invokeWithArguments_List_SamePackage_Virtual() throws Throwable
 l.add(1);
 l.add(2);
 
-AssertJUnit.assertEquals(3,(int)mh.invokeWithArguments(l));
+Assert.assertEquals((int)mh.invokeWithArguments(l), 3);
 }
 
 /**
  * Negative test : invokeWithArgument(List<?>) test with mismatched number of argument passed in argument list
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_invokeWithArguments_List_SamePackage_Virtual_WrongArgCount() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findVirtual(SamePackageExample.class, ""addPublic"", MethodType.methodType(int.class,int.class,int.class));
 SamePackageExample g = new SamePackageExample();
 mh = mh.bindTo(g);
-boolean wmtThrown = false;
 
 List<Integer> l = new ArrayList<Integer>();
 l.add(1);
 l.add(2);
 l.add(3);
 
-try {
-AssertJUnit.assertEquals(6,(int)mh.invokeWithArguments(l));
-}
-catch(WrongMethodTypeException e) {
-wmtThrown = true;
-}
-
-AssertJUnit.assertTrue(wmtThrown);
+Assert.assertEquals((int)mh.invokeWithArguments(l), 6);",Fixed at multiple places.,
66188228,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -1163,23 +1026,20 @@ public void test_invokeWithArguments_List_CrossPackage_Static() throws Throwable
 l.add(1);
 l.add(2);
 
-AssertJUnit.assertEquals(3,(int)mh.invokeWithArguments(l));
+Assert.assertEquals((int)mh.invokeWithArguments(l), 3);
 }
 
 
 /****************************************
  * Tests for invokeWithArguments(Object...)
  * **************************************/
 
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_invokeWithArguments_WMT_NULL_args()  throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findVirtual(Object.class, ""toString"", MethodType.methodType(String.class));
-try {
-mh.invokeWithArguments(""receiver"", null, null);
-Assert.fail(""Should have thrown WMT"");
-} catch(WrongMethodTypeException e) {
-
-}
+mh.invokeWithArguments(""receiver"", null, null);
+Assert.fail(""Should have thrown WMT"");
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of null arguments"");",Updated.,
66188325,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -1203,30 +1063,22 @@ public void test_invokeWithArguments_VarargsObj_SamePackage_Virtual_VarargsMetho
 MethodHandle mh = MethodHandles.lookup().findVirtual(SamePackageExample.class, ""addPublicVariableArity"", MethodType.methodType(int.class,Object[].class));
 SamePackageExample g = new SamePackageExample();
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
+Assert.assertTrue(mh.isVarargsCollector());
 
-AssertJUnit.assertEquals(9,mh.invokeWithArguments(g, 1, 2, 2, 2, 2));
+Assert.assertEquals(mh.invokeWithArguments(g, 1, 2, 2, 2, 2), 9);
 }
 
 /**
  * Negative test : invokeWithArguments(Object... args) with wrong argument type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_invokeWithArguments_VarargsObj_SamePackage_Virtual_WrongArgCount() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findVirtual(SamePackageExample.class, ""addPublic"", MethodType.methodType(int.class,int.class,int.class));
 SamePackageExample g = new SamePackageExample();
 mh = mh.bindTo(g);
-boolean wmtThrown = false;
-
-try {
-AssertJUnit.assertEquals(6,(int)mh.invokeWithArguments(1,2,3));
-}
-catch(WrongMethodTypeException e) {
-wmtThrown = true;
-}
-
-AssertJUnit.assertTrue(wmtThrown);
+Assert.assertEquals((int)mh.invokeWithArguments(1,2,3), 6);",Fixed.,
66188405,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -1273,35 +1125,27 @@ public void test_invokeWithArguments_VarargsObj_CrossPackage_Static() throws Thr
 l[0] = 1;
 l[1] = 2;
 
-AssertJUnit.assertEquals(3,(int)mh.invokeWithArguments(l));
+Assert.assertEquals((int)mh.invokeWithArguments(l), 3);
 }
 
 /**
  * invokeWithArguments(Object... args) test with Corner case of 0 length array
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_invokeWithArguments_VarargsObj_CrossPackage_Static_ZeroLengthArray() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(SamePackageExample.class, ""returnOne"", MethodType.methodType(String.class));
 
 Object [] l = new Object[0];
 
-AssertJUnit.assertEquals(""1"",(String)mh.invokeWithArguments(l));
+Assert.assertEquals((String)mh.invokeWithArguments(l), ""1"");
 
 MethodHandle mh2 = MethodHandles.lookup().findStatic(SamePackageExample.class, ""addPublicStatic"", MethodType.methodType(int.class,int.class,int.class));
 
 Object [] l2 = new Object[0];
 
-boolean wrongMethodTypeExceptionThrown = false;
-
-try {
-AssertJUnit.assertEquals(0,(int)mh2.invokeWithArguments(l2));
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+Assert.assertEquals((int)mh2.invokeWithArguments(l2), 0);",Fixed.,
66188760,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -1518,116 +1338,76 @@ public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_RT_int_to_long() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
+Assert.assertTrue(mh.isVarargsCollector());
 
 mh = mh.asType(MethodType.methodType(long.class,int[].class));
 
-AssertJUnit.assertFalse(mh.isVarargsCollector());  
+Assert.assertFalse(mh.isVarargsCollector());  
 }
 
 /**
  * Ensure that an asVarargsCollector handle that has been asTyped() to a different type no longer remains asVarargsCollector type
  * Negative test : Change type of argument from int --> double : This is an invalid conversion
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_double() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
-
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asType(MethodType.methodType(int.class,double.class));
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
+Assert.assertTrue(mh.isVarargsCollector());
 
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asType(MethodType.methodType(int.class,double.class));
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the invalid type conversion from int to double"");
 }
 
     /**
      * Tests bindTo by binding non-null and null objects to a MethodHandle
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = NullPointerException.class, groups = { ""level.extended"" })
 public void testBindTo() throws Throwable {
         MethodHandle handle = SamePackageExample.getLookup().findSpecial(SamePackageExample.class, ""isReceiverNull"", MethodType.methodType(boolean.class), SamePackageExample.class);
         
-        AssertJUnit.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
-        
-        boolean npeThrownWhenNullIsPassedInBindTo = false;
+        Assert.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
         
-        try{
-        boolean b = (boolean)(handle.bindTo(null).invokeExact());
-        }
-        catch(NullPointerException e) {
-        npeThrownWhenNullIsPassedInBindTo = true;
-        }
-        AssertJUnit.assertTrue(npeThrownWhenNullIsPassedInBindTo);
+        boolean b = (boolean)(handle.bindTo(null).invokeExact());
+        Assert.fail(""The test case failed to throw an NullPointerException in the case of null objects"");
     }
     
     /**
      * Negative test for invoke
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = { NumberFormatException.class, WrongMethodTypeException.class }, groups = { ""level.extended"" })
 public void test_Invoke() throws Throwable {
     MethodHandle handle = MethodHandles.lookup().findStatic(Integer.class, ""parseInt"", MethodType.methodType(int.class,String.class));
-    boolean nfeHit = false;
-    boolean wmtHit = false;
     
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(""s""));
-    }
-    catch(NumberFormatException e) {
-    nfeHit = true;
-    }
+    Assert.assertEquals(handle.invoke(""s""), 5);",Fixed.,
66199541,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -1518,116 +1338,76 @@ public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_RT_int_to_long() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
+Assert.assertTrue(mh.isVarargsCollector());
 
 mh = mh.asType(MethodType.methodType(long.class,int[].class));
 
-AssertJUnit.assertFalse(mh.isVarargsCollector());  
+Assert.assertFalse(mh.isVarargsCollector());  
 }
 
 /**
  * Ensure that an asVarargsCollector handle that has been asTyped() to a different type no longer remains asVarargsCollector type
  * Negative test : Change type of argument from int --> double : This is an invalid conversion
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_double() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
-
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asType(MethodType.methodType(int.class,double.class));
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
+Assert.assertTrue(mh.isVarargsCollector());
 
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asType(MethodType.methodType(int.class,double.class));
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the invalid type conversion from int to double"");
 }
 
     /**
      * Tests bindTo by binding non-null and null objects to a MethodHandle
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = NullPointerException.class, groups = { ""level.extended"" })
 public void testBindTo() throws Throwable {
         MethodHandle handle = SamePackageExample.getLookup().findSpecial(SamePackageExample.class, ""isReceiverNull"", MethodType.methodType(boolean.class), SamePackageExample.class);
         
-        AssertJUnit.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
-        
-        boolean npeThrownWhenNullIsPassedInBindTo = false;
+        Assert.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
         
-        try{
-        boolean b = (boolean)(handle.bindTo(null).invokeExact());
-        }
-        catch(NullPointerException e) {
-        npeThrownWhenNullIsPassedInBindTo = true;
-        }
-        AssertJUnit.assertTrue(npeThrownWhenNullIsPassedInBindTo);
+        boolean b = (boolean)(handle.bindTo(null).invokeExact());
+        Assert.fail(""The test case failed to throw an NullPointerException in the case of null objects"");
     }
     
     /**
      * Negative test for invoke
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = { NumberFormatException.class, WrongMethodTypeException.class }, groups = { ""level.extended"" })
 public void test_Invoke() throws Throwable {
     MethodHandle handle = MethodHandles.lookup().findStatic(Integer.class, ""parseInt"", MethodType.methodType(int.class,String.class));
-    boolean nfeHit = false;
-    boolean wmtHit = false;
     
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(""s""));
-    }
-    catch(NumberFormatException e) {
-    nfeHit = true;
-    }
+    Assert.assertEquals(handle.invoke(""s""), 5);
+    Assert.fail(""The test case failed to throw an NumberFormatException"");
     
-    AssertJUnit.assertTrue(nfeHit);
-    
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(5));
-    }
-    catch(WrongMethodTypeException e) {
-    wmtHit = true;
-    }
-    
-    AssertJUnit.assertTrue(wmtHit);
+    Assert.assertEquals(handle.invoke(5), 5);",Already split.,
66199574,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -1518,116 +1338,76 @@ public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_RT_int_to_long() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
+Assert.assertTrue(mh.isVarargsCollector());
 
 mh = mh.asType(MethodType.methodType(long.class,int[].class));
 
-AssertJUnit.assertFalse(mh.isVarargsCollector());  
+Assert.assertFalse(mh.isVarargsCollector());  
 }
 
 /**
  * Ensure that an asVarargsCollector handle that has been asTyped() to a different type no longer remains asVarargsCollector type
  * Negative test : Change type of argument from int --> double : This is an invalid conversion
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_isVarargsCollector_Using_asVarargsCollector_asTyped_arg_int_to_double() throws Throwable {
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStaticVariableArity"",MethodType.methodType(int.class, int[].class));
 
-AssertJUnit.assertTrue(mh.isVarargsCollector());
-
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asType(MethodType.methodType(int.class,double.class));
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
+Assert.assertTrue(mh.isVarargsCollector());
 
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asType(MethodType.methodType(int.class,double.class));
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the invalid type conversion from int to double"");
 }
 
     /**
      * Tests bindTo by binding non-null and null objects to a MethodHandle
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = NullPointerException.class, groups = { ""level.extended"" })
 public void testBindTo() throws Throwable {
         MethodHandle handle = SamePackageExample.getLookup().findSpecial(SamePackageExample.class, ""isReceiverNull"", MethodType.methodType(boolean.class), SamePackageExample.class);
         
-        AssertJUnit.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
-        
-        boolean npeThrownWhenNullIsPassedInBindTo = false;
+        Assert.assertFalse((boolean)handle.bindTo(new SamePackageExample()).invokeExact());
         
-        try{
-        boolean b = (boolean)(handle.bindTo(null).invokeExact());
-        }
-        catch(NullPointerException e) {
-        npeThrownWhenNullIsPassedInBindTo = true;
-        }
-        AssertJUnit.assertTrue(npeThrownWhenNullIsPassedInBindTo);
+        boolean b = (boolean)(handle.bindTo(null).invokeExact());
+        Assert.fail(""The test case failed to throw an NullPointerException in the case of null objects"");
     }
     
     /**
      * Negative test for invoke
      * @throws Throwable
      */
-    @Test(groups = { ""level.extended"" })
+    @Test(expectedExceptions = { NumberFormatException.class, WrongMethodTypeException.class }, groups = { ""level.extended"" })
 public void test_Invoke() throws Throwable {
     MethodHandle handle = MethodHandles.lookup().findStatic(Integer.class, ""parseInt"", MethodType.methodType(int.class,String.class));
-    boolean nfeHit = false;
-    boolean wmtHit = false;
     
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(""s""));
-    }
-    catch(NumberFormatException e) {
-    nfeHit = true;
-    }
+    Assert.assertEquals(handle.invoke(""s""), 5);
+    Assert.fail(""The test case failed to throw an NumberFormatException"");
     
-    AssertJUnit.assertTrue(nfeHit);
-    
-    try {
-    AssertJUnit.assertEquals(5,handle.invoke(5));
-    }
-    catch(WrongMethodTypeException e) {
-    wmtHit = true;
-    }
-    
-    AssertJUnit.assertTrue(wmtHit);
+    Assert.assertEquals(handle.invoke(5), 5);
+    Assert.fail(""The test case failed to throw an WrongMethodTypeException"");
+
     }
     
 /**
  * Negative test for invokeExcat
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = { WrongMethodTypeException.class, WrongMethodTypeException.class }, groups = { ""level.extended"" })
 public void test_InvokeExact() throws Throwable {
 MethodHandle mh  = MethodHandles.lookup().findVirtual(SamePackageExample.class,""arrayToString"",MethodType.methodType(String.class,Object[].class));
 SamePackageExample g = new SamePackageExample();
 mh = mh.bindTo(g);
-boolean wmtHit = false;
-try{
-AssertJUnit.assertEquals(""[a,b]"",(String)mh.invokeExact(""a"",""b""));
-}
-catch(WrongMethodTypeException e) {
-wmtHit = true;
-}
 
-AssertJUnit.assertTrue(wmtHit);
+Assert.assertEquals((String)mh.invokeExact(""a"",""b""), ""[a,b]"");
+Assert.fail(""The test case failed to throw an WrongMethodTypeException"");",Already split.,
66222236,ca07097185747535aa4771d4ef7225f52be4486c,CONTRIBUTING.md,False,"@@ -90,7 +90,7 @@ Correct race in frobnicator
 
 This patch eliminates the race condition in issue #1234.
 
-Issue: #1234
+Fixes: #1234",@pshipton unfortunately I don't think this will work. https://help.github.com/articles/closing-issues-using-keywords/ states that the keyword must be followed by the issue number. The colon here will mess this up and GitHub won't recognize it.,
66051354,cb8ac5c78b35d9b7b2680546b01c7664dc4a7c9b,buildenv/jenkins/README.md,False,"@@ -0,0 +1,194 @@
+[Eclipse OpenJ9 Jenkins Builds](https://ci.eclipse.org/openj9/)
+
+This folder contains Jenkins pipeline scripts that are used in the OpenJ9 Jenkins builds.
+
+### Triggering Pull Request Builds from Github
+
+- Current supported PR builds are ""Compile"", ""Compile & Sanity"", or ""Compile & Extended""
+- Current available platforms are Linux s390x and Linux PPCLE
+- OpenJ9 committers can request builds by commenting in a pull request
+- Request a build in a PR by commenting
+    - `Jenkins compile`
+    - `Jenkins test sanity`
+    - `Jenkins test extended`
+- Request a single platform instead of ""all""
+    - `Jenkins test sanity zlinux`
+    - `Jenkins test sanity plinux`
+- You can also request a ""Compile & Sanity"" build from an openj9-openjdk-jdk9 PR or an openj9-omr PR.
+
+##### Dependent Changes
+
+- If you have dependent change(s) in either eclipse/omr, eclipse/openj9-omr, or ibmruntimes/openj9-openjdk-jdk9, you can build & test with all needed changes
+- Request a build by including the PR ref in your trigger comment
+- Ex. Dependent change in OMR Pull Request `#123`
+    - `Jenkins test sanity depends eclipse/omr#123`
+- Ex. Dependent change in OpenJ9-OMR Pull Request `#456`
+    - `Jenkins test sanity depends eclipse/openj9-omr#456`
+- Ex. Dependent change in OpenJDK Pull Request `#789`
+    - `Jenkins test sanity depends ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. Dependent changes in OMR and OpenJDK
+    - `Jenkins test sanity depends eclipse/omr#123 ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. If you have a dependent change and only want one platform, depends comes last
+    - `Jenkins test sanity zlinux depends eclipse/omr#123`
+
+**Note:** Dependent changes can only be requested from an OpenJ9 Pull Request
+
+### Overview of Builds
+
+#### Build
+
+- Build-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Build-linux_390-64_cmprssptrs)
+    - Description:
+        - Compiles on linux_390-64_cmprssptrs
+        - Archives the SDK and test material
+    - Trigger:
+        - This job is used in other pipelines but can be launched manually
+
+- Build-linux_ppc-64_cmprssptrs_le
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_ppc-64_cmprssptrs_le)](https://ci.eclipse.org/openj9/job/Build-linux_ppc-64_cmprssptrs_le)
+    - Description
+        - Compiles on linux_ppc-64_cmprssptrs_le
+        - Archives the SDK and test material
+    - Trigger:
+        - This job is used in other pipelines but can be launched manually
+
+#### Infrastructure
+
+- Mirror-OMR-to-OpenJ9-OMR
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Mirror-OMR-to-OpenJ9-OMR)](https://ci.eclipse.org/openj9/job/Mirror-OMR-to-OpenJ9-OMR)
+    - Description:
+        - Mirrors eclipse/omr/master to eclipse/openj9-omr/master
+        - Triggers `Pipeline-OMR-Acceptance` when there is new content        
+    - Trigger:
+        - Build periodically, 15 minutes
+
+- Mirror-OpenJ9-Website-to-Eclipse
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Mirror-OpenJ9-Website-to-Eclipse)](https://ci.eclipse.org/openj9/job/Mirror-OpenJ9-Website-to-Eclipse)
+    - Description:
+        - Mirrors github.com/eclipse/openj9-website to the Eclipse.org repo
+    - Trigger:
+        - Poll Github repo for changes
+
+- Promote-OpenJ9-OMR-master-to-openj9
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Promote-OpenJ9-OMR-master-to-openj9)](https://ci.eclipse.org/openj9/job/Promote-OpenJ9-OMR-master-to-openj9)
+    - Description:
+        - Promotes eclipse/openj9-omr branch master to branch openj9
+    - Trigger:
+        - Last step of `Pipeline-OMR-Acceptance`
+ 
+#### Pipleines",typo,
66051521,cb8ac5c78b35d9b7b2680546b01c7664dc4a7c9b,buildenv/jenkins/README.md,False,"@@ -0,0 +1,194 @@
+[Eclipse OpenJ9 Jenkins Builds](https://ci.eclipse.org/openj9/)
+
+This folder contains Jenkins pipeline scripts that are used in the OpenJ9 Jenkins builds.
+
+### Triggering Pull Request Builds from Github
+
+- Current supported PR builds are ""Compile"", ""Compile & Sanity"", or ""Compile & Extended""
+- Current available platforms are Linux s390x and Linux PPCLE
+- OpenJ9 committers can request builds by commenting in a pull request
+- Request a build in a PR by commenting
+    - `Jenkins compile`
+    - `Jenkins test sanity`
+    - `Jenkins test extended`
+- Request a single platform instead of ""all""
+    - `Jenkins test sanity zlinux`
+    - `Jenkins test sanity plinux`
+- You can also request a ""Compile & Sanity"" build from an openj9-openjdk-jdk9 PR or an openj9-omr PR.
+
+##### Dependent Changes
+
+- If you have dependent change(s) in either eclipse/omr, eclipse/openj9-omr, or ibmruntimes/openj9-openjdk-jdk9, you can build & test with all needed changes
+- Request a build by including the PR ref in your trigger comment
+- Ex. Dependent change in OMR Pull Request `#123`
+    - `Jenkins test sanity depends eclipse/omr#123`
+- Ex. Dependent change in OpenJ9-OMR Pull Request `#456`
+    - `Jenkins test sanity depends eclipse/openj9-omr#456`
+- Ex. Dependent change in OpenJDK Pull Request `#789`
+    - `Jenkins test sanity depends ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. Dependent changes in OMR and OpenJDK
+    - `Jenkins test sanity depends eclipse/omr#123 ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. If you have a dependent change and only want one platform, depends comes last
+    - `Jenkins test sanity zlinux depends eclipse/omr#123`
+
+**Note:** Dependent changes can only be requested from an OpenJ9 Pull Request
+
+### Overview of Builds
+
+#### Build
+
+- Build-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Build-linux_390-64_cmprssptrs)
+    - Description:
+        - Compiles on linux_390-64_cmprssptrs
+        - Archives the SDK and test material
+    - Trigger:
+        - This job is used in other pipelines but can be launched manually
+
+- Build-linux_ppc-64_cmprssptrs_le
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_ppc-64_cmprssptrs_le)](https://ci.eclipse.org/openj9/job/Build-linux_ppc-64_cmprssptrs_le)
+    - Description
+        - Compiles on linux_ppc-64_cmprssptrs_le
+        - Archives the SDK and test material
+    - Trigger:
+        - This job is used in other pipelines but can be launched manually
+
+#### Infrastructure
+
+- Mirror-OMR-to-OpenJ9-OMR
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Mirror-OMR-to-OpenJ9-OMR)](https://ci.eclipse.org/openj9/job/Mirror-OMR-to-OpenJ9-OMR)
+    - Description:
+        - Mirrors eclipse/omr/master to eclipse/openj9-omr/master
+        - Triggers `Pipeline-OMR-Acceptance` when there is new content        
+    - Trigger:
+        - Build periodically, 15 minutes
+
+- Mirror-OpenJ9-Website-to-Eclipse
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Mirror-OpenJ9-Website-to-Eclipse)](https://ci.eclipse.org/openj9/job/Mirror-OpenJ9-Website-to-Eclipse)
+    - Description:
+        - Mirrors github.com/eclipse/openj9-website to the Eclipse.org repo
+    - Trigger:
+        - Poll Github repo for changes
+
+- Promote-OpenJ9-OMR-master-to-openj9
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Promote-OpenJ9-OMR-master-to-openj9)](https://ci.eclipse.org/openj9/job/Promote-OpenJ9-OMR-master-to-openj9)
+    - Description:
+        - Promotes eclipse/openj9-omr branch master to branch openj9
+    - Trigger:
+        - Last step of `Pipeline-OMR-Acceptance`
+ 
+#### Pipleines
+
+- Pipeline-Build-Test-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Pipeline-Build-Test-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Pipeline-Build-Test-linux_390-64_cmprssptrs)
+    - Description:
+        - Compile and Test Sanity & Extended
+        - Triggers
+            - `Build-linux_390-64_cmprssptrs`
+            - `Test-Sanity-linux_390-64_cmprssptrs`
+            - `Test-Extended-linux_390-64_cmprssptrs`
+
+    - Trigger:
+        - build periodically, @midnight
+
+- Pipeline-Build-Test-linux_ppc-64_cmprssptrs_le
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Pipeline-Build-Test-linux_ppc-64_cmprssptrs_le)](https://ci.eclipse.org/openj9/job/Pipeline-Build-Test-linux_ppc-64_cmprssptrs_le)
+    - Description:
+        - Compile and Test Sanity & Extended
+        - Triggers
+            - `Build-linux_ppc-64_cmprssptrs_le`
+            - `Test-Sanity-linux_ppc-64_cmprssptrs_le`
+            - `Test-Extended-linux_ppc-64_cmprssptrs_le`
+    - Trigger:
+        - build periodically, @midnight
+        
+- Pipeline-OMR-Acceptance
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Pipeline-OMR-Acceptance)](https://ci.eclipse.org/openj9/job/Pipeline-OMR-Acceptance)
+    - Description:
+        - Compile and Test Sanity against new OMR content
+        - Triggers
+            - `Build-linux_390-64_cmprssptrs`
+            - `Build-linux_ppc-64_cmprssptrs_le`
+            - `Test-Sanity-linux_390-64_cmprssptrs`
+            - `Test-Sanity-linux_ppc-64_cmprssptrs_le`
+            - `Promote-OpenJ9-OMR-master-to-openj9`
+    - Trigger: Triggered by `Mirror-OMR-to-OpenJ9-OMR`
+
+#### Pull Requests
+
+- PullRequest-Compile-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=PullRequest-Compile-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/PullRequest-Compile-linux_390-64_cmprssptrs)
+    - Description:
+        - Compile on linux_390-64_cmprssptrs
+    - Trigger:
+        - Github PR comment `Jenkins compile`    
+
+- PullRequest-Compile-linux_ppc-64_cmprssptrs_le
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=PullRequest-Compile-linux_ppc-64_cmprssptrs_le)](https://ci.eclipse.org/openj9/job/PullRequest-Compile-linux_ppc-64_cmprssptrs_le)
+    - Description:
+        - Compile on linux_ppc-64_cmprssptrs_le
+    - Trigger:
+        - Github PR comment `Jenkins compile`
+
+- PullRequest-Extended-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=PullRequest-Extended-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/PullRequest-Extended-linux_390-64_cmprssptrs)
+    - Description:
+        - Compile and Extended tests on linux_390-64_cmprssptrs
+    - Trigger:
+        - Github PR comment `Jenkins test extended`    
+
+- PullRequest-Extended-linux_ppc-64_cmprssptrs_le
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=PullRequest-Extended-linux_ppc-64_cmprssptrs_le)](https://ci.eclipse.org/openj9/job/PullRequest-Extended-linux_ppc-64_cmprssptrs_le)
+    - Description:
+        - Compile and Extended tests on linux_ppc-64_cmprssptrs_le
+    - Trigger:
+        - Github PR comment `Jenkins test extended`
+
+- PullRequest-Sanity-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=PullRequest-Sanity-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/PullRequest-Sanity-linux_390-64_cmprssptrs)
+    - Description:
+        - Compile and Sanity tests on linux_390-64_cmprssptrs
+    - Trigger:
+        - Github PR comment `Jenkins test sanity`    
+
+- PullRequest-Sanity-linux_ppc-64_cmprssptrs_le
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=PullRequest-Sanity-linux_ppc-64_cmprssptrs_le)](https://ci.eclipse.org/openj9/job/PullRequest-Sanity-linux_ppc-64_cmprssptrs_le)
+    - Description:
+        - Compile and Sanity tests on linux_ppc-64_cmprssptrs_le
+    - Trigger:
+        - Github PR comment `Jenkins test sanity`
+
+#### Test
+
+- Test-Extended-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Test-Extended-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Test-Extended-linux_390-64_cmprssptrs)
+    - Descirption:",typo,
66051792,cb8ac5c78b35d9b7b2680546b01c7664dc4a7c9b,buildenv/jenkins/README.md,False,"@@ -0,0 +1,194 @@
+[Eclipse OpenJ9 Jenkins Builds](https://ci.eclipse.org/openj9/)
+
+This folder contains Jenkins pipeline scripts that are used in the OpenJ9 Jenkins builds.
+
+### Triggering Pull Request Builds from Github
+
+- Current supported PR builds are ""Compile"", ""Compile & Sanity"", or ""Compile & Extended""
+- Current available platforms are Linux s390x and Linux PPCLE
+- OpenJ9 committers can request builds by commenting in a pull request
+- Request a build in a PR by commenting
+    - `Jenkins compile`
+    - `Jenkins test sanity`
+    - `Jenkins test extended`
+- Request a single platform instead of ""all""
+    - `Jenkins test sanity zlinux`
+    - `Jenkins test sanity plinux`
+- You can also request a ""Compile & Sanity"" build from an openj9-openjdk-jdk9 PR or an openj9-omr PR.
+
+##### Dependent Changes
+
+- If you have dependent change(s) in either eclipse/omr, eclipse/openj9-omr, or ibmruntimes/openj9-openjdk-jdk9, you can build & test with all needed changes
+- Request a build by including the PR ref in your trigger comment
+- Ex. Dependent change in OMR Pull Request `#123`
+    - `Jenkins test sanity depends eclipse/omr#123`
+- Ex. Dependent change in OpenJ9-OMR Pull Request `#456`
+    - `Jenkins test sanity depends eclipse/openj9-omr#456`
+- Ex. Dependent change in OpenJDK Pull Request `#789`
+    - `Jenkins test sanity depends ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. Dependent changes in OMR and OpenJDK
+    - `Jenkins test sanity depends eclipse/omr#123 ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. If you have a dependent change and only want one platform, depends comes last
+    - `Jenkins test sanity zlinux depends eclipse/omr#123`
+
+**Note:** Dependent changes can only be requested from an OpenJ9 Pull Request
+
+### Overview of Builds
+
+#### Build
+
+- Build-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Build-linux_390-64_cmprssptrs)
+    - Description:
+        - Compiles on linux_390-64_cmprssptrs
+        - Archives the SDK and test material","If this is only a build job, probably no test material archived.",
66134224,cb8ac5c78b35d9b7b2680546b01c7664dc4a7c9b,buildenv/jenkins/README.md,True,"@@ -0,0 +1,194 @@
+[Eclipse OpenJ9 Jenkins Builds](https://ci.eclipse.org/openj9/)
+
+This folder contains Jenkins pipeline scripts that are used in the OpenJ9 Jenkins builds.
+
+### Triggering Pull Request Builds from Github
+
+- Current supported PR builds are ""Compile"", ""Compile & Sanity"", or ""Compile & Extended""
+- Current available platforms are Linux s390x and Linux PPCLE
+- OpenJ9 committers can request builds by commenting in a pull request
+- Request a build in a PR by commenting
+    - `Jenkins compile`
+    - `Jenkins test sanity`
+    - `Jenkins test extended`
+- Request a single platform instead of ""all""
+    - `Jenkins test sanity zlinux`
+    - `Jenkins test sanity plinux`
+- You can also request a ""Compile & Sanity"" build from an openj9-openjdk-jdk9 PR or an openj9-omr PR.
+
+##### Dependent Changes
+
+- If you have dependent change(s) in either eclipse/omr, eclipse/openj9-omr, or ibmruntimes/openj9-openjdk-jdk9, you can build & test with all needed changes
+- Request a build by including the PR ref in your trigger comment
+- Ex. Dependent change in OMR Pull Request `#123`
+    - `Jenkins test sanity depends eclipse/omr#123`
+- Ex. Dependent change in OpenJ9-OMR Pull Request `#456`
+    - `Jenkins test sanity depends eclipse/openj9-omr#456`
+- Ex. Dependent change in OpenJDK Pull Request `#789`
+    - `Jenkins test sanity depends ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. Dependent changes in OMR and OpenJDK
+    - `Jenkins test sanity depends eclipse/omr#123 ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. If you have a dependent change and only want one platform, depends comes last
+    - `Jenkins test sanity zlinux depends eclipse/omr#123`
+
+**Note:** Dependent changes can only be requested from an OpenJ9 Pull Request
+
+### Overview of Builds
+
+#### Build
+
+- Build-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Build-linux_390-64_cmprssptrs)
+    - Description:
+        - Compiles on linux_390-64_cmprssptrs
+        - Archives the SDK and test material","The purpose here for archiving the test source is to pass both the sdk and test material to the Test Jobs. That way we don't need to reclone it in the test job and we ensure we get the same source version as the build. We could not archive it and pass a SHA, but as I said, we would have to clone again. Not sure if one method is better than the other though.",
66184934,cb8ac5c78b35d9b7b2680546b01c7664dc4a7c9b,buildenv/jenkins/README.md,False,"@@ -0,0 +1,194 @@
+[Eclipse OpenJ9 Jenkins Builds](https://ci.eclipse.org/openj9/)
+
+This folder contains Jenkins pipeline scripts that are used in the OpenJ9 Jenkins builds.
+
+### Triggering Pull Request Builds from Github
+
+- Current supported PR builds are ""Compile"", ""Compile & Sanity"", or ""Compile & Extended""
+- Current available platforms are Linux s390x and Linux PPCLE
+- OpenJ9 committers can request builds by commenting in a pull request
+- Request a build in a PR by commenting
+    - `Jenkins compile`
+    - `Jenkins test sanity`
+    - `Jenkins test extended`
+- Request a single platform instead of ""all""
+    - `Jenkins test sanity zlinux`
+    - `Jenkins test sanity plinux`
+- You can also request a ""Compile & Sanity"" build from an openj9-openjdk-jdk9 PR or an openj9-omr PR.",Can make the extensions repo and openj9-omr repo mentions into links?,
66184934,cb8ac5c78b35d9b7b2680546b01c7664dc4a7c9b,buildenv/jenkins/README.md,False,"@@ -0,0 +1,194 @@
+[Eclipse OpenJ9 Jenkins Builds](https://ci.eclipse.org/openj9/)
+
+This folder contains Jenkins pipeline scripts that are used in the OpenJ9 Jenkins builds.
+
+### Triggering Pull Request Builds from Github
+
+- Current supported PR builds are ""Compile"", ""Compile & Sanity"", or ""Compile & Extended""
+- Current available platforms are Linux s390x and Linux PPCLE
+- OpenJ9 committers can request builds by commenting in a pull request
+- Request a build in a PR by commenting
+    - `Jenkins compile`
+    - `Jenkins test sanity`
+    - `Jenkins test extended`
+- Request a single platform instead of ""all""
+    - `Jenkins test sanity zlinux`
+    - `Jenkins test sanity plinux`
+- You can also request a ""Compile & Sanity"" build from an openj9-openjdk-jdk9 PR or an openj9-omr PR.
+
+##### Dependent Changes
+
+- If you have dependent change(s) in either eclipse/omr, eclipse/openj9-omr, or ibmruntimes/openj9-openjdk-jdk9, you can build & test with all needed changes
+- Request a build by including the PR ref in your trigger comment
+- Ex. Dependent change in OMR Pull Request `#123`
+    - `Jenkins test sanity depends eclipse/omr#123`
+- Ex. Dependent change in OpenJ9-OMR Pull Request `#456`
+    - `Jenkins test sanity depends eclipse/openj9-omr#456`
+- Ex. Dependent change in OpenJDK Pull Request `#789`
+    - `Jenkins test sanity depends ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. Dependent changes in OMR and OpenJDK
+    - `Jenkins test sanity depends eclipse/omr#123 ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. If you have a dependent change and only want one platform, depends comes last
+    - `Jenkins test sanity zlinux depends eclipse/omr#123`
+
+**Note:** Dependent changes can only be requested from an OpenJ9 Pull Request
+
+### Overview of Builds
+
+#### Build
+
+- Build-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Build-linux_390-64_cmprssptrs)
+    - Description:
+        - Compiles on linux_390-64_cmprssptrs
+        - Archives the SDK and test material","Can you change the wording then to something like ""Archives the SDK and test material for later pipeline stages""?",
66184934,cb8ac5c78b35d9b7b2680546b01c7664dc4a7c9b,buildenv/jenkins/README.md,False,"@@ -0,0 +1,194 @@
+[Eclipse OpenJ9 Jenkins Builds](https://ci.eclipse.org/openj9/)
+
+This folder contains Jenkins pipeline scripts that are used in the OpenJ9 Jenkins builds.
+
+### Triggering Pull Request Builds from Github
+
+- Current supported PR builds are ""Compile"", ""Compile & Sanity"", or ""Compile & Extended""
+- Current available platforms are Linux s390x and Linux PPCLE
+- OpenJ9 committers can request builds by commenting in a pull request
+- Request a build in a PR by commenting
+    - `Jenkins compile`
+    - `Jenkins test sanity`
+    - `Jenkins test extended`
+- Request a single platform instead of ""all""
+    - `Jenkins test sanity zlinux`
+    - `Jenkins test sanity plinux`
+- You can also request a ""Compile & Sanity"" build from an openj9-openjdk-jdk9 PR or an openj9-omr PR.
+
+##### Dependent Changes
+
+- If you have dependent change(s) in either eclipse/omr, eclipse/openj9-omr, or ibmruntimes/openj9-openjdk-jdk9, you can build & test with all needed changes
+- Request a build by including the PR ref in your trigger comment
+- Ex. Dependent change in OMR Pull Request `#123`
+    - `Jenkins test sanity depends eclipse/omr#123`
+- Ex. Dependent change in OpenJ9-OMR Pull Request `#456`
+    - `Jenkins test sanity depends eclipse/openj9-omr#456`
+- Ex. Dependent change in OpenJDK Pull Request `#789`
+    - `Jenkins test sanity depends ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. Dependent changes in OMR and OpenJDK
+    - `Jenkins test sanity depends eclipse/omr#123 ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. If you have a dependent change and only want one platform, depends comes last
+    - `Jenkins test sanity zlinux depends eclipse/omr#123`
+
+**Note:** Dependent changes can only be requested from an OpenJ9 Pull Request
+
+### Overview of Builds
+
+#### Build
+
+- Build-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Build-linux_390-64_cmprssptrs)
+    - Description:
+        - Compiles on linux_390-64_cmprssptrs
+        - Archives the SDK and test material
+    - Trigger:
+        - This job is used in other pipelines but can be launched manually
+
+- Build-linux_ppc-64_cmprssptrs_le
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_ppc-64_cmprssptrs_le)](https://ci.eclipse.org/openj9/job/Build-linux_ppc-64_cmprssptrs_le)
+    - Description
+        - Compiles on linux_ppc-64_cmprssptrs_le
+        - Archives the SDK and test material
+    - Trigger:
+        - This job is used in other pipelines but can be launched manually
+
+#### Infrastructure
+
+- Mirror-OMR-to-OpenJ9-OMR
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Mirror-OMR-to-OpenJ9-OMR)](https://ci.eclipse.org/openj9/job/Mirror-OMR-to-OpenJ9-OMR)
+    - Description:
+        - Mirrors eclipse/omr/master to eclipse/openj9-omr/master",links would be great for the repos here.,
66184934,cb8ac5c78b35d9b7b2680546b01c7664dc4a7c9b,buildenv/jenkins/README.md,False,"@@ -0,0 +1,194 @@
+[Eclipse OpenJ9 Jenkins Builds](https://ci.eclipse.org/openj9/)
+
+This folder contains Jenkins pipeline scripts that are used in the OpenJ9 Jenkins builds.
+
+### Triggering Pull Request Builds from Github
+
+- Current supported PR builds are ""Compile"", ""Compile & Sanity"", or ""Compile & Extended""
+- Current available platforms are Linux s390x and Linux PPCLE
+- OpenJ9 committers can request builds by commenting in a pull request
+- Request a build in a PR by commenting
+    - `Jenkins compile`
+    - `Jenkins test sanity`
+    - `Jenkins test extended`
+- Request a single platform instead of ""all""
+    - `Jenkins test sanity zlinux`
+    - `Jenkins test sanity plinux`
+- You can also request a ""Compile & Sanity"" build from an openj9-openjdk-jdk9 PR or an openj9-omr PR.
+
+##### Dependent Changes
+
+- If you have dependent change(s) in either eclipse/omr, eclipse/openj9-omr, or ibmruntimes/openj9-openjdk-jdk9, you can build & test with all needed changes
+- Request a build by including the PR ref in your trigger comment
+- Ex. Dependent change in OMR Pull Request `#123`
+    - `Jenkins test sanity depends eclipse/omr#123`
+- Ex. Dependent change in OpenJ9-OMR Pull Request `#456`
+    - `Jenkins test sanity depends eclipse/openj9-omr#456`
+- Ex. Dependent change in OpenJDK Pull Request `#789`
+    - `Jenkins test sanity depends ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. Dependent changes in OMR and OpenJDK
+    - `Jenkins test sanity depends eclipse/omr#123 ibmruntimes/openj9-openjdk-jdk9#789`
+- Ex. If you have a dependent change and only want one platform, depends comes last
+    - `Jenkins test sanity zlinux depends eclipse/omr#123`
+
+**Note:** Dependent changes can only be requested from an OpenJ9 Pull Request
+
+### Overview of Builds
+
+#### Build
+
+- Build-linux_390-64_cmprssptrs
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_390-64_cmprssptrs)](https://ci.eclipse.org/openj9/job/Build-linux_390-64_cmprssptrs)
+    - Description:
+        - Compiles on linux_390-64_cmprssptrs
+        - Archives the SDK and test material
+    - Trigger:
+        - This job is used in other pipelines but can be launched manually
+
+- Build-linux_ppc-64_cmprssptrs_le
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Build-linux_ppc-64_cmprssptrs_le)](https://ci.eclipse.org/openj9/job/Build-linux_ppc-64_cmprssptrs_le)
+    - Description
+        - Compiles on linux_ppc-64_cmprssptrs_le
+        - Archives the SDK and test material
+    - Trigger:
+        - This job is used in other pipelines but can be launched manually
+
+#### Infrastructure
+
+- Mirror-OMR-to-OpenJ9-OMR
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Mirror-OMR-to-OpenJ9-OMR)](https://ci.eclipse.org/openj9/job/Mirror-OMR-to-OpenJ9-OMR)
+    - Description:
+        - Mirrors eclipse/omr/master to eclipse/openj9-omr/master
+        - Triggers `Pipeline-OMR-Acceptance` when there is new content        
+    - Trigger:
+        - Build periodically, 15 minutes
+
+- Mirror-OpenJ9-Website-to-Eclipse
+    - [![Build Status](https://ci.eclipse.org/openj9/buildStatus/icon?job=Mirror-OpenJ9-Website-to-Eclipse)](https://ci.eclipse.org/openj9/job/Mirror-OpenJ9-Website-to-Eclipse)
+    - Description:
+        - Mirrors github.com/eclipse/openj9-website to the Eclipse.org repo
+    - Trigger:
+        - Poll Github repo for changes
+
+- Promote-OpenJ9-OMR-master-to-openj9","Can we reorganize this a little so the two OMR related builds are together and the website one comes after?

Also, can this describe the tag laid down on merges?",
65939977,0c34ac3557db95bc72659cdeeb7c4c668f6fd818,runtime/port/linuxs390/j9gs.c,False,"@@ -89,12 +90,20 @@ j9gs_initialize(struct J9PortLibrary *portLibrary, struct J9GSParameters *gsPara
 Trc_PRT_gs_initialize_Exit(ret_code, gsParams->flags);
 
 return IS_GS_INITIALIZED(gsParams) ? 1 : 0;
+
+#else /* !defined(J9ZTPF) */","Is there a reason to have the #else section here?  Can't the ztpf code just exclude the main body and avoid duplicating the TRC and return?  Provided the gsParams is initialized before calling the function, this should be fine.",
65939977,0c34ac3557db95bc72659cdeeb7c4c668f6fd818,runtime/port/linuxs390/j9gs.c,False,"@@ -114,4 +123,9 @@ j9gs_deinitialize(struct J9PortLibrary *portLibrary, struct J9GSParameters *gsPa
 Trc_PRT_gs_deinitialize_Exit();
 
 return IS_GS_INITIALIZED(gsParams) ? 0 : 1;
+
+#else /* !defined(J9ZTPF) */",Same question as above.  Can we limit the ztpf-specific code paths by changing what's #ifdef'd out,
66315483,0c34ac3557db95bc72659cdeeb7c4c668f6fd818,runtime/port/linuxs390/j9gs.c,True,"@@ -89,12 +90,20 @@ j9gs_initialize(struct J9PortLibrary *portLibrary, struct J9GSParameters *gsPara
 Trc_PRT_gs_initialize_Exit(ret_code, gsParams->flags);
 
 return IS_GS_INITIALIZED(gsParams) ? 1 : 0;
+
+#else /* !defined(J9ZTPF) */",Update made.,
66315484,0c34ac3557db95bc72659cdeeb7c4c668f6fd818,runtime/port/linuxs390/j9gs.c,True,"@@ -114,4 +123,9 @@ j9gs_deinitialize(struct J9PortLibrary *portLibrary, struct J9GSParameters *gsPa
 Trc_PRT_gs_deinitialize_Exit();
 
 return IS_GS_INITIALIZED(gsParams) ? 0 : 1;
+
+#else /* !defined(J9ZTPF) */",Update made.,
66431057,67aa3433ad16dbcbcb173c4ac7b03bc6032b417d,runtime/tr.source/trj9/optimizer/FearPointAnalysis.cpp,False,"@@ -39,18 +39,26 @@ bool TR_FearPointAnalysis::virtualGuardsKillFear()
    return feGetEnv(""TR_FPAnalaysisGuardsDoNotKillFear"") == NULL;
    }
 
-static bool containsPrepareForOSR(TR::Block *block)
+bool TR_FearPointAnalysis::containsPrepareForOSR(TR::Block *block)",Since this function is called from two analyses would it be better somewhere in the OSR infrastructure?,
66270560,10f2cbcb26e935bd7fbc0e1f2041a3c7948bbcc1,runtime/j9vm/java9vmi.c,False,"@@ -989,6 +990,18 @@ JVM_DefineModule(JNIEnv * env, jobject module, jstring version, jstring location
 success = vmFuncs->setBootLoaderModulePatchPaths(vm, j9mod, (const char *)nameUTF);
 if (FALSE == success) {
 goto nativeOOM;
+} else {
+const char* moduleName = ""openj9.sharedclasses"";
+
+if (0 == strncmp(nameUTF, moduleName, 20)) {",The string length shouldn't be hard coded. sizeof() can determine the string size at compile time.,
66271084,10f2cbcb26e935bd7fbc0e1f2041a3c7948bbcc1,runtime/j9vm/java9vmi.c,False,"@@ -989,6 +990,18 @@ JVM_DefineModule(JNIEnv * env, jobject module, jstring version, jstring location
 success = vmFuncs->setBootLoaderModulePatchPaths(vm, j9mod, (const char *)nameUTF);
 if (FALSE == success) {
 goto nativeOOM;
+} else {
+const char* moduleName = ""openj9.sharedclasses"";
+
+if (0 == strncmp(nameUTF, moduleName, 20)) {","The terminating zero needs to be included in the comparison, otherwise the check could match a subset of a longer name.",
66271419,10f2cbcb26e935bd7fbc0e1f2041a3c7948bbcc1,runtime/j9vm/java9vmi.c,False,"@@ -989,6 +990,18 @@ JVM_DefineModule(JNIEnv * env, jobject module, jstring version, jstring location
 success = vmFuncs->setBootLoaderModulePatchPaths(vm, j9mod, (const char *)nameUTF);
 if (FALSE == success) {
 goto nativeOOM;
+} else {
+const char* moduleName = ""openj9.sharedclasses"";
+
+if (0 == strncmp(nameUTF, moduleName, 20)) {
+J9VMDllLoadInfo *entry = FIND_DLL_TABLE_ENTRY(J9_SHARED_DLL_NAME);
+
+if ((NULL != entry)
+&& (J9_ARE_ALL_BITS_SET(entry->loadFlags, FAILED_TO_LOAD))",Could the J9_SHARED_DLL_NAME ever fail to be found? I'm wondering the message should also be printed when (NULL == entry).,
66473884,10f2cbcb26e935bd7fbc0e1f2041a3c7948bbcc1,runtime/j9vm/java9vmi.c,True,"@@ -989,6 +990,18 @@ JVM_DefineModule(JNIEnv * env, jobject module, jstring version, jstring location
 success = vmFuncs->setBootLoaderModulePatchPaths(vm, j9mod, (const char *)nameUTF);
 if (FALSE == success) {
 goto nativeOOM;
+} else {
+const char* moduleName = ""openj9.sharedclasses"";
+
+if (0 == strncmp(nameUTF, moduleName, 20)) {","I think it is unlikely we will have another module that does not depend on j9shr29 dll but its name begins with ""openj9.sharedclasses"". But I am fine changing it to use strcmp() too.",
66473903,10f2cbcb26e935bd7fbc0e1f2041a3c7948bbcc1,runtime/j9vm/java9vmi.c,True,"@@ -989,6 +990,18 @@ JVM_DefineModule(JNIEnv * env, jobject module, jstring version, jstring location
 success = vmFuncs->setBootLoaderModulePatchPaths(vm, j9mod, (const char *)nameUTF);
 if (FALSE == success) {
 goto nativeOOM;
+} else {
+const char* moduleName = ""openj9.sharedclasses"";
+
+if (0 == strncmp(nameUTF, moduleName, 20)) {
+J9VMDllLoadInfo *entry = FIND_DLL_TABLE_ENTRY(J9_SHARED_DLL_NAME);
+
+if ((NULL != entry)
+&& (J9_ARE_ALL_BITS_SET(entry->loadFlags, FAILED_TO_LOAD))","Right, it is better to also print this message when entry is null. ",
66541482,10f2cbcb26e935bd7fbc0e1f2041a3c7948bbcc1,runtime/j9vm/java9vmi.c,False,"@@ -989,6 +990,18 @@ JVM_DefineModule(JNIEnv * env, jobject module, jstring version, jstring location
 success = vmFuncs->setBootLoaderModulePatchPaths(vm, j9mod, (const char *)nameUTF);
 if (FALSE == success) {
 goto nativeOOM;
+} else {
+const char* moduleName = ""openj9.sharedclasses"";
+
+if (0 == strncmp(nameUTF, moduleName, 20)) {","strncmp() is fine, just the length should include the null terminator.",
65601993,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,jcl/src/java.base/share/classes/java/lang/J9VMInternals.java,False,"@@ -430,16 +430,21 @@ static int fastIdentityHashCode(Object anObject) {
 if (null == h) {
 return identityHashCode(anObject); /* use early returns to make the JIT code faster */
 }
-Class<?> aClazz = anObject.getClass();
 if (h.is32Bit()) {
 int ptr = h.getIntFromObject(anObject, 0L);
-if (((ptr & com.ibm.oti.vm.VM.OBJECT_HEADER_HAS_BEEN_MOVED_IN_CLASS) != 0) && !aClazz.isArray()) {
-return h.getIntFromObject(anObject, h.getBackfillOffsetFromJ9Class32(h.getJ9ClassFromClass32(aClazz)));
+if ((ptr & com.ibm.oti.vm.VM.OBJECT_HEADER_HAS_BEEN_MOVED_IN_CLASS) != 0){",Space before {,
65604665,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,jcl/src/java.base/share/classes/com/ibm/jit/JITHelpers.java,False,"@@ -135,6 +135,37 @@ private static int classIsInterfaceFlag() {
 }
 
 /*
+ * To be recognized by the JIT and turned into trees that is foldable when obj is known at compile time.
+ */
+public boolean isArray(Object obj) {
+if (is32Bit()) {
+int j9Class = getJ9ClassFromObject32(obj);
+int flags = getClassDepthAndFlagsFromJ9Class32(j9Class);
+return (flags & VM.J9_ACC_CLASS_ARRAY) == 0 ? false : true;",Is there a specific reason you need the ? here (for the JIT)?  This would read better as simply != 0.,
65604720,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,jcl/src/java.base/share/classes/com/ibm/jit/JITHelpers.java,False,"@@ -135,6 +135,37 @@ private static int classIsInterfaceFlag() {
 }
 
 /*
+ * To be recognized by the JIT and turned into trees that is foldable when obj is known at compile time.
+ */
+public boolean isArray(Object obj) {
+if (is32Bit()) {
+int j9Class = getJ9ClassFromObject32(obj);
+int flags = getClassDepthAndFlagsFromJ9Class32(j9Class);
+return (flags & VM.J9_ACC_CLASS_ARRAY) == 0 ? false : true;
+}
+else {
+long j9Class = getJ9ClassFromObject64(obj);
+// Cast the flag to int because only the lower 32 bits are valid and VM.J9_ACC_CLASS_ARRAY is int type
+int flags = (int)getClassDepthAndFlagsFromJ9Class64(j9Class);
+return (flags & VM.J9_ACC_CLASS_ARRAY) == 0 ? false : true;",See above.,
65623628,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,jcl/src/java.base/share/classes/java/lang/J9VMInternals.java,True,"@@ -430,16 +430,21 @@ static int fastIdentityHashCode(Object anObject) {
 if (null == h) {
 return identityHashCode(anObject); /* use early returns to make the JIT code faster */
 }
-Class<?> aClazz = anObject.getClass();
 if (h.is32Bit()) {
 int ptr = h.getIntFromObject(anObject, 0L);
-if (((ptr & com.ibm.oti.vm.VM.OBJECT_HEADER_HAS_BEEN_MOVED_IN_CLASS) != 0) && !aClazz.isArray()) {
-return h.getIntFromObject(anObject, h.getBackfillOffsetFromJ9Class32(h.getJ9ClassFromClass32(aClazz)));
+if ((ptr & com.ibm.oti.vm.VM.OBJECT_HEADER_HAS_BEEN_MOVED_IN_CLASS) != 0){",Fixed.,
65623638,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,jcl/src/java.base/share/classes/com/ibm/jit/JITHelpers.java,True,"@@ -135,6 +135,37 @@ private static int classIsInterfaceFlag() {
 }
 
 /*
+ * To be recognized by the JIT and turned into trees that is foldable when obj is known at compile time.
+ */
+public boolean isArray(Object obj) {
+if (is32Bit()) {
+int j9Class = getJ9ClassFromObject32(obj);
+int flags = getClassDepthAndFlagsFromJ9Class32(j9Class);
+return (flags & VM.J9_ACC_CLASS_ARRAY) == 0 ? false : true;",Fixed.,
65623648,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,jcl/src/java.base/share/classes/com/ibm/jit/JITHelpers.java,True,"@@ -135,6 +135,37 @@ private static int classIsInterfaceFlag() {
 }
 
 /*
+ * To be recognized by the JIT and turned into trees that is foldable when obj is known at compile time.
+ */
+public boolean isArray(Object obj) {
+if (is32Bit()) {
+int j9Class = getJ9ClassFromObject32(obj);
+int flags = getClassDepthAndFlagsFromJ9Class32(j9Class);
+return (flags & VM.J9_ACC_CLASS_ARRAY) == 0 ? false : true;
+}
+else {
+long j9Class = getJ9ClassFromObject64(obj);
+// Cast the flag to int because only the lower 32 bits are valid and VM.J9_ACC_CLASS_ARRAY is int type
+int flags = (int)getClassDepthAndFlagsFromJ9Class64(j9Class);
+return (flags & VM.J9_ACC_CLASS_ARRAY) == 0 ? false : true;",Fixed.,
65627821,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,False,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv",I don't follow the idiv here... could you explain a bit more?,
65629059,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,True,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv",Class.isArray returns boolean so the result can only be 0 or 1.,
65630505,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,False,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv",should this be a right shift or something if we are trying to get rid of trailing zeros or something then? idiv is an expensive thing that the optimizer needs to see through so we should avoid generating it,
65637658,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,True,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv","Since the divisor is a constant and power of two, it will be turned into a shift instruction in codegen.",
65647111,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,False,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv",Since you're creating the expression yourself I suggest you create the optimal one now rather than relying on the code generator to do any sort of optimization on it. We have multiple code generators and creating trees that then need to be optimized in all of them is not such a good idea.,
65651012,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,True,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv","Make sense, will make the change",
65662056,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,True,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv",idiv has been replaced with iushr.,
66811492,146cd1905d5e7a8b4519782bfebe5ec728eb97cd,runtime/jvmti/jvmtiModules.c,False,"@@ -686,3 +686,70 @@ jvmtiAddModuleProvides(jvmtiEnv* jvmtiEnv,
 return rc;
 }
 
+/**
+ * Determines whether a module is modifiable. Currently, no criteria
+ * is specified to tag modules as modifiable. So, is_modifiable_module_ptr
+ * is set to JNI_TRUE for all modules. In case of error, is_modifiable_module_ptr
+ * is set to JNI_FALSE.
+ *
+ * @param [in]     env                      pointer to jvmtiEnv
+ * @param [in]     module                   module being checked
+ * @param [in/out] is_modifiable_module_ptr points to the boolean result
+ *
+ * @return jvmtiError, JVMTI_ERROR_NONE on success
+ *         jvmtiError, JVMTI_ERROR_INVALID_MODULE if module is not a module object
+ *         jvmtiError, JVMTI_ERROR_NULL_POINTER if module is NULL
+ *         jvmtiError, JVMTI_ERROR_NULL_POINTER if is_modifiable_module_ptr is NULL
+ *         jvmtiError, one of the universal errors
+ */
+jvmtiError JNICALL
+jvmtiIsModifiableModule(jvmtiEnv* env,
+jobject module,
+jboolean* is_modifiable_module_ptr)
+{
+J9VMThread *currentThread = NULL;
+J9JavaVM *vm = JAVAVM_FROM_ENV(env);
+jvmtiError rc = JVMTI_ERROR_NONE;
+ENSURE_PHASE_LIVE(env);
+ENSURE_NON_NULL(module);
+ENSURE_NON_NULL(is_modifiable_module_ptr);
+
+*is_modifiable_module_ptr = JNI_FALSE;
+
+rc = getCurrentVMThread(vm, &currentThread);
+if (JVMTI_ERROR_NONE == rc) {
+J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;
+j9object_t moduleObject = NULL;
+J9Class *moduleJ9Class = NULL;
+
+vmFuncs->internalEnterVMFromJNI(currentThread);
+
+moduleObject = J9_JNI_UNWRAP_REFERENCE(module);
+if(J2SE_SHAPE(vm) < J2SE_SHAPE_B165) {
+moduleJ9Class = J9VMJAVALANGREFLECTMODULE_OR_NULL(vm);
+} else {
+moduleJ9Class = J9VMJAVALANGMODULE_OR_NULL(vm);
+}
+
+Assert_JVMTI_notNull(moduleJ9Class);
+
+if (!isSameOrSuperClassOf(moduleJ9Class, J9OBJECT_CLAZZ(currentThread, moduleObject))) {
+rc = JVMTI_ERROR_INVALID_MODULE;
+} else if (J9_IS_J9MODULE_UNNAMED(vm, J9OBJECT_ADDRESS_LOAD(currentThread, moduleObject, vm->modulePointerOffset))) {",maybe comment out this check since and only have the else case since we will always be returning true,
66827031,146cd1905d5e7a8b4519782bfebe5ec728eb97cd,runtime/jvmti/jvmtiModules.c,False,"@@ -686,3 +686,70 @@ jvmtiAddModuleProvides(jvmtiEnv* jvmtiEnv,
 return rc;
 }
 
+/**
+ * Determines whether a module is modifiable. Currently, no criteria
+ * is specified to tag modules as modifiable. So, is_modifiable_module_ptr
+ * is set to JNI_TRUE for all modules. In case of error, is_modifiable_module_ptr
+ * is set to JNI_FALSE.
+ *
+ * @param [in]     env                      pointer to jvmtiEnv
+ * @param [in]     module                   module being checked
+ * @param [in/out] is_modifiable_module_ptr points to the boolean result
+ *
+ * @return jvmtiError, JVMTI_ERROR_NONE on success
+ *         jvmtiError, JVMTI_ERROR_INVALID_MODULE if module is not a module object
+ *         jvmtiError, JVMTI_ERROR_NULL_POINTER if module is NULL
+ *         jvmtiError, JVMTI_ERROR_NULL_POINTER if is_modifiable_module_ptr is NULL
+ *         jvmtiError, one of the universal errors
+ */
+jvmtiError JNICALL
+jvmtiIsModifiableModule(jvmtiEnv* env,
+jobject module,
+jboolean* is_modifiable_module_ptr)
+{
+J9VMThread *currentThread = NULL;
+J9JavaVM *vm = JAVAVM_FROM_ENV(env);
+jvmtiError rc = JVMTI_ERROR_NONE;
+ENSURE_PHASE_LIVE(env);
+ENSURE_NON_NULL(module);
+ENSURE_NON_NULL(is_modifiable_module_ptr);
+
+*is_modifiable_module_ptr = JNI_FALSE;
+
+rc = getCurrentVMThread(vm, &currentThread);
+if (JVMTI_ERROR_NONE == rc) {
+J9InternalVMFunctions *vmFuncs = vm->internalVMFunctions;
+j9object_t moduleObject = NULL;
+J9Class *moduleJ9Class = NULL;
+
+vmFuncs->internalEnterVMFromJNI(currentThread);
+
+moduleObject = J9_JNI_UNWRAP_REFERENCE(module);
+if(J2SE_SHAPE(vm) < J2SE_SHAPE_B165) {
+moduleJ9Class = J9VMJAVALANGREFLECTMODULE_OR_NULL(vm);
+} else {
+moduleJ9Class = J9VMJAVALANGMODULE_OR_NULL(vm);
+}
+
+Assert_JVMTI_notNull(moduleJ9Class);
+
+if (!isSameOrSuperClassOf(moduleJ9Class, J9OBJECT_CLAZZ(currentThread, moduleObject))) {
+rc = JVMTI_ERROR_INVALID_MODULE;
+} else if (J9_IS_J9MODULE_UNNAMED(vm, J9OBJECT_ADDRESS_LOAD(currentThread, moduleObject, vm->modulePointerOffset))) {","I'll just merge it the way it is. This condition is explicitly called out in the java.lang.instrument.Instrumentation.isModifiableModule?() javadoc, so the condition needs to be in the code if there is ever a case that returns false. Keeping the condition avoids having to slow down the code later.",
66844908,b7ba3d6b236fdb0db1a3b98027a7a803baf3abea,runtime/makelib/targets.mk.ftl,False,"@@ -486,9 +486,15 @@ UMA_PASM_INCLUDES:=$(addprefix -I ,$(UMA_INCLUDES))
 </#if>
 
 <#if uma.spec.type.windows>
+ifdef USE_MINGW
+UMA_M4_INCLUDES:=$(UMA_C_INCLUDES)
+else
+UMA_M4_INCLUDES:=$(subst /I,-I,$(UMA_C_INCLUDES))","This needs to use `patsubst` instead to avoid altering paths like `foo/Interface` to `foo-Interface`.
```
UMA_M4_INCLUDES := $(patsubst /I%,-I%,$(UMA_C_INCLUDES))
```
Also, spacing around `:=` improves readability.",
66282094,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/jcl/common/sun_misc_Unsafe.cpp,False,"@@ -899,18 +818,30 @@ registerJdkInternalMiscUnsafeNativesB136(JNIEnv *env, jclass clazz) {
 env->RegisterNatives(clazz, natives, sizeof(natives)/sizeof(JNINativeMethod));
 }
 
+/* register jdk.internal.misc.Unsafe natives for Java 18.3 */
+static void
+registerJdkInternalMiscUnsafeNativesJava183(JNIEnv *env, jclass clazz) {",18_3 would be better,
66283135,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/oti/j2sever.h,False,"@@ -52,12 +61,22 @@
 /*
  * Note: J2SE_SHAPE_LATEST has to be updated to highest JCL level supported by VM
  *  This allows JVM operates with latest level when classlib.properties doesn't present.
+ * Additional note:
+ *  J2SE_SHAPE_LATEST will be kept as J2SE_SHAPE_B165 while Java 18.3 raw build is being built.
+ *  When a separated Java 18.3 binary is required, a #ifdef flag will be introduced to define
+ *  J2SE_SHAPE_B165 to different values accordingly such as following:
+ *  #if J9VM_JAVA9_BUILD > 9
+ *  #define J2SE_SHAPE_LATEST  J2SE_SHAPE_B1803
+ *  #else
+ *  #define J2SE_SHAPE_LATEST  J2SE_SHAPE_B165
+ *  #endif
  */
 #define J2SE_SHAPE_LATEST    J2SE_SHAPE_B165
 #define J2SE_SHAPE_SUN     0x10000
 #define J2SE_SHAPE_B136    0x40000
 #define J2SE_SHAPE_B148    0x50000
 #define J2SE_SHAPE_B165    0x60000
+#define J2SE_SHAPE_B1803    0x70000",The value doesn't line up with the others.,
66283202,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/oti/j2sever.h,False,"@@ -52,12 +61,22 @@
 /*
  * Note: J2SE_SHAPE_LATEST has to be updated to highest JCL level supported by VM
  *  This allows JVM operates with latest level when classlib.properties doesn't present.
+ * Additional note:
+ *  J2SE_SHAPE_LATEST will be kept as J2SE_SHAPE_B165 while Java 18.3 raw build is being built.
+ *  When a separated Java 18.3 binary is required, a #ifdef flag will be introduced to define",separated should be separate,
66283249,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/oti/j2sever.h,False,"@@ -29,6 +29,15 @@
 /*
  * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
  *  This allows JVM operates with latest version when classlib.properties doesn't present.
+ * Additional note:
+ *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
+ *  When a separated Java 18.3 binary is required, a #ifdef flag will be introduced to define",separated should be separate,
66457913,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",What is this for? It appears unused.,
66458375,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/j9vm/jvm.c,False,"@@ -1150,6 +1150,7 @@ VersionSetting SHAPE_SETTINGS[] = {
 {""b135"", J2SE_SHAPE_B136},
 {""b148"", J2SE_SHAPE_B148},
 {""b165"", J2SE_SHAPE_B165},
+{""b1803"", J2SE_SHAPE_B1803},","Should this be more specific? There were several _shapes_ for Java 9, we should assume there will be several for 18.3 as well.",
66458914,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/jcl/common/reflecthelp.c,False,"@@ -972,12 +972,15 @@ createConstructor(struct J9VMThread *vmThread, J9JNIMethodID *methodID, j9object
 }
 
 static struct J9JNIFieldID *
-idFromFieldObject(J9VMThread* vmThread, j9object_t fieldObject)
+idFromFieldObject(J9VMThread* vmThread, j9object_t declaringClassObject, j9object_t fieldObject)
 {
 J9JNIFieldID *fieldID = NULL;
+J9Class *declaringClass = NULL;
 U_32 index = J9VMJAVALANGREFLECTFIELD_INTFIELDID(vmThread, fieldObject);
-j9object_t declaringClassObject = J9VMJAVALANGREFLECTFIELD_DECLARINGCLASS(vmThread, fieldObject);
-J9Class *declaringClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, declaringClassObject);
+if (NULL == declaringClassObject) {
+declaringClassObject = J9VMJAVALANGREFLECTFIELD_DECLARINGCLASS(vmThread, fieldObject);",Our coding guidelines generally frown upon modifying a formal parameter.,
66459954,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",We should be careful adding instance fields to string due to the footprint increase they cause,
66460140,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,False,"@@ -257,7 +257,16 @@ static final void initializeClassLoaders() {
 
 /*[IF Sidecar19-SE]*/
 jdk.internal.misc.VM.initLevel(1);
-System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+try {
+/*[ENDIF]*/
+System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+} catch (Exception ex) {",Is this temporary?,
66461024,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/jcl/common/sun_misc_Unsafe.cpp,False,"@@ -899,18 +818,30 @@ registerJdkInternalMiscUnsafeNativesB136(JNIEnv *env, jclass clazz) {
 env->RegisterNatives(clazz, natives, sizeof(natives)/sizeof(JNINativeMethod));
 }
 
+/* register jdk.internal.misc.Unsafe natives for Java 18.3 */
+static void
+registerJdkInternalMiscUnsafeNativesJava18_3(JNIEnv *env, jclass clazz) {
+/* clazz can't be null */
+JNINativeMethod natives[] = {
+{
+(char*)""objectFieldOffset1"",
+(char*)""(Ljava/lang/Class;Ljava/lang/String;)J"",
+(void *)&Java_jdk_internal_misc_Unsafe_objectFieldOffset1",Please be consistent with formatting casts (space between type and `*`).,
66462009,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/jcl/common/sun_misc_Unsafe.cpp,False,"@@ -899,18 +818,30 @@ registerJdkInternalMiscUnsafeNativesB136(JNIEnv *env, jclass clazz) {
 env->RegisterNatives(clazz, natives, sizeof(natives)/sizeof(JNINativeMethod));
 }
 
+/* register jdk.internal.misc.Unsafe natives for Java 18.3 */
+static void
+registerJdkInternalMiscUnsafeNativesJava18_3(JNIEnv *env, jclass clazz) {
+/* clazz can't be null */
+JNINativeMethod natives[] = {
+{
+(char*)""objectFieldOffset1"",
+(char*)""(Ljava/lang/Class;Ljava/lang/String;)J"",
+(void *)&Java_jdk_internal_misc_Unsafe_objectFieldOffset1
+}
+};
+env->RegisterNatives(clazz, natives, sizeof(natives)/sizeof(JNINativeMethod));
+}
+
+/* class jdk.internal.misc.Unsafe only presents in Java 9 and beyond */
 void JNICALL
 Java_jdk_internal_misc_Unsafe_registerNatives(JNIEnv *env, jclass clazz)
 {
 J9VMThread *currentThread = (J9VMThread*)env;
-J9JavaVM *vm = currentThread->javaVM;
 
 Java_sun_misc_Unsafe_registerNatives(env, clazz);
-
-if (J2SE_VERSION(vm) >= J2SE_19) {
-registerJdkInternalMiscUnsafeNativesB136(env, clazz);
-} else {
-registerJdkInternalMiscUnsafeNatives(env, clazz);
+registerJdkInternalMiscUnsafeNativesCommon(env, clazz);
+if(J2SE_SHAPE(currentThread->javaVM) >= J2SE_SHAPE_B1803) {",Formatting nit: space after 'if'.,
66476224,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",This field is required for Java 18.3 due to references by j.i.UnixFileSystem.canonicalize0.,
66476960,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/j9vm/jvm.c,True,"@@ -1150,6 +1150,7 @@ VersionSetting SHAPE_SETTINGS[] = {
 {""b135"", J2SE_SHAPE_B136},
 {""b148"", J2SE_SHAPE_B148},
 {""b165"", J2SE_SHAPE_B165},
+{""b1803"", J2SE_SHAPE_B1803},","@pshipton indicated in https://github.com/eclipse/openj9/issues/152 ""We expect to only support the latest so a build number should not be needed, and will quickly become out of date."".",
66478459,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,True,"@@ -257,7 +257,16 @@ static final void initializeClassLoaders() {
 
 /*[IF Sidecar19-SE]*/
 jdk.internal.misc.VM.initLevel(1);
-System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+try {
+/*[ENDIF]*/
+System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+} catch (Exception ex) {",This is required for `Java 18.3` due to `j.i.ModuleBootstrap.boot()` in this Java version throws Exception.,
66488130,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/jcl/common/sun_misc_Unsafe.cpp,False,"@@ -683,121 +684,39 @@ Java_jdk_internal_misc_Unsafe_shouldBeInitialized(JNIEnv *env, jobject receiver,
 return JNI_FALSE;
 }
 
-void
-registerJdkInternalMiscUnsafeNatives(JNIEnv *env, jclass clazz) {
-/* clazz can't be null */
-JNINativeMethod natives[] = {
-{
-(char*)""defineClass"",","The replacement set of natives don't match those required by Java 8.
Each of these should omit the `0` suffix for Java 8 (so they can't be classified as 'common'):
```
allocateMemory0
copyMemory0
defineAnonymousClass0
defineClass0
ensureClassInitialized0
freeMemory0
getLoadAverage0
objectFieldOffset0
reallocateMemory0
setMemory0
staticFieldBase0
staticFieldOffset0
```
These don't appear to exist in Java 8 (I would have expected the call to `RegisterNatives` to complain): they should be removed for Java 8:
```
getUncompressedObject
isBigEndian0
unalignedAccess0
```",
66492658,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/jcl/common/sun_misc_Unsafe.cpp,True,"@@ -683,121 +684,39 @@ Java_jdk_internal_misc_Unsafe_shouldBeInitialized(JNIEnv *env, jobject receiver,
 return JNI_FALSE;
 }
 
-void
-registerJdkInternalMiscUnsafeNatives(JNIEnv *env, jclass clazz) {
-/* clazz can't be null */
-JNINativeMethod natives[] = {
-{
-(char*)""defineClass"",","Pls note the comments for the method `registerJdkInternalMiscUnsafeNativesCommon` as following:
/* register jdk.internal.misc.Unsafe natives common to Java 9, 18.3 and beyond */
`Java 8` doesn't have class j.i.m.Unsafe.",
66498932,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/jcl/common/sun_misc_Unsafe.cpp,False,"@@ -683,121 +684,39 @@ Java_jdk_internal_misc_Unsafe_shouldBeInitialized(JNIEnv *env, jobject receiver,
 return JNI_FALSE;
 }
 
-void
-registerJdkInternalMiscUnsafeNatives(JNIEnv *env, jclass clazz) {
-/* clazz can't be null */
-JNINativeMethod natives[] = {
-{
-(char*)""defineClass"",",Java 8 _does_ have sun.misc.Unsafe and it was my understanding that this was how those native were registered (and would be broken by this change). Am I missing something?,
66501309,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/jcl/common/sun_misc_Unsafe.cpp,True,"@@ -683,121 +684,39 @@ Java_jdk_internal_misc_Unsafe_shouldBeInitialized(JNIEnv *env, jobject receiver,
 return JNI_FALSE;
 }
 
-void
-registerJdkInternalMiscUnsafeNatives(JNIEnv *env, jclass clazz) {
-/* clazz can't be null */
-JNINativeMethod natives[] = {
-{
-(char*)""defineClass"",","`Java 8` `s.m.Unsafe` natives are exported explicitly (see `sun_misc_Unsafe_exports.xml`).
Again, `Java 8` doesn't have class j.i.m.Unsafe, whatever change within `Java_jdk_internal_misc_Unsafe_registerNatives` won't affect `Java 8` behaviours.",
66507998,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",As Andrew pointed out this will (negatively) affect footprint: Perhaps we ought to fix UnixFileSystem.canonicalize0?,
66510072,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","`j.i.UnixFileSystem.canonicalize0` is part of `OpenJDK`. The general idea is to avoid JCL patch as much as possible. 
`Java 18.3` code is still progressing so it might be changed in future builds. In case it stays in final release, the footprint impact on `Java 18.3` due to this additional instance field could be addressed later.",
66523340,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","I see a reference in java.base/share/native/libjava/jni_util.c, not UnixFileSystem. Adding that byte might _*double*_ the footprint of a String. I don't think we can afford that.",
66537642,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/j9vm/jvm.c,False,"@@ -1150,6 +1150,7 @@ VersionSetting SHAPE_SETTINGS[] = {
 {""b135"", J2SE_SHAPE_B136},
 {""b148"", J2SE_SHAPE_B148},
 {""b165"", J2SE_SHAPE_B165},
+{""b1803"", J2SE_SHAPE_B1803},",That makes sense. Thanks.,
66543466,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,False,"@@ -257,7 +257,16 @@ static final void initializeClassLoaders() {
 
 /*[IF Sidecar19-SE]*/
 jdk.internal.misc.VM.initLevel(1);
-System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+try {
+/*[ENDIF]*/
+System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+} catch (Exception ex) {",Do we still need to call ModuleBootstrap.boot() for Java 18.3? Something is wrong if it needs to be called but then throws an exception.,
66546753,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","Not sure about *double* part, there are a few other instance fields within `j.l.String` such as 
`private final byte[] value;`
`private final int count;`
`private int hashCode;`

`Java 18.3` `b23` -version throws following exception without the `coder` field
````
Exception in thread ""main"" java/lang/NoSuchFieldError: java/lang/String.coder
        at java/io/UnixFileSystem.canonicalize0 (java.base@9/NativeMethod:4294967295)
        at java/io/UnixFileSystem.canonicalize (java.base@9/UnixFileSystem.java:170)
        at java/io/File.getCanonicalPath (java.base@9/File.java:618)
        at java/io/File.getCanonicalFile (java.base@9/File.java:643)
        at jdk/internal/loader/URLClassPath.toFileURL (java.base@9/URLClassPath.java:253)
        at jdk/internal/loader/URLClassPath.<init> (java.base@9/URLClassPath.java:188)
        at jdk/internal/loader/ClassLoaders.<clinit> (java.base@9/ClassLoaders.java:85)
        at java/lang/ClassLoader.initializeClassLoaders (java.base@9/ClassLoader.java:183)
        at java/lang/Thread.initialize (java.base@9/Thread.java:422)
        at java/lang/Thread.<init> (java.base@9/Thread.java:153)
````",
66565538,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,False,"@@ -257,7 +257,16 @@ static final void initializeClassLoaders() {
 
 /*[IF Sidecar19-SE]*/
 jdk.internal.misc.VM.initLevel(1);
-System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+try {
+/*[ENDIF]*/
+System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+} catch (Exception ex) {","Sorry, ignore my comment, doesn't make any sense.",
66566125,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,True,"@@ -257,7 +257,16 @@ static final void initializeClassLoaders() {
 
 /*[IF Sidecar19-SE]*/
 jdk.internal.misc.VM.initLevel(1);
-System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+try {
+/*[ENDIF]*/
+System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+} catch (Exception ex) {","This exception catching code is required because `jdk.internal.module.ModuleBootstrap.boot()` is declared with `throws Exception`, which is mainly due to ` systemModuleFinder.find(JAVA_BASE)` might throw an `IOException`. ",
66844385,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","OpenJDK `Java 18.3` only has following three instance fields:
  `private final byte[] value;`
  `private final byte coder;`
  `private int hash;`
There is no `count`.
fyi @fjeremic 
",
66845849,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",We bundle to `coder` and the `count` into a single field thus getting the benefit of having a `count` which speeds up substring operations and StringBuilder interaction while also supporting string compression.,
66847064,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","Adding the coder increases footprint of all strings in compressedrefs by 33% (currently 3 fields so `J9Class*` plus 3 32-bit fields is 16 bytes. Adding another field bumps this to 20, but because of alignment it increases to 24. 1 - 16/24 = 33%. This is definitely something we don't want.",
66866820,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","I think it's worse: my understanding is that the unit of allocation is now 16 bytes (so everything is 16-byte aligned). String is 16 bytes in Java 8 & 9, the extra byte requires another 16 bytes for a total of 32 bytes.",
66868931,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","I feel OpenJ9 should have a field `coder` to match OpenJDK for two reasons:
1. OpenJ9 with same `j.l.String` fields as OpenJDK can avoid JCL patches required to fix `NoSuchFieldError` as per earlier comment in this thread. Avoiding JCL patch is as important as performance advantages. Past experience shows JCL patch price tag is high in all perspectives;
2. User applications attempting reflection access of `j.l.String` field `coder` will succeed in OpenJDK but fail at OpenJ9 which usually causes confusion and defect against J9.

Can field `coder` serve the purpose of OpenJ9 only field `count`? I suggest to open another issue for further discussion to rename the field `count` to `coder`. This pull request (adding field `coder`) won't affect `Java 8 & 9`, and allow adoption of `Java 18.3` further updates.",
66869152,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","> I think it's worse: my understanding is that the unit of allocation is now 16 bytes (so everything is 16-byte aligned). String is 16 bytes in Java 8 & 9, the extra byte requires another 16 bytes for a total of 32 bytes.

You're right! We support compressedrefs shift of 4 so 2^4 = 16 byte alignment. This change will double the size of all string objects.",
66875530,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","The coder field does not serve the same purpose as count. There is an important difference in the String implementation behavior here for OpenJ9. In OpenJ9 the backing array of a string can be longer than the string length. This is a very useful optimization for a number of cases including when a StringBuilder/StringBuffer has append called after a toString; a substring is used to generate prefix strings; and to prevent having to truncate the backing array of a StringBuilder/StringBuffer when toString is called if the builder's of buffer's backing array is over allocated. Without the count field these optimizations cannot be done. Removing or repurposing the count field does have a major performance implication as a result.

Adding a new field does need a good justification given the huge object size increases that can be seen (per the discussion above). I agree there is a case for minimizing patches, but given how performance sensitive String is a little bit more study might be justified before adopting the field.",
66877050,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","The only problem with renaming the field from count to coder is that count is an int and coder field is a byte. The byte may only hold 0 or 1 or something like that, but for count the MSB is the bit so I don't know that we can make the reflective access equivalent...",
66879878,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",Related to https://github.com/eclipse/openj9/issues/223.,
66881002,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","We would go ahead and deliver this change to temporarily add the coder field. As @JasonFengJ9 said, the addition of the coder field only affects Java 18.3, for which there isn't yet any OpenJ9 build provided. The extensions repo for Java 18.3 hasn't been created yet, so we don't have a simple way to patch the JCL code at this time. It can be done later after the extensions repo is created, #223 is opened to track this. Delivering this change enables raw builds of Java 18.3, which is desirable in order to provide initial support for Java 18.3 and make it easier to stay up to date and keep it working.",
66882295,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",Note that the coder field will likely not have the correct value once OpenJ9 enables string compression by default leading the presence of this field to cause incorrect behavior.,
66884778,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","Does coder() return correct coder value, or the coder value might be changed after string construction once OpenJ9 enables string compression by default?",
66886724,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",coder() does so the initialization was right - I take back my comment it should be correct.,
67073693,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",The timing of this initialization is problematic: it occurs before the body of any constructor and so it will observe `count == 0` yielding the wrong answer for uncompressed strings.,
67076775,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/oti/j2sever.h,False,"@@ -52,13 +61,23 @@
 /*
  * Note: J2SE_SHAPE_LATEST has to be updated to highest JCL level supported by VM
  *  This allows JVM operates with latest level when classlib.properties doesn't present.
+ * Additional note:
+ *  J2SE_SHAPE_LATEST will be kept as J2SE_SHAPE_B165 while Java 18.3 raw build is being built.
+ *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
+ *  J2SE_SHAPE_B165 to different values accordingly such as following:
+ *  #if J9VM_JAVA9_BUILD > 9
+ *  #define J2SE_SHAPE_LATEST  J2SE_SHAPE_B1803
+ *  #else
+ *  #define J2SE_SHAPE_LATEST  J2SE_SHAPE_B165
+ *  #endif
  */
-#define J2SE_SHAPE_LATEST    J2SE_SHAPE_B165
+#define J2SE_SHAPE_LATEST  J2SE_SHAPE_B165
 #define J2SE_SHAPE_SUN     0x10000
 #define J2SE_SHAPE_B136    0x40000
 #define J2SE_SHAPE_B148    0x50000
 #define J2SE_SHAPE_B165    0x60000
-#define J2SE_SHAPE_RAWPLUSJ90x80000
+#define J2SE_SHAPE_B1803   0x70000
+#define J2SE_SHAPE_RAWPLUSJ9   0x80000",There is a mix of spaces and tabs here that won't leave everyone pleased. IMO tabs should never appear after a non-tab.,
67088936,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/oti/j2sever.h,False,"@@ -52,13 +61,23 @@
 /*
  * Note: J2SE_SHAPE_LATEST has to be updated to highest JCL level supported by VM
  *  This allows JVM operates with latest level when classlib.properties doesn't present.
+ * Additional note:
+ *  J2SE_SHAPE_LATEST will be kept as J2SE_SHAPE_B165 while Java 18.3 raw build is being built.
+ *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
+ *  J2SE_SHAPE_B165 to different values accordingly such as following:
+ *  #if J9VM_JAVA9_BUILD > 9
+ *  #define J2SE_SHAPE_LATEST  J2SE_SHAPE_B1803
+ *  #else
+ *  #define J2SE_SHAPE_LATEST  J2SE_SHAPE_B165
+ *  #endif
  */
-#define J2SE_SHAPE_LATEST    J2SE_SHAPE_B165
+#define J2SE_SHAPE_LATEST  J2SE_SHAPE_B165
 #define J2SE_SHAPE_SUN     0x10000
 #define J2SE_SHAPE_B136    0x40000
 #define J2SE_SHAPE_B148    0x50000
 #define J2SE_SHAPE_B165    0x60000
-#define J2SE_SHAPE_RAWPLUSJ90x80000
+#define J2SE_SHAPE_B1803   0x70000
+#define J2SE_SHAPE_RAWPLUSJ9   0x80000","In particular, we try to avoid this kind of alignment as keeping the spacing consistent when new entries are added results in unnecessary changes.",
67102116,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,runtime/oti/j2sever.h,True,"@@ -52,13 +61,23 @@
 /*
  * Note: J2SE_SHAPE_LATEST has to be updated to highest JCL level supported by VM
  *  This allows JVM operates with latest level when classlib.properties doesn't present.
+ * Additional note:
+ *  J2SE_SHAPE_LATEST will be kept as J2SE_SHAPE_B165 while Java 18.3 raw build is being built.
+ *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
+ *  J2SE_SHAPE_B165 to different values accordingly such as following:
+ *  #if J9VM_JAVA9_BUILD > 9
+ *  #define J2SE_SHAPE_LATEST  J2SE_SHAPE_B1803
+ *  #else
+ *  #define J2SE_SHAPE_LATEST  J2SE_SHAPE_B165
+ *  #endif
  */
-#define J2SE_SHAPE_LATEST    J2SE_SHAPE_B165
+#define J2SE_SHAPE_LATEST  J2SE_SHAPE_B165
 #define J2SE_SHAPE_SUN     0x10000
 #define J2SE_SHAPE_B136    0x40000
 #define J2SE_SHAPE_B148    0x50000
 #define J2SE_SHAPE_B165    0x60000
-#define J2SE_SHAPE_RAWPLUSJ90x80000
+#define J2SE_SHAPE_B1803   0x70000
+#define J2SE_SHAPE_RAWPLUSJ9   0x80000",Removing the space changes to other entries to avoid unnecessary modification.,
67102426,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",Moving `coder` initialization to inside of `j.l.String` constructors. ,
67115330,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private byte coder;",This field should be final. That would highlight the missing initialization in several constructors.,
67122323,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private byte coder;",sigh... fixed.,
67129361,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private byte coder;","That's better. Thanks, Jason.",
67083410,055b5235281f0f23d110c7663269834fe1690817,buildenv/jenkins/copyrightCheck,False,"@@ -0,0 +1,72 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+Boolean FAIL = false
+String SRC_REPO = 'https://github.com/eclipse/openj9.git'
+def BAD_FILES = []
+String HASHES = '###################################'
+
+stage('Copyright Check') {
+    node ('master') {
+        timestamps {
+            git url: SRC_REPO
+            sh ""git fetch --tags --progress origin +refs/pull/*:refs/remotes/origin/pr/*""
+            sh ""git checkout --detach ${sha1}""
+            sh 'git fetch origin'
+            FILES = sh (
+                script: ""git diff --diff-filter=ACM --name-only origin/${ghprbTargetBranch} HEAD"",
+                returnStdout: true
+            ).trim()
+            echo FILES
+            def FILES_LIST = FILES.split(""\\r?\\n"")
+            DATE_YEAR = sh (
+                script: ""date +%Y"",
+                returnStdout: true
+            ).trim()
+            FILES_LIST.each() {
+                println ""Checking file: '${it}'""
+                RESULT = sh (
+                    script: ""grep -qE \""Copyright \\(c\\) ([0-9]{4}), ${DATE_YEAR} IBM Corp. and others\"" '${it}'"",","If you use single quotes around the pattern, I expect fewer escapes would be required.",
67112969,055b5235281f0f23d110c7663269834fe1690817,buildenv/jenkins/copyrightCheck,True,"@@ -0,0 +1,72 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+Boolean FAIL = false
+String SRC_REPO = 'https://github.com/eclipse/openj9.git'
+def BAD_FILES = []
+String HASHES = '###################################'
+
+stage('Copyright Check') {
+    node ('master') {
+        timestamps {
+            git url: SRC_REPO
+            sh ""git fetch --tags --progress origin +refs/pull/*:refs/remotes/origin/pr/*""
+            sh ""git checkout --detach ${sha1}""
+            sh 'git fetch origin'
+            FILES = sh (
+                script: ""git diff --diff-filter=ACM --name-only origin/${ghprbTargetBranch} HEAD"",
+                returnStdout: true
+            ).trim()
+            echo FILES
+            def FILES_LIST = FILES.split(""\\r?\\n"")
+            DATE_YEAR = sh (
+                script: ""date +%Y"",
+                returnStdout: true
+            ).trim()
+            FILES_LIST.each() {
+                println ""Checking file: '${it}'""
+                RESULT = sh (
+                    script: ""grep -qE \""Copyright \\(c\\) ([0-9]{4}), ${DATE_YEAR} IBM Corp. and others\"" '${it}'"",","updated commit, seems to still work properly",
67125810,055b5235281f0f23d110c7663269834fe1690817,buildenv/jenkins/copyrightCheck,False,"@@ -0,0 +1,72 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+Boolean FAIL = false
+String SRC_REPO = 'https://github.com/eclipse/openj9.git'
+def BAD_FILES = []
+String HASHES = '###################################'
+
+stage('Copyright Check') {
+    node ('master') {
+        timestamps {
+            git url: SRC_REPO
+            sh ""git fetch --tags --progress origin +refs/pull/*:refs/remotes/origin/pr/*""
+            sh ""git checkout --detach ${sha1}""
+            sh 'git fetch origin'
+            FILES = sh (
+                script: ""git diff --diff-filter=ACM --name-only origin/${ghprbTargetBranch} HEAD"",
+                returnStdout: true
+            ).trim()
+            echo FILES
+            def FILES_LIST = FILES.split(""\\r?\\n"")
+            DATE_YEAR = sh (
+                script: ""date +%Y"",
+                returnStdout: true
+            ).trim()
+            FILES_LIST.each() {
+                println ""Checking file: '${it}'""
+                RESULT = sh (
+                    script: ""grep -qE 'Copyright \\(c\\) ([0-9]{4}), ${DATE_YEAR} IBM Corp. and others' '${it}'"",
+                    returnStatus: true)
+                if(RESULT != 0) {
+                    echo ""FAILURE - Copyright date in file: '${it}' appears to be incorrect""
+                    FAIL = true
+                    BAD_FILES << ""${it}""
+                } else {
+                    echo ""Copyright date in file: appears to be correct""
+                }
+
+            }
+            if (FAIL) {
+                echo ""${HASHES}""
+                echo ""The following files were modified and have incorrect Copyrights""
+                BAD_FILES.each() {
+                    echo ""${it}""
+                }
+                echo ""${HASHES}""
+                sh 'exit 1'
+            } else {
+                echo ""All modified files appear to have correct Coprights""","That's not how you spell 'copyrights'. ;-)
I don't think that word should be capitalized.",
67126553,055b5235281f0f23d110c7663269834fe1690817,buildenv/jenkins/copyrightCheck,False,"@@ -0,0 +1,72 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+Boolean FAIL = false
+String SRC_REPO = 'https://github.com/eclipse/openj9.git'
+def BAD_FILES = []
+String HASHES = '###################################'
+
+stage('Copyright Check') {
+    node ('master') {
+        timestamps {
+            git url: SRC_REPO
+            sh ""git fetch --tags --progress origin +refs/pull/*:refs/remotes/origin/pr/*""
+            sh ""git checkout --detach ${sha1}""
+            sh 'git fetch origin'
+            FILES = sh (
+                script: ""git diff --diff-filter=ACM --name-only origin/${ghprbTargetBranch} HEAD"",
+                returnStdout: true
+            ).trim()
+            echo FILES
+            def FILES_LIST = FILES.split(""\\r?\\n"")
+            DATE_YEAR = sh (
+                script: ""date +%Y"",
+                returnStdout: true
+            ).trim()
+            FILES_LIST.each() {
+                println ""Checking file: '${it}'""
+                RESULT = sh (
+                    script: ""grep -qE \""Copyright \\(c\\) ([0-9]{4}), ${DATE_YEAR} IBM Corp. and others\"" '${it}'"",","I suspect you didn't have `\` escapes before, but it seems right now.",
67158060,055b5235281f0f23d110c7663269834fe1690817,buildenv/jenkins/copyrightCheck,True,"@@ -0,0 +1,72 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+Boolean FAIL = false
+String SRC_REPO = 'https://github.com/eclipse/openj9.git'
+def BAD_FILES = []
+String HASHES = '###################################'
+
+stage('Copyright Check') {
+    node ('master') {
+        timestamps {
+            git url: SRC_REPO
+            sh ""git fetch --tags --progress origin +refs/pull/*:refs/remotes/origin/pr/*""
+            sh ""git checkout --detach ${sha1}""
+            sh 'git fetch origin'
+            FILES = sh (
+                script: ""git diff --diff-filter=ACM --name-only origin/${ghprbTargetBranch} HEAD"",
+                returnStdout: true
+            ).trim()
+            echo FILES
+            def FILES_LIST = FILES.split(""\\r?\\n"")
+            DATE_YEAR = sh (
+                script: ""date +%Y"",
+                returnStdout: true
+            ).trim()
+            FILES_LIST.each() {
+                println ""Checking file: '${it}'""
+                RESULT = sh (
+                    script: ""grep -qE 'Copyright \\(c\\) ([0-9]{4}), ${DATE_YEAR} IBM Corp. and others' '${it}'"",
+                    returnStatus: true)
+                if(RESULT != 0) {
+                    echo ""FAILURE - Copyright date in file: '${it}' appears to be incorrect""
+                    FAIL = true
+                    BAD_FILES << ""${it}""
+                } else {
+                    echo ""Copyright date in file: appears to be correct""
+                }
+
+            }
+            if (FAIL) {
+                echo ""${HASHES}""
+                echo ""The following files were modified and have incorrect Copyrights""
+                BAD_FILES.each() {
+                    echo ""${it}""
+                }
+                echo ""${HASHES}""
+                sh 'exit 1'
+            } else {
+                echo ""All modified files appear to have correct Coprights""",fixed,
67187056,75e0fd33d283523ef359e7493455c3a8a4e37e33,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -18739,12 +18742,22 @@ J9::Z::TreeEvaluator::pd2lVariableEvaluator(TR::Node* node, TR::CodeGenerator* c
    generateRIInstruction(cg, TR::InstOpCode::AGHI, node, lengthReg, 0x1);","The commit says this has been fixed, but this line is still present. I think you may have forgot to remove it. See #218 for details.",
67189471,75e0fd33d283523ef359e7493455c3a8a4e37e33,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,True,"@@ -18739,12 +18742,22 @@ J9::Z::TreeEvaluator::pd2lVariableEvaluator(TR::Node* node, TR::CodeGenerator* c
    generateRIInstruction(cg, TR::InstOpCode::AGHI, node, lengthReg, 0x1);",Fixed.,
66829450,a186e33fdd966ecff827292924f4717ce7d7df9c,jcl/src/com.ibm.management/share/classes/com/ibm/lang/management/MemoryPoolMXBean.java,False,"@@ -28,6 +28,93 @@
  * The IBM-specific interface for managing and monitoring the virtual machine's
  * memory pools.
  *
+ * The below lists 4 common behavior changes for {@link MemoryPoolMXBean}. If you expect old behavior, 
+ * you can revert to the earlier implementation of MemoryPoolMXBean by setting the 
+ * <b>-XX:+HeapManagementMXBeanCompatibility</b> Java command line option.
+ * 
+ * <h3>1. more detailed heap memory pools can be obtained by calling {@link java.lang.management.ManagementFactory#getMemoryPoolMXBeans}</h3>
+ * The names of the heap memory pools for each garbage collection policy are as follows:
+ * <br><br>
+ *For <b>-Xgcpolicy:gencon</b>
+ *<ul>
+ *<li><b>nursery-allocate</b>
+ *<li><b>nursery-survivor</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:optthruput</b> and <b>-Xgcpolicy:optavgpause</b>
+ *<ul>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:balanced</b>
+ *<ul>
+ *<li><b>balanced-reserved</b>
+ *<li><b>balanced-eden</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:metronome</b>
+ *<ul>
+ *<li><b>JavaHeap</b>
+ *</ul>
+ *
+ * <br><p>
+ * Setting <b>-XX:+HeapManagementMXBeanCompatibility</b> on Java command line turns on compatibility with earlier versions of the VM. 
+ * Information about heap memory pools is reported in the older format.
+ * <br>
+ * The name of heap memory pool for all garbage collection policies in old format:
+ * <ul>
+ * <li><b>Java heap</b>
+ * </ul>
+ * 
+ * <h3>2. Memory Usage</h3>
+ * Memory Usage for each heap memory pool can be retrieved via {@link java.lang.management.MemoryPoolMXBean#getUsage} or {@link #getCollectionUsage}.","The U in ""Memory Usage"" shouldn't be capitalized.",
66829797,a186e33fdd966ecff827292924f4717ce7d7df9c,jcl/src/com.ibm.management/share/classes/com/ibm/lang/management/MemoryPoolMXBean.java,False,"@@ -28,6 +28,93 @@
  * The IBM-specific interface for managing and monitoring the virtual machine's
  * memory pools.
  *
+ * The below lists 4 common behavior changes for {@link MemoryPoolMXBean}. If you expect old behavior, 
+ * you can revert to the earlier implementation of MemoryPoolMXBean by setting the 
+ * <b>-XX:+HeapManagementMXBeanCompatibility</b> Java command line option.
+ * 
+ * <h3>1. more detailed heap memory pools can be obtained by calling {@link java.lang.management.ManagementFactory#getMemoryPoolMXBeans}</h3>
+ * The names of the heap memory pools for each garbage collection policy are as follows:
+ * <br><br>
+ *For <b>-Xgcpolicy:gencon</b>
+ *<ul>
+ *<li><b>nursery-allocate</b>
+ *<li><b>nursery-survivor</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:optthruput</b> and <b>-Xgcpolicy:optavgpause</b>
+ *<ul>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:balanced</b>
+ *<ul>
+ *<li><b>balanced-reserved</b>
+ *<li><b>balanced-eden</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:metronome</b>
+ *<ul>
+ *<li><b>JavaHeap</b>
+ *</ul>
+ *
+ * <br><p>
+ * Setting <b>-XX:+HeapManagementMXBeanCompatibility</b> on Java command line turns on compatibility with earlier versions of the VM. 
+ * Information about heap memory pools is reported in the older format.
+ * <br>
+ * The name of heap memory pool for all garbage collection policies in old format:
+ * <ul>
+ * <li><b>Java heap</b>
+ * </ul>
+ * 
+ * <h3>2. Memory Usage</h3>
+ * Memory Usage for each heap memory pool can be retrieved via {@link java.lang.management.MemoryPoolMXBean#getUsage} or {@link #getCollectionUsage}.
+ * In some cases the total sum of memory usage of all heap memory pools is more than the maximum heap size. 
+ * This irregularity can be caused if data for each pool is collected between garbage collection cycles,
+ * where objects have been moved or reclaimed.
+ * If you want to collect memory usage data that is synchronized across the memory pools, use the 
+ * {@link com.sun.management.GarbageCollectionNotificationInfo} or {@link com.sun.management.GarbageCollectorMXBean#getLastGcInfo} extensions.
+ * 
+ * <h3>3. Usage Threshold ({@link #getUsageThreshold}, {@link #setUsageThreshold}, {@link #isUsageThresholdExceeded})</h3>
+ * Usage threshold attribute is designed for monitoring the increasing trend of memory usage with low overhead. ",The usage threshold attribute ...,
66830047,a186e33fdd966ecff827292924f4717ce7d7df9c,jcl/src/com.ibm.management/share/classes/com/ibm/lang/management/MemoryPoolMXBean.java,False,"@@ -28,6 +28,93 @@
  * The IBM-specific interface for managing and monitoring the virtual machine's
  * memory pools.
  *
+ * The below lists 4 common behavior changes for {@link MemoryPoolMXBean}. If you expect old behavior, 
+ * you can revert to the earlier implementation of MemoryPoolMXBean by setting the 
+ * <b>-XX:+HeapManagementMXBeanCompatibility</b> Java command line option.
+ * 
+ * <h3>1. more detailed heap memory pools can be obtained by calling {@link java.lang.management.ManagementFactory#getMemoryPoolMXBeans}</h3>
+ * The names of the heap memory pools for each garbage collection policy are as follows:
+ * <br><br>
+ *For <b>-Xgcpolicy:gencon</b>
+ *<ul>
+ *<li><b>nursery-allocate</b>
+ *<li><b>nursery-survivor</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:optthruput</b> and <b>-Xgcpolicy:optavgpause</b>
+ *<ul>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:balanced</b>
+ *<ul>
+ *<li><b>balanced-reserved</b>
+ *<li><b>balanced-eden</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:metronome</b>
+ *<ul>
+ *<li><b>JavaHeap</b>
+ *</ul>
+ *
+ * <br><p>
+ * Setting <b>-XX:+HeapManagementMXBeanCompatibility</b> on Java command line turns on compatibility with earlier versions of the VM. 
+ * Information about heap memory pools is reported in the older format.
+ * <br>
+ * The name of heap memory pool for all garbage collection policies in old format:
+ * <ul>
+ * <li><b>Java heap</b>
+ * </ul>
+ * 
+ * <h3>2. Memory Usage</h3>
+ * Memory Usage for each heap memory pool can be retrieved via {@link java.lang.management.MemoryPoolMXBean#getUsage} or {@link #getCollectionUsage}.
+ * In some cases the total sum of memory usage of all heap memory pools is more than the maximum heap size. 
+ * This irregularity can be caused if data for each pool is collected between garbage collection cycles,
+ * where objects have been moved or reclaimed.
+ * If you want to collect memory usage data that is synchronized across the memory pools, use the 
+ * {@link com.sun.management.GarbageCollectionNotificationInfo} or {@link com.sun.management.GarbageCollectorMXBean#getLastGcInfo} extensions.
+ * 
+ * <h3>3. Usage Threshold ({@link #getUsageThreshold}, {@link #setUsageThreshold}, {@link #isUsageThresholdExceeded})</h3>
+ * Usage threshold attribute is designed for monitoring the increasing trend of memory usage with low overhead. 
+ * Usage threshold may not be appropriate for some memory pools.
+ * The {@link #isUsageThresholdSupported} method can be used to determine if this functionality is supported by the memory pool
+ * to avoid unexpected {@link java.lang.UnsupportedOperationException}.
+ * <br>
+ * Names of heap memory pools supporting usage threshold:
+ * <ul>
+ *<li><b>JavaHeap</b>
+ *<li><b>tenured</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ * </ul>
+ * 
+ * <h3>4. Collection Usage Threshold ({@link #getCollectionUsageThreshold}, {@link #setCollectionUsageThreshold}, {@link #isCollectionUsageThresholdExceeded})</h3>
+ * Collection usage threshold is a manageable attribute only applicable to some garbage-collected memory pools.",The collection usage threshold ...,
66830240,a186e33fdd966ecff827292924f4717ce7d7df9c,jcl/src/com.ibm.management/share/classes/com/ibm/lang/management/MemoryPoolMXBean.java,False,"@@ -28,6 +28,93 @@
  * The IBM-specific interface for managing and monitoring the virtual machine's
  * memory pools.
  *
+ * The below lists 4 common behavior changes for {@link MemoryPoolMXBean}. If you expect old behavior, 
+ * you can revert to the earlier implementation of MemoryPoolMXBean by setting the 
+ * <b>-XX:+HeapManagementMXBeanCompatibility</b> Java command line option.
+ * 
+ * <h3>1. more detailed heap memory pools can be obtained by calling {@link java.lang.management.ManagementFactory#getMemoryPoolMXBeans}</h3>
+ * The names of the heap memory pools for each garbage collection policy are as follows:
+ * <br><br>
+ *For <b>-Xgcpolicy:gencon</b>
+ *<ul>
+ *<li><b>nursery-allocate</b>
+ *<li><b>nursery-survivor</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:optthruput</b> and <b>-Xgcpolicy:optavgpause</b>
+ *<ul>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:balanced</b>
+ *<ul>
+ *<li><b>balanced-reserved</b>
+ *<li><b>balanced-eden</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:metronome</b>
+ *<ul>
+ *<li><b>JavaHeap</b>
+ *</ul>
+ *
+ * <br><p>
+ * Setting <b>-XX:+HeapManagementMXBeanCompatibility</b> on Java command line turns on compatibility with earlier versions of the VM. 
+ * Information about heap memory pools is reported in the older format.
+ * <br>
+ * The name of heap memory pool for all garbage collection policies in old format:
+ * <ul>
+ * <li><b>Java heap</b>
+ * </ul>
+ * 
+ * <h3>2. Memory Usage</h3>
+ * Memory Usage for each heap memory pool can be retrieved via {@link java.lang.management.MemoryPoolMXBean#getUsage} or {@link #getCollectionUsage}.
+ * In some cases the total sum of memory usage of all heap memory pools is more than the maximum heap size. 
+ * This irregularity can be caused if data for each pool is collected between garbage collection cycles,
+ * where objects have been moved or reclaimed.
+ * If you want to collect memory usage data that is synchronized across the memory pools, use the 
+ * {@link com.sun.management.GarbageCollectionNotificationInfo} or {@link com.sun.management.GarbageCollectorMXBean#getLastGcInfo} extensions.
+ * 
+ * <h3>3. Usage Threshold ({@link #getUsageThreshold}, {@link #setUsageThreshold}, {@link #isUsageThresholdExceeded})</h3>
+ * Usage threshold attribute is designed for monitoring the increasing trend of memory usage with low overhead. 
+ * Usage threshold may not be appropriate for some memory pools.
+ * The {@link #isUsageThresholdSupported} method can be used to determine if this functionality is supported by the memory pool
+ * to avoid unexpected {@link java.lang.UnsupportedOperationException}.
+ * <br>
+ * Names of heap memory pools supporting usage threshold:
+ * <ul>
+ *<li><b>JavaHeap</b>
+ *<li><b>tenured</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ * </ul>
+ * 
+ * <h3>4. Collection Usage Threshold ({@link #getCollectionUsageThreshold}, {@link #setCollectionUsageThreshold}, {@link #isCollectionUsageThresholdExceeded})</h3>
+ * Collection usage threshold is a manageable attribute only applicable to some garbage-collected memory pools.
+ * After a Java virtual machine has expended effort in reclaiming memory space by recycling unused objects 
+ * in a memory pool at garbage collection time, some number of bytes in the memory pools that are garbaged collected","""garbaged"" should be ""garbage""",
66876116,a186e33fdd966ecff827292924f4717ce7d7df9c,jcl/src/com.ibm.management/share/classes/com/ibm/lang/management/MemoryPoolMXBean.java,False,"@@ -28,6 +28,93 @@
  * The IBM-specific interface for managing and monitoring the virtual machine's
  * memory pools.
  *
+ * The below lists 4 common behavior changes for {@link MemoryPoolMXBean}. If you expect old behavior, 
+ * you can revert to the earlier implementation of MemoryPoolMXBean by setting the 
+ * <b>-XX:+HeapManagementMXBeanCompatibility</b> Java command line option.
+ * 
+ * <h3>1. more detailed heap memory pools can be obtained by calling {@link java.lang.management.ManagementFactory#getMemoryPoolMXBeans}</h3>
+ * The names of the heap memory pools for each garbage collection policy are as follows:
+ * <br><br>
+ *For <b>-Xgcpolicy:gencon</b>
+ *<ul>
+ *<li><b>nursery-allocate</b>
+ *<li><b>nursery-survivor</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:optthruput</b> and <b>-Xgcpolicy:optavgpause</b>
+ *<ul>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:balanced</b>
+ *<ul>
+ *<li><b>balanced-reserved</b>
+ *<li><b>balanced-eden</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:metronome</b>
+ *<ul>
+ *<li><b>JavaHeap</b>
+ *</ul>
+ *
+ * <br><p>
+ * Setting <b>-XX:+HeapManagementMXBeanCompatibility</b> on Java command line turns on compatibility with earlier versions of the VM. 
+ * Information about heap memory pools is reported in the older format.
+ * <br>
+ * The name of heap memory pool for all garbage collection policies in old format:
+ * <ul>
+ * <li><b>Java heap</b>
+ * </ul>
+ * 
+ * <h3>2. Memory Usage</h3>
+ * Memory Usage for each heap memory pool can be retrieved via {@link java.lang.management.MemoryPoolMXBean#getUsage} or {@link #getCollectionUsage}.
+ * In some cases the total sum of memory usage of all heap memory pools is more than the maximum heap size. 
+ * This irregularity can be caused if data for each pool is collected between garbage collection cycles,
+ * where objects have been moved or reclaimed.
+ * If you want to collect memory usage data that is synchronized across the memory pools, use the 
+ * {@link com.sun.management.GarbageCollectionNotificationInfo} or {@link com.sun.management.GarbageCollectorMXBean#getLastGcInfo} extensions.
+ * 
+ * <h3>3. Usage Threshold ({@link #getUsageThreshold}, {@link #setUsageThreshold}, {@link #isUsageThresholdExceeded})</h3>
+ * Usage threshold attribute is designed for monitoring the increasing trend of memory usage with low overhead. 
+ * Usage threshold may not be appropriate for some memory pools.
+ * The {@link #isUsageThresholdSupported} method can be used to determine if this functionality is supported by the memory pool
+ * to avoid unexpected {@link java.lang.UnsupportedOperationException}.
+ * <br>
+ * Names of heap memory pools supporting usage threshold:
+ * <ul>
+ *<li><b>JavaHeap</b>
+ *<li><b>tenured</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ * </ul>
+ * 
+ * <h3>4. Collection Usage Threshold ({@link #getCollectionUsageThreshold}, {@link #setCollectionUsageThreshold}, {@link #isCollectionUsageThresholdExceeded})</h3>
+ * Collection usage threshold is a manageable attribute only applicable to some garbage-collected memory pools.
+ * After a Java virtual machine has expended effort in reclaiming memory space by recycling unused objects 
+ * in a memory pool at garbage collection time, some number of bytes in the memory pools that are garbaged collected
+ * will still be in use.
+ * The {@link #isCollectionUsageThresholdSupported} method can be used to determine if this functionality is supported by 
+ * the memory pool to avoid unexpected {@link java.lang.UnsupportedOperationException}.
+ * <br>
+ * Names of heap memory pools supporting collection usage threshold:
+ * <ul>
+ *<li><b>JavaHeap</b>
+ *<li><b>tenured</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *<li><b>nursery-allocate</b>
+ *<li><b>balanced-eden</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ * </ul>
+ * ","Looking at the html output, there should be a ```<br>``` or two here.",
66885929,a186e33fdd966ecff827292924f4717ce7d7df9c,jcl/src/com.ibm.management/share/classes/com/ibm/lang/management/MemoryPoolMXBean.java,False,"@@ -28,6 +28,94 @@
  * The IBM-specific interface for managing and monitoring the virtual machine's",This should say OpenJ9 instead of IBM-specific.,
66886033,a186e33fdd966ecff827292924f4717ce7d7df9c,jcl/src/com.ibm.management/share/classes/com/ibm/lang/management/MemoryPoolMXBean.java,False,"@@ -28,6 +28,94 @@
  * The IBM-specific interface for managing and monitoring the virtual machine's
  * memory pools.
  *
+ * The below lists 4 common behavior changes for {@link MemoryPoolMXBean}. If you expect old behavior, 
+ * you can revert to the earlier implementation of MemoryPoolMXBean by setting the 
+ * <b>-XX:+HeapManagementMXBeanCompatibility</b> Java command line option.
+ * 
+ * <h3>1. more detailed heap memory pools can be obtained by calling {@link java.lang.management.ManagementFactory#getMemoryPoolMXBeans}</h3>",more should be More,
67109781,a186e33fdd966ecff827292924f4717ce7d7df9c,jcl/src/com.ibm.management/share/classes/com/ibm/lang/management/MemoryPoolMXBean.java,False,"@@ -25,9 +25,95 @@
 import java.lang.management.MemoryUsage;
 
 /**
- * The IBM-specific interface for managing and monitoring the virtual machine's
+ * The OpenJ9 interface for managing and monitoring the virtual machine's
  * memory pools.
  *
+ * The following list describes 4 common behavior changes for {@link MemoryPoolMXBean}. 
+ * You can revert to the earlier implementation of {@link MemoryPoolMXBean} by setting the 
+ * <b>-XX:+HeapManagementMXBeanCompatibility</b> Java command line option.
+ * 
+ * <h3>1. More detailed heap memory pools can be obtained by calling {@link java.lang.management.ManagementFactory#getMemoryPoolMXBeans}</h3>
+ * The following names are reported for heap memory pools, listed by garbage collection policy:
+ * <br><br>
+ *For <b>-Xgcpolicy:gencon</b>
+ *<ul>
+ *<li><b>nursery-allocate</b>
+ *<li><b>nursery-survivor</b>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:optthruput</b> and <b>-Xgcpolicy:optavgpause</b>
+ *<ul>
+ *<li><b>tenured-LOA</b>
+ *<li><b>tenured-SOA</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:balanced</b>
+ *<ul>
+ *<li><b>balanced-reserved</b>
+ *<li><b>balanced-eden</b>
+ *<li><b>balanced-survivor</b>
+ *<li><b>balanced-old</b>
+ *</ul>
+ * <br>
+ *For <b>-Xgcpolicy:metronome</b>
+ *<ul>
+ *<li><b>JavaHeap</b>
+ *</ul>
+ *
+ * <br><p>
+ * If you set the <b>-XX:+HeapManagementMXBeanCompatibility</b> option to turn on compatibility with earlier versions of the VM,
+ * information about heap memory pools is reported in the older format.
+ * <br>
+ * The following name is reported for the heap memory pool for all garbage collection policies in the old format:
+ * <ul>
+ * <li><b>Java heap</b>
+ * </ul>
+ * 
+ * <h3>2. Memory Usage</h3>
+ * Memory usage for each heap memory pool can be retrieved by using {@link java.lang.management.MemoryPoolMXBean#getUsage} or {@link java.lang.management.MemoryPoolMXBean#getCollectionUsage}.
+ * In some cases the total sum of memory usage of all heap memory pools is more than the maximum heap size. 
+ * This irregularity can be caused if data for each pool is collected between garbage collection cycles,
+ * where objects have been moved or reclaimed.
+ * If you want to collect memory usage data that is synchronized across the memory pools, use the 
+ * {@link com.sun.management.GarbageCollectionNotificationInfo} or {@link com.sun.management.GarbageCollectorMXBean#getLastGcInfo} extensions.
+ * 
+ * <h3>3. Usage Threshold ({@link java.lang.management.MemoryPoolMXBean#getUsageThreshold}, {@link java.lang.management.MemoryPoolMXBean#setUsageThreshold}, {@link java.lang.management.MemoryPoolMXBean#isUsageThresholdExceeded})</h3>
+ * The usage threshold attribute is designed for monitoring the increasing trend of memory usage and incurs only a low overhead.
+ * This attribute might not be appropriate for some memory pools.","Instead of ""might not be"" use ""is not"".",
67368035,9b9559cab1f03437c9a0909f3a9dee055b64b9aa,runtime/tr.source/trj9/env/j9method.cpp,False,"@@ -5248,6 +5284,247 @@ TR_J9MethodBase::isUnsafeWithObjectArg(TR::Compilation * c)
    }
 
 bool
+TR_J9MethodBase::isUnsafeGetPutWithObjectArg(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putByteOrdered_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBooleanOrdered_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putCharOrdered_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShortOrdered_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putIntOrdered_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLongOrdered_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloatOrdered_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDoubleOrdered_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObjectOrdered_jlObjectJjlObject_V:
+         return true;
+      default:
+         return false;
+      }
+
+   return false;
+   }
+
+TR::DataType
+TR_J9MethodBase::unsafeDataTypeForObject(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+         return TR::Int32;
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+         return TR::Int64;
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+         return TR::Float;
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+         return TR::Double;
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+         return TR::Address;
+      default:
+         return TR::NoType;",Should this assert?,
67368088,9b9559cab1f03437c9a0909f3a9dee055b64b9aa,runtime/tr.source/trj9/env/j9method.cpp,False,"@@ -5248,6 +5284,247 @@ TR_J9MethodBase::isUnsafeWithObjectArg(TR::Compilation * c)
    }
 
 bool
+TR_J9MethodBase::isUnsafeGetPutWithObjectArg(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putByteOrdered_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBooleanOrdered_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putCharOrdered_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShortOrdered_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putIntOrdered_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLongOrdered_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloatOrdered_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDoubleOrdered_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObjectOrdered_jlObjectJjlObject_V:
+         return true;
+      default:
+         return false;
+      }
+
+   return false;
+   }
+
+TR::DataType
+TR_J9MethodBase::unsafeDataTypeForObject(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+         return TR::Int32;
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+         return TR::Int64;
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+         return TR::Float;
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+         return TR::Double;
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+         return TR::Address;
+      default:
+         return TR::NoType;
+      }
+   return TR::NoType;
+   }
+
+TR::DataType
+TR_J9MethodBase::unsafeDataTypeForArray(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+         return TR::Int8;
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+         return TR::Int16;
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+         return TR::Int32;
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+         return TR::Int64;
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+         return TR::Float;
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+         return TR::Double;
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+         return TR::Address;
+      default:
+         return TR::NoType;",should this assert?,
67368950,9b9559cab1f03437c9a0909f3a9dee055b64b9aa,runtime/tr.source/trj9/optimizer/UnsafeFastPath.cpp,False,"@@ -349,13 +392,36 @@ int32_t TR_UnsafeFastPath::perform()
 
          if (type != TR::NoType && performTransformation(comp(), ""%s Found unsafe/JITHelpers calls, turning node ["" POINTER_PRINTF_FORMAT ""] into a load/store\n"", optDetailString(), node))
             {
+
             TR::SymbolReference * unsafeSymRef = comp()->getSymRefTab()->findOrCreateUnsafeSymbolRef(type, true, false, isVolatile);
 
+            // Change the object child to the starting address of static fields in J9Class
+            if (isStatic)
+               {
+               TR::Node *jlClass = node->getChild(1);
+               TR::Node *j9Class =
+                  TR::Node::createWithSymRef(TR::aloadi, 1, 1, jlClass,
+                                  comp()->getSymRefTab()->findOrCreateClassFromJavaLangClassSymbolRef());
+               TR::Node *ramStatics =
+                  TR::Node::createWithSymRef(TR::aloadi, 1, 1, j9Class,
+                                  comp()->getSymRefTab()->findOrCreateRamStaticsFromClassSymbolRef());
+               node->setAndIncChild(1, ramStatics);
+               jlClass->recursivelyDecReferenceCount();
+               offset = node->getChild(2);
+               TR::Node *newOffset =",could you put a comment on what is happening here?,
67390164,9b9559cab1f03437c9a0909f3a9dee055b64b9aa,runtime/tr.source/trj9/optimizer/UnsafeFastPath.cpp,False,"@@ -349,13 +392,37 @@ int32_t TR_UnsafeFastPath::perform()
 
          if (type != TR::NoType && performTransformation(comp(), ""%s Found unsafe/JITHelpers calls, turning node ["" POINTER_PRINTF_FORMAT ""] into a load/store\n"", optDetailString(), node))
             {
+
             TR::SymbolReference * unsafeSymRef = comp()->getSymRefTab()->findOrCreateUnsafeSymbolRef(type, true, false, isVolatile);
 
+            // Change the object child to the starting address of static fields in J9Class
+            if (isStatic)
+               {
+               TR::Node *jlClass = node->getChild(1);
+               TR::Node *j9Class =
+                  TR::Node::createWithSymRef(TR::aloadi, 1, 1, jlClass,
+                                  comp()->getSymRefTab()->findOrCreateClassFromJavaLangClassSymbolRef());
+               TR::Node *ramStatics =
+                  TR::Node::createWithSymRef(TR::aloadi, 1, 1, j9Class,
+                                  comp()->getSymRefTab()->findOrCreateRamStaticsFromClassSymbolRef());
+               node->setAndIncChild(1, ramStatics);
+               jlClass->recursivelyDecReferenceCount();
+               offset = node->getChild(2);
+               // The offset for a static field is low taged, mask out the last bit to get the real offset
+               TR::Node *newOffset =
+                  TR::Node::create(offset, TR::land, 2, offset,
+                                  TR::Node::lconst(offset, -2));",can you write this as ~1 rather than -2 so that it is a bit more clear.,
67411122,761cc0d206f0f4ed8731178bbb370b9662b90b5a,test/TestConfig/scripts/tools/getDependencies.pl,False,"@@ -99,6 +131,16 @@
 die ""ERROR: downloading $url failed, return code: $? \n"";
 }
 }
+
+# validate dependencies sha1 sum
+$sha->addfile($filename);
+$digest = $sha->hexdigest ;
+if ( $digest ne $jars_info[$i]{sha1}) {
+print ""Expected sha1 is: $jars_info[$i]{sha1}, \n"";
+print ""Actual sha1 is  : $digest. \n"";
+print ""Please delete the existing one and download it again!"";","I just want this message to be more clear. Instead of ""Please delete the existing one and download it again!"", I think we should say something like - Please delete $filename and rerun the program!",
67411665,761cc0d206f0f4ed8731178bbb370b9662b90b5a,test/TestConfig/scripts/tools/getDependencies.pl,False,"@@ -99,6 +131,16 @@
 die ""ERROR: downloading $url failed, return code: $? \n"";
 }
 }
+
+# validate dependencies sha1 sum
+$sha->addfile($filename);
+$digest = $sha->hexdigest ;
+if ( $digest ne $jars_info[$i]{sha1}) {
+print ""Expected sha1 is: $jars_info[$i]{sha1}, \n"";
+print ""Actual sha1 is  : $digest. \n"";
+print ""Please delete the existing one and download it again!"";
+die ""ERRPR: $filename is broken, the sha1 sum is not invalid. \n"";
+}",this is valid or invalid? :),
67416630,761cc0d206f0f4ed8731178bbb370b9662b90b5a,test/TestConfig/scripts/tools/getDependencies.pl,True,"@@ -99,6 +131,16 @@
 die ""ERROR: downloading $url failed, return code: $? \n"";
 }
 }
+
+# validate dependencies sha1 sum
+$sha->addfile($filename);
+$digest = $sha->hexdigest ;
+if ( $digest ne $jars_info[$i]{sha1}) {
+print ""Expected sha1 is: $jars_info[$i]{sha1}, \n"";
+print ""Actual sha1 is  : $digest. \n"";
+print ""Please delete the existing one and download it again!"";","message updated.
",
67416758,761cc0d206f0f4ed8731178bbb370b9662b90b5a,test/TestConfig/scripts/tools/getDependencies.pl,True,"@@ -99,6 +131,16 @@
 die ""ERROR: downloading $url failed, return code: $? \n"";
 }
 }
+
+# validate dependencies sha1 sum
+$sha->addfile($filename);
+$digest = $sha->hexdigest ;
+if ( $digest ne $jars_info[$i]{sha1}) {
+print ""Expected sha1 is: $jars_info[$i]{sha1}, \n"";
+print ""Actual sha1 is  : $digest. \n"";
+print ""Please delete the existing one and download it again!"";
+die ""ERRPR: $filename is broken, the sha1 sum is not invalid. \n"";
+}","It's invalid, thanks for pointing it out. Error message is updated.",
67490780,b733c4a934c58303fd06b7ccebf7b9053df021fa,.travis.yml,False,"@@ -28,57 +28,61 @@ dist: trusty
 addons:
   apt:
     packages:
-      - autoconf 
-      - ca-certificates 
-      - ccache 
-      - cpio 
-      - file 
-      - g++-4.8 
-      - gcc-4.8 
-      - git 
-      - git-core 
-      - libasound2-dev 
-      - libcups2-dev 
-      - libelf-dev 
-      - libfreetype6-dev 
-      - libnuma-dev 
-      - libx11-dev 
-      - libxext-dev 
-      - libxrender-dev 
-      - libxt-dev 
-      - libxtst-dev 
-      - make 
-      - openjdk-8-jdk 
-      - pkg-config 
-      - realpath 
-      - ssh 
-      - unzip 
-      - wget 
-      - zip 
+      - autoconf
+      - ca-certificates
+      - ccache
+      - cpio
+      - file
+      - g++-4.8
+      - gcc-4.8
+      - git
+      - git-core
+      - libasound2-dev
+      - libcups2-dev
+      - libelf-dev
+      - libfreetype6-dev
+      - libnuma-dev
+      - libx11-dev
+      - libxext-dev
+      - libxrender-dev
+      - libxt-dev
+      - libxtst-dev
+      - make
+      - openjdk-8-jdk
+      - pkg-config
+      - realpath
+      - ssh
+      - unzip
+      - wget
+      - zip
 before_install:
   - jdk_switcher use oraclejdk8
 env:
   global:
 before_script:
-        #  - ccache -s -z
+  # - ccache -s -z
+  # Exit immediately if any unexpected error occurs.
+  - set -e
   - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
   - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
   - cd ..
-  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load
+  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load.
   - git clone --depth 1 https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
 script:
-  # Clear this option so it doesn't interfere with configure detecting the bootjdk
+  # Clear this option so it doesn't interfere with configure detecting the bootjdk.
   - unset _JAVA_OPTIONS
-  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.  
-  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win. 
-  - cd openj9-openjdk-jdk9 && bash ./get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT
-  # Based on https://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/ travis container builds
-  # have 2 cores and 4 gigs of memory.  Attempt to double provision the number of cores for the make...
-  # Limit number of jobs to work around g++ internal compiler error
-  - export UMA_WINDOWS_PARRALLEL_HACK=""-j4""
-  - bash ./configure --with-freemarker-jar=$TRAVIS_BUILD_DIR/freemarker.jar --with-jobs=4 --with-num-cores=4
+  # Exit immediately if any unexpected error occurs.
+  - set -e
+  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.
+  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win.
+  - cd openj9-openjdk-jdk9 && bash get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT",We should stop specifying `-openj9-branch` since we really only care about `-openj9-sha`,
67502472,b733c4a934c58303fd06b7ccebf7b9053df021fa,.travis.yml,False,"@@ -28,57 +28,61 @@ dist: trusty
 addons:
   apt:
     packages:
-      - autoconf 
-      - ca-certificates 
-      - ccache 
-      - cpio 
-      - file 
-      - g++-4.8 
-      - gcc-4.8 
-      - git 
-      - git-core 
-      - libasound2-dev 
-      - libcups2-dev 
-      - libelf-dev 
-      - libfreetype6-dev 
-      - libnuma-dev 
-      - libx11-dev 
-      - libxext-dev 
-      - libxrender-dev 
-      - libxt-dev 
-      - libxtst-dev 
-      - make 
-      - openjdk-8-jdk 
-      - pkg-config 
-      - realpath 
-      - ssh 
-      - unzip 
-      - wget 
-      - zip 
+      - autoconf
+      - ca-certificates
+      - ccache
+      - cpio
+      - file
+      - g++-4.8
+      - gcc-4.8
+      - git
+      - git-core
+      - libasound2-dev
+      - libcups2-dev
+      - libelf-dev
+      - libfreetype6-dev
+      - libnuma-dev
+      - libx11-dev
+      - libxext-dev
+      - libxrender-dev
+      - libxt-dev
+      - libxtst-dev
+      - make
+      - openjdk-8-jdk
+      - pkg-config
+      - realpath
+      - ssh
+      - unzip
+      - wget
+      - zip
 before_install:
   - jdk_switcher use oraclejdk8
 env:
   global:
 before_script:
-        #  - ccache -s -z
+  # - ccache -s -z
+  # Exit immediately if any unexpected error occurs.
+  - set -e
   - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
   - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
   - cd ..
-  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load
+  # Shallow clone of the openj9-openjdk-jdk9 repo to speed up clone / reduce server load.
   - git clone --depth 1 https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
 script:
-  # Clear this option so it doesn't interfere with configure detecting the bootjdk
+  # Clear this option so it doesn't interfere with configure detecting the bootjdk.
   - unset _JAVA_OPTIONS
-  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.  
-  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win. 
-  - cd openj9-openjdk-jdk9 && bash ./get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT
-  # Based on https://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/ travis container builds
-  # have 2 cores and 4 gigs of memory.  Attempt to double provision the number of cores for the make...
-  # Limit number of jobs to work around g++ internal compiler error
-  - export UMA_WINDOWS_PARRALLEL_HACK=""-j4""
-  - bash ./configure --with-freemarker-jar=$TRAVIS_BUILD_DIR/freemarker.jar --with-jobs=4 --with-num-cores=4
+  # Exit immediately if any unexpected error occurs.
+  - set -e
+  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.
+  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win.
+  - cd openj9-openjdk-jdk9 && bash get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT","I suppose it doesn't really matter. `$TRAVIS_BRANCH=master` and the default is `master` so it doesn't really change anything. If at some point the get_source script changes its default, we would probably want `TRAVIS_BRANCH` instead, although it doesn't really matter because he checkout the SHA anyways.",
67492867,35fba96aa6621ba70790d68b52c72c9b7d8b30d2,sourcetools/com.ibm.uma/com/ibm/uma/om/Module.java,False,"@@ -64,7 +64,12 @@ public void addArtifact(Artifact artifact) throws UMAException {
 }
 
 public void addExports(String group, Exports exps) {
-exports.put(group, exps);
+if ( exports.keySet().contains(group) ) {",containsKey() would also work,
67493160,35fba96aa6621ba70790d68b52c72c9b7d8b30d2,sourcetools/com.ibm.uma/com/ibm/uma/om/Module.java,False,"@@ -64,7 +64,12 @@ public void addArtifact(Artifact artifact) throws UMAException {
 }
 
 public void addExports(String group, Exports exps) {
-exports.put(group, exps);
+if ( exports.keySet().contains(group) ) {
+exps.addExports(exports.get(group));","To avoid unexpected problems, and just as good practice, please create a new Exports rather than modifying the parameter.",
67502364,35fba96aa6621ba70790d68b52c72c9b7d8b30d2,sourcetools/com.ibm.uma/com/ibm/uma/om/Module.java,True,"@@ -64,7 +64,12 @@ public void addArtifact(Artifact artifact) throws UMAException {
 }
 
 public void addExports(String group, Exports exps) {
-exports.put(group, exps);
+if ( exports.keySet().contains(group) ) {
+exps.addExports(exports.get(group));","@pshipton Fixed as suggested, thx!",
67507151,35fba96aa6621ba70790d68b52c72c9b7d8b30d2,sourcetools/com.ibm.uma/com/ibm/uma/om/Module.java,False,"@@ -64,7 +64,13 @@ public void addArtifact(Artifact artifact) throws UMAException {
 }
 
 public void addExports(String group, Exports exps) {
-exports.put(group, exps);
+if ( exports.containsKey(group) ) {
+Exports allGroupExports = exports.get(group);
+allGroupExports.addExports(exps);
+exports.replace(group, allGroupExports);","This shouldn't be needed, since the Exports in the Map was already modified on the previous line.",
67517362,35fba96aa6621ba70790d68b52c72c9b7d8b30d2,sourcetools/com.ibm.uma/com/ibm/uma/om/Module.java,True,"@@ -64,7 +64,13 @@ public void addArtifact(Artifact artifact) throws UMAException {
 }
 
 public void addExports(String group, Exports exps) {
-exports.put(group, exps);
+if ( exports.containsKey(group) ) {
+Exports allGroupExports = exports.get(group);
+allGroupExports.addExports(exps);
+exports.replace(group, allGroupExports);","Right, corrected, thx!",
67479688,99822ef344d4e72688c39947c812f78654e70852,test/Utils/src/org/openj9/test/util/IncludeExcludeTestAnnotationTransformer.java,False,"@@ -42,7 +42,7 @@
 String line = null;
 String excludeFile = System.getenv(""EXCLUDE_FILE"");
 if (null == excludeFile) {
-excludeFile = IncludeExcludeTestAnnotationTransformer.class.getClassLoader().getResource(""excludes/default_exclude.txt"").getFile();
+excludeFile = IncludeExcludeTestAnnotationTransformer.class.getClassLoader().getResource(""excludes/openj9_exclude.txt"").getFile();
 }","I think we have to keep the default to be ""default_exclude.txt"".",
67524927,99822ef344d4e72688c39947c812f78654e70852,test/Utils/src/org/openj9/test/util/IncludeExcludeTestAnnotationTransformer.java,True,"@@ -42,7 +42,7 @@
 String line = null;
 String excludeFile = System.getenv(""EXCLUDE_FILE"");
 if (null == excludeFile) {
-excludeFile = IncludeExcludeTestAnnotationTransformer.class.getClassLoader().getResource(""excludes/default_exclude.txt"").getFile();
+excludeFile = IncludeExcludeTestAnnotationTransformer.class.getClassLoader().getResource(""excludes/openj9_exclude.txt"").getFile();
 }",change default back to default_exclude.txt,
66044458,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -1667,20 +1671,67 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
+ * @throws NullPointerException - if any of the arguments is null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
 public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+if ((null == targetClass) || (null == callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must be non-null""]*/
+System.out.println(""NullPointerException K065S: Both the requested class and the caller lookup must be non-null""); //$NON-NLS-1$",Remove the System.out.println call.,
66044530,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -1667,20 +1671,67 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
+ * @throws NullPointerException - if any of the arguments is null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
 public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+if ((null == targetClass) || (null == callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must be non-null""]*/
+System.out.println(""NullPointerException K065S: Both the requested class and the caller lookup must be non-null""); //$NON-NLS-1$
+throw new NullPointerException(com.ibm.oti.util.Msg.getString(""K065S"")); //$NON-NLS-1$",This is a good candidate for `Objects.notNull()`,
66545668,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -1667,20 +1671,67 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
+ * @throws NullPointerException - if any of the arguments is null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
 public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+if ((null == targetClass) || (null == callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must be non-null""]*/
+System.out.println(""NullPointerException K065S: Both the requested class and the caller lookup must be non-null""); //$NON-NLS-1$",These printing messages were used for test and already removed.,
66545762,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -1667,20 +1671,67 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
+ * @throws NullPointerException - if any of the arguments is null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
 public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+if ((null == targetClass) || (null == callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must be non-null""]*/
+System.out.println(""NullPointerException K065S: Both the requested class and the caller lookup must be non-null""); //$NON-NLS-1$
+throw new NullPointerException(com.ibm.oti.util.Msg.getString(""K065S"")); //$NON-NLS-1$",Already replaced with Objects.isNull(),
66773728,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/playlist.xml,False,"@@ -38,12 +39,13 @@
 </subsets>
 </test>
 
-<test>
-<testCaseName>openj9_jsr292Test_JitCount0_SE90</testCaseName>
-<variations>
+<test>
+<testCaseName>openj9_jsr292Test_JitCount0_SE90</testCaseName>
+<variations>
 <variation>-Xjit:count=0</variation>
-</variations>
+</variations>",Please add one more indentation before \<testCaseName\> \<variations\> and \</variations\>.,
66896016,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -1735,22 +1735,64 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-SE-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
+ * @throws NullPointerException - if any of the arguments is null
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
-public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws NullPointerException, IllegalArgumentException, IllegalAccessException, SecurityException {
+if (Objects.isNull(targetClass) || Objects.isNull(callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must be non-null""]*/
+throw new NullPointerException(com.ibm.oti.util.Msg.getString(""K065S"")); //$NON-NLS-1$
+}
+
+if (targetClass.isPrimitive() || targetClass.isArray()) {
+/*[MSG ""K065T"", ""The target class: {0} must not be a primitive type or an array class""]*/
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K065T"", targetClass.getCanonicalName())); //$NON-NLS-1$
+}
+
+Module targetClassModule = targetClass.getModule();
+String targetClassPackageName = targetClass.getPackageName();
+Module accessClassModule = callerLookup.accessClass.getModule();
+
+/* Check whether the named module containing the old lookup can read the module containing the target class.
+ * Note: an unnamed module can read any module.
+ */
+if (accessClassModule.isNamed() && (!accessClassModule.canRead(targetClassModule))) {
+/*[MSG ""K065U"", ""The module: {0} containing the old lookup can't read the module: {1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065U"", accessClassModule.getName(), targetClassModule.getName())); //$NON-NLS-1$
+}
+
+/* Check whether the module has the package (containing the target class) opened to
+ * the module containing the old lookup.
+ */
+if (!targetClassModule.isOpen(targetClassPackageName, accessClassModule)) {
+/*[MSG ""K065V"", ""The package: {0} containing the target class is not opened to the module: {1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065V"", targetClassPackageName, accessClassModule.getName())); //$NON-NLS-1$
+}
+
+int callerLookupMode = callerLookup.lookupModes();
+if (Lookup.MODULE != (Lookup.MODULE & callerLookupMode)) {
+/*[MSG ""K065W"", ""The access mode: 0x{0} of the caller lookup doesn't have the MODULE mode : 0x{1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065W"", Integer.toHexString(callerLookupMode), Integer.toHexString(Lookup.MODULE))); //$NON-NLS-1$
+}
+
+SecurityManager secmgr = System.getSecurityManager();
+if (null != secmgr) {
+secmgr.checkPermission(new ReflectPermission(""suppressAccessChecks"")); //$NON-NLS-1$",This `RuntimePermission` can be defined within `com\ibm\oti\util\RuntimePermissions.java` as a static constant.,
66897722,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulea/mods/modulea/package1/AnotherModuleExample.java,False,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others","Pls use `2017, 2017` instead.",
66897923,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulea/mods/modulea/package1/ModuleExample.java,False,"@@ -0,0 +1,32 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Same as comments above.,
66897960,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulea/mods/modulea/package2/SameModuleExample.java,False,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Same as comments above.,
66898023,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.moduleb/mods/moduleb/package1/DifferentModuleExample1.java,False,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Same as comments above.,
66898071,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.moduleb/module-info.java,False,"@@ -0,0 +1,22 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others
",Same as comments above.,
66898103,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulec/mods/modulec/package1/DifferentModuleExample2.java,False,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Same as comments above.,
66898146,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulec/module-info.java,False,"@@ -0,0 +1,21 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others
",Same as comments above.,
66898215,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/src/com/ibm/j9/jsr292/api/MethodHandleAPI_privateLookupIn.java,False,"@@ -0,0 +1,152 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Same as comments above.,
66899091,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/com/ibm/oti/util/ExternalMessages-MasterIndex.properties,False,"@@ -1239,6 +1239,11 @@ K065O=The parameter types of init doesn't match that of iterator: {0} != {1}
 K065P=The external parameter types of body: {0} doesn't match the external parameter list: {1}
 K065Q=The loop body must be non-null
 K065R=The requested lookup mode: 0x{0} is not one of the existing access modes: 0x{1}
+K065S=Both the requested class and the caller lookup must be non-null",_must not be null_ sounds better.,
66900391,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -1735,22 +1735,64 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-SE-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
+ * @throws NullPointerException - if any of the arguments is null","Pls be specific about the argument, `targetClass` or `callerLookup`.",
66901328,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -1735,22 +1735,64 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-SE-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
+ * @throws NullPointerException - if any of the arguments is null
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
-public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws NullPointerException, IllegalArgumentException, IllegalAccessException, SecurityException {
+if (Objects.isNull(targetClass) || Objects.isNull(callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must be non-null""]*/
+throw new NullPointerException(com.ibm.oti.util.Msg.getString(""K065S"")); //$NON-NLS-1$
+}
+
+if (targetClass.isPrimitive() || targetClass.isArray()) {
+/*[MSG ""K065T"", ""The target class: {0} must not be a primitive type or an array class""]*/
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K065T"", targetClass.getCanonicalName())); //$NON-NLS-1$
+}
+
+Module targetClassModule = targetClass.getModule();
+String targetClassPackageName = targetClass.getPackageName();
+Module accessClassModule = callerLookup.accessClass.getModule();
+
+/* Check whether the named module containing the old lookup can read the module containing the target class.
+ * Note: an unnamed module can read any module.
+ */
+if (accessClassModule.isNamed() && (!accessClassModule.canRead(targetClassModule))) {",`accessClassModule.isNamed()` is redundant. `Module.canRead()` handles unnamed module case internally.,
67124310,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/playlist.xml,True,"@@ -38,12 +39,13 @@
 </subsets>
 </test>
 
-<test>
-<testCaseName>openj9_jsr292Test_JitCount0_SE90</testCaseName>
-<variations>
+<test>
+<testCaseName>openj9_jsr292Test_JitCount0_SE90</testCaseName>
+<variations>
 <variation>-Xjit:count=0</variation>
-</variations>
+</variations>",Fixed.,
67124577,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -1735,22 +1735,64 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-SE-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
+ * @throws NullPointerException - if any of the arguments is null
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
-public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws NullPointerException, IllegalArgumentException, IllegalAccessException, SecurityException {
+if (Objects.isNull(targetClass) || Objects.isNull(callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must be non-null""]*/
+throw new NullPointerException(com.ibm.oti.util.Msg.getString(""K065S"")); //$NON-NLS-1$
+}
+
+if (targetClass.isPrimitive() || targetClass.isArray()) {
+/*[MSG ""K065T"", ""The target class: {0} must not be a primitive type or an array class""]*/
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K065T"", targetClass.getCanonicalName())); //$NON-NLS-1$
+}
+
+Module targetClassModule = targetClass.getModule();
+String targetClassPackageName = targetClass.getPackageName();
+Module accessClassModule = callerLookup.accessClass.getModule();
+
+/* Check whether the named module containing the old lookup can read the module containing the target class.
+ * Note: an unnamed module can read any module.
+ */
+if (accessClassModule.isNamed() && (!accessClassModule.canRead(targetClassModule))) {
+/*[MSG ""K065U"", ""The module: {0} containing the old lookup can't read the module: {1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065U"", accessClassModule.getName(), targetClassModule.getName())); //$NON-NLS-1$
+}
+
+/* Check whether the module has the package (containing the target class) opened to
+ * the module containing the old lookup.
+ */
+if (!targetClassModule.isOpen(targetClassPackageName, accessClassModule)) {
+/*[MSG ""K065V"", ""The package: {0} containing the target class is not opened to the module: {1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065V"", targetClassPackageName, accessClassModule.getName())); //$NON-NLS-1$
+}
+
+int callerLookupMode = callerLookup.lookupModes();
+if (Lookup.MODULE != (Lookup.MODULE & callerLookupMode)) {
+/*[MSG ""K065W"", ""The access mode: 0x{0} of the caller lookup doesn't have the MODULE mode : 0x{1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065W"", Integer.toHexString(callerLookupMode), Integer.toHexString(Lookup.MODULE))); //$NON-NLS-1$
+}
+
+SecurityManager secmgr = System.getSecurityManager();
+if (null != secmgr) {
+secmgr.checkPermission(new ReflectPermission(""suppressAccessChecks"")); //$NON-NLS-1$",Agreed and fixed as suggested.,
67124669,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulea/mods/modulea/package1/AnotherModuleExample.java,True,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Updated.,
67124695,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulea/mods/modulea/package1/ModuleExample.java,True,"@@ -0,0 +1,32 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Updated.,
67124720,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.moduleb/mods/moduleb/package1/DifferentModuleExample1.java,True,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Updated.,
67124740,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulea/mods/modulea/package2/SameModuleExample.java,True,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Updated.,
67124785,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.moduleb/module-info.java,True,"@@ -0,0 +1,22 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others
",Updated.,
67124836,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulec/mods/modulec/package1/DifferentModuleExample2.java,True,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others",Updated.,
67124881,11eebe747ee4282d293ed2bc71fca16f2dc39e15,test/OpenJ9_Jsr_292_API/modules/mods.modulec/module-info.java,True,"@@ -0,0 +1,21 @@
+/*******************************************************************************
+ * Copyright (c) 2017 IBM Corp. and others
",Updated.,
67124904,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/com/ibm/oti/util/ExternalMessages-MasterIndex.properties,True,"@@ -1239,6 +1239,11 @@ K065O=The parameter types of init doesn't match that of iterator: {0} != {1}
 K065P=The external parameter types of body: {0} doesn't match the external parameter list: {1}
 K065Q=The loop body must be non-null
 K065R=The requested lookup mode: 0x{0} is not one of the existing access modes: 0x{1}
+K065S=Both the requested class and the caller lookup must be non-null",Updated.,
67124928,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -1735,22 +1735,64 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-SE-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
+ * @throws NullPointerException - if any of the arguments is null",Updated.,
67124982,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -1735,22 +1735,64 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-SE-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
+ * @throws NullPointerException - if any of the arguments is null
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
-public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws NullPointerException, IllegalArgumentException, IllegalAccessException, SecurityException {
+if (Objects.isNull(targetClass) || Objects.isNull(callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must be non-null""]*/
+throw new NullPointerException(com.ibm.oti.util.Msg.getString(""K065S"")); //$NON-NLS-1$
+}
+
+if (targetClass.isPrimitive() || targetClass.isArray()) {
+/*[MSG ""K065T"", ""The target class: {0} must not be a primitive type or an array class""]*/
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K065T"", targetClass.getCanonicalName())); //$NON-NLS-1$
+}
+
+Module targetClassModule = targetClass.getModule();
+String targetClassPackageName = targetClass.getPackageName();
+Module accessClassModule = callerLookup.accessClass.getModule();
+
+/* Check whether the named module containing the old lookup can read the module containing the target class.
+ * Note: an unnamed module can read any module.
+ */
+if (accessClassModule.isNamed() && (!accessClassModule.canRead(targetClassModule))) {",Agreed and fixed.,
67521183,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -1735,22 +1735,64 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-SE-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
+ * @throws NullPointerException - if targetClass or callerLookup is null
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
-public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws NullPointerException, IllegalArgumentException, IllegalAccessException, SecurityException {
+if (Objects.isNull(targetClass) || Objects.isNull(callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must not be null""]*/
+throw new NullPointerException(com.ibm.oti.util.Msg.getString(""K065S"")); //$NON-NLS-1$
+}
+
+if (targetClass.isPrimitive() || targetClass.isArray()) {
+/*[MSG ""K065T"", ""The target class: {0} must not be a primitive type or an array class""]*/
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K065T"", targetClass.getCanonicalName())); //$NON-NLS-1$
+}
+
+Module targetClassModule = targetClass.getModule();
+String targetClassPackageName = targetClass.getPackageName();
+Module accessClassModule = callerLookup.accessClass.getModule();
+
+/* Check whether the named module containing the old lookup can read the module containing the target class.
+ * Note: an unnamed module can read any module.
+ */
+if (!accessClassModule.canRead(targetClassModule)) {
+/*[MSG ""K065U"", ""The module: {0} containing the old lookup can't read the module: {1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065U"", accessClassModule.getName(), targetClassModule.getName())); //$NON-NLS-1$
+}
+
+/* Check whether the module has the package (containing the target class) opened to
+ * the module containing the old lookup.
+ */
+if (!targetClassModule.isOpen(targetClassPackageName, accessClassModule)) {
+/*[MSG ""K065V"", ""The package: {0} containing the target class is not opened to the module: {1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065V"", targetClassPackageName, accessClassModule.getName())); //$NON-NLS-1$
+}
+
+int callerLookupMode = callerLookup.lookupModes();
+if (Lookup.MODULE != (Lookup.MODULE & callerLookupMode)) {
+/*[MSG ""K065W"", ""The access mode: 0x{0} of the caller lookup doesn't have the MODULE mode : 0x{1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065W"", Integer.toHexString(callerLookupMode), Integer.toHexString(Lookup.MODULE))); //$NON-NLS-1$
+}
+
+SecurityManager secmgr = System.getSecurityManager();
+if (null != secmgr) {
+secmgr.checkPermission(com.ibm.oti.util.ReflectPermissions.permissionSuppressAccessChecks);","There is another occurrence of `new ReflectPermission(""suppressAccessChecks"")` at method `reflectAs`, pls change it to `ReflectPermissions.permissionSuppressAccessChecks` as well.",
67710717,11eebe747ee4282d293ed2bc71fca16f2dc39e15,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -1735,22 +1735,64 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi
 return Lookup.PUBLIC_LOOKUP;
 }
 
-/*[IF Sidecar19-SE]*/
+/*[IF Sidecar19-SE-B175]*/
 /**
- * Return a MethodHandles.Lookup object that is only able to access <code>private</code> members.
+ * Return a MethodHandles.Lookup object with full capabilities including the access 
+ * to the <code>private</code> members in the requested class
  * 
  * @param targetClass - the requested class containing private members
  * @param callerLookup - a Lookup object specific to the caller
  * @return a MethodHandles.Lookup object with private access to the requested class
+ * @throws NullPointerException - if targetClass or callerLookup is null
  * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class
- * @throws NullPointerException - if any of the arguments are null
  * @throws IllegalAccessException - if access checking fails
  * @throws SecurityException - if the SecurityManager prevents access
  */
-public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws IllegalArgumentException, NullPointerException, IllegalAccessException, SecurityException {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static MethodHandles.Lookup privateLookupIn(Class<?> targetClass, MethodHandles.Lookup callerLookup) throws NullPointerException, IllegalArgumentException, IllegalAccessException, SecurityException {
+if (Objects.isNull(targetClass) || Objects.isNull(callerLookup)) {
+/*[MSG ""K065S"", ""Both the requested class and the caller lookup must not be null""]*/
+throw new NullPointerException(com.ibm.oti.util.Msg.getString(""K065S"")); //$NON-NLS-1$
+}
+
+if (targetClass.isPrimitive() || targetClass.isArray()) {
+/*[MSG ""K065T"", ""The target class: {0} must not be a primitive type or an array class""]*/
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K065T"", targetClass.getCanonicalName())); //$NON-NLS-1$
+}
+
+Module targetClassModule = targetClass.getModule();
+String targetClassPackageName = targetClass.getPackageName();
+Module accessClassModule = callerLookup.accessClass.getModule();
+
+/* Check whether the named module containing the old lookup can read the module containing the target class.
+ * Note: an unnamed module can read any module.
+ */
+if (!accessClassModule.canRead(targetClassModule)) {
+/*[MSG ""K065U"", ""The module: {0} containing the old lookup can't read the module: {1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065U"", accessClassModule.getName(), targetClassModule.getName())); //$NON-NLS-1$
+}
+
+/* Check whether the module has the package (containing the target class) opened to
+ * the module containing the old lookup.
+ */
+if (!targetClassModule.isOpen(targetClassPackageName, accessClassModule)) {
+/*[MSG ""K065V"", ""The package: {0} containing the target class is not opened to the module: {1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065V"", targetClassPackageName, accessClassModule.getName())); //$NON-NLS-1$
+}
+
+int callerLookupMode = callerLookup.lookupModes();
+if (Lookup.MODULE != (Lookup.MODULE & callerLookupMode)) {
+/*[MSG ""K065W"", ""The access mode: 0x{0} of the caller lookup doesn't have the MODULE mode : 0x{1}""]*/
+throw new IllegalAccessException(com.ibm.oti.util.Msg.getString(""K065W"", Integer.toHexString(callerLookupMode), Integer.toHexString(Lookup.MODULE))); //$NON-NLS-1$
+}
+
+SecurityManager secmgr = System.getSecurityManager();
+if (null != secmgr) {
+secmgr.checkPermission(com.ibm.oti.util.ReflectPermissions.permissionSuppressAccessChecks);",Updated.,
64395741,a77cceef1938b448ef55b0f229e9a2483cc48b9a,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -18728,15 +18728,13 @@ J9::Z::TreeEvaluator::pd2lVariableEvaluator(TR::Node* node, TR::CodeGenerator* c
       regPair = cg->allocateConsecutiveRegisterPair(LReg, HReg);
       }
 
-   // byte-length = precision/2 + 1
    TR::Register* callAddrReg = cg->evaluate(pdAddressNode);
    TR::Register* precisionReg = cg->evaluate(pdOpNode->getChild(2));
+   TR::Register* lengthReg = cg->allocateRegister();
    TR_ASSERT(precisionReg && (precisionReg->getKind() == TR_GPR), ""precision should be a 32bit GPR"");
 
-   TR::Register* lengthReg = cg->allocateRegister();
-   generateRRInstruction(cg, TR::InstOpCode::LR, node, lengthReg, precisionReg);
-   generateRSInstruction(cg, TR::InstOpCode::SRA, pdOpNode, lengthReg, lengthReg, 0x1, NULL);
-   generateRIInstruction(cg, TR::InstOpCode::AGHI, node, lengthReg, 0x1);
+   // byte-length = precision/2 + 1. Note that the length codes of all instructions are (byte-length-1)","Minor nit.  Let's change byte-length to byteLength or byte_length, since you end up using this in an equation to subtract 1 at the end.",
64395741,a77cceef1938b448ef55b0f229e9a2483cc48b9a,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -18728,15 +18728,13 @@ J9::Z::TreeEvaluator::pd2lVariableEvaluator(TR::Node* node, TR::CodeGenerator* c
       regPair = cg->allocateConsecutiveRegisterPair(LReg, HReg);
       }
 
-   // byte-length = precision/2 + 1
    TR::Register* callAddrReg = cg->evaluate(pdAddressNode);
    TR::Register* precisionReg = cg->evaluate(pdOpNode->getChild(2));
+   TR::Register* lengthReg = cg->allocateRegister();
    TR_ASSERT(precisionReg && (precisionReg->getKind() == TR_GPR), ""precision should be a 32bit GPR"");
 
-   TR::Register* lengthReg = cg->allocateRegister();
-   generateRRInstruction(cg, TR::InstOpCode::LR, node, lengthReg, precisionReg);
-   generateRSInstruction(cg, TR::InstOpCode::SRA, pdOpNode, lengthReg, lengthReg, 0x1, NULL);
-   generateRIInstruction(cg, TR::InstOpCode::AGHI, node, lengthReg, 0x1);
+   // byte-length = precision/2 + 1. Note that the length codes of all instructions are (byte-length-1)
+   generateRSInstruction(cg, TR::InstOpCode::SRAK, pdOpNode, lengthReg, precisionReg, 0x1, NULL);",I think SRAK is only available on z196 and newer.  Can you double check if we can unconditionally use this?,
64399035,a77cceef1938b448ef55b0f229e9a2483cc48b9a,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,True,"@@ -18728,15 +18728,13 @@ J9::Z::TreeEvaluator::pd2lVariableEvaluator(TR::Node* node, TR::CodeGenerator* c
       regPair = cg->allocateConsecutiveRegisterPair(LReg, HReg);
       }
 
-   // byte-length = precision/2 + 1
    TR::Register* callAddrReg = cg->evaluate(pdAddressNode);
    TR::Register* precisionReg = cg->evaluate(pdOpNode->getChild(2));
+   TR::Register* lengthReg = cg->allocateRegister();
    TR_ASSERT(precisionReg && (precisionReg->getKind() == TR_GPR), ""precision should be a 32bit GPR"");
 
-   TR::Register* lengthReg = cg->allocateRegister();
-   generateRRInstruction(cg, TR::InstOpCode::LR, node, lengthReg, precisionReg);
-   generateRSInstruction(cg, TR::InstOpCode::SRA, pdOpNode, lengthReg, lengthReg, 0x1, NULL);
-   generateRIInstruction(cg, TR::InstOpCode::AGHI, node, lengthReg, 0x1);
+   // byte-length = precision/2 + 1. Note that the length codes of all instructions are (byte-length-1)",Will do.,
64403514,a77cceef1938b448ef55b0f229e9a2483cc48b9a,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,True,"@@ -18728,15 +18728,13 @@ J9::Z::TreeEvaluator::pd2lVariableEvaluator(TR::Node* node, TR::CodeGenerator* c
       regPair = cg->allocateConsecutiveRegisterPair(LReg, HReg);
       }
 
-   // byte-length = precision/2 + 1
    TR::Register* callAddrReg = cg->evaluate(pdAddressNode);
    TR::Register* precisionReg = cg->evaluate(pdOpNode->getChild(2));
+   TR::Register* lengthReg = cg->allocateRegister();
    TR_ASSERT(precisionReg && (precisionReg->getKind() == TR_GPR), ""precision should be a 32bit GPR"");
 
-   TR::Register* lengthReg = cg->allocateRegister();
-   generateRRInstruction(cg, TR::InstOpCode::LR, node, lengthReg, precisionReg);
-   generateRSInstruction(cg, TR::InstOpCode::SRA, pdOpNode, lengthReg, lengthReg, 0x1, NULL);
-   generateRIInstruction(cg, TR::InstOpCode::AGHI, node, lengthReg, 0x1);
+   // byte-length = precision/2 + 1. Note that the length codes of all instructions are (byte-length-1)
+   generateRSInstruction(cg, TR::InstOpCode::SRAK, pdOpNode, lengthReg, precisionReg, 0x1, NULL);",Nice catch. Fixed SRAK.,
67494957,66c9f1c2b3583b8b5110b99d924bcce16ac0358f,runtime/jcl/cl_se9/module.xml,False,"@@ -103,7 +103,7 @@
 <makefilestub data=""UMA_ENABLE_ALL_WARNINGS=1""/>
 <makefilestub data=""UMA_TREAT_WARNINGS_AS_ERRORS=1""/>
 <makefilestub data=""ifneq ($(OPENJ9_BUILD),true)""/>
-<makefilestub data=""jclcinit$(UMA_DOT_O) : CFLAGS += -DOPENJ9_REPO='&quot;J9VM     - &quot;'""/>
+<makefilestub data=""jclcinit$(UMA_DOT_O) : CFLAGS += -DVENDOR_VERSION=1 -DOPENJ9_REPO='&quot;J9VM     - &quot;'""/>","I think VENDOR_VERSION should only be defined when its not an OPENJ9_BUILD.
-DVENDOR_VERSION should be sufficient.",
68369762,66c9f1c2b3583b8b5110b99d924bcce16ac0358f,runtime/include/vendor_version.h,False,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 1998, 2017 IBM Corp. and others",This is a new file: the first year should be 2017.,
68369958,66c9f1c2b3583b8b5110b99d924bcce16ac0358f,runtime/include/vendor_version.h,False,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 1998, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+/* Example usage for repo and sha.  This value will be inserted into the
+ * java.fiullversio and java.vm.info system properties
+ * #define VENDOR_VERSION_STRING ""<repo name> - <sha>""
+ * or descriptive string
+ * #define VENDOR_VERSION_STRING ""Add some experimental code to java.base""
+*/",Please indent the final line of the comment like the preceding lines.,
68403001,66c9f1c2b3583b8b5110b99d924bcce16ac0358f,runtime/include/vendor_version.h,False,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+/* Example usage for repo and sha.  This value will be inserted into the
+ * java.fiullversio and java.vm.info system properties","couple of typos in fiullversio, extra i and missing n.",
68411846,66c9f1c2b3583b8b5110b99d924bcce16ac0358f,runtime/include/vendor_version.h,True,"@@ -0,0 +1,28 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+/* Example usage for repo and sha.  This value will be inserted into the
+ * java.fiullversio and java.vm.info system properties","sigh, thats where those keystrokes went. :)  Fixed.",
67226316,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -395,11 +400,30 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 } catch (Throwable e) {
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);",Why does this probe both the old and new locations for the property?,
67357846,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,True,"@@ -395,11 +400,30 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 } catch (Throwable e) {
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);","The intent of this is to set the local connector address in the system properties, per the reference implementation, and return the address.  

If the property is unset in the system properties, then the agent has not been started before.  This is not an error condition.  However, if the agent has been started  the property should have been set.",
67539721,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -395,11 +400,30 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 } catch (Throwable e) {
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+systemProperties.setProperty(LOCAL_CONNECTOR_ADDRESS, addr);
+}
+}
+/*[ELSE] Sidecar19-SE-B165
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);",Does this need to be commented out?,
67539883,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -395,11 +400,30 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 } catch (Throwable e) {
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+systemProperties.setProperty(LOCAL_CONNECTOR_ADDRESS, addr);",Should addr be checked for null first?,
67540165,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -395,11 +400,30 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 } catch (Throwable e) {
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+systemProperties.setProperty(LOCAL_CONNECTOR_ADDRESS, addr);
+}
+}
+/*[ELSE] Sidecar19-SE-B165
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*[ENDIF] Sidecar19-SE-B165*/
+if (Objects.isNull(addr)) {
+IPC.logMessage(LOCAL_CONNECTOR_ADDRESS+"" not set""); //$NON-NLS-1$",Pls add spaces around +,
67540186,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -395,11 +400,30 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 } catch (Throwable e) {
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+systemProperties.setProperty(LOCAL_CONNECTOR_ADDRESS, addr);
+}
+}
+/*[ELSE] Sidecar19-SE-B165
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*[ENDIF] Sidecar19-SE-B165*/
+if (Objects.isNull(addr)) {
+IPC.logMessage(LOCAL_CONNECTOR_ADDRESS+"" not set""); //$NON-NLS-1$
+throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$",Pls add spaces around +,
67540264,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -395,11 +400,30 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 } catch (Throwable e) {
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+systemProperties.setProperty(LOCAL_CONNECTOR_ADDRESS, addr);
+}
+}
+/*[ELSE] Sidecar19-SE-B165
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*[ENDIF] Sidecar19-SE-B165*/
+if (Objects.isNull(addr)) {
+IPC.logMessage(LOCAL_CONNECTOR_ADDRESS+"" not set""); //$NON-NLS-1$
+throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
 }
-IPC.logMessage(IPC.LOCAL_CONNECTOR_ADDRESS+""="", addr); //$NON-NLS-1$
+IPC.logMessage(LOCAL_CONNECTOR_ADDRESS+""="", addr); //$NON-NLS-1$",Pls add spaces around +,
68394283,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -393,13 +398,37 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent cannot access ""+START_LOCAL_MANAGEMENT_AGENT); //$NON-NLS-1$
 }
 } catch (Throwable e) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
+throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:"" + e.getClass()+"" "" + e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*
+ * add should not be null at this point.  If it is, and exception is thrown below.","""add"" should be ""addr"".
This comment is not proper English. ",
68394391,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -393,13 +398,37 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent cannot access ""+START_LOCAL_MANAGEMENT_AGENT); //$NON-NLS-1$
 }
 } catch (Throwable e) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
+throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:"" + e.getClass()+"" "" + e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*
+ * add should not be null at this point.  If it is, and exception is thrown below.
+ * Don't bother checking for null since
+ * systemProperties had a null value before.","This comment implies that calling setProperty with a null value will work, however it throws NPE.",
68397328,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,True,"@@ -393,13 +398,37 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent cannot access ""+START_LOCAL_MANAGEMENT_AGENT); //$NON-NLS-1$
 }
 } catch (Throwable e) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
+throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:"" + e.getClass()+"" "" + e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*
+ * add should not be null at this point.  If it is, and exception is thrown below.",Fixed.,
68397353,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,True,"@@ -393,13 +398,37 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent cannot access ""+START_LOCAL_MANAGEMENT_AGENT); //$NON-NLS-1$
 }
 } catch (Throwable e) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
+throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:"" + e.getClass()+"" "" + e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*
+ * add should not be null at this point.  If it is, and exception is thrown below.
+ * Don't bother checking for null since
+ * systemProperties had a null value before.",True.  Fixed.,
68430258,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -393,13 +398,37 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent cannot access ""+START_LOCAL_MANAGEMENT_AGENT); //$NON-NLS-1$
 }
 } catch (Throwable e) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
+throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:"" + e.getClass()+"" "" + e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*
+ * addr should not be null at this point.  If it is, and exception is thrown below.","I think you mean ""an exception"", not ""and exception"".",
68430751,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,False,"@@ -393,13 +398,37 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent cannot access ""+START_LOCAL_MANAGEMENT_AGENT); //$NON-NLS-1$
 }
 } catch (Throwable e) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
+throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:"" + e.getClass()+"" "" + e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*
+ * addr should not be null at this point.  If it is, and exception is thrown below.
+ * Don't bother checking for null since
+ * systemProperties had a null value before.","My previous comment here was ""This comment implies that calling setProperty with a null value will work, however it throws NPE."" to which the response was ""True. Fixed"". However I don't see any change.",
68614027,00b82eaa33d4f9761807bfda9ede006c6a6a9a33,jcl/src/java.base/share/classes/com/ibm/tools/attach/target/Attachment.java,True,"@@ -393,13 +398,37 @@ private static String startLocalAgent() throws IbmAttachOperationFailedException
 throw new IbmAttachOperationFailedException(""startLocalManagementAgent cannot access ""+START_LOCAL_MANAGEMENT_AGENT); //$NON-NLS-1$
 }
 } catch (Throwable e) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:""+e.getClass()+"" ""+e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
+throw new IbmAttachOperationFailedException(""startLocalManagementAgent error starting agent:"" + e.getClass()+"" "" + e.getMessage()); //$NON-NLS-1$ //$NON-NLS-2$
 }
-String addr = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties().getProperty(IPC.LOCAL_CONNECTOR_ADDRESS);
-if (null == addr) {
-throw new IbmAttachOperationFailedException(""startLocalManagementAgent: ""+IPC.LOCAL_CONNECTOR_ADDRESS+"" not defined""); //$NON-NLS-1$ //$NON-NLS-2$
+/*
+ * sun.management.Agent.startLocalManagementAgent() in Java 8 sets 
+ * c.s.m.j.localConnectorAddress in System.properties.
+ * jdk.internal.agent.Agent.startLocalManagementAgent() in Java 9 sets 
+ * c.s.m.j.localConnectorAddress in a different Properties object.
+ */
+Properties systemProperties = com.ibm.oti.vm.VM.getVMLangAccess().internalGetProperties();
+String addr;
+/*[IF Sidecar19-SE-B165]*/
+synchronized (systemProperties) {
+addr = systemProperties.getProperty(LOCAL_CONNECTOR_ADDRESS);
+if (Objects.isNull(addr)) {
+addr = VMSupport.getAgentProperties().getProperty(LOCAL_CONNECTOR_ADDRESS);
+/*
+ * addr should not be null at this point.  If it is, and exception is thrown below.
+ * Don't bother checking for null since
+ * systemProperties had a null value before.","Sorry, forgot to push my changes.",
68418274,07b63e9db68b1273d8d4c10ca9330255774e230d,runtime/tr.source/trj9/optimizer/J9Simplifier.cpp,False,"@@ -833,7 +833,7 @@ J9::Simplifier::simplifyiOrPatterns(TR::Node *node)
    secondChild = node->getSecondChild();
    if (!disableIORByteSwap &&
        !TR::Compiler->target.cpu.isBigEndian() &&  // the bigEndian case needs more thought
-       comp()->cg()->getSupportsIbyteswap() && secondChild->getOpCodeValue() == TR::ior)","hmm, the bigEndian case needs more thought - wasn't was wrong the big endian case?",
68428425,07b63e9db68b1273d8d4c10ca9330255774e230d,runtime/tr.source/trj9/optimizer/J9Simplifier.cpp,True,"@@ -833,7 +833,7 @@ J9::Simplifier::simplifyiOrPatterns(TR::Node *node)
    secondChild = node->getSecondChild();
    if (!disableIORByteSwap &&
        !TR::Compiler->target.cpu.isBigEndian() &&  // the bigEndian case needs more thought
-       comp()->cg()->getSupportsIbyteswap() && secondChild->getOpCodeValue() == TR::ior)","It seems the problem was that both endian cases were incorrect, but since the little endian use case had been running in testing for 8 months without signs of problems we assumed that the problem was big-endian specific and disabled that code path. This change effectively swaps the little endian handling to what would have been (part of) the big endian code path.",
67682485,47686d83b7134f75ce37b041bf92a56184c5325f,runtime/exelib/common/rconsole.c,False,"@@ -60,7 +60,7 @@ remoteConsole_parseCmdLine(J9PortLibrary *portLibrary, UDATA lastLegalArg, char
 port = NULL;
 filepath = NULL;
 for (i = 1; i <= lastLegalArg; i++) {
-if ((argv[i][0] == '-')) {
+if (argv[i][0] == '-') {",Can you swap the arguments so the constant is on the left?,
67710087,47686d83b7134f75ce37b041bf92a56184c5325f,runtime/exelib/common/rconsole.c,True,"@@ -60,7 +60,7 @@ remoteConsole_parseCmdLine(J9PortLibrary *portLibrary, UDATA lastLegalArg, char
 port = NULL;
 filepath = NULL;
 for (i = 1; i <= lastLegalArg; i++) {
-if ((argv[i][0] == '-')) {
+if (argv[i][0] == '-') {",did you want me to go through the rest of the function / file or just submit the swap for this one line for now ? ,
67715618,47686d83b7134f75ce37b041bf92a56184c5325f,runtime/exelib/common/rconsole.c,False,"@@ -60,7 +60,7 @@ remoteConsole_parseCmdLine(J9PortLibrary *portLibrary, UDATA lastLegalArg, char
 port = NULL;
 filepath = NULL;
 for (i = 1; i <= lastLegalArg; i++) {
-if ((argv[i][0] == '-')) {
+if (argv[i][0] == '-') {","Actually, I think that sort of 'cleanup' should be done in a separate PR.
You will need to sign the Eclipse Contributor Agreement (ECA).",
67719530,47686d83b7134f75ce37b041bf92a56184c5325f,runtime/exelib/common/rconsole.c,True,"@@ -60,7 +60,7 @@ remoteConsole_parseCmdLine(J9PortLibrary *portLibrary, UDATA lastLegalArg, char
 port = NULL;
 filepath = NULL;
 for (i = 1; i <= lastLegalArg; i++) {
-if ((argv[i][0] == '-')) {
+if (argv[i][0] == '-') {",I have a ECA signed yesterday so hopefully all in the system by now,
67741226,47686d83b7134f75ce37b041bf92a56184c5325f,runtime/exelib/common/rconsole.c,False,"@@ -60,7 +60,7 @@ remoteConsole_parseCmdLine(J9PortLibrary *portLibrary, UDATA lastLegalArg, char
 port = NULL;
 filepath = NULL;
 for (i = 1; i <= lastLegalArg; i++) {
-if ((argv[i][0] == '-')) {
+if (argv[i][0] == '-') {",It is weird.  You did not fail the IP-Validation.  It says that the service is down.   It does appear that your commit message is missing the signed-off by tag though.  Your PR comment has it but not the commit as far as I can see.,
67743728,47686d83b7134f75ce37b041bf92a56184c5325f,runtime/exelib/common/rconsole.c,False,"@@ -60,7 +60,7 @@ remoteConsole_parseCmdLine(J9PortLibrary *portLibrary, UDATA lastLegalArg, char
 port = NULL;
 filepath = NULL;
 for (i = 1; i <= lastLegalArg; i++) {
-if ((argv[i][0] == '-')) {
+if (argv[i][0] == '-') {","The format of that line (in your commits) should be:
```
Signed-off-by: Steve Wallin <steve_wallin@uk.ibm.com>
```",
66808827,29d7858a38d803bd50cc4ae248eb355684c93d1c,runtime/vm/callin.cpp,False,"@@ -974,7 +974,18 @@ sendResolveInvokeDynamic(J9VMThread *currentThread, J9ConstantPool *ramCP, UDATA
 nameString = POP_OBJECT_IN_SPECIAL_FRAME(currentThread);
 if (NULL != sigString) {
 /* Run the method */
-*--currentThread->sp = (UDATA)J9VM_J9CLASS_TO_HEAPCLASS(ramCP->ramClass);
+currentThread->sp -= 2; /* skip one slot because we are passing a long */
+*(U_64*)currentThread->sp = (U_64)ramCP->ramClass;","Comments should generally go above the code being described, rather than below.",
66811127,29d7858a38d803bd50cc4ae248eb355684c93d1c,jcl/src/java.base/share/classes/java/lang/VMAccess.java,False,"@@ -174,4 +182,25 @@ public Package getSystemPackage(String name) {
 return Package.getSystemPackage(name);
 }
 /*[ENDIF]*/
+
+/**
+ * Returns a J9ClassRef object.
+ * 
+ * @param addr - the native addr of the J9Class
+ * @return A J9Class reference object
+ */ 
+@Override
+public Object createJ9ClassRef(long addr) {",Rename?,
67512758,29d7858a38d803bd50cc4ae248eb355684c93d1c,jcl/src/java.base/share/classes/java/lang/VMAccess.java,False,"@@ -174,4 +182,25 @@ public Package getSystemPackage(String name) {
 return Package.getSystemPackage(name);
 }
 /*[ENDIF]*/
+
+/**
+ * Returns a J9ClassRef object.
+ * 
+ * @param addr - the native addr of the J9Class
+ * @return A J9Class reference object","Above it says J9ClassRef and here it says J9Class, although it returns an InternalRamClass",
67518925,29d7858a38d803bd50cc4ae248eb355684c93d1c,jcl/src/java.base/share/classes/java/lang/VMAccess.java,False,"@@ -174,4 +182,25 @@ public Package getSystemPackage(String name) {
 return Package.getSystemPackage(name);
 }
 /*[ENDIF]*/
+
+/**
+ * Returns a J9ClassRef object.
+ * 
+ * @param addr - the native addr of the J9Class
+ * @return A J9Class reference object
+ */ 
+@Override
+public Object createInternalRamClass(long addr) {
+return new InternalRamClass(addr);
+}
+
+/**
+ * Returns a ConstanPool object
+ * @param j9ClassRef An object ref to a j9class",j9ClassRef doesn't match the argument internalRamClass,
67761045,29d7858a38d803bd50cc4ae248eb355684c93d1c,jcl/src/java.base/share/classes/com/ibm/oti/vm/VMLangAccess.java,False,"@@ -122,4 +129,19 @@
 public Package getSystemPackage(String name);
 /*[ENDIF]*/
 
+/**
+ * Returns a J9ClassRef object.","I didn't notice earlier. This comment has the same problem fixed in VMAccess.java, referring to J9ClassRef and J9Class.",
68468746,29d7858a38d803bd50cc4ae248eb355684c93d1c,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java,False,"@@ -832,33 +833,48 @@ MethodHandle insertArguments(MethodHandle equivalent, MethodHandle unboxingHandl
 private static final int BSM_OPTIONAL_ARGUMENTS_START_INDEX = 3;
 
 @SuppressWarnings(""unused"")
-private static final MethodHandle resolveInvokeDynamic(Class<?> clazz, String name, String methodDescriptor, long bsmData) throws Throwable {
+private static final MethodHandle resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {
 Unsafe unsafe = getUnsafe();
 MethodHandle result = null;
 MethodType type = null;
 
 try {
+VMLangAccess access = VM.getVMLangAccess();
+Object internalRamClass = access.createInternalRamClass(j9class);
+JITHelpers jitHelper = getJITHelpers();
+Class<?> classObject = null;
+if (jitHelper.is32Bit()) {
+classObject = getJITHelpers().getClassFromJ9Class32((int)j9class);",Don't call `getJITHelpers` again.  It's already been fetched into the `jitHelper` local.  Same on the other branch of the if.,
68468746,29d7858a38d803bd50cc4ae248eb355684c93d1c,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java,False,"@@ -832,33 +833,48 @@ MethodHandle insertArguments(MethodHandle equivalent, MethodHandle unboxingHandl
 private static final int BSM_OPTIONAL_ARGUMENTS_START_INDEX = 3;
 
 @SuppressWarnings(""unused"")
-private static final MethodHandle resolveInvokeDynamic(Class<?> clazz, String name, String methodDescriptor, long bsmData) throws Throwable {
+private static final MethodHandle resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {
 Unsafe unsafe = getUnsafe();
 MethodHandle result = null;
 MethodType type = null;
 
 try {
+VMLangAccess access = VM.getVMLangAccess();
+Object internalRamClass = access.createInternalRamClass(j9class);
+JITHelpers jitHelper = getJITHelpers();
+Class<?> classObject = null;
+if (jitHelper.is32Bit()) {
+classObject = getJITHelpers().getClassFromJ9Class32((int)j9class);
+} else {
+classObject = getJITHelpers().getClassFromJ9Class64(j9class);
+}
+assert(null != classObject);",Java `asserts` almost never run as they are only enabled when running with `-ea` or similar command line variation.  Use `Objects. requireNonNull(classObject)` to enforce the check always.,
68468746,29d7858a38d803bd50cc4ae248eb355684c93d1c,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java,False,"@@ -832,33 +833,48 @@ MethodHandle insertArguments(MethodHandle equivalent, MethodHandle unboxingHandl
 private static final int BSM_OPTIONAL_ARGUMENTS_START_INDEX = 3;
 
 @SuppressWarnings(""unused"")
-private static final MethodHandle resolveInvokeDynamic(Class<?> clazz, String name, String methodDescriptor, long bsmData) throws Throwable {
+private static final MethodHandle resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {
 Unsafe unsafe = getUnsafe();
 MethodHandle result = null;
 MethodType type = null;
 
 try {
+VMLangAccess access = VM.getVMLangAccess();
+Object internalRamClass = access.createInternalRamClass(j9class);
+JITHelpers jitHelper = getJITHelpers();
+Class<?> classObject = null;
+if (jitHelper.is32Bit()) {
+classObject = getJITHelpers().getClassFromJ9Class32((int)j9class);
+} else {
+classObject = getJITHelpers().getClassFromJ9Class64(j9class);
+}
+assert(null != classObject);
+
+
 try { 
-type = MethodType.fromMethodDescriptorString(methodDescriptor, VM.getVMLangAccess().getClassloader(clazz));
+type = MethodType.fromMethodDescriptorString(methodDescriptor, VM.getVMLangAccess().getClassloader(classObject));",`VM.getVMLangAccess()` is already cached in the `access` local.,
68468746,29d7858a38d803bd50cc4ae248eb355684c93d1c,runtime/oti/vmconstantpool.xml,False,"@@ -80,7 +80,7 @@
 <classref name=""java/lang/ClassFormatError""/>
 <classref name=""java/lang/StackTraceElement""/>
 <classref name=""java/lang/StackWalker$StackFrameImpl""/>
-
+<classref name=""java/lang/InternalRamClass""/>","Although adding classes to the vmconstantpool is the easy way to get them loaded / available, it is a startup cost. 

Given that the sun_reflect_constantpool code already uses the JNI id cache, wouldn't this be a good candidate for that mechanism rather than the vmconstantpool?",
68468746,29d7858a38d803bd50cc4ae248eb355684c93d1c,runtime/jcl/common/sun_reflect_ConstantPool.c,False,"@@ -25,6 +25,9 @@
 #include ""jclprots.h""
 #include ""jclglob.h""
 #include ""jniidcacheinit.h""
+#include ""j9.h""
+
+#define J9CLASS_FROMJ9CLASSREF(vmThread, j9ClassRef) J9VMJAVALANGINTERNALRAMCLASS_VMREF(vmThread, J9_JNI_UNWRAP_REFERENCE(j9ClassRef))",`CLASSREF` has classfile constant pool connotations.  This should mention either the ConstantPoolOOP or InternalRamClassRef in the name of the macro so it's clearer what's happening here.,
68468746,29d7858a38d803bd50cc4ae248eb355684c93d1c,runtime/jcl/common/sun_reflect_ConstantPool.c,False,"@@ -267,11 +270,21 @@ getMethodAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFla
 methodID = (jmethodID) vmFunctions->getJNIMethodID(vmThread, method);
 }
 }
-vmFunctions->internalReleaseVMAccess(vmThread);
-}
 
-if (NULL != methodID) {
-returnValue = (*env)->ToReflectedMethod(env, constantPoolOop, methodID, J9CPTYPE_STATIC_METHOD == cpType);
+if (NULL != methodID) {
+j9object_t classObject = J9CLASS_FROMJ9CLASSREF(vmThread, constantPoolOop)->classObject;
+jclass jlClass = vmFunctions->j9jni_createLocalRef(env, classObject);
+if (NULL != jlClass) {
+vmFunctions->internalReleaseVMAccess(vmThread);
+returnValue = (*env)->ToReflectedMethod(env, jlClass, methodID, J9CPTYPE_STATIC_METHOD == cpType);
+vmFunctions->internalEnterVMFromJNI(vmThread);","There's an lot of atomic operations happening here - 
* this method drops VMAccess, 
* then toReflectMethod will acquire and drop it again, 
* then this method acquires it so it can be dropped again at the bottom of the method.

 Things that we can ignore: 
* deleting the localref isn't necessary - it will be cleaned up when the method returns.
* extra acquire / releases in the setNativeOOM case are fine.  In fact, use `throwNativeOOMError()` as it handles the acquire / release for you.",
68468746,29d7858a38d803bd50cc4ae248eb355684c93d1c,runtime/jcl/common/sun_reflect_ConstantPool.c,False,"@@ -267,11 +270,21 @@ getMethodAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFla
 methodID = (jmethodID) vmFunctions->getJNIMethodID(vmThread, method);
 }
 }
-vmFunctions->internalReleaseVMAccess(vmThread);
-}
 
-if (NULL != methodID) {
-returnValue = (*env)->ToReflectedMethod(env, constantPoolOop, methodID, J9CPTYPE_STATIC_METHOD == cpType);
+if (NULL != methodID) {
+j9object_t classObject = J9CLASS_FROMJ9CLASSREF(vmThread, constantPoolOop)->classObject;
+jclass jlClass = vmFunctions->j9jni_createLocalRef(env, classObject);",Can this be cached above to avoid the vmaccess concerns?,
68637994,29d7858a38d803bd50cc4ae248eb355684c93d1c,runtime/oti/vmconstantpool.xml,True,"@@ -80,7 +80,7 @@
 <classref name=""java/lang/ClassFormatError""/>
 <classref name=""java/lang/StackTraceElement""/>
 <classref name=""java/lang/StackWalker$StackFrameImpl""/>
-
+<classref name=""java/lang/InternalRamClass""/>","Do you mean load j.l.InternalRamClass with `(*env)->FindClass(...)` and then store it in the `JniIDCache` ?

If we took this approach we would have to also cache the `vmref` `jfieldID` as well and use `(*env)->GetLongField(...)` in every place we are using `J9CLASS_FROMJ9CLASSREF`. This would mean adding more acquire / releases vmaccess points.

What I really need is the vmconstantpool fieldref for `vmref`. It is my understanding that if you create a fieldref you also need the owning classref in the vmconstanpool. I don't need to explicitly load the class or even require `J9Class*` for j.l.InternalRamClass.",
68676457,29d7858a38d803bd50cc4ae248eb355684c93d1c,runtime/oti/vmconstantpool.xml,False,"@@ -80,7 +80,7 @@
 <classref name=""java/lang/ClassFormatError""/>
 <classref name=""java/lang/StackTraceElement""/>
 <classref name=""java/lang/StackWalker$StackFrameImpl""/>
-
+<classref name=""java/lang/InternalRamClass""/>","Correct - anything in the VM CP with a fieldref is resolved on startup, and can always be used.  You still need VM access to do so.

Also note, that JNI functions like FindClass are VM access acquire/release points already, so doing it explicitly is not actually more calls.",
68331202,e5b9a5ba0246b2bb627ae8feaffab8a3575a25b5,jcl/src/java.base/share/classes/java/lang/invoke/ArrayVarHandle.java,False,"@@ -143,6 +126,10 @@ static final void boundsCheck(int arrayLength, long index) {
 }
 }
 
+static final long computeIndex(int index, int indexOffset, int indexScale) {
+return indexOffset + ((long)index * indexScale);
+}",The method that this replaces was poorly named: I suggest 'computeOffset' would be better. Also the second argument would be better named 'baseOffset' to reflect the origin of that value.,
68332389,e5b9a5ba0246b2bb627ae8feaffab8a3575a25b5,jcl/src/java.base/share/classes/java/lang/invoke/ArrayVarHandle.java,True,"@@ -143,6 +126,10 @@ static final void boundsCheck(int arrayLength, long index) {
 }
 }
 
+static final long computeIndex(int index, int indexOffset, int indexScale) {
+return indexOffset + ((long)index * indexScale);
+}",Thanks! Will fix it.,
68334148,e5b9a5ba0246b2bb627ae8feaffab8a3575a25b5,jcl/src/java.base/share/classes/java/lang/invoke/ArrayVarHandle.java,False,"@@ -163,66 +150,69 @@ private static final IllegalArgumentException newIllegalArgumentException(Class<
 }
 
 static final class OpObject extends ArrayVarHandleOperations {
+private static final int OFFSET = _unsafe.arrayBaseOffset(Object[].class);",A better name for this class of fields would be 'BASE_OFFSET'.,
68335475,e5b9a5ba0246b2bb627ae8feaffab8a3575a25b5,jcl/src/java.base/share/classes/java/lang/invoke/ArrayVarHandle.java,False,"@@ -163,66 +150,69 @@ private static final IllegalArgumentException newIllegalArgumentException(Class<
 }
 
 static final class OpObject extends ArrayVarHandleOperations {
+private static final int OFFSET = _unsafe.arrayBaseOffset(Object[].class);
+private static final int SCALE = _unsafe.arrayIndexScale(Object[].class);
+
 private static final Object get(Object receiver, int index, ArrayVarHandle varHandle) {
 receiver.getClass();
 boundsCheck(((Object[])receiver).length, index);
-return _unsafe.getObject(receiver, varHandle.computeIndex(index));
+return _unsafe.getObject(receiver, computeIndex(index, OFFSET, SCALE));",Perhaps it would improve clarity and avoid the possibility of permuting the arguments to 'computeIndex' by introducing a single-argument version that mixes in OFFSET and SCALE.,
68652036,e5b9a5ba0246b2bb627ae8feaffab8a3575a25b5,jcl/src/java.base/share/classes/java/lang/invoke/ArrayVarHandle.java,True,"@@ -163,66 +150,69 @@ private static final IllegalArgumentException newIllegalArgumentException(Class<
 }
 
 static final class OpObject extends ArrayVarHandleOperations {
+private static final int OFFSET = _unsafe.arrayBaseOffset(Object[].class);
+private static final int SCALE = _unsafe.arrayIndexScale(Object[].class);
+
 private static final Object get(Object receiver, int index, ArrayVarHandle varHandle) {
 receiver.getClass();
 boundsCheck(((Object[])receiver).length, index);
-return _unsafe.getObject(receiver, varHandle.computeIndex(index));
+return _unsafe.getObject(receiver, computeIndex(index, OFFSET, SCALE));","I was hoping to achieve this, but it would mean copying the `computeOffset` method body into every type-specific subclass.",
68730252,e5b9a5ba0246b2bb627ae8feaffab8a3575a25b5,jcl/src/java.base/share/classes/java/lang/invoke/ArrayVarHandle.java,True,"@@ -163,66 +150,69 @@ private static final IllegalArgumentException newIllegalArgumentException(Class<
 }
 
 static final class OpObject extends ArrayVarHandleOperations {
+private static final int OFFSET = _unsafe.arrayBaseOffset(Object[].class);
+private static final int SCALE = _unsafe.arrayIndexScale(Object[].class);
+
 private static final Object get(Object receiver, int index, ArrayVarHandle varHandle) {
 receiver.getClass();
 boundsCheck(((Object[])receiver).length, index);
-return _unsafe.getObject(receiver, varHandle.computeIndex(index));
+return _unsafe.getObject(receiver, computeIndex(index, OFFSET, SCALE));",Fixed,
68730310,e5b9a5ba0246b2bb627ae8feaffab8a3575a25b5,jcl/src/java.base/share/classes/java/lang/invoke/ArrayVarHandle.java,True,"@@ -163,66 +150,69 @@ private static final IllegalArgumentException newIllegalArgumentException(Class<
 }
 
 static final class OpObject extends ArrayVarHandleOperations {
+private static final int OFFSET = _unsafe.arrayBaseOffset(Object[].class);",Fixed,
68730337,e5b9a5ba0246b2bb627ae8feaffab8a3575a25b5,jcl/src/java.base/share/classes/java/lang/invoke/ArrayVarHandle.java,True,"@@ -143,6 +126,10 @@ static final void boundsCheck(int arrayLength, long index) {
 }
 }
 
+static final long computeIndex(int index, int indexOffset, int indexScale) {
+return indexOffset + ((long)index * indexScale);
+}",Fixed,
68920384,da7f319ecdf7bbdd767bc5909c5123d11e08e8de,runtime/vm/jvminit.c,False,"@@ -6339,10 +6335,11 @@ isSSE2SupportedOnX86() {
 OMRSIG_SIGACTION(SIGILL, NULL, &oldHandler);
 OMRSIG_SIGNAL(SIGILL, (void (*)(int)) handleSIGILLForSSE);
 osSupportsSSE = TRUE;
-mxcsr = J9SSE2GetMXCSR();
+U_32 mxcsr;","We support some platforms that aren't using c99 compilers yet so locals need to be defined at the top of a scope.

Also, all locals should be given an initial value to protect against future refactoring that may read them before they're defined.",
68966162,da7f319ecdf7bbdd767bc5909c5123d11e08e8de,runtime/vm/jvminit.c,True,"@@ -6339,10 +6335,11 @@ isSSE2SupportedOnX86() {
 OMRSIG_SIGACTION(SIGILL, NULL, &oldHandler);
 OMRSIG_SIGNAL(SIGILL, (void (*)(int)) handleSIGILLForSSE);
 osSupportsSSE = TRUE;
-mxcsr = J9SSE2GetMXCSR();
+U_32 mxcsr;",I see. It has been updated.,
66852656,ac2d3853a00cf01f50a2cf5b3ccd6dc96c9edf57,runtime/tr.source/trj9/build/files/host/i386.mk,False,"@@ -20,7 +20,6 @@
 
 JIT_PRODUCT_SOURCE_FILES+=\
     tr.source/trj9/x/i386/runtime/J9IA32ArrayCopy.asm \
-    tr.source/trj9/x/i386/runtime/J9IA32ArrayTranslate.asm \
     tr.source/trj9/x/i386/runtime/J9IA32CompressString.asm \",Slightly related but it appears J9IA32CompressString.asm can be deprecated too. This is outside the scope of this PR though.,
66856835,ac2d3853a00cf01f50a2cf5b3ccd6dc96c9edf57,runtime/tr.source/trj9/build/files/host/i386.mk,True,"@@ -20,7 +20,6 @@
 
 JIT_PRODUCT_SOURCE_FILES+=\
     tr.source/trj9/x/i386/runtime/J9IA32ArrayCopy.asm \
-    tr.source/trj9/x/i386/runtime/J9IA32ArrayTranslate.asm \
     tr.source/trj9/x/i386/runtime/J9IA32CompressString.asm \","Thank-you for pointing it out, I'll look into clean it up later.",
69014845,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,False,"@@ -565,75 +491,70 @@ public void test_asSpreader_CrossPackage_Virtual() throws Throwable{
 public void test_asSpreader_CrossPackage_Static() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
 mh = mh.asSpreader(int[].class, 2);
-AssertJUnit.assertEquals(MethodType.methodType(int.class,int[].class),mh.type());
-AssertJUnit.assertEquals(5,(int)mh.invokeExact(new int[] {3,2}));
+Assert.assertEquals(mh.type(), MethodType.methodType(int.class,int[].class));
+Assert.assertEquals((int)mh.invokeExact(new int[] {3,2}), 5);
 }
 
 /**
  * Negative test : asSpreader test using cross package virtual method with a wrong method type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Virtual_WrongType() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findVirtual(PackageExamples.class,""addPublic"",MethodType.methodType(int.class,int.class,int.class));
 PackageExamples g = new PackageExamples();
 mh = mh.bindTo(g);
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asSpreader(String[].class, 2);
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asSpreader(String[].class, 2);
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the wrong method type"");
 }
 
 /**
  * Negative test : asSpreader test using a cross-package static method and wrong method type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = IllegalArgumentException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Static_WrongType() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
 mh = mh.asSpreader(int[].class, 2);
-boolean illegalArgumentExceptionThrown = false; 
-
-try {
-mh = mh.asSpreader(String[].class, 2);
-}
-catch(IllegalArgumentException e) {
-illegalArgumentExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(illegalArgumentExceptionThrown);
+mh = mh.asSpreader(String[].class, 2);
+Assert.fail(""The test case failed to throw an IllegalArgumentException in the case of the wrong method type"");
 }
 
 /**
  * Negative test : asSpreader test using cross package static method and a wrong argument count
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = IllegalArgumentException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Static_WrongArgCount() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
-
-boolean illegalArgumentException = false; 
-
-try {
-mh = mh.asSpreader(int[].class, 3);
-}
-catch(IllegalArgumentException e) {
-illegalArgumentException = true;
-}
-
-AssertJUnit.assertTrue(illegalArgumentException);
+mh = mh.asSpreader(int[].class, 3);
+Assert.fail(""The test case failed to throw an IllegalArgumentException in the case of the wrong argument count"");
 }
 
 /******************************
  * Tests for MethodHandle arity
  * ****************************/
 /**
+ * Create MethodHandle with highest possible arity and use findConstructor (253)
+ * @throws Throwable
+ */
+@Test(groups = { ""level.extended"" })
+public void test_findConstructor_ArityLimit() throws Throwable {
+MethodHandle mh = MethodHandles.lookup().findConstructor(HelperConstructorClass.class, helperMethodType_void_253int);
+mh = mh.asSpreader(int[].class, 253);",Does this need an assert?  Or is not throwing an exception sufficient?,
69020001,b9dde1c86b3d88ed1287bad147697c5f5cb80199,test/Jsr292/src/com/ibm/j9/jsr292/MethodHandleTest.java,True,"@@ -565,75 +491,70 @@ public void test_asSpreader_CrossPackage_Virtual() throws Throwable{
 public void test_asSpreader_CrossPackage_Static() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
 mh = mh.asSpreader(int[].class, 2);
-AssertJUnit.assertEquals(MethodType.methodType(int.class,int[].class),mh.type());
-AssertJUnit.assertEquals(5,(int)mh.invokeExact(new int[] {3,2}));
+Assert.assertEquals(mh.type(), MethodType.methodType(int.class,int[].class));
+Assert.assertEquals((int)mh.invokeExact(new int[] {3,2}), 5);
 }
 
 /**
  * Negative test : asSpreader test using cross package virtual method with a wrong method type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = WrongMethodTypeException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Virtual_WrongType() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findVirtual(PackageExamples.class,""addPublic"",MethodType.methodType(int.class,int.class,int.class));
 PackageExamples g = new PackageExamples();
 mh = mh.bindTo(g);
-boolean wrongMethodTypeExceptionThrown = false; 
-
-try {
-mh = mh.asSpreader(String[].class, 2);
-}
-catch(WrongMethodTypeException e) {
-wrongMethodTypeExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(wrongMethodTypeExceptionThrown);
+mh = mh.asSpreader(String[].class, 2);
+Assert.fail(""The test case failed to throw an WrongMethodTypeException in the case of the wrong method type"");
 }
 
 /**
  * Negative test : asSpreader test using a cross-package static method and wrong method type
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = IllegalArgumentException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Static_WrongType() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
 mh = mh.asSpreader(int[].class, 2);
-boolean illegalArgumentExceptionThrown = false; 
-
-try {
-mh = mh.asSpreader(String[].class, 2);
-}
-catch(IllegalArgumentException e) {
-illegalArgumentExceptionThrown = true;
-}
-
-AssertJUnit.assertTrue(illegalArgumentExceptionThrown);
+mh = mh.asSpreader(String[].class, 2);
+Assert.fail(""The test case failed to throw an IllegalArgumentException in the case of the wrong method type"");
 }
 
 /**
  * Negative test : asSpreader test using cross package static method and a wrong argument count
  * @throws Throwable
  */
-@Test(groups = { ""level.extended"" })
+@Test(expectedExceptions = IllegalArgumentException.class, groups = { ""level.extended"" })
 public void test_asSpreader_CrossPackage_Static_WrongArgCount() throws Throwable{
 MethodHandle mh = MethodHandles.lookup().findStatic(PackageExamples.class,""addPublicStatic"",MethodType.methodType(int.class,int.class,int.class));
-
-boolean illegalArgumentException = false; 
-
-try {
-mh = mh.asSpreader(int[].class, 3);
-}
-catch(IllegalArgumentException e) {
-illegalArgumentException = true;
-}
-
-AssertJUnit.assertTrue(illegalArgumentException);
+mh = mh.asSpreader(int[].class, 3);
+Assert.fail(""The test case failed to throw an IllegalArgumentException in the case of the wrong argument count"");
 }
 
 /******************************
  * Tests for MethodHandle arity
  * ****************************/
 /**
+ * Create MethodHandle with highest possible arity and use findConstructor (253)
+ * @throws Throwable
+ */
+@Test(groups = { ""level.extended"" })
+public void test_findConstructor_ArityLimit() throws Throwable {
+MethodHandle mh = MethodHandles.lookup().findConstructor(HelperConstructorClass.class, helperMethodType_void_253int);
+mh = mh.asSpreader(int[].class, 253);","This is a normal test case that should pass in any case; otherwise, any exception will be captured if something wrong. 

In addition, we've got test_findConstructor_ArityLimit_TooHigh() to capture the exception in the corner case.",
69074059,b7882796b4f06d9f25125db4ee57b9e73f2ff517,runtime/jcl/common/jcldefine.c,False,"@@ -145,6 +145,10 @@ defineClassCommon(JNIEnv *env, jobject classLoaderObject,
 tempClassBytes = classBytes;
 tempLength = length;
 
+/* Try to find classLocation. Ignore return code because there are valid cases where it might not find it (ie. bytecode spinning).
+ * If the class is not found the default class location is fine. */","*/ should be on it's own line, with stars lined up",
63390856,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcutil/cfreader.c,False,"@@ -1555,12 +1555,20 @@ checkMethods(J9CfrClassFile* classfile, U_8* segment, U_32 flags)
  */
 if (classfileVersion < BCT_Java7MajorVersionShifted) {
 method->accessFlags |= CFR_ACC_STATIC;
-method->accessFlags &= CFR_CLINIT_METHOD_ACCESS_MASK;
-} else if (J9_ARE_ALL_BITS_SET(method->accessFlags, CFR_ACC_STATIC)) {
-method->accessFlags &= CFR_CLINIT_METHOD_ACCESS_MASK;
-/* missing code attribute  detected elsewhere */
+
+/* if (J2SE_VERSION(vm) >= J2SE_19) { */","Can you add a comment here to explain why the commented out code is here?  I know there's a valid reason in this case (make it easy to find this location if the 8 vs 9 checks are changed to a compile time decision) and without a comment to remind reviewers, it looks like dead code and might be removed in the future.",
63390856,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/nls/cfre/cfrerr.nls,False,"@@ -1297,3 +1297,20 @@ J9NLS_CFR_ERR_BAD_NEST_TOP_INDEX.user_response=Contact the provider of the class
 
 # END NON-TRANSLATABLE
 
+# <clinit> method at version 51.0 or above does not have static flag set
+J9NLS_CFR_ERR_CLINIT_NOT_STATIC=Method <clinit> is not static
+# START NON-TRANSLATABLE
+J9NLS_CFR_ERR_CLINIT_NOT_STATIC.explanation=Please consult the Java Virtual Machine Specification for a detailed explanation.
+J9NLS_CFR_ERR_CLINIT_NOT_STATIC.system_action=The JVM will throw a verification or classloading-related exception such as java.lang.ClassFormatError.
+J9NLS_CFR_ERR_CLINIT_NOT_STATIC.user_response=Contact the provider of the classfile for a corrected version.
+
+# END NON-TRANSLATABLE
+
+# <clinit> method at version 51.0 must be void and take no arguments",Where is this used?  The staticverify.c change was reverted before we opened the code.  Did it get lost?,
63408112,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/nls/cfre/cfrerr.nls,True,"@@ -1297,3 +1297,20 @@ J9NLS_CFR_ERR_BAD_NEST_TOP_INDEX.user_response=Contact the provider of the class
 
 # END NON-TRANSLATABLE
 
+# <clinit> method at version 51.0 or above does not have static flag set
+J9NLS_CFR_ERR_CLINIT_NOT_STATIC=Method <clinit> is not static
+# START NON-TRANSLATABLE
+J9NLS_CFR_ERR_CLINIT_NOT_STATIC.explanation=Please consult the Java Virtual Machine Specification for a detailed explanation.
+J9NLS_CFR_ERR_CLINIT_NOT_STATIC.system_action=The JVM will throw a verification or classloading-related exception such as java.lang.ClassFormatError.
+J9NLS_CFR_ERR_CLINIT_NOT_STATIC.user_response=Contact the provider of the classfile for a corrected version.
+
+# END NON-TRANSLATABLE
+
+# <clinit> method at version 51.0 must be void and take no arguments",Yes. I've added it back in. I will rebuild this change.,
64996777,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcverify/staticverify.c,False,"@@ -1767,6 +1767,19 @@ j9bcv_verifyClassStructure (J9PortLibrary * portLib, J9CfrClassFile * classfile,
 goto _formatError;
 }
 
+/* The requirement for taking no arguments was introduced in Java SE 9.",Does this only apply to Java 9?  It'll likely need a `if (J2SE_VERSION(vm) >= J2SE_19) ` check,
65369382,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcutil/cfreader.c,True,"@@ -2528,12 +2539,13 @@ j9bcutil_readClassFileBytes(J9PortLibrary *portLib,
 }
 
 /* Make sure that following verification uses the class file version number */
+U_32 vmVersionShifted = flags & BCT_MajorClassFileVersionMask;;",@DanHeidinga I figured out the version issue I was having was because the vm version is replaced by the class file version prior to checking the <clinit> structure. What do you think of this fix with passing in a new variable with the vm version?,
66045734,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcverify/staticverify.c,False,"@@ -1767,6 +1767,24 @@ j9bcv_verifyClassStructure (J9PortLibrary * portLib, J9CfrClassFile * classfile,
 goto _formatError;
 }
 
+/* The requirement for taking no arguments was introduced in Java SE 9.
+ * In a class file whose version number is 51.0 or above, the method
+ * has its ACC_STATIC flag set and takes no arguments.
+ */
+                 /* Leave this here to find usages of the following check:
+                  * if (J2SE_VERSION(vm) >= J2SE_19) {
+                  */
+if (((vmVersionShifted & BCT_MajorClassFileVersionMask) >= BCT_Java9MajorVersionShifted) || ((vmVersionShifted & BCT_MajorClassFileVersionMask) == 0)) {",`vmVersionShifted & BCT_MajorClassFileVersionMask` can this be pulled into a local?  The check will more readable that way.,
66046332,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcutil/cfreader.c,False,"@@ -1514,6 +1514,8 @@ checkMethods(J9CfrClassFile* classfile, U_8* segment, U_32 flags)
 BOOLEAN nameIndexOK;
 U_32 classfileVersion = flags & BCT_MajorClassFileVersionMask;
 
+PORT_ACCESS_FROM_PORT(portLib);",Why does this take a portlb and set up for using it?  I don't see a use in the function.,
66046485,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcverify/staticverify.c,False,"@@ -1767,6 +1767,24 @@ j9bcv_verifyClassStructure (J9PortLibrary * portLib, J9CfrClassFile * classfile,
 goto _formatError;
 }
 
+/* The requirement for taking no arguments was introduced in Java SE 9.
+ * In a class file whose version number is 51.0 or above, the method
+ * has its ACC_STATIC flag set and takes no arguments.
+ */
+                 /* Leave this here to find usages of the following check:
+                  * if (J2SE_VERSION(vm) >= J2SE_19) {
+                  */
+if (((vmVersionShifted & BCT_MajorClassFileVersionMask) >= BCT_Java9MajorVersionShifted) || ((vmVersionShifted & BCT_MajorClassFileVersionMask) == 0)) {","Or, rather than passing the shifted version around, can the version be determined at the calcite and just pass the vmSupportedVersion around?",
66046519,86016d5e9d2f52c5d6170f252e283a02d3a6100b,',False,"@@ -0,0 +1,3247 @@
+/*******************************************************************************",Not sure what happened here but it shouldn't be a new file.,
66178559,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcutil/cfreader.c,True,"@@ -1514,6 +1514,8 @@ checkMethods(J9CfrClassFile* classfile, U_8* segment, U_32 flags)
 BOOLEAN nameIndexOK;
 U_32 classfileVersion = flags & BCT_MajorClassFileVersionMask;
 
+PORT_ACCESS_FROM_PORT(portLib);",That was just for debugging.,
66180732,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcverify/staticverify.c,True,"@@ -1767,6 +1767,24 @@ j9bcv_verifyClassStructure (J9PortLibrary * portLib, J9CfrClassFile * classfile,
 goto _formatError;
 }
 
+/* The requirement for taking no arguments was introduced in Java SE 9.
+ * In a class file whose version number is 51.0 or above, the method
+ * has its ACC_STATIC flag set and takes no arguments.
+ */
+                 /* Leave this here to find usages of the following check:
+                  * if (J2SE_VERSION(vm) >= J2SE_19) {
+                  */
+if (((vmVersionShifted & BCT_MajorClassFileVersionMask) >= BCT_Java9MajorVersionShifted) || ((vmVersionShifted & BCT_MajorClassFileVersionMask) == 0)) {",The mask is redundant from the declaration of vmVersion in cfreader.c. I'll remove it.,
68688866,98e738ea7996919836309e89375d0ab83f6990fc,runtime/rasdump/javadump.cpp,False,"@@ -993,6 +994,13 @@ JavaCoreDumpWriter::writeEnvironmentSection(void)
 _OutputStream.writeCharacters(_VirtualMachine->memoryManagerFunctions->omrgc_get_version(_VirtualMachine->omrVM));
 _OutputStream.writeCharacters(""\n"");
 
+#ifdef VENDOR_NAME
+/* Write the VM version data */
+_OutputStream.writeCharacters(""1CI"");
+_OutputStream.writeCharacters(VENDOR_NAME,3);","Please add a space after the comma.
I think we should expect `vendor_version.h` to also define `VENDOR_SHORT_NAME` (or something similar) which should be used here rather than the first three characters of `VENDOR_NAME`.",
68947303,98e738ea7996919836309e89375d0ab83f6990fc,runtime/jcl/common/jclcinit.c,False,"@@ -182,9 +182,9 @@ jint computeFullVersionString(J9JavaVM* vm)
 strcat(vminfo, gcVersion);
 #endif /* J9VM_GC_MODRON_GC */
 
-#if defined(VENDOR_VERSION_STRING)
-strcat(fullversion, ""\n"" VENDOR_VERSION_STRING);
-strcat(vminfo, ""\n"" VENDOR_VERSION_STRING);
+#if defined(VENDOR_NAME)","This should be
```
#if defined(VENDOR_NAME) && defined(VENDOR_SHA)
```",
68947754,98e738ea7996919836309e89375d0ab83f6990fc,runtime/rasdump/javadump.cpp,False,"@@ -993,6 +994,13 @@ JavaCoreDumpWriter::writeEnvironmentSection(void)
 _OutputStream.writeCharacters(_VirtualMachine->memoryManagerFunctions->omrgc_get_version(_VirtualMachine->omrVM));
 _OutputStream.writeCharacters(""\n"");
 
+#ifdef VENDOR_NAME","This should be
```
#if defined(VENDOR_NAME) && defined(VENDOR_SHA)
```",
68948535,98e738ea7996919836309e89375d0ab83f6990fc,runtime/rasdump/javadump.cpp,False,"@@ -993,6 +994,13 @@ JavaCoreDumpWriter::writeEnvironmentSection(void)
 _OutputStream.writeCharacters(_VirtualMachine->memoryManagerFunctions->omrgc_get_version(_VirtualMachine->omrVM));
 _OutputStream.writeCharacters(""\n"");
 
+#ifdef VENDOR_NAME
+/* Write the VM version data */
+_OutputStream.writeCharacters(""1CI"");
+_OutputStream.writeCharacters(VENDOR_NAME,3);
+_OutputStream.writeCharacters(""VERSION  "" VENDOR_SHA ""\n"");","Now that the name and SHA are separate, the whole name should be written; also these three calls to `writeCharacters` can be collapsed.",
68948826,98e738ea7996919836309e89375d0ab83f6990fc,runtime/rasdump/javadump.cpp,False,"@@ -993,6 +994,13 @@ JavaCoreDumpWriter::writeEnvironmentSection(void)
 _OutputStream.writeCharacters(_VirtualMachine->memoryManagerFunctions->omrgc_get_version(_VirtualMachine->omrVM));
 _OutputStream.writeCharacters(""\n"");
 
+#ifdef VENDOR_NAME
+/* Write the VM version data */
+_OutputStream.writeCharacters(""1CI"");
+_OutputStream.writeCharacters(VENDOR_NAME,3);
+_OutputStream.writeCharacters(""VERSION  "" VENDOR_SHA ""\n"");
+#endif",There should be a comment at the end of this line identifying the condition in the `#if` line.,
68997004,98e738ea7996919836309e89375d0ab83f6990fc,runtime/include/vendor_version.h,False,"@@ -19,10 +19,10 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
-
-/* Example usage for repo and sha.  This value will be inserted into the
- * java.fullversion and java.vm.info system properties
- * #define VENDOR_VERSION_STRING ""<repo name> - <sha>""
- * or descriptive string
- * #define VENDOR_VERSION_STRING ""Add some experimental code to java.base""
+/* Example usage for inclusion of a vendor name and repository sha.  These values
+ * will be inserted into the java.fullversion and java.vm.info system properties
+ *
+ * #define VENDOR_NAME""ABC Widgets Inc.""
+ * #define VENDOR_SHORT_NAME""ABC""
+ * #define VENDOR_SHA""1a2b3c4""","Please don't use internal tabs, as the values don't line up with all tab settings.",
68997423,98e738ea7996919836309e89375d0ab83f6990fc,runtime/jcl/common/jclcinit.c,False,"@@ -182,10 +182,10 @@ jint computeFullVersionString(J9JavaVM* vm)
 strcat(vminfo, gcVersion);
 #endif /* J9VM_GC_MODRON_GC */
 
-#if defined(VENDOR_VERSION_STRING)
-strcat(fullversion, ""\n"" VENDOR_VERSION_STRING);
-strcat(vminfo, ""\n"" VENDOR_VERSION_STRING);
-#endif /* VENDOR_VERSION_STRING */
+#if defined(VENDOR_SHORT_NAME) && defined(VENDOR_SHA)
+strcat(fullversion, ""\n"" VENDOR_SHORT_NAME ""      - "" VENDOR_SHA);
+strcat(vminfo, ""\n"" VENDOR_SHORT_NAME ""      - "" VENDOR_SHA);
+#endif /* VENDOR_SHORT_NAME and VENDOR_SHA */",Please `&&` instead of `and` (for consistency at least).,
69011593,98e738ea7996919836309e89375d0ab83f6990fc,runtime/include/vendor_version.h,False,"@@ -19,10 +19,10 @@
  *
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
-",This blank line was helpful in separating the copyright notice from what follows.,
69246368,98e738ea7996919836309e89375d0ab83f6990fc,runtime/include/vendor_version.h,False,"@@ -20,9 +20,10 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
 
-/* Example usage for repo and sha.  This value will be inserted into the
- * java.fullversion and java.vm.info system properties
- * #define VENDOR_VERSION_STRING ""<repo name> - <sha>""
- * or descriptive string
- * #define VENDOR_VERSION_STRING ""Add some experimental code to java.base""
+/* Example usage for inclusion of a vendor name and repository sha.  These values
+ * will be inserted into the java.fullversion and java.vm.info system properties",and also the javacore file,
69283779,98e738ea7996919836309e89375d0ab83f6990fc,runtime/include/vendor_version.h,True,"@@ -20,9 +20,10 @@
  * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
  *******************************************************************************/
 
-/* Example usage for repo and sha.  This value will be inserted into the
- * java.fullversion and java.vm.info system properties
- * #define VENDOR_VERSION_STRING ""<repo name> - <sha>""
- * or descriptive string
- * #define VENDOR_VERSION_STRING ""Add some experimental code to java.base""
+/* Example usage for inclusion of a vendor name and repository sha.  These values
+ * will be inserted into the java.fullversion and java.vm.info system properties",Comment updated.,
63832901,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,399 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is nut supposed to accept null MethodHandle"");",spelling `nut` ,
63832901,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,399 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is nut supposed to accept null MethodHandle"");",same below,
63832901,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range*/","nitpick ""range*/"" should be space for '*/'",
63832901,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,399 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is nut supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is nut supposed to accept null parameter list"");
+}
+","A test with a target methodHandle that accepts no parameters (ie ()Ljava/lang/String;) might be usefull as well. 

Similarly a non-NULL empty parameter list would also be usefull",
63832901,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range*/
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(""Invalid parameters: skippedArgumentCount""); //$NON-NLS-1$
+}
+if ((0 > location) ||
+(valueTypes.size() < location) ||","if location is zero indexed then wouldn't ""valueTypes.size() <= location"" also be out of range?",
64300072,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,399 @@
+/*******************************************************************************
+ * Copyright (c) 2016, 2017 IBM Corp. and others","If this is a new introduced file, the year should begin from 2017",
64411023,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range*/
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(""Invalid parameters: skippedArgumentCount""); //$NON-NLS-1$
+}
+if ((0 > location) ||
+(valueTypes.size() < location) ||",I discussed with Jack and the second check ensures that location never overflows,
64477067,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(""Invalid parameters: skippedArgumentCount""); //$NON-NLS-1$",The string should be externalized. Look for MSG in this class to find examples.,
64653000,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,True,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(""Invalid parameters: skippedArgumentCount""); //$NON-NLS-1$","fixed, moved exceptions to ExternalMesages-MasterIndex
added entries K0670 - K0674",
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a prefix of the valueType list
+ * ie. [S...M] + [M...A] => S...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_prefix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [String, String, boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, String.class, String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(new Hash_Methods(), ""a"", ""b"", ""c"", ""d"", true, 'e', 1, 2, ""f"", ""g""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a suffix of the valueType list
+ * ie. [S...M] + [P...M] => S...P...M
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_suffix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a sublist of the valueType list
+ * ie. [S...M] + [P...M...A] => S...P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String, boolean, char, int, long] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class, boolean.class, char.class, int.class, long.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d"", false, 'f', 3, 4), ""abcd"", ""Method handle did not return expected result"");
+
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type boolean
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_boolean() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_boolean"", MethodType.methodType(String.class, boolean.class, boolean.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, boolean, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, boolean.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, true, false, 'a', 1, 2, true, ""b""), ""true"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type byte
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_byte() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte.class, byte.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, byte, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, byte.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d""), ""ab"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type char
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_char() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_char"", MethodType.methodType(String.class, char.class, char.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, char, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, char.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, 'a', true, 'c', 1, 2, 'b', ""d""), ""ab"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type int
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_int() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_int"", MethodType.methodType(String.class, int.class, int.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, int, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, int.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, 1, true, 'a', 3, 4, 2, ""b""), ""12"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type double
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_double() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_double"", MethodType.methodType(String.class, double.class, double.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, double, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, double.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, 1, true, 'a', 3, 4, 2, ""b""), ""1.02.0"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type int[]
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_Array() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_array"", MethodType.methodType(String.class, int[].class, int[].class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, int[], int[]] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, int[].class, int[].class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, new int[] {1, 2}, true, 'a', 5, 6, new int[] {3,4}, null), ""1234"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a prefix of the valueType list
+ * ie. [S...M] + [M...A] => S...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_prefix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [String, String, boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, String.class, String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(new Hash_Methods(), ""a"", ""b"", ""c"", ""d"", true, 'e', 1, 2, ""f"", ""g""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a suffix of the valueType list
+ * ie. [S...M] + [P...M] => S...P...M
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_suffix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a sublist of the valueType list
+ * ie. [S...M] + [P...M...A] => S...P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String, boolean, char, int, long] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class, boolean.class, char.class, int.class, long.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d"", false, 'f', 3, 4), ""abcd"", ""Method handle did not return expected result"");
+
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type boolean
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_boolean() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_boolean"", MethodType.methodType(String.class, boolean.class, boolean.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, boolean, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, boolean.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, true, false, 'a', 1, 2, true, ""b""), ""true"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type byte
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_byte() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte.class, byte.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, byte, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, byte.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d""), ""ab"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type char
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_char() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_char"", MethodType.methodType(String.class, char.class, char.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, char, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, char.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, 'a', true, 'c', 1, 2, 'b', ""d""), ""ab"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type int
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_int() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_int"", MethodType.methodType(String.class, int.class, int.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, int, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, int.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, 1, true, 'a', 3, 4, 2, ""b""), ""12"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type double
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_double() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_double"", MethodType.methodType(String.class, double.class, double.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, double, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, double.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, 1, true, 'a', 3, 4, 2, ""b""), ""1.02.0"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a prefix of the valueType list
+ * ie. [S...M] + [M...A] => S...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_prefix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [String, String, boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, String.class, String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(new Hash_Methods(), ""a"", ""b"", ""c"", ""d"", true, 'e', 1, 2, ""f"", ""g""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a suffix of the valueType list
+ * ie. [S...M] + [P...M] => S...P...M
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_suffix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a sublist of the valueType list
+ * ie. [S...M] + [P...M...A] => S...P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String, boolean, char, int, long] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class, boolean.class, char.class, int.class, long.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d"", false, 'f', 3, 4), ""abcd"", ""Method handle did not return expected result"");
+
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type boolean
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_boolean() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_boolean"", MethodType.methodType(String.class, boolean.class, boolean.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, boolean, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, boolean.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, true, false, 'a', 1, 2, true, ""b""), ""true"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type byte
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_byte() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte.class, byte.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, byte, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, byte.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d""), ""ab"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type char
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_char() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_char"", MethodType.methodType(String.class, char.class, char.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, char, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, char.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, 'a', true, 'c', 1, 2, 'b', ""d""), ""ab"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type int
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_int() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_int"", MethodType.methodType(String.class, int.class, int.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, int, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, int.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, 1, true, 'a', 3, 4, 2, ""b""), ""12"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a prefix of the valueType list
+ * ie. [S...M] + [M...A] => S...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_prefix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [String, String, boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, String.class, String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(new Hash_Methods(), ""a"", ""b"", ""c"", ""d"", true, 'e', 1, 2, ""f"", ""g""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a suffix of the valueType list
+ * ie. [S...M] + [P...M] => S...P...M
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_suffix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a sublist of the valueType list
+ * ie. [S...M] + [P...M...A] => S...P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String, boolean, char, int, long] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class, boolean.class, char.class, int.class, long.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d"", false, 'f', 3, 4), ""abcd"", ""Method handle did not return expected result"");
+
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type boolean
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_boolean() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_boolean"", MethodType.methodType(String.class, boolean.class, boolean.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, boolean, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, boolean.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, true, false, 'a', 1, 2, true, ""b""), ""true"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type byte
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_byte() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte.class, byte.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, byte, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, byte.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d""), ""ab"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type char
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_char() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_char"", MethodType.methodType(String.class, char.class, char.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, char, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, char.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, 'a', true, 'c', 1, 2, 'b', ""d""), ""ab"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a prefix of the valueType list
+ * ie. [S...M] + [M...A] => S...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_prefix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [String, String, boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, String.class, String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(new Hash_Methods(), ""a"", ""b"", ""c"", ""d"", true, 'e', 1, 2, ""f"", ""g""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a suffix of the valueType list
+ * ie. [S...M] + [P...M] => S...P...M
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_suffix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a sublist of the valueType list
+ * ie. [S...M] + [P...M...A] => S...P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String, boolean, char, int, long] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class, boolean.class, char.class, int.class, long.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d"", false, 'f', 3, 4), ""abcd"", ""Method handle did not return expected result"");
+
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type boolean
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_boolean() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_boolean"", MethodType.methodType(String.class, boolean.class, boolean.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, boolean, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, boolean.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, true, false, 'a', 1, 2, true, ""b""), ""true"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type byte
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_byte() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte.class, byte.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, byte, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, byte.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d""), ""ab"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a prefix of the valueType list
+ * ie. [S...M] + [M...A] => S...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_prefix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [String, String, boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, String.class, String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(new Hash_Methods(), ""a"", ""b"", ""c"", ""d"", true, 'e', 1, 2, ""f"", ""g""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a suffix of the valueType list
+ * ie. [S...M] + [P...M] => S...P...M
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_suffix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a sublist of the valueType list
+ * ie. [S...M] + [P...M...A] => S...P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String, boolean, char, int, long] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class, boolean.class, char.class, int.class, long.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d"", false, 'f', 3, 4), ""abcd"", ""Method handle did not return expected result"");
+
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is of type boolean
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist_boolean() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_boolean"", MethodType.methodType(String.class, boolean.class, boolean.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, boolean, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, boolean.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, true, false, 'a', 1, 2, true, ""b""), ""true"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a prefix of the valueType list
+ * ie. [S...M] + [M...A] => S...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_prefix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [String, String, boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, String.class, String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(new Hash_Methods(), ""a"", ""b"", ""c"", ""d"", true, 'e', 1, 2, ""f"", ""g""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a suffix of the valueType list
+ * ie. [S...M] + [P...M] => S...P...M
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_suffix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a sublist of the valueType list
+ * ie. [S...M] + [P...M...A] => S...P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_normal_sublist() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String, boolean, char, int, long] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class, boolean.class, char.class, int.class, long.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d"", false, 'f', 3, 4), ""abcd"", ""Method handle did not return expected result"");
+
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a prefix of the valueType list
+ * ie. [S...M] + [M...A] => S...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_prefix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [String, String, boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, String.class, String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(new Hash_Methods(), ""a"", ""b"", ""c"", ""d"", true, 'e', 1, 2, ""f"", ""g""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a suffix of the valueType list
+ * ie. [S...M] + [P...M] => S...P...M
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_suffix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 4);
+
+Hash_Methods hm = new Hash_Methods();
+Assert.assertEquals(h1.invoke(hm, ""a"", ""b"", true, 'e', 1, 2, ""c"", ""d""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test where handle parameter list is a prefix of the valueType list
+ * ie. [S...M] + [M...A] => S...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_prefix_list() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_multi_arguments"", MethodType.methodType(String.class, String.class, String.class, String.class, String.class));
+
+/* Method with rtype = String, ptype = [String, String, boolean, char, int, long, String, String] */
+MethodType typeList = MethodType.methodType(String.class, String.class, String.class, boolean.class, char.class, int.class, long.class, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 3, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(new Hash_Methods(), ""a"", ""b"", ""c"", ""d"", true, 'e', 1, 2, ""f"", ""g""), ""abcd"", ""Method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full skip, empty matching array
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_skip_all() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(""x"", ""y"", ""a"", ""b"", ""c"", ""d""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for full match, 0 skipped parameters
+ * ie. [M] + [P...M...A] => P...M...A
+ */
+@Test(groups = { ""level.extended"" })
+public static void test_dropArgumentsToMatch_no_skip() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.assertEquals(h1.invoke(""a"", ""x"", ""y"", ""b""), ""xy"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);
+}
+}
+
+/**
+ * test for empty valueList
+ */
+@Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_valueList() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type();
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke(), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -0,0 +1,451 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.jsr292.api;
+
+import org.testng.annotations.Test;
+import org.testng.Assert;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class MethodHandleAPI_dropArgumentsToMatch {
+public static class Hash_Methods {
+public Hash_Methods() {}
+
+public static String hash_void() {
+return ""abc"";
+}
+
+public String hash_boolean(boolean a, boolean b) {
+return String.valueOf(a && b);
+}
+
+public String hash_byte(byte a, byte b) {
+return new String(new byte[] {a, b});
+}
+
+public String hash_char(char a, char b) {
+return """" + a + b;
+}
+
+public String hash_int(int a, int b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_double(double a, double b) {
+return String.valueOf(a) + String.valueOf(b);
+}
+
+public String hash_array(int[] a, int[] b) {
+String res = """";
+for (int i = 0; i < a.length; i++) {
+res += String.valueOf(a[i]);
+}
+for (int j = 0; j < b.length; j++) {
+res += String.valueOf(b[j]);
+}
+return res;
+}
+
+public String hash_multi_arguments(String a, String b, String c, String d) {
+return a + b + c + d;
+}
+}
+
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_handle() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(null, 0, h0.type().parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null MethodHandle"");
+}
+
+/**
+ * test for null argument
+ * @throws NullPointerException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = NullPointerException.class)
+public static void test_dropArgumentsToMatch_null_list() throws Throwable {
+MethodHandle h0 = MethodHandles.constant(boolean.class, true);
+
+MethodHandle h1 = MethodHandles.dropArgumentsToMatch(h0, 0, null, 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept null parameter list"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, -2, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_skip() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 10, typeList.parameterList(), 0);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound skip value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_negative_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), -1);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept negative location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 10);
+
+Assert.fail(""dropArgumentsToMatch method is not supposed to accept outbound location value"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_non_mactching_location() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must match non-skipped parameters with valueTypes list starting at location"");
+}
+
+/**
+ * test for illegal arguments
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_void_class() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, int.class, void.class, char.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 1);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for illegal arguments where match location has passed the end of valueList
+ * @throws IllegalArgumentException
+ */
+@Test(groups = { ""level.extended"" }, expectedExceptions = IllegalArgumentException.class)
+public static void test_dropArgumentsToMatch_outrange_matching() throws Throwable {
+MethodHandle h1 = MethodHandles.lookup().findVirtual(String.class, ""concat"", MethodType.methodType(String.class, String.class));
+MethodType typeList = h1.type().insertParameterTypes(1, String.class, String.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 1, typeList.parameterList(), 4);
+
+Assert.fail(""dropArgumentsToMatch method must receive a valueTypes list that doesn't contain void.class"");
+}
+
+/**
+ * test for empty original parameter list
+ */
+    @Test(groups = {""level.extended""})
+public static void test_dropArgumentsToMatch_empty_original() {
+try {
+MethodHandle h1 = MethodHandles.lookup().findStatic(Hash_Methods.class, ""hash_void"", MethodType.methodType(String.class));
+MethodType typeList = h1.type().insertParameterTypes(0, char.class, int.class);
+
+h1 = MethodHandles.dropArgumentsToMatch(h1, 0, typeList.parameterList(), 0);
+
+Assert.assertEquals(h1.invoke('c', 2), ""abc"", ""Transformed method handle did not return expected result"");
+} catch (Throwable t) {
+Assert.fail(""No Exceptions/throwable expected from dropArgumentsToMatch."", t);",This isn't required.  An uncaught exception will cause the test to fail.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||","Can you write this as
```
if ((skippedArgumentCount < 0) || 
```
It tends to be easier to read as the bounds then.",
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0670"")); //$NON-NLS-1$",This should be proceeded by a comment that includes the K0670 and the message using preprocessor tags.  Search for other uses of the com.ibm.oti.util.Msg class to see how the comment should look,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];","Please cache `valueTypes.size()` in a local.  Because the parameter is a List, we don't know how expensive that operation might be and the result is used repeatedly in this method",
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0670"")); //$NON-NLS-1$
+}
+if ((0 > location) ||",`0 > value` is a strange idiom for checking if the value is negative.  Write the code so it's easy to read and matches most readers expectations.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0670"")); //$NON-NLS-1$
+}
+if ((0 > location) ||
+(valueTypes.size() < location) ||
+(valueTypes.size() < location + originalType.parameterCount() - skippedArgumentCount)) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0671"")); //$NON-NLS-1$",This should be proceeded by a comment that includes the K0670 and the message using preprocessor tags.  Search for other uses of the com.ibm.oti.util.Msg class to see how the comment should look,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0670"")); //$NON-NLS-1$
+}
+if ((0 > location) ||
+(valueTypes.size() < location) ||
+(valueTypes.size() < location + originalType.parameterCount() - skippedArgumentCount)) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0671"")); //$NON-NLS-1$
+}
+
+/* check for void.class in list during clone process */
+for (int i = 0; i < valueTypes.size(); i++) {
+if (valueTypes.get(i) == void.class) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0672"")); //$NON-NLS-1$",This should be proceeded by a comment that includes the K0670 and the message using preprocessor tags.  Search for other uses of the com.ibm.oti.util.Msg class to see how the comment should look,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0670"")); //$NON-NLS-1$
+}
+if ((0 > location) ||
+(valueTypes.size() < location) ||
+(valueTypes.size() < location + originalType.parameterCount() - skippedArgumentCount)) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0671"")); //$NON-NLS-1$
+}
+
+/* check for void.class in list during clone process */
+for (int i = 0; i < valueTypes.size(); i++) {
+if (valueTypes.get(i) == void.class) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0672"")); //$NON-NLS-1$
+}
+else if (valueTypes.get(i) == null) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0673"")); //$NON-NLS-1$",This should be proceeded by a comment that includes the K0670 and the message using preprocessor tags.  Search for other uses of the com.ibm.oti.util.Msg class to see how the comment should look,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0670"")); //$NON-NLS-1$
+}
+if ((0 > location) ||
+(valueTypes.size() < location) ||
+(valueTypes.size() < location + originalType.parameterCount() - skippedArgumentCount)) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0671"")); //$NON-NLS-1$
+}
+
+/* check for void.class in list during clone process */
+for (int i = 0; i < valueTypes.size(); i++) {
+if (valueTypes.get(i) == void.class) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0672"")); //$NON-NLS-1$
+}
+else if (valueTypes.get(i) == null) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0673"")); //$NON-NLS-1$
+}
+else {
+valueTypesCopy[i] = valueTypes.get(i);
+}
+}
+
+Class<?>[] ptypes = originalType.parameterArray();
+
+/* check if sublist match */
+for (int i = skippedArgumentCount; i < ptypes.length; i++) {
+if (ptypes[i] != valueTypesCopy[i + location - skippedArgumentCount]) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0674"")); //$NON-NLS-1$",This should be proceeded by a comment that includes the K0670 and the message using preprocessor tags.  Search for other uses of the com.ibm.oti.util.Msg class to see how the comment should look,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0670"")); //$NON-NLS-1$
+}
+if ((0 > location) ||
+(valueTypes.size() < location) ||
+(valueTypes.size() < location + originalType.parameterCount() - skippedArgumentCount)) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0671"")); //$NON-NLS-1$
+}
+
+/* check for void.class in list during clone process */
+for (int i = 0; i < valueTypes.size(); i++) {",cache the result of `valueTypes.get(i)` in a local in the for loop so it only needs to be executed once.,
69044489,4519f050137c9c221ff0b3eddcc9701249c97b28,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -2818,11 +2818,62 @@ public static MethodHandle dropArguments(MethodHandle originalHandle, int locati
  * @param originalHandle the original method handle to be transformed
  * @param skippedArgumentCount the number of argument to be skipped from the original method handle
  * @param valueTypes a List of the argument types to be inserted
- * @param location the location of the first argument to be removed
+ * @param location the (zero-indexed) location of the first argument to be removed
  * @return a MethodHandle representing a transformed handle as described above
  */
-public static MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
-throw new UnsupportedOperationException(""The method has not yet been implemented for now""); //$NON-NLS-1$
+public static final  MethodHandle dropArgumentsToMatch(MethodHandle originalHandle, int skippedArgumentCount, List<Class<?>> valueTypes, int location) {
+/* implicit null checks */
+MethodType originalType = originalHandle.type;
+Class<?>[] valueTypesCopy = new Class<?>[valueTypes.size()];
+
+/* check if indexing is in range */
+if ((0 > skippedArgumentCount) ||
+(skippedArgumentCount > originalType.parameterCount())) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0670"")); //$NON-NLS-1$
+}
+if ((0 > location) ||
+(valueTypes.size() < location) ||
+(valueTypes.size() < location + originalType.parameterCount() - skippedArgumentCount)) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0671"")); //$NON-NLS-1$
+}
+
+/* check for void.class in list during clone process */
+for (int i = 0; i < valueTypes.size(); i++) {
+if (valueTypes.get(i) == void.class) {
+throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K0672"")); //$NON-NLS-1$
+}","Formatting nitpick: please write this as
``` 
} else if {
```
Here and other places need to be modified.",
68333515,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.hpp,False,"@@ -65,6 +65,8 @@ class S390CHelperLinkage : public TR::Linkage
 virtual TR::RealRegister::RegNum getCAAPointerRegister() { return _CAAPointerRegister; }
 #endif
 #endif  
+   virtual uint32_t setPreservedRegisterMapForGC(uint32_t m) {return _preservedRegisterMapForGC = m; }
+   virtual uint32_t getPreservedRegisterMapForGC() {return _preservedRegisterMapForGC; }",Can we Doxygen document these functions?,
68333515,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.hpp,False,"@@ -73,17 +75,21 @@ class S390CHelperLinkage : public TR::Linkage
       }
    virtual TR::Register * buildDirectDispatch(TR::Node * callNode)
       {
-      return buildDirectDispatch(callNode,NULL);
+      return buildDirectDispatch(callNode, static_cast<TR::RegisterDependencyConditions**>(NULL));
       }
-   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister)
+   TR::Register* buildDirectDispatch(TR::Node *callNode, TR::Register *returnReg)
+      {
+      return buildDirectDispatch(callNode, NULL, returnReg);
+      }
+   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister, TR::Register *returnReg=NULL)
    {
-   return buildDirectDispatch(callNode, NULL, paramInRegister);
+   return buildDirectDispatch(callNode, NULL, paramInRegister, returnReg);
    }
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps)
+   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL)",There seems to be changes in the _public_ API here. Can we document these APIs?,
68333515,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -3773,7 +3773,9 @@ J9::Z::TreeEvaluator::ArrayStoreCHKEvaluator(TR::Node * node, TR::CodeGenerator
    TR_J9VMBase *fej9 = (TR_J9VMBase *)(comp->fe());
    TR::Node * firstChild = node->getFirstChild();
    TR_WriteBarrierKind gcMode = comp->getOptions()->getGcMode();
-
+   // As arguments to ArrayStoreCHKEvaluator helper function is children of first child,
+   // We need to create a dummy call node for helper call with children containing arguments to helper call. 
+   TR::Node *callNode = TR::Node::createWithSymRef(node, TR::call, 2, node->getSymbolReference());",Can we move this definition closer to where it is actually used?,
68333515,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,False,"@@ -126,6 +126,7 @@ TR::S390CHelperLinkage::S390CHelperLinkage(TR::CodeGenerator * codeGen,TR_S390Li
       setIntegerArgumentRegister(2, TR::RealRegister::GPR4);
       setIntegerArgumentRegister(3, TR::RealRegister::GPR5);
       setIntegerArgumentRegister(4, TR::RealRegister::GPR6);
+      setPreservedRegisterMapForGC(0x0000BFC0);","We don't have to do this now, but we would get some pretty subtle bugs if the preserved register list was ever modified without updating this constant. We should consider in the future generating this map using the list of preserved registers directly from the linkage rather than encoding it by hand.",
68333515,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,False,"@@ -252,13 +260,14 @@ class RealRegisterManager
  *    \param callNode The node for which you are generating a heleper call
  *    \param deps The pre register dependency conditions that will be filled by this function to attach within ICF
  *    \param paramInRegisters Stack of registers that contains arguments to be passed to the helper function,
- *           if passed empty stack, this function will evaluate children of node to prepare arguments
+ *           if passed empty stack, this function will clobber evaluate children of node to prepare arguments",We should document `returnReg`.,
68333515,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,False,"@@ -252,13 +260,14 @@ class RealRegisterManager
  *    \param callNode The node for which you are generating a heleper call
  *    \param deps The pre register dependency conditions that will be filled by this function to attach within ICF
  *    \param paramInRegisters Stack of registers that contains arguments to be passed to the helper function,
- *           if passed empty stack, this function will evaluate children of node to prepare arguments
+ *           if passed empty stack, this function will clobber evaluate children of node to prepare arguments
  *    \return TR::Register *helperReturnResult, gets the return value of helper function and return to the evaluator. 
  */
-TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters)
+TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg)",Is `paramInRegisters` even being used anywhere in the codebase? I don't see any occurrences. Is it possible to simplify this API by removing the parameter?,
68333515,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,False,"@@ -390,41 +388,50 @@ TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode,
 }
 else
 {
-      // Fastpath helper do not expects GC call in-between so only attaching them for normal dual mode helpers 
-cursor->setNeedsGCMap(0x0000FFFF);
+      // Fastpath helper do not expects GC call in-between so only attaching them for normal dual mode helpers
+      // As GC map is attached to instruction after RA is done, it is guaranteed that all the non-preserved register by system linkage are either stored in preserved register
+      // Or spilled to stack. We only need to mark preserved register in GC map. Only possiblity of non-preserved register containing a live object is in argument to helper which should be a clobberable copy of actual object. 
+cursor->setNeedsGCMap(getPreservedRegisterMapForGC());",You seem to be using a mix of tabs and spaces in this commit. Please use spaces only as the rest of the codebase does.,
68333515,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,False,"@@ -377,6 +374,7 @@ TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode,
 TR::SymbolReference * callSymRef = callNode->getSymbolReference();
 intptrj_t destAddr = (intptrj_t) callNode->getSymbolReference()->getSymbol()->castToMethodSymbol()->getMethodAddress();
 cursor = new (cg()->trHeapMemory()) TR::S390RILInstruction(TR::InstOpCode::BRASL, callNode, regRA, destAddr, callSymRef, cg());
+   cursor->setDependencyConditions(preDeps);",Formatting alignment issues here.,
68771821,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,True,"@@ -126,6 +126,7 @@ TR::S390CHelperLinkage::S390CHelperLinkage(TR::CodeGenerator * codeGen,TR_S390Li
       setIntegerArgumentRegister(2, TR::RealRegister::GPR4);
       setIntegerArgumentRegister(3, TR::RealRegister::GPR5);
       setIntegerArgumentRegister(4, TR::RealRegister::GPR6);
+      setPreservedRegisterMapForGC(0x0000BFC0);",Makes sense. I have added a comment at this point. Basically what we should have is one function that goes over list of preserved register and prepares register map for GC. I have added this in `TODO` right now. ,
68771962,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.hpp,True,"@@ -73,17 +75,21 @@ class S390CHelperLinkage : public TR::Linkage
       }
    virtual TR::Register * buildDirectDispatch(TR::Node * callNode)
       {
-      return buildDirectDispatch(callNode,NULL);
+      return buildDirectDispatch(callNode, static_cast<TR::RegisterDependencyConditions**>(NULL));
       }
-   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister)
+   TR::Register* buildDirectDispatch(TR::Node *callNode, TR::Register *returnReg)
+      {
+      return buildDirectDispatch(callNode, NULL, returnReg);
+      }
+   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister, TR::Register *returnReg=NULL)
    {
-   return buildDirectDispatch(callNode, NULL, paramInRegister);
+   return buildDirectDispatch(callNode, NULL, paramInRegister, returnReg);
    }
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps)
+   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL)",I added Doxygen styled documentation with explanation for each overloaded function. ,
68772639,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,True,"@@ -252,13 +260,14 @@ class RealRegisterManager
  *    \param callNode The node for which you are generating a heleper call
  *    \param deps The pre register dependency conditions that will be filled by this function to attach within ICF
  *    \param paramInRegisters Stack of registers that contains arguments to be passed to the helper function,
- *           if passed empty stack, this function will evaluate children of node to prepare arguments
+ *           if passed empty stack, this function will clobber evaluate children of node to prepare arguments
  *    \return TR::Register *helperReturnResult, gets the return value of helper function and return to the evaluator. 
  */
-TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters)
+TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg)","Currently `paramInRegister` is used only by `VMNewEvaluator`. In cases where we have child `iconst` or `iload` (Basically 32-bit values to be passed as argument), evaluating that child only changes the lower half of the register keeping upper half intact. This was hitting an issue where C helper function was trying to use whole argument register.",
68778671,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,False,"@@ -252,13 +260,14 @@ class RealRegisterManager
  *    \param callNode The node for which you are generating a heleper call
  *    \param deps The pre register dependency conditions that will be filled by this function to attach within ICF
  *    \param paramInRegisters Stack of registers that contains arguments to be passed to the helper function,
- *           if passed empty stack, this function will evaluate children of node to prepare arguments
+ *           if passed empty stack, this function will clobber evaluate children of node to prepare arguments
  *    \return TR::Register *helperReturnResult, gets the return value of helper function and return to the evaluator. 
  */
-TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters)
+TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg)",Is it possible to remove the use and deprecate this parameter?,
68778901,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,False,"@@ -268,23 +281,34 @@ TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode,
          RealRegisters.use((TR::RealRegister::RegNum)i);
          }
       }
-
+   TR::RegisterDependencyConditions *childNodeRegDeps = NULL;
    // An empty list passed here means we need to evaluate child of the node to prepare argument lists.
    if (paramInRegisters.isEmpty())
-   {
-   // TODO For Time Being, it is expected that param number won't increase beyond 3 need to fix this when support for stack is there
-   for (int i=0; i< callNode->getNumChildren(); i++)
-   {
-   if (i < self()->getNumIntegerArgumentRegisters())
-   paramInRegisters.push(cg()->evaluate(callNode->getChild(i)));
-   else
-   TR_ASSERT(false,""Parameters on Stack not supported yet"");
-   }
-   }
+{
+childNodeRegDeps = generateRegisterDependencyConditions(0,callNode->getNumChildren(), cg());
+// TODO For Time Being, it is expected that param number won't increase beyond 3 need to fix this when support for stack is there
+for (int i=0; i< callNode->getNumChildren(); i++)
+{
+if (i < self()->getNumIntegerArgumentRegisters())
+paramInRegisters.push(cg()->gprClobberEvaluate(callNode->getChild(i)));
+else
+TR_ASSERT(false,""Parameters on Stack not supported yet"");",Still a mix of tabs and spaces here. Please enable whitespace hints on your editor and fix all of them up. You may want to consider setting `core.safecrlf false` and `core.autocrlf input` in your .gitconfig for this project.,
68799778,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,True,"@@ -252,13 +260,14 @@ class RealRegisterManager
  *    \param callNode The node for which you are generating a heleper call
  *    \param deps The pre register dependency conditions that will be filled by this function to attach within ICF
  *    \param paramInRegisters Stack of registers that contains arguments to be passed to the helper function,
- *           if passed empty stack, this function will evaluate children of node to prepare arguments
+ *           if passed empty stack, this function will clobber evaluate children of node to prepare arguments
  *    \return TR::Register *helperReturnResult, gets the return value of helper function and return to the evaluator. 
  */
-TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters)
+TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg)",In VMNew evaluator with current implementation of `iconstEval*` on it is not possible it uses `LHI` instruction to load so we end up having only lower 32 bits of the register filled with value. `new` helper uses whole 64 bits in argument. This causes allocation of wrong type of object or very large size array which causes `AIOOB`. ,
68967164,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,False,"@@ -252,13 +260,14 @@ class RealRegisterManager
  *    \param callNode The node for which you are generating a heleper call
  *    \param deps The pre register dependency conditions that will be filled by this function to attach within ICF
  *    \param paramInRegisters Stack of registers that contains arguments to be passed to the helper function,
- *           if passed empty stack, this function will evaluate children of node to prepare arguments
+ *           if passed empty stack, this function will clobber evaluate children of node to prepare arguments
  *    \return TR::Register *helperReturnResult, gets the return value of helper function and return to the evaluator. 
  */
-TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters)
+TR::Register * TR::S390CHelperLinkage::buildDirectDispatch(TR::Node * callNode, TR::RegisterDependencyConditions **deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg)","Ok, I understand. Still seems odd that we have a very general API for a very specific case. IMO we would benefit from having consistency everywhere and sending hand crafted call nodes to the linkage, same as Power codegen does. In this would you can have an `i2l` tree for the scenario you describe in VMNewEvaluator and everything just works and is consistent.

This is outside the scope of this PR though, but a nice to have in the future.",
68973759,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,False,"@@ -135,7 +138,14 @@ TR::S390CHelperLinkage::S390CHelperLinkage(TR::CodeGenerator * codeGen,TR_S390Li
       {
       // 31-Bit zOS will need GPR12 for CAA register so it won't be preserved. For all other variant it is preserved
       if (TR::Compiler->target.is64Bit())
-         setRegisterFlag(TR::RealRegister::GPR12, Preserved); 
+         {",GPR14 is a preserved register according to XPLINK register linkage.  Should that be included here?   ,
68977752,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,True,"@@ -135,7 +138,14 @@ TR::S390CHelperLinkage::S390CHelperLinkage(TR::CodeGenerator * codeGen,TR_S390Li
       {
       // 31-Bit zOS will need GPR12 for CAA register so it won't be preserved. For all other variant it is preserved
       if (TR::Compiler->target.is64Bit())
-         setRegisterFlag(TR::RealRegister::GPR12, Preserved); 
+         {","@joransiu Good catch. Just checked linkage, We do need to preserve it on zOS. Added it. Let me do basic test with it. ",
69034688,15021ed5eb5baedbb96b998554e4e777870a9c50,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.cpp,True,"@@ -135,7 +138,14 @@ TR::S390CHelperLinkage::S390CHelperLinkage(TR::CodeGenerator * codeGen,TR_S390Li
       {
       // 31-Bit zOS will need GPR12 for CAA register so it won't be preserved. For all other variant it is preserved
       if (TR::Compiler->target.is64Bit())
-         setRegisterFlag(TR::RealRegister::GPR12, Preserved); 
+         {",Finished local unit tests. Should be good to go. ,
69453737,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcverify/staticverify.c,False,"@@ -1767,6 +1767,24 @@ j9bcv_verifyClassStructure (J9PortLibrary * portLib, J9CfrClassFile * classfile,
 goto _formatError;
 }
 
+/* The requirement for taking no arguments was introduced in Java SE 9.
+ * In a class file whose version number is 51.0 or above, the method
+ * has its ACC_STATIC flag set and takes no arguments.
+ */
+                 /* Leave this here to find usages of the following check:
+                  * if (J2SE_VERSION(vm) >= J2SE_19) {
+                  */
+if (vmVersionShifted >= BCT_Java9MajorVersionShifted) {
+if (classfile->majorVersion >= 51) {
+if ((CFR_METHOD_NAME_CLINIT == isInit) 
+&& (0 != argCount) 
+) {","Nitpick: This condition is reasonably short - it could get away with being a single line 
```
if ((CFR_METHOD_NAME_CLINIT == isInit) && (0 != argCount)) {
```",
69453990,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcverify/staticverify.c,False,"@@ -1767,6 +1767,24 @@ j9bcv_verifyClassStructure (J9PortLibrary * portLib, J9CfrClassFile * classfile,
 goto _formatError;
 }
 
+/* The requirement for taking no arguments was introduced in Java SE 9.
+ * In a class file whose version number is 51.0 or above, the method
+ * has its ACC_STATIC flag set and takes no arguments.
+ */
+                 /* Leave this here to find usages of the following check:
+                  * if (J2SE_VERSION(vm) >= J2SE_19) {
+                  */
+if (vmVersionShifted >= BCT_Java9MajorVersionShifted) {
+if (classfile->majorVersion >= 51) {
+if ((CFR_METHOD_NAME_CLINIT == isInit) 
+&& (0 != argCount) 
+) {","Given how long this has waited for me to finish the review (sorry) I'm going to merge it as is.  If you want to address this nitpick, feel free to open a new PR (or not).",
69454201,86016d5e9d2f52c5d6170f252e283a02d3a6100b,runtime/bcverify/staticverify.c,False,"@@ -1767,6 +1767,24 @@ j9bcv_verifyClassStructure (J9PortLibrary * portLib, J9CfrClassFile * classfile,
 goto _formatError;
 }
 
+/* The requirement for taking no arguments was introduced in Java SE 9.
+ * In a class file whose version number is 51.0 or above, the method
+ * has its ACC_STATIC flag set and takes no arguments.
+ */
+                 /* Leave this here to find usages of the following check:
+                  * if (J2SE_VERSION(vm) >= J2SE_19) {
+                  */
+if (vmVersionShifted >= BCT_Java9MajorVersionShifted) {
+if (classfile->majorVersion >= 51) {
+if ((CFR_METHOD_NAME_CLINIT == isInit) 
+&& (0 != argCount) 
+) {","or more precisely, I'll kick off the PR build and merge once the build succeeds.",
69328197,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,runtime/jvm.xml.ftl,False,"@@ -1518,6 +1518,7 @@
 </loadfile>
 
 <delete file=""${r""${output}""}/jmods/com.ibm.sharedclasses.jmod"" quiet=""true"" />
+<delete file=""${r""${output}""}/jmods/com.ibm.dataaccess.jmod"" quiet=""true"" />",I'm not sure of this change.  Can you comment on why it's necessary?,
69340339,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,runtime/jvm.xml.ftl,False,"@@ -1518,6 +1518,7 @@
 </loadfile>
 
 <delete file=""${r""${output}""}/jmods/com.ibm.sharedclasses.jmod"" quiet=""true"" />
+<delete file=""${r""${output}""}/jmods/com.ibm.dataaccess.jmod"" quiet=""true"" />","This is to maintain b148 composing which still overlays new changes at top of a base SDK. If not deleted, SDK will have two modules with same package/classes, and `jlink` won't work.",
69341054,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,jcl/j9modules.xml,False,"@@ -83,6 +83,14 @@
 </else>
 </if>
 </case>
+<case value=""com.ibm.dataaccess"">
+<removeexport package=""com.ibm.dataaccess"" />
+<delete verbose=""true"">
+<fileset dir=""${module.dir}/classes"">
+<include name=""com/ibm/dataaccess/*"" />
+</fileset>
+</delete>
+</case>","Is this script required? package `com.ibm.dataaccess` export is removed within module `java.base` in same xml file, and there is no change to the actual package/class files.",
69342082,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,jcl/src/openj9.dataaccess/share/classes/com/ibm/dataaccess/ByteArrayMarshaller.java,False,"@@ -1,6 +1,6 @@
 /*[INCLUDE-IF DAA]*/
 /*******************************************************************************
- * Copyright (c) 2013, 2015 IBM Corp. and others
+ * Copyright (c) 2013, 2017 IBM Corp. and others","Pls keep previous changes, i.e., just move the file and not modify it which has better chance to let EGit connect file history. Copyright year changing can be in another pull request.",
69347182,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,jcl/src/openj9.dataaccess/share/classes/com/ibm/dataaccess/ByteArrayMarshaller.java,True,"@@ -1,6 +1,6 @@
 /*[INCLUDE-IF DAA]*/
 /*******************************************************************************
- * Copyright (c) 2013, 2015 IBM Corp. and others
+ * Copyright (c) 2013, 2017 IBM Corp. and others",The copyright check fails without updating the copyright. Is that alright?,
69348242,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,jcl/src/openj9.dataaccess/share/classes/com/ibm/dataaccess/ByteArrayMarshaller.java,False,"@@ -1,6 +1,6 @@
 /*[INCLUDE-IF DAA]*/
 /*******************************************************************************
- * Copyright (c) 2013, 2015 IBM Corp. and others
+ * Copyright (c) 2013, 2017 IBM Corp. and others",I think it is ok to merge with copyright check failure in this case unless @DanHeidinga says otherwise.,
69452052,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,jcl/src/openj9.dataaccess/share/classes/com/ibm/dataaccess/ByteArrayMarshaller.java,False,"@@ -1,6 +1,6 @@
 /*[INCLUDE-IF DAA]*/
 /*******************************************************************************
- * Copyright (c) 2013, 2015 IBM Corp. and others
+ * Copyright (c) 2013, 2017 IBM Corp. and others","If its only a copyright check failure on a file that's been moved but not modified, then I agree with Jason that we're OK to ignore the check.  We haven't modified the code, so we don't need to change the date.",
69452146,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,jcl/.classpath,False,"@@ -8,7 +8,7 @@
 <classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/openj9.jvm/share/classes""/>
 <classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/jdk.management/share/classes""/>
 <classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/openj9.cuda/share/classes""/>
-<classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/com.ibm.dataaccess/share/classes""/>
+<classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/openj9.dataaccess/share/classes""/>",This file on the other hand is missing a copyright.  Can you add the copyright header to it?,
69593479,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,jcl/j9modules.xml,True,"@@ -83,6 +83,14 @@
 </else>
 </if>
 </case>
+<case value=""com.ibm.dataaccess"">
+<removeexport package=""com.ibm.dataaccess"" />
+<delete verbose=""true"">
+<fileset dir=""${module.dir}/classes"">
+<include name=""com/ibm/dataaccess/*"" />
+</fileset>
+</delete>
+</case>",This script doesn't seem to be needed. Will remove.,
69613807,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,jcl/.classpath,True,"@@ -8,7 +8,7 @@
 <classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/openj9.jvm/share/classes""/>
 <classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/jdk.management/share/classes""/>
 <classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/openj9.cuda/share/classes""/>
-<classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/com.ibm.dataaccess/share/classes""/>
+<classpathentry excluding=""**/module-info.java"" kind=""src"" path=""src/openj9.dataaccess/share/classes""/>",Added.,
69620391,c77be9b960b2dd1f5b6770f2a55417a528b7bbfc,jcl/j9modules.xml,False,"@@ -83,6 +83,7 @@
 </else>
 </if>
 </case>
+",There is no need to modify this file.,
69638111,d8c75bebae0599ef34731d9dee3b14e578e07403,debugtools/DDR_Autoblob/src/com/ibm/j9ddr/autoblob/GenerateBlobC.java,False,"@@ -211,7 +212,7 @@ private static void writeCFile(File inputFile, StructureXMLParser parser, Genera
 }
 }
 
-private static void loadTypes(SortedSet<UserDefinedType> typesToWrite, Collection<? extends UserDefinedType> toLoad, GenerateBlobCConfig config)",Why was private removed?,
69639196,d8c75bebae0599ef34731d9dee3b14e578e07403,debugtools/DDR_Autoblob/src/com/ibm/j9ddr/autoblob/GenerateBlobC.java,True,"@@ -211,7 +212,7 @@ private static void writeCFile(File inputFile, StructureXMLParser parser, Genera
 }
 }
 
-private static void loadTypes(SortedSet<UserDefinedType> typesToWrite, Collection<? extends UserDefinedType> toLoad, GenerateBlobCConfig config)",Removing the `private` modifier avoids the need for a bridge method.,
67694178,044c5452b655dd73f93eca820b67beff8c8843d1,runtime/buildtools.mk,False,"@@ -144,7 +144,7 @@ OMRGLUE_INCLUDES = \
   ../gc_vlhgc
 
 configure : uma
-$(MAKE) -C omr -f run_configure.mk 'SPEC=$(SPEC)' 'OMRGLUE=$(OMRGLUE)' 'CONFIG_INCL_DIR=$(CONFIG_INCL_DIR)' 'OMRGLUE_INCLUDES=$(OMRGLUE_INCLUDES)' 'EXTRA_CONFIGURE_ARGS=$(EXTRA_CONFIGURE_ARGS)'
+$(MAKE) -C omr -f run_configure.mk 'SPEC=osx_x86-64' 'OMRGLUE=$(OMRGLUE)' 'CONFIG_INCL_DIR=$(CONFIG_INCL_DIR)' 'OMRGLUE_INCLUDES=$(OMRGLUE_INCLUDES)' 'EXTRA_CONFIGURE_ARGS=$(EXTRA_CONFIGURE_ARGS)'","I know this pull request is WIP, but note this needs to be fixed.",
68672806,044c5452b655dd73f93eca820b67beff8c8843d1,runtime/gc_glue_java/configure_includes/configure_osx.mk,False,"@@ -0,0 +1,60 @@
+###############################################################################
+# Copyright (c) 2017, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at http://eclipse.org/legal/epl-2.0
+# or the Apache License, Version 2.0 which accompanies this distribution
+# and is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following Secondary
+# Licenses when the conditions for such availability set forth in the
+# Eclipse Public License, v. 2.0 are satisfied: GNU General Public License,
+# version 2 with the GNU Classpath Exception [1] and GNU General Public
+# License, version 2 with the OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+###############################################################################
+
+TEMP_TARGET_DATASIZE:=64
+
+include $(CONFIG_INCL_DIR)/configure_common.mk
+
+CONFIGURE_ARGS += \
+  --enable-OMR_EXAMPLE \
+  --enable-OMR_GC \
+  --enable-OMR_JITBUILDER \
+  --enable-OMR_PORT \
+  --enable-OMR_THREAD \
+  --enable-OMR_OMRSIG \
+  --enable-OMRTHREAD_LIB_UNIX \
+  --enable-OMR_ARCH_X86 \
+  --enable-OMR_ENV_DATA64 \
+  --enable-OMR_ENV_LITTLE_ENDIAN \
+  --enable-OMR_GC_TLH_PREFETCH_FTA \
+  --enable-OMR_PORT_CAN_RESERVE_SPECIFIC_ADDRESS \
+  --enable-OMR_TEST_COMPILER \
+  --enable-OMR_THR_FORK_SUPPORT \
+  --enable-OMR_THR_THREE_TIER_LOCKING \
+  --enable-OMR_THR_YIELD_ALG \
+  --enable-OMR_GC_ARRAYLETS \
+  --enable-OMR_THR_SPIN_WAKE_CONTROL
+
+
+CONFIGURE_ARGS += libprefix=lib exeext= solibext=.dylib arlibext=.a objext=.o
+
+CONFIGURE_ARGS += 'AS=as'
+CONFIGURE_ARGS += 'CC=cc'
+CONFIGURE_ARGS += 'CXX=c++'
+CONFIGURE_ARGS += 'CCLINK=$$(CC)'","`CCLINK` is defined a number of places, but I couldn't find any uses; perhaps this should define `CCLINKEXE`?",
68674961,044c5452b655dd73f93eca820b67beff8c8843d1,runtime/gc_glue_java/configure_includes/configure_osx.mk,True,"@@ -0,0 +1,60 @@
+###############################################################################
+# Copyright (c) 2017, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at http://eclipse.org/legal/epl-2.0
+# or the Apache License, Version 2.0 which accompanies this distribution
+# and is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following Secondary
+# Licenses when the conditions for such availability set forth in the
+# Eclipse Public License, v. 2.0 are satisfied: GNU General Public License,
+# version 2 with the GNU Classpath Exception [1] and GNU General Public
+# License, version 2 with the OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+###############################################################################
+
+TEMP_TARGET_DATASIZE:=64
+
+include $(CONFIG_INCL_DIR)/configure_common.mk
+
+CONFIGURE_ARGS += \
+  --enable-OMR_EXAMPLE \
+  --enable-OMR_GC \
+  --enable-OMR_JITBUILDER \
+  --enable-OMR_PORT \
+  --enable-OMR_THREAD \
+  --enable-OMR_OMRSIG \
+  --enable-OMRTHREAD_LIB_UNIX \
+  --enable-OMR_ARCH_X86 \
+  --enable-OMR_ENV_DATA64 \
+  --enable-OMR_ENV_LITTLE_ENDIAN \
+  --enable-OMR_GC_TLH_PREFETCH_FTA \
+  --enable-OMR_PORT_CAN_RESERVE_SPECIFIC_ADDRESS \
+  --enable-OMR_TEST_COMPILER \
+  --enable-OMR_THR_FORK_SUPPORT \
+  --enable-OMR_THR_THREE_TIER_LOCKING \
+  --enable-OMR_THR_YIELD_ALG \
+  --enable-OMR_GC_ARRAYLETS \
+  --enable-OMR_THR_SPIN_WAKE_CONTROL
+
+
+CONFIGURE_ARGS += libprefix=lib exeext= solibext=.dylib arlibext=.a objext=.o
+
+CONFIGURE_ARGS += 'AS=as'
+CONFIGURE_ARGS += 'CC=cc'
+CONFIGURE_ARGS += 'CXX=c++'
+CONFIGURE_ARGS += 'CCLINK=$$(CC)'","That could be.  I copied this from the omr/example/glue.  I am still working on getting a successful build alongside openj9 and the extensions.  My current area of area is the linking...so may change again.  I will investigate down this path too, thanks for the pointer.",
68676245,044c5452b655dd73f93eca820b67beff8c8843d1,runtime/makelib/targets.mk.osx.inc.ftl,True,"@@ -0,0 +1,526 @@
+<#-- ",This file needs review for removal of 390/ppc/arm use cases.,
68677581,044c5452b655dd73f93eca820b67beff8c8843d1,sourcetools/com.ibm.uma/com/ibm/j9/uma/configuration/ConfigurationImpl.java,False,"@@ -43,6 +43,7 @@
 import com.ibm.j9.uma.platform.PlatformUnix;
 import com.ibm.j9.uma.platform.PlatformWindows;
 import com.ibm.j9.uma.platform.PlatformZOS;
+import com.ibm.j9.uma.platform.PlatformOSX;",Can you please organize imports (alphabetically)?,
68677854,044c5452b655dd73f93eca820b67beff8c8843d1,sourcetools/com.ibm.uma/com/ibm/j9/uma/configuration/ConfigurationImpl.java,True,"@@ -43,6 +43,7 @@
 import com.ibm.j9.uma.platform.PlatformUnix;
 import com.ibm.j9.uma.platform.PlatformWindows;
 import com.ibm.j9.uma.platform.PlatformZOS;
+import com.ibm.j9.uma.platform.PlatformOSX;","Done, in the next push.",
69273334,044c5452b655dd73f93eca820b67beff8c8843d1,sourcetools/com.ibm.uma/com/ibm/j9/uma/platform/PlatformOSX.java,False,"@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.uma.platform;
+
+import java.util.Vector;
+
+import com.ibm.uma.IConfiguration;
+import com.ibm.uma.UMA;
+import com.ibm.uma.UMAException;
+import com.ibm.uma.om.Artifact;
+import com.ibm.uma.om.Export;
+import com.ibm.uma.util.FileAssistant;
+
+public class PlatformOSX extends PlatformImplementation {",If you subclassed the Unix implementation this file could be smaller as you would only have to override `getSharedLibSuffix()` but it may also change some of the functionality...,
69283819,044c5452b655dd73f93eca820b67beff8c8843d1,sourcetools/com.ibm.uma/com/ibm/j9/uma/platform/PlatformOSX.java,False,"@@ -0,0 +1,59 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.j9.uma.platform;
+
+import java.util.Vector;
+
+import com.ibm.uma.IConfiguration;
+import com.ibm.uma.UMA;
+import com.ibm.uma.UMAException;
+import com.ibm.uma.om.Artifact;
+import com.ibm.uma.om.Export;
+import com.ibm.uma.util.FileAssistant;
+
+public class PlatformOSX extends PlatformImplementation {","That occurred to me as well, but the class is so small I don't think it's really worth it.",
69640765,e5140fa59fb54065abc6115c2681a3d43f5c74bc,README.md,False,"@@ -62,10 +62,14 @@ To get started, read our [Contribution Guide](CONTRIBUTING.md).
 Where can I learn more?
 =======================
 
-Presentations
--------------
-
-- [J9: Under the hood of the next open source JVM](https://www.slideshare.net/DanHeidinga/j9-under-the-hood-of-the-next-open-source-jvm)
+Videos and Presentations
+------------------------
+
+- [JavaOne 2017: John Duimovich and Mike Milenkovich having fun chatting about Eclipse OpenJ9 (and EE4J)](https://www.youtube.com/watch?v=4g9SdVCPlnk)
+- [JavaOne 2017: Holly Cummins interviewing Dan Heidinga and Mark Stoodley on Eclipse OpenJ9 and OMR](https://www.youtube.com/watch?v=c1LVXqD3cII)
+- [JavaOne 2017: Open sourcing the IBM J9 Java Virtual Machine[(https://www.slideshare.net/MarkStoodley/javaone-2017-mark-stoodley-open-sourcing-ibm-j9-jvm)","`[JavaOne 2017: Open sourcing the IBM J9 Java Virtual Machine[`
The final `[` should be a `]`",
69680363,e5140fa59fb54065abc6115c2681a3d43f5c74bc,README.md,True,"@@ -62,10 +62,14 @@ To get started, read our [Contribution Guide](CONTRIBUTING.md).
 Where can I learn more?
 =======================
 
-Presentations
--------------
-
-- [J9: Under the hood of the next open source JVM](https://www.slideshare.net/DanHeidinga/j9-under-the-hood-of-the-next-open-source-jvm)
+Videos and Presentations
+------------------------
+
+- [JavaOne 2017: John Duimovich and Mike Milenkovich having fun chatting about Eclipse OpenJ9 (and EE4J)](https://www.youtube.com/watch?v=4g9SdVCPlnk)
+- [JavaOne 2017: Holly Cummins interviewing Dan Heidinga and Mark Stoodley on Eclipse OpenJ9 and OMR](https://www.youtube.com/watch?v=c1LVXqD3cII)
+- [JavaOne 2017: Open sourcing the IBM J9 Java Virtual Machine[(https://www.slideshare.net/MarkStoodley/javaone-2017-mark-stoodley-open-sourcing-ibm-j9-jvm)",d'oh!,
69677110,75b93baf0aa9b7cce2ecf30dc32f0977b3d94103,buildenv/jenkins/copyrightCheck,False,"@@ -37,35 +37,38 @@ stage('Copyright Check') {
                 returnStdout: true
             ).trim()
             echo FILES
-            def FILES_LIST = FILES.split(""\\r?\\n"")
-            DATE_YEAR = sh (
-                script: ""date +%Y"",
-                returnStdout: true
-            ).trim()
-            FILES_LIST.each() {
-                println ""Checking file: '${it}'""
-                RESULT = sh (
-                    script: ""grep -qE 'Copyright \\(c\\) ([0-9]{4}), ${DATE_YEAR} IBM Corp. and others' '${it}'"",
-                    returnStatus: true)
-                if(RESULT != 0) {
-                    echo ""FAILURE - Copyright date in file: '${it}' appears to be incorrect""
-                    FAIL = true
-                    BAD_FILES << ""${it}""
-                } else {
-                    echo ""Copyright date in file: appears to be correct""
+            if (FILES != """") {",I suggest this would read better if the `if` were inverted; then both the condition is closer to the beginning of both branches. (Same comment for both changes).,
69695499,75b93baf0aa9b7cce2ecf30dc32f0977b3d94103,buildenv/jenkins/copyrightCheck,False,"@@ -37,35 +37,38 @@ stage('Copyright Check') {
                 returnStdout: true
             ).trim()
             echo FILES
-            def FILES_LIST = FILES.split(""\\r?\\n"")
-            DATE_YEAR = sh (
-                script: ""date +%Y"",
-                returnStdout: true
-            ).trim()
-            FILES_LIST.each() {
-                println ""Checking file: '${it}'""
-                RESULT = sh (
-                    script: ""grep -qE 'Copyright \\(c\\) ([0-9]{4}), ${DATE_YEAR} IBM Corp. and others' '${it}'"",
-                    returnStatus: true)
-                if(RESULT != 0) {
-                    echo ""FAILURE - Copyright date in file: '${it}' appears to be incorrect""
-                    FAIL = true
-                    BAD_FILES << ""${it}""
-                } else {
-                    echo ""Copyright date in file: appears to be correct""
+            if ( FILES == """" ) {",The formatting is inconsistent (extra spacing).,
69891768,047cbca84a853f6f295ba1a7c65d21718e5b38d5,jcl/src/java.base/share/classes/java/lang/Class.java,False,"@@ -2166,7 +2166,7 @@ public String toGenericString() {
  */
 public Package getPackage() {
 String packageName = getPackageName();
-if (packageName == null) {
+if ((null == packageName) || isArray() || isPrimitive()) {","`getPackageName` will have called `isPrimitive` and may have already called `isArray`: perhaps it would be better to reorder the calls here so `getPackageName` is called after we've ruled out primitive and array types?

Could you also correct the javadoc for `getPackageName`?",
69908936,047cbca84a853f6f295ba1a7c65d21718e5b38d5,jcl/src/java.base/share/classes/java/lang/Class.java,True,"@@ -2166,7 +2166,7 @@ public String toGenericString() {
  */
 public Package getPackage() {
 String packageName = getPackageName();
-if (packageName == null) {
+if ((null == packageName) || isArray() || isPrimitive()) {",Good plan.  Done.,
386024805,69ba50da5d14fead1654ba8072419cd8e2d8fff8,runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp,True,"@@ -0,0 +1,258 @@
+/*******************************************************************************
+ * Copyright (c) 2020, 2020 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+ *******************************************************************************/
+
+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)
+#define FLATTENEDARRAYOBJECTSCANNER_HPP_
+
+#include ""j9.h""
+#include ""j9cfg.h""
+#include ""modron.h""
+
+#include ""objectdescription.h""
+#include ""ArrayObjectModel.hpp""
+#include ""GCExtensionsBase.hpp""
+#include ""HeadlessMixedObjectScanner.hpp""
+#include ""IndexableObjectScanner.hpp""
+
+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner
+{
+/* Data Members */
+private:
+
+MM_EnvironmentBase *_env;
+uintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */
+uintptr_t *_descriptionBasePtr; /**< Pointer to the description base */
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */
+#endif /* defined(OMR_GC_LEAF_BITS) */
+GC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */
+
+protected:
+
+public:
+
+/* Methods */
+private:
+
+protected:
+
+/**
+ * @param env The scanning thread environment
+ * @param arrayPtr pointer to the array to be processed
+ * @param basePtr pointer to the first contiguous array cell
+ * @param limitPtr pointer to end of last contiguous array cell
+ * @param scanPtr pointer to the array cell where scanning will start
+ * @param endPtr pointer to the array cell where scanning will stop
+ * @param scanMap The first scan map
+ * @param elementSize The size of each element, without padding
+ * @param elementStride The stride of each element, including element padding
+ * @param flags Scanning context flags
+ */
+MMINLINE GC_FlattenedArrayObjectScanner(
+MM_EnvironmentBase *env
+, omrobjectptr_t arrayPtr
+, fomrobject_t *basePtr
+, fomrobject_t *limitPtr
+, fomrobject_t *scanPtr
+, fomrobject_t *endPtr
+, uintptr_t elementSize
+, uintptr_t elementStride
+, uintptr_t *descriptionBasePtr
+#if defined(OMR_GC_LEAF_BITS)
+, uintptr_t *leafBasePtr
+#endif /* defined(OMR_GC_LEAF_BITS) */
+, uintptr_t flags)
+: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)
+, _env(env)
+, _elementSizeWithoutPadding(elementSize)
+, _descriptionBasePtr(descriptionBasePtr)
+#if defined(OMR_GC_LEAF_BITS)
+, _leafBasePtr(leafBasePtr)
+#endif /* defined(OMR_GC_LEAF_BITS) */
+/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */
+, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)
+{
+_typeId = __FUNCTION__;
+}
+
+MMINLINE void
+initialize(MM_EnvironmentBase *env)
+{
+#if defined(OMR_GC_LEAF_BITS)
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);
+#else /* defined(OMR_GC_LEAF_BITS) */
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+_indexableScanner.initialize(env);
+
+/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us
+ * to miss other elements of the array
+ */
+setMoreSlots();
+}
+
+public:
+
+/**
+ * @param[in] env The scanning thread environment
+ * @param[in] objectPtr pointer to the array to be processed
+ * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param[in] flags Scanning context flags
+ * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements
+ * @param[in] startIndex The index of the first element to scan
+ */
+MMINLINE static GC_FlattenedArrayObjectScanner *
+newInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)
+{
+GC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;
+GC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);
+J9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);
+J9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;
+
+/* TODO are these always the same? */
+Assert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);
+
+J9Class *elementClass = j9ArrayClass->componentType;
+omrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;
+
+uintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);
+uintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);
+uintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);
+fomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);
+fomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);
+fomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);",Fixed!,
386025065,69ba50da5d14fead1654ba8072419cd8e2d8fff8,runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp,True,"@@ -0,0 +1,258 @@
+/*******************************************************************************
+ * Copyright (c) 2020, 2020 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+ *******************************************************************************/
+
+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)
+#define FLATTENEDARRAYOBJECTSCANNER_HPP_
+
+#include ""j9.h""
+#include ""j9cfg.h""
+#include ""modron.h""
+
+#include ""objectdescription.h""
+#include ""ArrayObjectModel.hpp""
+#include ""GCExtensionsBase.hpp""
+#include ""HeadlessMixedObjectScanner.hpp""
+#include ""IndexableObjectScanner.hpp""
+
+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner
+{
+/* Data Members */
+private:
+
+MM_EnvironmentBase *_env;
+uintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */
+uintptr_t *_descriptionBasePtr; /**< Pointer to the description base */
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */
+#endif /* defined(OMR_GC_LEAF_BITS) */
+GC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */
+
+protected:
+
+public:
+
+/* Methods */
+private:
+
+protected:
+
+/**
+ * @param env The scanning thread environment
+ * @param arrayPtr pointer to the array to be processed
+ * @param basePtr pointer to the first contiguous array cell
+ * @param limitPtr pointer to end of last contiguous array cell
+ * @param scanPtr pointer to the array cell where scanning will start
+ * @param endPtr pointer to the array cell where scanning will stop
+ * @param scanMap The first scan map
+ * @param elementSize The size of each element, without padding
+ * @param elementStride The stride of each element, including element padding
+ * @param flags Scanning context flags
+ */
+MMINLINE GC_FlattenedArrayObjectScanner(
+MM_EnvironmentBase *env
+, omrobjectptr_t arrayPtr
+, fomrobject_t *basePtr
+, fomrobject_t *limitPtr
+, fomrobject_t *scanPtr
+, fomrobject_t *endPtr
+, uintptr_t elementSize
+, uintptr_t elementStride
+, uintptr_t *descriptionBasePtr
+#if defined(OMR_GC_LEAF_BITS)
+, uintptr_t *leafBasePtr
+#endif /* defined(OMR_GC_LEAF_BITS) */
+, uintptr_t flags)
+: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)
+, _env(env)
+, _elementSizeWithoutPadding(elementSize)
+, _descriptionBasePtr(descriptionBasePtr)
+#if defined(OMR_GC_LEAF_BITS)
+, _leafBasePtr(leafBasePtr)
+#endif /* defined(OMR_GC_LEAF_BITS) */
+/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */
+, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)
+{
+_typeId = __FUNCTION__;
+}
+
+MMINLINE void
+initialize(MM_EnvironmentBase *env)
+{
+#if defined(OMR_GC_LEAF_BITS)
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);
+#else /* defined(OMR_GC_LEAF_BITS) */
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+_indexableScanner.initialize(env);
+
+/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us
+ * to miss other elements of the array
+ */
+setMoreSlots();
+}
+
+public:
+
+/**
+ * @param[in] env The scanning thread environment
+ * @param[in] objectPtr pointer to the array to be processed
+ * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param[in] flags Scanning context flags
+ * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements
+ * @param[in] startIndex The index of the first element to scan
+ */
+MMINLINE static GC_FlattenedArrayObjectScanner *
+newInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)
+{
+GC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;
+GC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);
+J9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);
+J9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;
+
+/* TODO are these always the same? */
+Assert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);
+
+J9Class *elementClass = j9ArrayClass->componentType;
+omrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;
+
+uintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);
+uintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);
+uintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);
+fomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);
+fomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);
+fomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);
+fomrobject_t *endPtr = limitPtr;
+if (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {
+Assert_MM_unreachable();
+endPtr = scanPtr + (splitAmount * elementStride);","Fixed in the PR, I didn't use the automatic github commit.",
386025131,69ba50da5d14fead1654ba8072419cd8e2d8fff8,runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp,True,"@@ -0,0 +1,258 @@
+/*******************************************************************************
+ * Copyright (c) 2020, 2020 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+ *******************************************************************************/
+
+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)
+#define FLATTENEDARRAYOBJECTSCANNER_HPP_
+
+#include ""j9.h""
+#include ""j9cfg.h""
+#include ""modron.h""
+
+#include ""objectdescription.h""
+#include ""ArrayObjectModel.hpp""
+#include ""GCExtensionsBase.hpp""
+#include ""HeadlessMixedObjectScanner.hpp""
+#include ""IndexableObjectScanner.hpp""
+
+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner
+{
+/* Data Members */
+private:
+
+MM_EnvironmentBase *_env;
+uintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */
+uintptr_t *_descriptionBasePtr; /**< Pointer to the description base */
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */
+#endif /* defined(OMR_GC_LEAF_BITS) */
+GC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */
+
+protected:
+
+public:
+
+/* Methods */
+private:
+
+protected:
+
+/**
+ * @param env The scanning thread environment
+ * @param arrayPtr pointer to the array to be processed
+ * @param basePtr pointer to the first contiguous array cell
+ * @param limitPtr pointer to end of last contiguous array cell
+ * @param scanPtr pointer to the array cell where scanning will start
+ * @param endPtr pointer to the array cell where scanning will stop
+ * @param scanMap The first scan map
+ * @param elementSize The size of each element, without padding
+ * @param elementStride The stride of each element, including element padding
+ * @param flags Scanning context flags
+ */
+MMINLINE GC_FlattenedArrayObjectScanner(
+MM_EnvironmentBase *env
+, omrobjectptr_t arrayPtr
+, fomrobject_t *basePtr
+, fomrobject_t *limitPtr
+, fomrobject_t *scanPtr
+, fomrobject_t *endPtr
+, uintptr_t elementSize
+, uintptr_t elementStride
+, uintptr_t *descriptionBasePtr
+#if defined(OMR_GC_LEAF_BITS)
+, uintptr_t *leafBasePtr
+#endif /* defined(OMR_GC_LEAF_BITS) */
+, uintptr_t flags)
+: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)
+, _env(env)
+, _elementSizeWithoutPadding(elementSize)
+, _descriptionBasePtr(descriptionBasePtr)
+#if defined(OMR_GC_LEAF_BITS)
+, _leafBasePtr(leafBasePtr)
+#endif /* defined(OMR_GC_LEAF_BITS) */
+/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */
+, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)
+{
+_typeId = __FUNCTION__;
+}
+
+MMINLINE void
+initialize(MM_EnvironmentBase *env)
+{
+#if defined(OMR_GC_LEAF_BITS)
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);
+#else /* defined(OMR_GC_LEAF_BITS) */
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+_indexableScanner.initialize(env);
+
+/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us
+ * to miss other elements of the array
+ */
+setMoreSlots();
+}
+
+public:
+
+/**
+ * @param[in] env The scanning thread environment
+ * @param[in] objectPtr pointer to the array to be processed
+ * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param[in] flags Scanning context flags
+ * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements
+ * @param[in] startIndex The index of the first element to scan
+ */
+MMINLINE static GC_FlattenedArrayObjectScanner *
+newInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)
+{
+GC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;
+GC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);
+J9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);
+J9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;
+
+/* TODO are these always the same? */
+Assert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);
+
+J9Class *elementClass = j9ArrayClass->componentType;
+omrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;
+
+uintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);
+uintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);
+uintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);
+fomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);
+fomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);
+fomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);
+fomrobject_t *endPtr = limitPtr;
+if (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {
+Assert_MM_unreachable();
+endPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);
+if (endPtr > limitPtr) {
+endPtr = limitPtr;
+}
+}
+uintptr_t *instanceDescription = elementClass->instanceDescription;
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *leafDescription = elementClass->instanceLeafDescription;
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+#if defined(OMR_GC_LEAF_BITS)
+new(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);
+#else /* defined(OMR_GC_LEAF_BITS) */
+new(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+objectScanner->initialize(env);
+if (0 != startIndex) {
+objectScanner->clearHeadObjectScanner();
+}
+return objectScanner;
+}
+
+MMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }
+
+/**
+ * @param env The scanning thread environment
+ * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param splitAmount The maximum number of array elements to include
+ * @return Pointer to split scanner in allocSpace
+ */
+GC_IndexableObjectScanner *
+splitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)
+{
+Assert_MM_unimplemented();
+}
+
+/**
+ * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The
+ * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of
+ * increasing significance, and the least significant bit maps to the slot at the returned
+ * base pointer.
+ *
+ * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer
+ * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last
+ * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots
+ */
+virtual fomrobject_t *
+getNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)
+{
+fomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);
+/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */
+*hasNextSlotMap = true;
+if (result == NULL) {
+/* No more slots in the current element, get the next element of the array */
+result = _indexableScanner.nextIndexableElement();
+if (result == NULL) {
+/* There are no elements in the array */
+*hasNextSlotMap = false;
+} else {
+_mapPtr = result;
+_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);",Fixed,
386025186,69ba50da5d14fead1654ba8072419cd8e2d8fff8,runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp,True,"@@ -0,0 +1,258 @@
+/*******************************************************************************
+ * Copyright (c) 2020, 2020 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+ *******************************************************************************/
+
+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)
+#define FLATTENEDARRAYOBJECTSCANNER_HPP_
+
+#include ""j9.h""
+#include ""j9cfg.h""
+#include ""modron.h""
+
+#include ""objectdescription.h""
+#include ""ArrayObjectModel.hpp""
+#include ""GCExtensionsBase.hpp""
+#include ""HeadlessMixedObjectScanner.hpp""
+#include ""IndexableObjectScanner.hpp""
+
+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner
+{
+/* Data Members */
+private:
+
+MM_EnvironmentBase *_env;
+uintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */
+uintptr_t *_descriptionBasePtr; /**< Pointer to the description base */
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */
+#endif /* defined(OMR_GC_LEAF_BITS) */
+GC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */
+
+protected:
+
+public:
+
+/* Methods */
+private:
+
+protected:
+
+/**
+ * @param env The scanning thread environment
+ * @param arrayPtr pointer to the array to be processed
+ * @param basePtr pointer to the first contiguous array cell
+ * @param limitPtr pointer to end of last contiguous array cell
+ * @param scanPtr pointer to the array cell where scanning will start
+ * @param endPtr pointer to the array cell where scanning will stop
+ * @param scanMap The first scan map
+ * @param elementSize The size of each element, without padding
+ * @param elementStride The stride of each element, including element padding
+ * @param flags Scanning context flags
+ */
+MMINLINE GC_FlattenedArrayObjectScanner(
+MM_EnvironmentBase *env
+, omrobjectptr_t arrayPtr
+, fomrobject_t *basePtr
+, fomrobject_t *limitPtr
+, fomrobject_t *scanPtr
+, fomrobject_t *endPtr
+, uintptr_t elementSize
+, uintptr_t elementStride
+, uintptr_t *descriptionBasePtr
+#if defined(OMR_GC_LEAF_BITS)
+, uintptr_t *leafBasePtr
+#endif /* defined(OMR_GC_LEAF_BITS) */
+, uintptr_t flags)
+: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)
+, _env(env)
+, _elementSizeWithoutPadding(elementSize)
+, _descriptionBasePtr(descriptionBasePtr)
+#if defined(OMR_GC_LEAF_BITS)
+, _leafBasePtr(leafBasePtr)
+#endif /* defined(OMR_GC_LEAF_BITS) */
+/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */
+, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)
+{
+_typeId = __FUNCTION__;
+}
+
+MMINLINE void
+initialize(MM_EnvironmentBase *env)
+{
+#if defined(OMR_GC_LEAF_BITS)
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);
+#else /* defined(OMR_GC_LEAF_BITS) */
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+_indexableScanner.initialize(env);
+
+/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us
+ * to miss other elements of the array
+ */
+setMoreSlots();
+}
+
+public:
+
+/**
+ * @param[in] env The scanning thread environment
+ * @param[in] objectPtr pointer to the array to be processed
+ * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param[in] flags Scanning context flags
+ * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements
+ * @param[in] startIndex The index of the first element to scan
+ */
+MMINLINE static GC_FlattenedArrayObjectScanner *
+newInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)
+{
+GC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;
+GC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);
+J9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);
+J9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;
+
+/* TODO are these always the same? */
+Assert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);
+
+J9Class *elementClass = j9ArrayClass->componentType;
+omrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;
+
+uintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);
+uintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);
+uintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);
+fomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);
+fomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + sizeInElements*elementStride);
+fomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + startIndex*elementStride);
+fomrobject_t *endPtr = limitPtr;
+if (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {
+Assert_MM_unreachable();
+endPtr = (fomrobject_t *)((uintptr_t)scanPtr + splitAmount*elementStride);
+if (endPtr > limitPtr) {
+endPtr = limitPtr;
+}
+}
+uintptr_t *instanceDescription = elementClass->instanceDescription;
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *leafDescription = elementClass->instanceLeafDescription;
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+#if defined(OMR_GC_LEAF_BITS)
+new(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);
+#else /* defined(OMR_GC_LEAF_BITS) */
+new(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+objectScanner->initialize(env);
+if (0 != startIndex) {
+objectScanner->clearHeadObjectScanner();
+}
+return objectScanner;
+}
+
+MMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }
+
+/**
+ * @param env The scanning thread environment
+ * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param splitAmount The maximum number of array elements to include
+ * @return Pointer to split scanner in allocSpace
+ */
+GC_IndexableObjectScanner *
+splitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)
+{
+Assert_MM_unimplemented();
+}
+
+/**
+ * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The
+ * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of
+ * increasing significance, and the least significant bit maps to the slot at the returned
+ * base pointer.
+ *
+ * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer
+ * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last
+ * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots
+ */
+virtual fomrobject_t *
+getNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)
+{
+fomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);
+/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */
+*hasNextSlotMap = true;
+if (result == NULL) {
+/* No more slots in the current element, get the next element of the array */
+result = _indexableScanner.nextIndexableElement();
+if (result == NULL) {
+/* There are no elements in the array */
+*hasNextSlotMap = false;
+} else {
+_mapPtr = result;
+_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);
+GC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);
+/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. 
+ * We must also return (hasNextSlotMap = true) on top of this
+ */
+setMoreSlots();
+}
+}
+return result;
+}
+
+#if defined(OMR_GC_LEAF_BITS)
+/**
+ * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The
+ * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of
+ * increasing significance, and the least significant bit maps to the slot at the returned
+ * base pointer.
+ *
+ * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer
+ * @param[out] leafMap the leaf bit map for the slots contiguous with the returned base pointer
+ * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last
+ * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots
+ */
+virtual fomrobject_t *
+getNextSlotMap(uintptr_t *slotMap, uintptr_t *leafMap, bool *hasNextSlotMap)
+{
+fomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, leafMap, hasNextSlotMap);
+/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */
+*hasNextSlotMap = true;
+if (result == NULL) {
+/* No more slots in the current element, get the next element of the array */
+result = _indexableScanner.nextIndexableElement();
+if (result == NULL) {
+/* There are no elements in the array */
+*hasNextSlotMap = false;
+} else {
+_mapPtr = result;
+_endPtr = (fomrobject_t *)((uint8_t*)_mapPtr + _elementSizeWithoutPadding);",Fixed,
386027425,69ba50da5d14fead1654ba8072419cd8e2d8fff8,test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java,True,"@@ -252,6 +255,71 @@ static public void testCreateArrayPoint2D() throws Throwable {
 assertEquals(getY.invoke(point2D_2_check), getY.invoke(point2D_2));
 }
 
+@Test(priority=5)
+static public void testGCFlattenedPoint2DArray() throws Throwable {
+int x1 = 0xFFEEFFEE;
+int y1 = 0xAABBAABB;
+Object point2D = makePoint2D.invoke(x1, y1);
+Object arrayObject = Array.newInstance(point2DClass, 8);
+
+for (int i = 1; i < 8; i++) {
+Array.set(arrayObject, i, point2D);
+}
+
+System.gc();
+System.gc();
+
+Object value = Array.get(arrayObject, 0);
+}
+
+@Test(priority=5)
+static public void testGCFlattenedAssortedValueArray() throws Throwable {
+Object arrayObject = Array.newInstance(assortedValueWithLongAlignmentClass, 4);
+Object assortedValueWithLongAlignment = createAssorted(makeAssortedValueWithLongAlignment, typeWithLongAlignmentFields);
+
+for (int i = 1; i < 4; i++) {
+Array.set(arrayObject, i, assortedValueWithLongAlignment);
+}
+
+System.gc();
+System.gc();
+
+Object value = Array.get(arrayObject, 0);","I added tests so now we're doing all three `singleAlignment`, `objectAlignment`, and `longAlignment`.  The tests are now using `checkFieldAccessMHOfAssortedType` on each array element.",
386027904,69ba50da5d14fead1654ba8072419cd8e2d8fff8,test/functional/Valhalla/src/org/openj9/test/lworld/ValueTypeTests.java,True,"@@ -1402,7 +1471,7 @@ static public void testStaticFieldsWithObjectAlignment() throws Throwable {
 static public void testCreateLargeNumberOfPoint2D() throws Throwable {
 String fields[] = {""x:I"", ""y:I""};
 String className = ""Point2D"";
-for (int valueIndex = 0; valueIndex < 200000; valueIndex++) {
+for (int valueIndex = 0; valueIndex < 200; valueIndex++) {",I just switched back the number for now.,
386028862,69ba50da5d14fead1654ba8072419cd8e2d8fff8,test/functional/Valhalla/playlist.xml,True,"@@ -27,6 +27,7 @@
 <variations>
 <variation>NoOptions</variation>
 <variation>-Xgcpolicy:nogc -XX:ValueTypeFlatteningThreshold=99999</variation>
+<variation>-Xgcpolicy:optthruput -Xnocompactgc -XX:ValueTypeFlatteningThreshold=99999</variation>",@tajila I think it makes sense to enable the GC as a separate variation.  It may help track down if the issue is GC specific. What do you think?,
386618062,69ba50da5d14fead1654ba8072419cd8e2d8fff8,runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp,True,"@@ -0,0 +1,255 @@
+/*******************************************************************************
+ * Copyright (c) 2020, 2020 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+ *******************************************************************************/
+
+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)
+#define FLATTENEDARRAYOBJECTSCANNER_HPP_
+
+#include ""j9.h""
+#include ""j9cfg.h""
+#include ""modron.h""
+
+#include ""objectdescription.h""
+#include ""ArrayObjectModel.hpp""
+#include ""GCExtensionsBase.hpp""
+#include ""HeadlessMixedObjectScanner.hpp""
+#include ""IndexableObjectScanner.hpp""
+
+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner
+{
+/* Data Members */
+private:
+
+MM_EnvironmentBase *_env;
+uintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */
+uintptr_t *_descriptionBasePtr; /**< Pointer to the description base */
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */
+#endif /* defined(OMR_GC_LEAF_BITS) */
+GC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */
+
+protected:
+
+public:
+
+/* Methods */
+private:
+
+protected:
+
+/**
+ * @param env The scanning thread environment
+ * @param arrayPtr pointer to the array to be processed
+ * @param basePtr pointer to the first contiguous array cell
+ * @param limitPtr pointer to end of last contiguous array cell
+ * @param scanPtr pointer to the array cell where scanning will start
+ * @param endPtr pointer to the array cell where scanning will stop
+ * @param scanMap The first scan map
+ * @param elementSize The size of each element, without padding
+ * @param elementStride The stride of each element, including element padding
+ * @param flags Scanning context flags
+ */
+MMINLINE GC_FlattenedArrayObjectScanner(
+MM_EnvironmentBase *env
+, omrobjectptr_t arrayPtr
+, fomrobject_t *basePtr
+, fomrobject_t *limitPtr
+, fomrobject_t *scanPtr
+, fomrobject_t *endPtr
+, uintptr_t elementSize
+, uintptr_t elementStride
+, uintptr_t *descriptionBasePtr
+#if defined(OMR_GC_LEAF_BITS)
+, uintptr_t *leafBasePtr
+#endif /* defined(OMR_GC_LEAF_BITS) */
+, uintptr_t flags)
+: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)
+, _env(env)
+, _elementSizeWithoutPadding(elementSize)
+, _descriptionBasePtr(descriptionBasePtr)
+#if defined(OMR_GC_LEAF_BITS)
+, _leafBasePtr(leafBasePtr)
+#endif /* defined(OMR_GC_LEAF_BITS) */
+/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */
+, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)
+{
+_typeId = __FUNCTION__;
+}
+
+MMINLINE void
+initialize(MM_EnvironmentBase *env)
+{
+#if defined(OMR_GC_LEAF_BITS)
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);
+#else /* defined(OMR_GC_LEAF_BITS) */
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+_indexableScanner.initialize(env);
+
+/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us
+ * to miss other elements of the array
+ */
+setMoreSlots();
+}
+
+public:
+
+/**
+ * @param[in] env The scanning thread environment
+ * @param[in] objectPtr pointer to the array to be processed
+ * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param[in] flags Scanning context flags
+ * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements
+ * @param[in] startIndex The index of the first element to scan
+ */
+MMINLINE static GC_FlattenedArrayObjectScanner *
+newInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)
+{
+GC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;
+GC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);
+J9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);
+J9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;
+
+/* TODO are these always the same? */
+Assert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);
+
+J9Class *elementClass = j9ArrayClass->componentType;
+omrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;
+
+uintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);
+uintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);
+uintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);
+fomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);
+fomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + (sizeInElements * elementStride));
+fomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + (startIndex * elementStride));
+fomrobject_t *endPtr = limitPtr;
+if (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {
+Assert_MM_unreachable();
+endPtr = (fomrobject_t *)((uintptr_t)scanPtr + (splitAmount * elementStride));
+if (endPtr > limitPtr) {
+endPtr = limitPtr;
+}
+}
+uintptr_t *instanceDescription = elementClass->instanceDescription;
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *leafDescription = elementClass->instanceLeafDescription;
+new(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);
+#else /* defined(OMR_GC_LEAF_BITS) */
+new(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+objectScanner->initialize(env);
+if (0 != startIndex) {
+objectScanner->clearHeadObjectScanner();
+}
+return objectScanner;
+}
+
+MMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }
+
+/**
+ * @param env The scanning thread environment
+ * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param splitAmount The maximum number of array elements to include
+ * @return Pointer to split scanner in allocSpace
+ */
+GC_IndexableObjectScanner *
+splitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)
+{
+Assert_MM_unimplemented();
+}
+
+/**
+ * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The
+ * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of
+ * increasing significance, and the least significant bit maps to the slot at the returned
+ * base pointer.
+ *
+ * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer
+ * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last
+ * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots
+ */
+virtual fomrobject_t *
+getNextSlotMap(uintptr_t *slotMap, bool *hasNextSlotMap)
+{
+fomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, hasNextSlotMap);
+/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */
+*hasNextSlotMap = true;
+if (result == NULL) {
+/* No more slots in the current element, get the next element of the array */
+result = _indexableScanner.nextIndexableElement();
+if (result == NULL) {
+/* There are no elements in the array */
+*hasNextSlotMap = false;
+} else {
+_mapPtr = result;
+_endPtr = (fomrobject_t *)((uintptr_t)_mapPtr + _elementSizeWithoutPadding);
+GC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);
+/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. 
+ * We must also return (hasNextSlotMap = true) on top of this
+ */
+setMoreSlots();
+}
+}
+return result;
+}
+
+#if defined(OMR_GC_LEAF_BITS)
+/**
+ * Return base pointer and slot bit map for next block of contiguous slots to be scanned. The
+ * base pointer must be fomrobject_t-aligned. Bits in the bit map are scanned in order of
+ * increasing significance, and the least significant bit maps to the slot at the returned
+ * base pointer.
+ *
+ * @param[out] scanMap the bit map for the slots contiguous with the returned base pointer
+ * @param[out] leafMap the leaf bit map for the slots contiguous with the returned base pointer
+ * @param[out] hasNextSlotMap set this to true if this method should be called again, false if this map is known to be last
+ * @return a pointer to the first slot mapped by the least significant bit of the map, or NULL if no more slots
+ */
+virtual fomrobject_t *
+getNextSlotMap(uintptr_t *slotMap, uintptr_t *leafMap, bool *hasNextSlotMap)
+{
+fomrobject_t *result = GC_HeadlessMixedObjectScanner::getNextSlotMap(slotMap, leafMap, hasNextSlotMap);
+/* Ignore hasNextSlotMap from HeadLess, we want to always report that there is another element */
+*hasNextSlotMap = true;
+if (result == NULL) {
+/* No more slots in the current element, get the next element of the array */
+result = _indexableScanner.nextIndexableElement();
+if (result == NULL) {
+/* There are no elements in the array */
+*hasNextSlotMap = false;
+} else {
+_mapPtr = result;
+_endPtr = (fomrobject_t *)((uintptr_t)_mapPtr + _elementSizeWithoutPadding);
+GC_HeadlessMixedObjectScanner::initialize(_env, _descriptionBasePtr, _leafBasePtr);
+/* GC_HeadlessMixedObjectScanner::initialize() may setNoMoreSlots(), so set it back to true. 
+ * We must also return (hasNextSlotMap = true) on top of this
+ */
+setMoreSlots();
+}
+}
+return result;
+}
+#endif /* defined(OMR_GC_LEAF_BITS) */
+};
+
+#endif /* FLATTENEDARRAYOBJECTSCANNER_HPP_ */",Fixed,
386641375,69ba50da5d14fead1654ba8072419cd8e2d8fff8,runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp,True,"@@ -0,0 +1,255 @@
+/*******************************************************************************
+ * Copyright (c) 2020, 2020 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+ *******************************************************************************/
+
+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)
+#define FLATTENEDARRAYOBJECTSCANNER_HPP_
+
+#include ""j9.h""
+#include ""j9cfg.h""
+#include ""modron.h""
+
+#include ""objectdescription.h""
+#include ""ArrayObjectModel.hpp""
+#include ""GCExtensionsBase.hpp""
+#include ""HeadlessMixedObjectScanner.hpp""
+#include ""IndexableObjectScanner.hpp""
+
+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner
+{
+/* Data Members */
+private:
+
+MM_EnvironmentBase *_env;",Created an issue for this: https://github.com/eclipse/omr/issues/5018,
391168648,0ec1f0199678682c6834af71905dbcc60a990515,runtime/gc_glue_java/FlattenedArrayObjectScanner.hpp,True,"@@ -0,0 +1,256 @@
+/*******************************************************************************
+ * Copyright (c) 2020, 2020 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
+ *******************************************************************************/
+
+#if !defined(FLATTENEDARRAYOBJECTSCANNER_HPP_)
+#define FLATTENEDARRAYOBJECTSCANNER_HPP_
+
+#include ""j9.h""
+#include ""j9cfg.h""
+#include ""modron.h""
+
+#include ""objectdescription.h""
+#include ""ArrayObjectModel.hpp""
+#include ""GCExtensionsBase.hpp""
+#include ""HeadlessMixedObjectScanner.hpp""
+#include ""IndexableObjectScanner.hpp""
+
+class GC_FlattenedArrayObjectScanner : public GC_HeadlessMixedObjectScanner
+{
+/* Data Members */
+private:
+
+MM_EnvironmentBase *_env;
+uintptr_t _elementSizeWithoutPadding; /**< Size of the flattened element, without padding */
+uintptr_t *_descriptionBasePtr; /**< Pointer to the description base */
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *_leafBasePtr; /**< Pointer to the leaf description base */
+#endif /* defined(OMR_GC_LEAF_BITS) */
+GC_IndexableObjectScanner _indexableScanner; /**< Used to iterate the array by element */
+
+protected:
+
+public:
+
+/* Methods */
+private:
+
+protected:
+
+/**
+ * @param env The scanning thread environment
+ * @param arrayPtr pointer to the array to be processed
+ * @param basePtr pointer to the first contiguous array cell
+ * @param limitPtr pointer to end of last contiguous array cell
+ * @param scanPtr pointer to the array cell where scanning will start
+ * @param endPtr pointer to the array cell where scanning will stop
+ * @param scanMap The first scan map
+ * @param elementSize The size of each element, without padding
+ * @param elementStride The stride of each element, including element padding
+ * @param flags Scanning context flags
+ */
+MMINLINE GC_FlattenedArrayObjectScanner(
+MM_EnvironmentBase *env
+, omrobjectptr_t arrayPtr
+, fomrobject_t *basePtr
+, fomrobject_t *limitPtr
+, fomrobject_t *scanPtr
+, fomrobject_t *endPtr
+, uintptr_t elementSize
+, uintptr_t elementStride
+, uintptr_t *descriptionBasePtr
+#if defined(OMR_GC_LEAF_BITS)
+, uintptr_t *leafBasePtr
+#endif /* defined(OMR_GC_LEAF_BITS) */
+, uintptr_t flags)
+: GC_HeadlessMixedObjectScanner(env, scanPtr, elementSize, flags | GC_ObjectScanner::indexableObject)
+, _env(env)
+, _elementSizeWithoutPadding(elementSize)
+, _descriptionBasePtr(descriptionBasePtr)
+#if defined(OMR_GC_LEAF_BITS)
+, _leafBasePtr(leafBasePtr)
+#endif /* defined(OMR_GC_LEAF_BITS) */
+/* Pass 0 for scanMap, as the indexable iterator does not use the scanMap */
+, _indexableScanner(env, arrayPtr, basePtr, limitPtr, scanPtr, endPtr, 0, elementStride, flags)
+{
+_typeId = __FUNCTION__;
+}
+
+MMINLINE void
+initialize(MM_EnvironmentBase *env)
+{
+#if defined(OMR_GC_LEAF_BITS)
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr, _leafBasePtr);
+#else /* defined(OMR_GC_LEAF_BITS) */
+GC_HeadlessMixedObjectScanner::initialize(env, _descriptionBasePtr);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+_indexableScanner.initialize(env);
+
+/* The HeadlessMixedObjectScanner will setNoMoreSlots() causing us
+ * to miss other elements of the array
+ */
+setMoreSlots();
+}
+
+public:
+
+/**
+ * @param[in] env The scanning thread environment
+ * @param[in] objectPtr pointer to the array to be processed
+ * @param[in] allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param[in] flags Scanning context flags
+ * @param[in] splitAmount If >0, the number of elements to include for this scanner instance; if 0, include all elements
+ * @param[in] startIndex The index of the first element to scan
+ */
+MMINLINE static GC_FlattenedArrayObjectScanner *
+newInstance(MM_EnvironmentBase *env, omrobjectptr_t objectPtr, void *allocSpace, uintptr_t flags, uintptr_t splitAmount, uintptr_t startIndex = 0)
+{
+GC_FlattenedArrayObjectScanner *objectScanner = (GC_FlattenedArrayObjectScanner *)allocSpace;
+GC_ArrayObjectModel *arrayObjectModel = &(env->getExtensions()->indexableObjectModel);
+J9Class *clazzPtr = J9GC_J9OBJECT_CLAZZ(objectPtr, env);
+J9ArrayClass *j9ArrayClass = (J9ArrayClass *) clazzPtr;
+
+/* TODO are these always the same? */
+Assert_MM_true(j9ArrayClass->componentType == j9ArrayClass->leafComponentType);
+
+J9Class *elementClass = j9ArrayClass->componentType;
+omrarrayptr_t arrayPtr = (omrarrayptr_t)objectPtr;
+
+uintptr_t sizeInElements = arrayObjectModel->getSizeInElements(arrayPtr);
+uintptr_t elementSize = J9_VALUETYPE_FLATTENED_SIZE(elementClass);
+uintptr_t elementStride = J9ARRAYCLASS_GET_STRIDE(clazzPtr);
+fomrobject_t *basePtr = (fomrobject_t *)arrayObjectModel->getDataPointerForContiguous(arrayPtr);
+fomrobject_t *limitPtr = (fomrobject_t *)((uintptr_t)basePtr + (sizeInElements * elementStride));
+fomrobject_t *scanPtr = (fomrobject_t *)((uintptr_t)basePtr + (startIndex * elementStride));
+fomrobject_t *endPtr = limitPtr;
+if (!GC_ObjectScanner::isIndexableObjectNoSplit(flags) && (splitAmount != 0)) {
+Assert_MM_unreachable();
+endPtr = (fomrobject_t *)((uintptr_t)scanPtr + (splitAmount * elementStride));
+if (endPtr > limitPtr) {
+endPtr = limitPtr;
+}
+}
+uintptr_t *instanceDescription = elementClass->instanceDescription;
+#if defined(OMR_GC_LEAF_BITS)
+uintptr_t *leafDescription = elementClass->instanceLeafDescription;
+new(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, leafDescription, flags);
+#else /* defined(OMR_GC_LEAF_BITS) */
+new(objectScanner) GC_FlattenedArrayObjectScanner(env, objectPtr, basePtr, limitPtr, scanPtr, endPtr, elementSize, elementStride, instanceDescription, flags);
+#endif /* defined(OMR_GC_LEAF_BITS) */
+
+objectScanner->initialize(env);
+if (0 != startIndex) {
+objectScanner->clearHeadObjectScanner();
+}
+return objectScanner;
+}
+
+MMINLINE uintptr_t getBytesRemaining() { return sizeof(fomrobject_t) * (_endPtr - _scanPtr); }
+
+/**
+ * @param env The scanning thread environment
+ * @param allocSpace pointer to space within which the scanner should be instantiated (in-place)
+ * @param splitAmount The maximum number of array elements to include
+ * @return Pointer to split scanner in allocSpace
+ */
+GC_IndexableObjectScanner *
+splitTo(MM_EnvironmentBase *env, void *allocSpace, uintptr_t splitAmount)
+{
+Assert_MM_unimplemented();
+return NULL;",This one line was added.,
63426489,82d4f8b9d0412ac998164025275446f78ac24762,.travis.yml,False,"@@ -0,0 +1,83 @@
+###############################################################################
+# Copyright (c) 2016, 2017 IBM Corp. and others
+# 
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#      
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#    
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+# 
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+###############################################################################
+os:
+  - linux
+language: cpp
+sudo: false
+#cache: ccache # https://docs.travis-ci.com/user/caching/
+dist: trusty
+addons:
+  apt:
+    packages:
+      - autoconf 
+      - ca-certificates 
+      - ccache 
+      - cpio 
+      - file 
+      - g++-4.8 
+      - gcc-4.8 
+      - git 
+      - git-core 
+      - libasound2-dev 
+      - libcups2-dev 
+      - libelf-dev 
+      - libfreetype6-dev 
+      - libnuma-dev 
+      - libx11-dev 
+      - libxext-dev 
+      - libxrender-dev 
+      - libxt-dev 
+      - libxtst-dev 
+      - make 
+      - openjdk-8-jdk 
+      - pkg-config 
+      - realpath 
+      - ssh 
+      - unzip 
+      - wget 
+      - zip 
+before_install:
+  - jdk_switcher use oraclejdk8
+env:
+  global:
+before_script:
+        #  - ccache -s -z
+  - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+  - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+  - cd ..
+  - git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
+script:
+  # Clear this option so it doesn't interfere with configure detecting the bootjdk
+  - unset _JAVA_OPTIONS
+  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.  
+  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win. 
+  - cd openj9-openjdk-jdk9 && bash ./get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT
+  # Based on https://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/ travis container builds
+  # have 2 cores and 4 gigs of memory.  Attempt to double provision the number of cores for the make...
+  # Limit number of jobs to work around g++ internal compiler error
+  - export UMA_WINDOWS_PARRALLEL_HACK=""-j4""",Is the hack actually misspelled? (Two `R`s),
63430482,82d4f8b9d0412ac998164025275446f78ac24762,.travis.yml,False,"@@ -0,0 +1,83 @@
+###############################################################################
+# Copyright (c) 2016, 2017 IBM Corp. and others
+# 
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#      
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#    
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+# 
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+###############################################################################
+os:
+  - linux
+language: cpp
+sudo: false
+#cache: ccache # https://docs.travis-ci.com/user/caching/
+dist: trusty
+addons:
+  apt:
+    packages:
+      - autoconf 
+      - ca-certificates 
+      - ccache 
+      - cpio 
+      - file 
+      - g++-4.8 
+      - gcc-4.8 
+      - git 
+      - git-core 
+      - libasound2-dev 
+      - libcups2-dev 
+      - libelf-dev 
+      - libfreetype6-dev 
+      - libnuma-dev 
+      - libx11-dev 
+      - libxext-dev 
+      - libxrender-dev 
+      - libxt-dev 
+      - libxtst-dev 
+      - make 
+      - openjdk-8-jdk 
+      - pkg-config 
+      - realpath 
+      - ssh 
+      - unzip 
+      - wget 
+      - zip 
+before_install:
+  - jdk_switcher use oraclejdk8
+env:
+  global:
+before_script:
+        #  - ccache -s -z
+  - wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+  - tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+  - cd ..
+  - git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9.git
+script:
+  # Clear this option so it doesn't interfere with configure detecting the bootjdk
+  - unset _JAVA_OPTIONS
+  # Point the get_sources script at the OpenJ9 repo that's already been cloned to disk.  
+  # Results in a copy of the source (disk space =( ) but no new network activity so overall a win. 
+  - cd openj9-openjdk-jdk9 && bash ./get_source.sh -openj9-repo=$TRAVIS_BUILD_DIR -openj9-branch=$TRAVIS_BRANCH -openj9-sha=$TRAVIS_COMMIT
+  # Based on https://blog.travis-ci.com/2014-12-17-faster-builds-with-container-based-infrastructure/ travis container builds
+  # have 2 cores and 4 gigs of memory.  Attempt to double provision the number of cores for the make...
+  # Limit number of jobs to work around g++ internal compiler error
+  - export UMA_WINDOWS_PARRALLEL_HACK=""-j4""",![facepalm](https://media.giphy.com/media/3og0INyCmHlNylks9O/giphy.gif),
63660148,86feaf10679379f2a30177addb0e1d2b14a52dc5,doc/jit.md,False,"@@ -0,0 +1,44 @@
+# Testarossa JIT (tr.jit) compiler
+
+Testarossa JIT compiler is a high performant dynamic compiler that powers openj9 - an enterprise-grade Java Virtual Machine (JVM). It's characteristic features are to compress the application code for improved runtime performance by exploiting the exact host CPU model and apply profiling on the runtime behavior of the generated code, feed it back to the optimizer to further refine it. The component provides a wide range of command line options to (i) trace the actions of the compilation and the compiled code, and (ii) control the compiler behavior.","* 'high performance', or 'highly performant'
* 'OpenJ9', not 'openj9' 
* Talking in the abstract about the component is odd -- I'd instead simply talk about the 'compiler' ",
63660148,86feaf10679379f2a30177addb0e1d2b14a52dc5,doc/jit.md,False,"@@ -0,0 +1,44 @@
+# Testarossa JIT (tr.jit) compiler
+
+Testarossa JIT compiler is a high performant dynamic compiler that powers openj9 - an enterprise-grade Java Virtual Machine (JVM). It's characteristic features are to compress the application code for improved runtime performance by exploiting the exact host CPU model and apply profiling on the runtime behavior of the generated code, feed it back to the optimizer to further refine it. The component provides a wide range of command line options to (i) trace the actions of the compilation and the compiled code, and (ii) control the compiler behavior.
+
+While care is taken at the design itself to derive optimal performance under default configurations for the most common workloads, these command line options help to derive insight into the efficiency of the compiler for a given workload, and fine tune the compilation behavior for maximizing the runtime performance / throughput.
+
+
+This page contains the full list of compiler options that are classified into: (i) optimization control knob options (which generally takes the form of enable | disable syntax), (ii) trace options (which generally take the form of traceXXX syntax), and (iii) debug options (which generally helps to manually control the execution on a specific compilation / compiled code event) and (iv) Environment variables that influences the behavior of JVMs that are spawned within that environment.","I tend to agree with Andrew, that detail should probably not live in this document; doubly so since a good chunk of this would end up reproducing the[ Testarossa Problem Determination Guide from OMR](https://github.com/eclipse/omr/blob/master/doc/compiler/ProblemDetermination.md)",
63660148,86feaf10679379f2a30177addb0e1d2b14a52dc5,doc/jit.md,False,"@@ -0,0 +1,44 @@
+# Testarossa JIT (tr.jit) compiler
+
+Testarossa JIT compiler is a high performant dynamic compiler that powers openj9 - an enterprise-grade Java Virtual Machine (JVM). It's characteristic features are to compress the application code for improved runtime performance by exploiting the exact host CPU model and apply profiling on the runtime behavior of the generated code, feed it back to the optimizer to further refine it. The component provides a wide range of command line options to (i) trace the actions of the compilation and the compiled code, and (ii) control the compiler behavior.
+
+While care is taken at the design itself to derive optimal performance under default configurations for the most common workloads, these command line options help to derive insight into the efficiency of the compiler for a given workload, and fine tune the compilation behavior for maximizing the runtime performance / throughput.
+
+
+This page contains the full list of compiler options that are classified into: (i) optimization control knob options (which generally takes the form of enable | disable syntax), (ii) trace options (which generally take the form of traceXXX syntax), and (iii) debug options (which generally helps to manually control the execution on a specific compilation / compiled code event) and (iv) Environment variables that influences the behavior of JVMs that are spawned within that environment.
+
+For most part of the documentation, this below code will be used.
+
+```java
+public class Foo {
+  public static void main(String args[]) {
+    new Foo().run(Integer.parseInt(args[0]));
+  }
+  public void run(int count) {
+    for(int i=0; i<count; i++)
+      System.out.println(""hello jit world!"");
+  }
+}
+```
+
+## Control options
+
+### Disable JIT",I almost think it would be best to document `-Xtrace` first :) ,
71990625,111c29a7b98c426d3b8c69f33ca2ee378bc3208b,runtime/tr.source/trj9/optimizer/J9TransformUtil.cpp,True,"@@ -1393,7 +1393,7 @@ TR::Node * J9::TransformUtil::calculateOffsetFromIndexInContiguousArray(TR::Comp
 
    if (shift)
       {
-      TR::Node *shiftNode = TR::Node::create(constOp, 0);","To me, it looks a bit funny if you do it that way, but this could just be the way that my brain likes repetition close together. 
",
73263616,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following command:
+```
+ln -s g++ /usr/bin/c++ \
+  && ln -s g++-4.8 /usr/bin/g++ \
+  && ln -s gcc /usr/bin/cc \
+  && ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into the /root directory:
+```
+cd /root \
+  && wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz \
+  && tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2 \
+  && rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script.",Issue is https://github.com/ibmruntimes/openj9-openjdk-jdk9/issues/34,
73475341,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,322 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, [Get the source](#2-get-the-source).
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the list of dependencies that can be obtained with the `apt-get` command from the following section of the Dockerfile:
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contains a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following commands:
+```
+ln -s g++ /usr/bin/c++
+ln -s g++-4.8 /usr/bin/g++
+ln -s gcc /usr/bin/cc
+ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into a directory. The example commands use `/root` to be consistent with the Docker instructions. If you aren't
+using Docker, you probably want to store the **freemarker.jar** in your home directory.
+```
+cd /root
+wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script. For more information, read this [issue](ibmruntimes/openj9-openjdk-jdk9#34).","Right -- the link has to be `https://github.com/ibmruntimes/openj9-openjdk-jdk9/issues/34` 

(Github collapses internal links into identifiers that are easier to read, but do not function within markdown documents)",
75442341,908ae900de9659c8495a3fa2ba5712b383ee5e4f,runtime/tr.source/trj9/env/CpuUtilization.hpp,False,"@@ -189,7 +189,15 @@ struct TR_CpuEntitlement
    // sure te portlib is up and running
    void init(J9JITConfig *jitConfig)
       {
-      _hypervisorPresent = TR_maybe;
+      /* Couple of issues were discovered when the support for hypervisor was enabled.
+       * When JVM ran on VMWare, then the port library loaded libvmGuestLib.so which
+       * interferes with implementation of some of j.l.Math methods.
+       * The library also causes JVM to core dump when an application is using libjsig.so
+       * for signal chaining.
+       * For these reasons, support for hypervisor is being disabled until the issues with
+       * VMWare library are resolved.
+       */",Can this comment link to an issue tracking this problem? ,
78926599,b665f5a71447049408378baeaab9e5da3b2e4b36,runtime/compiler/trj9/control/CompilationThread.cpp,False,"@@ -9737,6 +9736,9 @@ TR::CompilationInfoPerThreadBase::processException(
       throw;
       }
 
+   // The catch blocks below are ordered such that in each group of
+   // blocks, the basest type is at the end of the group.","Maybe replace ""basest"" with least-derived, or most generic? ",
373626567,c226bfdb9cbd8703f6148c6490e36a5b7613aad4,runtime/compiler/optimizer/InterpreterEmulator.hpp,True,"@@ -57,6 +57,8 @@
 #include ""optimizer/J9EstimateCodeSize.hpp""
 #include ""env/TRMemory.hpp""
 
+#include ""optimizer/PreExistence.hpp"" // TR_PREXARGINFO_TRACER_CLASS",I alphabetized the includes in `InterpreterEmulator.hpp` and `J9Inliner.hpp` in c226bfd,
398268304,6589fcd2b8a576d48b602961b0ce7f3b4b13f2a6,runtime/compiler/optimizer/J9ValuePropagation.cpp,True,"@@ -250,6 +261,228 @@ J9::ValuePropagation::isKnownStringObject(TR::VPConstraint *constraint)
           && (constraint->isConstString() || constraint->getKnownObject());
    }
 
+bool J9::ValuePropagation::transformIndexOfKnownString(
+   TR::Node *indexOfNode,
+   TR::Node *sourceStringNode,
+   TR::Node *targetCharNode,
+   TR::Node *startNode,
+   TR::Node *lengthNode,
+   bool is16Bit)
+   {
+   // Keep track of whether or not all constraints are global.
+   bool isGlobal = true;
+   bool isGlobalQuery;
+
+   TR::VPConstraint *sourceConstraint = getConstraint(sourceStringNode, isGlobalQuery);
+   isGlobal &= isGlobalQuery;
+   if (!sourceConstraint)
+      return false;
+   TR::VPKnownObject *knownObject = sourceConstraint->getKnownObject();
+   // The source string must either be a KnownObject or a ConstString.
+   // Otherwise, do not attempt transformations.
+   if (!knownObject && !sourceConstraint->isConstString())
+      return false;
+   TR::KnownObjectTable *knot;
+   if (knownObject)
+      {
+      knot = comp()->getOrCreateKnownObjectTable();
+      if (!knot)
+         return false;
+      TR_OpaqueClassBlock *klazz = knownObject->getClass();
+      if (!comp()->fej9()->isPrimitiveArray(klazz))
+         return false;
+      }
+
+   TR::VPConstraint *targetConstraint = getConstraint(targetCharNode, isGlobal) ;
+   bool targetIsConstChar = false;
+   uint16_t targetChar = -1;
+   if (!targetConstraint)
+      {
+      targetIsConstChar = false;
+      }
+   else if (targetConstraint->asIntConst())
+      {
+      targetIsConstChar = true;
+      targetChar = targetConstraint->asIntConst()->getInt();","I tried adding some logging and it looks like we are getting there.

For a call like `""abcde"".indexOf('a')`, the trees look like this:
```
n5n         icall  java/lang/String.indexOf(I)I[#361  final virtual Method -200] [flags 0x20500 0x0 ]  [0x7f0d05419490] bci=[-1,4,92] rc=2 vc=9 vn=- li=- udi=- nc=2
n3n           aload  <string ""abcde"">[#358  Static] (obj1) [flags 0x80000307 0x0 ]            [0x7f0d054193f0] bci=[-1,0,92] rc=1 vc=8 vn=- li=- udi=- nc=0
n4n           iconst 97                                                                       [0x7f0d05419440] bci=[-1,2,92] rc=1 vc=8 vn=- li=- udi=- nc=0
```

I think because the `'a'` becomes an `iconst`, the constraint is an integer type.

I will change targetChar to 32-bit.",
64292049,ddfed8526053edfb96a89b03d07a891253f6d9a8,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -906,7 +918,36 @@ public MethodHandle findStaticSetter(Class<?> clazz, String fieldName, Class<?>
 /*[IF ]*/
 /* If the new lookup class differs from the old one, protected members will not be accessible by virtue of inheritance. (Protected members may continue to be accessible because of package sharing.) */
 /*[ENDIF]*/
+/*[IF !Sidecar19-SE-B175]
 int newAccessMode = accessMode & ~PROTECTED;
+/*[ELSE]*/
+/* The UNCONDITIONAL bit is discarded if the new lookup class differs from the old one in Java 9 */
+int newAccessMode = accessMode & ~UNCONDITIONAL;
+
+/* There are 3 cases to be addressed for the new lookup class from a different module:
+ * 1) There is no access if the package containing the new lookup class is not exported to 
+ *    the package containing the old one.
+ * 2) There is no access if the old lookup class is in a named module
+ *    Note: The public access will be reserved if the old loop class is a public lookup.",typo here? `loop class` must be changed to `lookup class`?,
95883134,11e22e5cfba0107a5a2e9de4561d282db8e07d35,test/TestConfig/settings.mk,True,"@@ -58,6 +58,12 @@ else
 export JAVA_VERSION:=$(JAVA_VERSION)
 endif
 
+ifndef JVM_VERSION","Can you explain why we need to ""construct"" JVM_VERSION using JAVA_IMPL and and JAVA_VERSION? I am just trying to understand :)) 

The way I have it in this PR seems to be working perfectly. For example, in the job below, the JVM_VERSION provided while launching the Jenkins job is 'openjdk8-openj9', and it gets passed down into the actual third party application test build script as expected:  e.g.: https://ci.adoptopenjdk.net/view/work%20in%20progress/job/test_personal/223/console",
95919585,11e22e5cfba0107a5a2e9de4561d282db8e07d35,test/TestConfig/settings.mk,True,"@@ -58,6 +58,12 @@ else
 export JAVA_VERSION:=$(JAVA_VERSION)
 endif
 
+ifndef JVM_VERSION","Thanks for the explanation. Makes sense to me now! I've made the change in the PR. 

Validated the change with personal build: https://ci.adoptopenjdk.net/view/work%20in%20progress/job/test_personal/230/console",
95932851,11e22e5cfba0107a5a2e9de4561d282db8e07d35,test/TestConfig/settings.mk,True,"@@ -58,6 +58,28 @@ else
 export JAVA_VERSION:=$(JAVA_VERSION)
 endif
 
+ifndef JAVA_IMPL",Done!,
65561812,ca6d839669d5713aca4568b44168a77debd44b62,runtime/tr.source/trj9/env/PersistentCHTable.cpp,False,"@@ -75,34 +75,16 @@ TR_PersistentCHTable::commitSideEffectGuards(TR::Compilation *comp)
 
    for (TR_ClassLoadCheck * clc = comp->getClassesThatShouldNotBeLoaded()->getFirst(); clc; clc = clc->getNext())
       {
-      for (int32_t i = 0; i < CLASSHASHTABLE_SIZE; ++i)
+      TR_OpaqueClassBlock *clazz = comp->fej9()->getClassFromSignature(clc->_name, clc->_length, comp->getCurrentMethod());",Is ClassesThatShouldNotBeLoaded normalized so there is only one entry per class? If it is then this is fine. If there are duplicates we may need to cache the lookup result since the name lookup can be expensive.,
65627821,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,False,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv",I don't follow the idiv here... could you explain a bit more?,
65628597,ca6d839669d5713aca4568b44168a77debd44b62,runtime/tr.source/trj9/env/PersistentCHTable.cpp,False,"@@ -75,34 +75,16 @@ TR_PersistentCHTable::commitSideEffectGuards(TR::Compilation *comp)
 
    for (TR_ClassLoadCheck * clc = comp->getClassesThatShouldNotBeLoaded()->getFirst(); clc; clc = clc->getNext())
       {
-      for (int32_t i = 0; i < CLASSHASHTABLE_SIZE; ++i)
+      TR_OpaqueClassBlock *clazz = comp->fej9()->getClassFromSignature(clc->_name, clc->_length, comp->getCurrentMethod());",Ok then this looks ok,
65630505,f17b8f1803e317e3a2a9022fbe05b3888e0e8f0a,runtime/tr.source/trj9/env/VMJ9.cpp,False,"@@ -7473,6 +7473,72 @@ TR_J9VMBase::releaseCodeEstimator(TR::Compilation *comp, TR_EstimateCodeSize *es
    comp->allocator().deallocate(estimator, sizeof(TR_J9EstimateCodeSize));
    }
 
+void
+TR_J9VM::transformJavaLangClassIsArray(TR::Compilation * comp, TR::Node * callNode, TR::TreeTop * treeTop)
+   {
+   // Example for the transformation
+   // treetop (may be null check)
+   //   icalli                   <= callNode
+   //     aload <parm 1>         <= jlClass
+   //
+   //
+   // Final: (when target.is32Bit() == true)
+   //
+   // NULLCHK (if there is a null check)
+   //   PassThrough
+   //     aload <parm 1>         <= jlClass
+   // treetop
+   //   idiv",should this be a right shift or something if we are trying to get rid of trailing zeros or something then? idiv is an expensive thing that the optimizer needs to see through so we should avoid generating it,
66431057,67aa3433ad16dbcbcb173c4ac7b03bc6032b417d,runtime/tr.source/trj9/optimizer/FearPointAnalysis.cpp,False,"@@ -39,18 +39,26 @@ bool TR_FearPointAnalysis::virtualGuardsKillFear()
    return feGetEnv(""TR_FPAnalaysisGuardsDoNotKillFear"") == NULL;
    }
 
-static bool containsPrepareForOSR(TR::Block *block)
+bool TR_FearPointAnalysis::containsPrepareForOSR(TR::Block *block)",Since this function is called from two analyses would it be better somewhere in the OSR infrastructure?,
66459954,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",We should be careful adding instance fields to string due to the footprint increase they cause,
66460140,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,False,"@@ -257,7 +257,16 @@ static final void initializeClassLoaders() {
 
 /*[IF Sidecar19-SE]*/
 jdk.internal.misc.VM.initLevel(1);
-System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+try {
+/*[ENDIF]*/
+System.bootLayer = jdk.internal.module.ModuleBootstrap.boot();
+/*[IF Java18.3]*/
+} catch (Exception ex) {",Is this temporary?,
66875530,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","The coder field does not serve the same purpose as count. There is an important difference in the String implementation behavior here for OpenJ9. In OpenJ9 the backing array of a string can be longer than the string length. This is a very useful optimization for a number of cases including when a StringBuilder/StringBuffer has append called after a toString; a substring is used to generate prefix strings; and to prevent having to truncate the backing array of a StringBuilder/StringBuffer when toString is called if the builder's of buffer's backing array is over allocated. Without the count field these optimizations cannot be done. Removing or repurposing the count field does have a major performance implication as a result.

Adding a new field does need a good justification given the huge object size increases that can be seen (per the discussion above). I agree there is a case for minimizing patches, but given how performance sensitive String is a little bit more study might be justified before adopting the field.",
66877050,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();","The only problem with renaming the field from count to coder is that count is an int and coder field is a byte. The byte may only hold 0 or 1 or something like that, but for count the MSB is the bit so I don't know that we can make the reflective access equivalent...",
66882295,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",Note that the coder field will likely not have the correct value once OpenJ9 enables string compression by default leading the presence of this field to cause incorrect behavior.,
66886724,6b6c51afb7b3c9c773d7b9f049e7fe75a101f643,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -71,6 +71,9 @@
 static final boolean enableCompression = com.ibm.oti.vm.VM.J9_STRING_COMPRESSION_ENABLED;
 
 /*[IF Sidecar19-SE]*/
+/*[IF Java18.3]*/
+private final byte coder = coder();",coder() does so the initialization was right - I take back my comment it should be correct.,
67368035,9b9559cab1f03437c9a0909f3a9dee055b64b9aa,runtime/tr.source/trj9/env/j9method.cpp,False,"@@ -5248,6 +5284,247 @@ TR_J9MethodBase::isUnsafeWithObjectArg(TR::Compilation * c)
    }
 
 bool
+TR_J9MethodBase::isUnsafeGetPutWithObjectArg(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putByteOrdered_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBooleanOrdered_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putCharOrdered_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShortOrdered_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putIntOrdered_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLongOrdered_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloatOrdered_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDoubleOrdered_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObjectOrdered_jlObjectJjlObject_V:
+         return true;
+      default:
+         return false;
+      }
+
+   return false;
+   }
+
+TR::DataType
+TR_J9MethodBase::unsafeDataTypeForObject(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+         return TR::Int32;
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+         return TR::Int64;
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+         return TR::Float;
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+         return TR::Double;
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+         return TR::Address;
+      default:
+         return TR::NoType;",Should this assert?,
67368088,9b9559cab1f03437c9a0909f3a9dee055b64b9aa,runtime/tr.source/trj9/env/j9method.cpp,False,"@@ -5248,6 +5284,247 @@ TR_J9MethodBase::isUnsafeWithObjectArg(TR::Compilation * c)
    }
 
 bool
+TR_J9MethodBase::isUnsafeGetPutWithObjectArg(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putByteOrdered_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_putBooleanOrdered_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_putCharOrdered_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_putShortOrdered_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_putIntOrdered_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_putLongOrdered_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_putFloatOrdered_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_putDoubleOrdered_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_putObjectOrdered_jlObjectJjlObject_V:
+         return true;
+      default:
+         return false;
+      }
+
+   return false;
+   }
+
+TR::DataType
+TR_J9MethodBase::unsafeDataTypeForObject(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+         return TR::Int32;
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+         return TR::Int64;
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+         return TR::Float;
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+         return TR::Double;
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+         return TR::Address;
+      default:
+         return TR::NoType;
+      }
+   return TR::NoType;
+   }
+
+TR::DataType
+TR_J9MethodBase::unsafeDataTypeForArray(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::sun_misc_Unsafe_getBoolean_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBoolean_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByte_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByte_jlObjectJB_V:
+      case TR::sun_misc_Unsafe_getBooleanVolatile_jlObjectJ_Z:
+      case TR::sun_misc_Unsafe_putBooleanVolatile_jlObjectJZ_V:
+      case TR::sun_misc_Unsafe_getByteVolatile_jlObjectJ_B:
+      case TR::sun_misc_Unsafe_putByteVolatile_jlObjectJB_V:
+         return TR::Int8;
+      case TR::sun_misc_Unsafe_getChar_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putChar_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShort_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShort_jlObjectJS_V:
+      case TR::sun_misc_Unsafe_getCharVolatile_jlObjectJ_C:
+      case TR::sun_misc_Unsafe_putCharVolatile_jlObjectJC_V:
+      case TR::sun_misc_Unsafe_getShortVolatile_jlObjectJ_S:
+      case TR::sun_misc_Unsafe_putShortVolatile_jlObjectJS_V:
+         return TR::Int16;
+      case TR::sun_misc_Unsafe_getInt_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putInt_jlObjectJI_V:
+      case TR::sun_misc_Unsafe_getIntVolatile_jlObjectJ_I:
+      case TR::sun_misc_Unsafe_putIntVolatile_jlObjectJI_V:
+         return TR::Int32;
+      case TR::sun_misc_Unsafe_getLong_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLong_jlObjectJJ_V:
+      case TR::sun_misc_Unsafe_getLongVolatile_jlObjectJ_J:
+      case TR::sun_misc_Unsafe_putLongVolatile_jlObjectJJ_V:
+         return TR::Int64;
+      case TR::sun_misc_Unsafe_getFloat_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloat_jlObjectJF_V:
+      case TR::sun_misc_Unsafe_getFloatVolatile_jlObjectJ_F:
+      case TR::sun_misc_Unsafe_putFloatVolatile_jlObjectJF_V:
+         return TR::Float;
+      case TR::sun_misc_Unsafe_getDouble_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDouble_jlObjectJD_V:
+      case TR::sun_misc_Unsafe_getDoubleVolatile_jlObjectJ_D:
+      case TR::sun_misc_Unsafe_putDoubleVolatile_jlObjectJD_V:
+         return TR::Double;
+      case TR::sun_misc_Unsafe_getObject_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObject_jlObjectJjlObject_V:
+      case TR::sun_misc_Unsafe_getObjectVolatile_jlObjectJ_jlObject:
+      case TR::sun_misc_Unsafe_putObjectVolatile_jlObjectJjlObject_V:
+         return TR::Address;
+      default:
+         return TR::NoType;",should this assert?,
67368950,9b9559cab1f03437c9a0909f3a9dee055b64b9aa,runtime/tr.source/trj9/optimizer/UnsafeFastPath.cpp,False,"@@ -349,13 +392,36 @@ int32_t TR_UnsafeFastPath::perform()
 
          if (type != TR::NoType && performTransformation(comp(), ""%s Found unsafe/JITHelpers calls, turning node ["" POINTER_PRINTF_FORMAT ""] into a load/store\n"", optDetailString(), node))
             {
+
             TR::SymbolReference * unsafeSymRef = comp()->getSymRefTab()->findOrCreateUnsafeSymbolRef(type, true, false, isVolatile);
 
+            // Change the object child to the starting address of static fields in J9Class
+            if (isStatic)
+               {
+               TR::Node *jlClass = node->getChild(1);
+               TR::Node *j9Class =
+                  TR::Node::createWithSymRef(TR::aloadi, 1, 1, jlClass,
+                                  comp()->getSymRefTab()->findOrCreateClassFromJavaLangClassSymbolRef());
+               TR::Node *ramStatics =
+                  TR::Node::createWithSymRef(TR::aloadi, 1, 1, j9Class,
+                                  comp()->getSymRefTab()->findOrCreateRamStaticsFromClassSymbolRef());
+               node->setAndIncChild(1, ramStatics);
+               jlClass->recursivelyDecReferenceCount();
+               offset = node->getChild(2);
+               TR::Node *newOffset =",could you put a comment on what is happening here?,
67390164,9b9559cab1f03437c9a0909f3a9dee055b64b9aa,runtime/tr.source/trj9/optimizer/UnsafeFastPath.cpp,False,"@@ -349,13 +392,37 @@ int32_t TR_UnsafeFastPath::perform()
 
          if (type != TR::NoType && performTransformation(comp(), ""%s Found unsafe/JITHelpers calls, turning node ["" POINTER_PRINTF_FORMAT ""] into a load/store\n"", optDetailString(), node))
             {
+
             TR::SymbolReference * unsafeSymRef = comp()->getSymRefTab()->findOrCreateUnsafeSymbolRef(type, true, false, isVolatile);
 
+            // Change the object child to the starting address of static fields in J9Class
+            if (isStatic)
+               {
+               TR::Node *jlClass = node->getChild(1);
+               TR::Node *j9Class =
+                  TR::Node::createWithSymRef(TR::aloadi, 1, 1, jlClass,
+                                  comp()->getSymRefTab()->findOrCreateClassFromJavaLangClassSymbolRef());
+               TR::Node *ramStatics =
+                  TR::Node::createWithSymRef(TR::aloadi, 1, 1, j9Class,
+                                  comp()->getSymRefTab()->findOrCreateRamStaticsFromClassSymbolRef());
+               node->setAndIncChild(1, ramStatics);
+               jlClass->recursivelyDecReferenceCount();
+               offset = node->getChild(2);
+               // The offset for a static field is low taged, mask out the last bit to get the real offset
+               TR::Node *newOffset =
+                  TR::Node::create(offset, TR::land, 2, offset,
+                                  TR::Node::lconst(offset, -2));",can you write this as ~1 rather than -2 so that it is a bit more clear.,
68418274,07b63e9db68b1273d8d4c10ca9330255774e230d,runtime/tr.source/trj9/optimizer/J9Simplifier.cpp,False,"@@ -833,7 +833,7 @@ J9::Simplifier::simplifyiOrPatterns(TR::Node *node)
    secondChild = node->getSecondChild();
    if (!disableIORByteSwap &&
        !TR::Compiler->target.cpu.isBigEndian() &&  // the bigEndian case needs more thought
-       comp()->cg()->getSupportsIbyteswap() && secondChild->getOpCodeValue() == TR::ior)","hmm, the bigEndian case needs more thought - wasn't was wrong the big endian case?",
70024569,830b52c0368c94ff12dbe138d027694fe3e6709b,runtime/tr.source/trj9/compile/J9Compilation.cpp,True,"@@ -83,11 +83,11 @@ void *operator new(size_t size)
 /**
  * Since we are using arena allocation, heap deletions must be a no-op, and
  * can't be used by JIT code, so we inject an assertion here.
- */
+ *
 void operator delete(void *)
    {
    TR_ASSERT(0, ""Invalid use of global operator delete"");
-   }
+   }*/",The Java 9 libraries were tripping debug builds because of operator new and delete in non JIT libraries from the JCL - removed from the commits.,
70024766,830b52c0368c94ff12dbe138d027694fe3e6709b,runtime/tr.source/trj9/optimizer/UnsafeFastPath.cpp,True,"@@ -149,6 +149,16 @@ int32_t TR_UnsafeFastPath::perform()
          bool isVolatile = false;
          bool isArrayOperation = false;
          bool isByIndex = false;
+         int32_t objectChild = 1;
+         int32_t offsetChild = 2;",The class is not static as a means of reducing the ability to access it - for the same reasons Unsafe is not static - the singleton accessor has a security check.,
70024923,830b52c0368c94ff12dbe138d027694fe3e6709b,runtime/tr.source/trj9/il/symbol/J9MethodSymbol.cpp,True,"@@ -538,6 +538,9 @@ static TR::RecognizedMethod canSkipZeroInitializationOnNewarrays[] =
    //TR::java_util_Arrays_copyOf,
    TR::java_io_Writer_write_lStringII,
    TR::java_io_Writer_write_I,
+   TR::java_lang_StringCoding_encode8859_1,
+   TR::java_lang_StringCoding_encodeASCII,
+   TR::java_lang_StringCoding_encodeUTF8,",yes - getChar will be turned directly into a read - no bounds checking at all.,
70193152,830b52c0368c94ff12dbe138d027694fe3e6709b,runtime/tr.source/trj9/compile/J9Compilation.cpp,True,"@@ -83,11 +83,11 @@ void *operator new(size_t size)
 /**
  * Since we are using arena allocation, heap deletions must be a no-op, and
  * can't be used by JIT code, so we inject an assertion here.
- */
+ *
 void operator delete(void *)
    {
    TR_ASSERT(0, ""Invalid use of global operator delete"");
-   }
+   }*/","Opened #374 to track this one - not sure of the 'correct' fix, but put some ideas in the issue.",
70193354,830b52c0368c94ff12dbe138d027694fe3e6709b,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -2423,14 +2423,19 @@ public boolean equalsIgnoreCase(String string) {
 int currentLength = lengthInternal();
 
 /*[IF Sidecar19-SE]*/
+byte[] buffer = value;
 // Check if the String is compressed
 if (enableCompression && count >= 0) {
-byte[] buffer = new byte[currentLength];
-compressedArrayCopy(value, 0, buffer, 0, currentLength);
+if (buffer.length != currentLength) {
+buffer = new byte[currentLength];
+compressedArrayCopy(value, 0, buffer, 0, currentLength);
+}
 return StringCoding.encode(String.LATIN1, buffer);
 } else {
-byte[] buffer = new byte[currentLength * 2];
-decompressedArrayCopy(value, 0, buffer, 0, currentLength);
+if (buffer.length != currentLength << 1) {",Most of the string implementation is using the << operator and it is prevalent in the StringCoding bytecode so I was sticking with that convention. You are right that the JIT would pick which ever is better for the platform in most cases.,
70194968,830b52c0368c94ff12dbe138d027694fe3e6709b,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -2423,14 +2423,19 @@ public boolean equalsIgnoreCase(String string) {
 int currentLength = lengthInternal();
 
 /*[IF Sidecar19-SE]*/
+byte[] buffer = value;
 // Check if the String is compressed
 if (enableCompression && count >= 0) {
-byte[] buffer = new byte[currentLength];
-compressedArrayCopy(value, 0, buffer, 0, currentLength);
+if (buffer.length != currentLength) {
+buffer = new byte[currentLength];","That is an interesting idea - it would save the extra allocates in subsequent getBytes() calls, but when you have shared strings ie multiple strings with the same backing array and different lengths, doing so could increase memory usage. I guess since we are having to allocate anyway one could argue the memory has already increased, the difference would be the increase would be permanent as opposed to transient. I'm not sure on the performance implications one way or the other. @DanHeidinga do you have any thoughts? Regardless this is an improvement since we will no longer copy on every call. Perhaps we can put this in and then try to figure out a study to see if there is benefit from storing it back by surveying some benchmarks or something?",
70198521,830b52c0368c94ff12dbe138d027694fe3e6709b,runtime/tr.source/trj9/optimizer/UnsafeFastPath.cpp,True,"@@ -149,6 +149,16 @@ int32_t TR_UnsafeFastPath::perform()
          bool isVolatile = false;
          bool isArrayOperation = false;
          bool isByIndex = false;
+         int32_t objectChild = 1;
+         int32_t offsetChild = 2;
+
+         switch (symbol->getRecognizedMethod())
+            {
+            case TR::java_lang_StringUTF16_getChar:
+               objectChild = 0;
+               offsetChild = 1;
+               break;
+            }","I created a separate switch because there may well be other cases where we want to change the offsets that are not related to arrayness. The basic pattern here is we have a switch to set a particular flag or set of values and I think I prefer the idea of doing the object and offset in their own so it is clear how things map. It may make an extra lookup table, but the cost should be low in terms of compile time and it makes the logic more clear in my opinion.",
70222916,830b52c0368c94ff12dbe138d027694fe3e6709b,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -2423,14 +2423,19 @@ public boolean equalsIgnoreCase(String string) {
 int currentLength = lengthInternal();
 
 /*[IF Sidecar19-SE]*/
+byte[] buffer = value;
 // Check if the String is compressed
 if (enableCompression && count >= 0) {
-byte[] buffer = new byte[currentLength];
-compressedArrayCopy(value, 0, buffer, 0, currentLength);
+if (buffer.length != currentLength) {
+buffer = new byte[currentLength];",I have opened #375 to track this work.,
71260160,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {
+if (regex != null && substitute != null && regex.lengthInternal() == 1 && !hasMetaChars(regex)) {
+int substituteLength = substitute.lengthInternal();
+int length = lengthInternal();
+int newCharIndex = 0;
+if (substituteLength < 2) {
+if (enableCompression && isCompressed() && (substituteLength == 0 || substitute.isCompressed())) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length];
+/*[ELSE]*/
+char[] newChars = new char[(length + 1) >> 1];
+/*[ENDIF]*/
+byte toReplace = helpers.getByteFromArrayByIndex(regex, 0);
+byte replacement = substituteLength == 1 ? helpers.getByteFromArrayByIndex(substitute, 0) : (byte)-1;",the -1 will only happen when subsituteLength == 0 and so 4295 will never see the value. -1 is just a dummy value that is more obviously bad than 0 should the logic ever break,
71260248,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {
+if (regex != null && substitute != null && regex.lengthInternal() == 1 && !hasMetaChars(regex)) {
+int substituteLength = substitute.lengthInternal();
+int length = lengthInternal();
+int newCharIndex = 0;
+if (substituteLength < 2) {
+if (enableCompression && isCompressed() && (substituteLength == 0 || substitute.isCompressed())) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length];
+/*[ELSE]*/
+char[] newChars = new char[(length + 1) >> 1];
+/*[ENDIF]*/
+byte toReplace = helpers.getByteFromArrayByIndex(regex, 0);
+byte replacement = substituteLength == 1 ? helpers.getByteFromArrayByIndex(substitute, 0) : (byte)-1;
+for (int i = 0; i < length; ++i) {
+byte current = helpers.getByteFromArrayByIndex(value, i);
+if (current != toReplace) {
+helpers.putByteInArrayByIndex(newChars, newCharIndex++, current);
+} else if (substituteLength == 1) {
+helpers.putByteInArrayByIndex(newChars, newCharIndex++, replacement);
+}
+}
+return new String(newChars, 0, newCharIndex, true);
+} else if (!enableCompression || !isCompressed()) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length << 1];
+/*[ELSE]*/
+char[] newChars = new char[length];
+/*[ENDIF]*/
+char toReplace = regex.charAtInternal(0);
+char replacement = substituteLength == 1 ? substitute.charAtInternal(0) : (char)-1; ",same reasoning as above to say the -1 is never used/seen,
71261536,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {",added,
71507720,089f4bfc23065b7a246eb87e24c66bcf378396bf,runtime/tr.source/trj9/build/toolcfg/gnu/common.mk,False,"@@ -114,13 +114,15 @@ CX_OPTFLAG?=$(CX_DEFAULTOPT)
 CX_FLAGS_PROD+=$(CX_OPTFLAG)
 
 ifeq ($(HOST_ARCH),x)
+    CX_FLAGS+=-mfpmath=sse -msse -msse2 -fno-strict-aliasing -fno-math-errno -fno-rounding-math -fno-trapping-math -fno-signaling-nans",I think a comment near hear about the flags and what they change is warranted for reference purposes.,
71509318,dffa8e862911c80f3ba1f8d585a64bd47160654e,runtime/tr.source/trj9/optimizer/RecognizedCallTransformer.cpp,False,"@@ -0,0 +1,125 @@
+/*******************************************************************************
+* Copyright (c) 2000, 2017 IBM Corp. and others",dates need fixing,
72188981,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/codegen/J9CodeGenerator.cpp,False,"@@ -666,7 +666,10 @@ J9::CodeGenerator::lowerTreesPreChildrenVisit(TR::Node *parent, TR::TreeTop *tre
       if (self()->comp()->useCompressedPointers())
          {
          TR::MethodSymbol *methodSymbol = parent->getSymbol()->castToMethodSymbol();
+         // Unsafe could be the jdk.internal JNI method or the sun.misc ordinary method wrapper,",Please include that this is the case in Java 9 up - 8 and earlier will have the sun.misc.Unsafe as the native.,
72189132,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/optimizer/InlinerTempForJ9.cpp,False,"@@ -349,57 +349,71 @@ TR_J9InlinerPolicy::mustBeInlinedEvenInDebug(TR_ResolvedMethod * calleeMethod, T
    return false;
    }
 
+/* Identify methods for which the benefits of inlining them into the caller",Please format this for doxygen,
72189240,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/optimizer/InlinerTempForJ9.cpp,False,"@@ -349,57 +349,71 @@ TR_J9InlinerPolicy::mustBeInlinedEvenInDebug(TR_ResolvedMethod * calleeMethod, T
    return false;
    }
 
+/* Identify methods for which the benefits of inlining them into the caller
+   are particularly significant.
+*/
 bool
 TR_J9InlinerPolicy::alwaysWorthInlining(TR_ResolvedMethod * calleeMethod, TR::Node *callNode)
    {
-   if (calleeMethod && isInlineableJNI(calleeMethod, callNode))
+   // if we are passed a null calleeMethod then we can only return false",This is obvious from the code.,
72189589,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/optimizer/InlinerTempForJ9.cpp,False,"@@ -349,57 +349,71 @@ TR_J9InlinerPolicy::mustBeInlinedEvenInDebug(TR_ResolvedMethod * calleeMethod, T
    return false;
    }
 
+/* Identify methods for which the benefits of inlining them into the caller
+   are particularly significant.
+*/
 bool
 TR_J9InlinerPolicy::alwaysWorthInlining(TR_ResolvedMethod * calleeMethod, TR::Node *callNode)
    {
-   if (calleeMethod && isInlineableJNI(calleeMethod, callNode))
+   // if we are passed a null calleeMethod then we can only return false
+   if (!calleeMethod) return false;
+
+   if (isInlineableJNI(calleeMethod, callNode))
       return true;
 
-   if (calleeMethod && calleeMethod->isDAAWrapperMethod())
+   if (calleeMethod->isDAAWrapperMethod())
       return true;
 
-   if (calleeMethod)
+   switch (calleeMethod->convertToMethod()->getMandatoryRecognizedMethod())
       {
-      switch (calleeMethod->convertToMethod()->getMandatoryRecognizedMethod())
-         {
-         case TR::java_lang_invoke_MethodHandle_asType:
-         case TR::java_lang_invoke_MethodHandle_invokeExactTargetAddress:
-            return true;
-         default:
-          break;
-         }
-
-      // we rely on inlining compareAndSwap so we see the inner native call and can special case it
-      // get/putLongVolatile is not supported by all codegens so we want to inline to expose the native
-      // if we haven't special cased it in the walker
-      switch (calleeMethod->getRecognizedMethod())
-         {
-         case TR::java_lang_J9VMInternals_fastIdentityHashCode:
-         case TR::java_lang_Class_getSuperclass:
-         case TR::java_lang_String_regionMatches:
-         case TR::java_lang_Class_newInstance:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapIntInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapLongInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapObjectInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapIntInArray:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapLongInArray:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapObjectInArray:
-         case TR::com_ibm_jit_JITHelpers_jitHelpers:
-         case TR::java_lang_String_charAtInternal_I:
-         case TR::java_lang_String_charAtInternal_IB:
-         case TR::java_lang_String_length:
-         case TR::java_lang_String_lengthInternal:
-         case TR::java_lang_String_isCompressed:
-         case TR::java_lang_StringBuffer_capacityInternal:
-         case TR::java_lang_StringBuffer_lengthInternalUnsynchronized:
-         case TR::java_lang_StringBuilder_capacityInternal:
-         case TR::java_lang_StringBuilder_lengthInternal:
-         case TR::java_util_HashMap_get:
-         case TR::java_util_HashMap_getNode:
-            return true;
-         default:
-          break;
-         }
+      case TR::java_lang_invoke_MethodHandle_asType:
+      case TR::java_lang_invoke_MethodHandle_invokeExactTargetAddress:
+         return true;
+      default:
+       break;",formatting,
72189958,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/optimizer/InlinerTempForJ9.cpp,False,"@@ -349,57 +349,71 @@ TR_J9InlinerPolicy::mustBeInlinedEvenInDebug(TR_ResolvedMethod * calleeMethod, T
    return false;
    }
 
+/* Identify methods for which the benefits of inlining them into the caller
+   are particularly significant.
+*/
 bool
 TR_J9InlinerPolicy::alwaysWorthInlining(TR_ResolvedMethod * calleeMethod, TR::Node *callNode)
    {
-   if (calleeMethod && isInlineableJNI(calleeMethod, callNode))
+   // if we are passed a null calleeMethod then we can only return false
+   if (!calleeMethod) return false;
+
+   if (isInlineableJNI(calleeMethod, callNode))
       return true;
 
-   if (calleeMethod && calleeMethod->isDAAWrapperMethod())
+   if (calleeMethod->isDAAWrapperMethod())
       return true;
 
-   if (calleeMethod)
+   switch (calleeMethod->convertToMethod()->getMandatoryRecognizedMethod())
       {
-      switch (calleeMethod->convertToMethod()->getMandatoryRecognizedMethod())
-         {
-         case TR::java_lang_invoke_MethodHandle_asType:
-         case TR::java_lang_invoke_MethodHandle_invokeExactTargetAddress:
-            return true;
-         default:
-          break;
-         }
-
-      // we rely on inlining compareAndSwap so we see the inner native call and can special case it
-      // get/putLongVolatile is not supported by all codegens so we want to inline to expose the native
-      // if we haven't special cased it in the walker
-      switch (calleeMethod->getRecognizedMethod())
-         {
-         case TR::java_lang_J9VMInternals_fastIdentityHashCode:
-         case TR::java_lang_Class_getSuperclass:
-         case TR::java_lang_String_regionMatches:
-         case TR::java_lang_Class_newInstance:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapIntInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapLongInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapObjectInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapIntInArray:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapLongInArray:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapObjectInArray:
-         case TR::com_ibm_jit_JITHelpers_jitHelpers:
-         case TR::java_lang_String_charAtInternal_I:
-         case TR::java_lang_String_charAtInternal_IB:
-         case TR::java_lang_String_length:
-         case TR::java_lang_String_lengthInternal:
-         case TR::java_lang_String_isCompressed:
-         case TR::java_lang_StringBuffer_capacityInternal:
-         case TR::java_lang_StringBuffer_lengthInternalUnsynchronized:
-         case TR::java_lang_StringBuilder_capacityInternal:
-         case TR::java_lang_StringBuilder_lengthInternal:
-         case TR::java_util_HashMap_get:
-         case TR::java_util_HashMap_getNode:
-            return true;
-         default:
-          break;
-         }
+      case TR::java_lang_invoke_MethodHandle_asType:
+      case TR::java_lang_invoke_MethodHandle_invokeExactTargetAddress:
+         return true;
+      default:
+       break;
+      }
+
+   // we rely on inlining compareAndSwap so we see the inner native call and can special case it",redundant - the comment belongs with the specific list of enum entries that have the special handling. so please move this down there / incorporate into the other ocmments you added there,
72190356,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/x/codegen/J9TreeEvaluator.cpp,False,"@@ -13004,6 +13004,8 @@ inlineAtomicStampedReference_doubleWordSet(
    return true;
    }
 
+// Note that this function must have behaviour consistent with the OMR function",This should either be properly doxygen'd or the comment moved into the method body and not put in the place where doxygen would go.,
72190975,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/x/codegen/J9TreeEvaluator.cpp,False,"@@ -13021,6 +13023,9 @@ inlineCompareAndSwapNative(
 
    TR_X86OpCodes op;
 
+   TR::SymbolReference *callSymRef = node->getSymbolReference();
+   TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();",I don't think these locals are necessary node->getSymbolReference()->getSymbol()->castToMethodSymbol() should be a fine chain if you need to test native-ness. Do we need to worry about a NULL return from castToMethodSymbol()? Move any locals necessary for null checking down near the use rather than declaring them up here.,
72214427,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/x/codegen/J9TreeEvaluator.cpp,False,"@@ -13021,6 +13023,9 @@ inlineCompareAndSwapNative(
 
    TR_X86OpCodes op;
 
+   TR::SymbolReference *callSymRef = node->getSymbolReference();
+   TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();","True for C, but not so for the version of C++ used in the compiler. You could create a block with {}s to limit the scope if you wanted to.",
75806841,144955a297c73fe2691c010b7eff20e88e68dc25,runtime/tr.source/trj9/optimizer/J9Optimizer.cpp,False,"@@ -665,6 +665,7 @@ static const OptimizationStrategy cheapWarmStrategyOpts[] =
    { OMR::blockShuffling                                                             },
    { OMR::idiomRecognition,                          OMR::IfLoopsAndNotProfiling     },",This shouldn't be duplicated it should be pulled out of the ifdef,
78805674,e858983ecebb378c494f23ce844f5ee63ff51aad,runtime/compiler/trj9/env/j9method.cpp,False,"@@ -4504,7 +4505,19 @@ TR_ResolvedJ9Method::TR_ResolvedJ9Method(TR_OpaqueMethodBlock * aMethod, TR_Fron
          else if ((classNameLen == 29) && !strncmp(className, ""java/lang/invoke/MethodHandle"", 29))
             {
             if (!strncmp(name, ""asType"", 6))
-               setRecognizedMethodInfo(TR::java_lang_invoke_MethodHandle_asType);
+               {
+               int32_t instanceAsTypeSigLen = sizeof(""(Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;"");",I don't believe signatures from the VM are guaranteed to have a '\0' so does this actually work in practice? I think it may read one character too many...,
78926858,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/control/J9Recompilation.cpp,False,"@@ -439,6 +442,24 @@ J9::Recompilation::getValueProfiler()
    return 0;
    }
 
+TR_BlockFrequencyProfiler *
+J9::Recompilation::getBlockFrequencyProfiler()
+   {
+   for (TR_RecompilationProfiler * rp = getFirstProfiler(); rp; rp = rp->getNext())
+      {
+      TR_BlockFrequencyProfiler *vp = rp->asBlockFrequencyProfiler();
+      if (vp)
+         return vp;
+      }
+
+   return 0;",This should use return NULL rather than return 0 for future compatibility.,
78926951,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/control/J9Recompilation.cpp,False,"@@ -439,6 +442,24 @@ J9::Recompilation::getValueProfiler()
    return 0;
    }
 
+TR_BlockFrequencyProfiler *
+J9::Recompilation::getBlockFrequencyProfiler()
+   {
+   for (TR_RecompilationProfiler * rp = getFirstProfiler(); rp; rp = rp->getNext())
+      {
+      TR_BlockFrequencyProfiler *vp = rp->asBlockFrequencyProfiler();
+      if (vp)",A comment about why this can be NULL is probably warranted,
78927051,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/control/J9Recompilation.cpp,False,"@@ -439,6 +442,24 @@ J9::Recompilation::getValueProfiler()
    return 0;
    }
 
+TR_BlockFrequencyProfiler *
+J9::Recompilation::getBlockFrequencyProfiler()",As a new API this should have doxygen,
78927122,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/control/J9Recompilation.cpp,False,"@@ -439,6 +442,24 @@ J9::Recompilation::getValueProfiler()
    return 0;
    }
 
+TR_BlockFrequencyProfiler *
+J9::Recompilation::getBlockFrequencyProfiler()
+   {
+   for (TR_RecompilationProfiler * rp = getFirstProfiler(); rp; rp = rp->getNext())
+      {
+      TR_BlockFrequencyProfiler *vp = rp->asBlockFrequencyProfiler();
+      if (vp)
+         return vp;
+      }
+
+   return 0;
+   }
+
+void
+J9::Recompilation::removeProfiler(TR_RecompilationProfiler *rp)",doxygen for this as well,
78927271,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/runtime/J9Profiler.hpp,False,"@@ -205,6 +206,7 @@ class TR_RecompilationProfiler : public TR_Link<TR_RecompilationProfiler>
    void setInitialiCompilation(bool b) { _flags.set(initialCompilation, b); }
 
    virtual TR_ValueProfiler * asValueProfiler() {return NULL;}
+   virtual TR_BlockFrequencyProfiler * asBlockFrequencyProfiler() {return NULL;}",code style - prefer spaces around { }s,
78927712,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/BlockJProfiling.cpp,False,"@@ -756,42 +756,18 @@ int32_t TR_BlockJProfiling::processCFGForCounting(BlockParents &parent, TR::Bloc
 
 /**
  * Initialize the persistent data structurs used to store and exploit the method profiling data
- * \param addValueProfilingTrees Add trees to store method call target and other value profiling information
- *        (high overhead)
  * \return The block frequency information data structure holding the profiling counters
  */
-TR_BlockFrequencyInfo *TR_BlockJProfiling::initRecompDataStructures(bool addValueProfilingTrees)
+TR_BlockFrequencyInfo *TR_BlockJProfiling::initRecompDataStructures()
    {
    TR_PersistentProfileInfo *profileInfo = comp()->getRecompilationInfo()->findOrCreateProfileInfo();
-   if (addValueProfilingTrees)
-      {
-      comp()->getRecompilationInfo()->createProfilers();
-      comp()->getRecompilationInfo()->getValueProfiler()->modifyTrees();
-      }
-   if (!comp()->haveCommittedCallSiteInfo() && profileInfo->getCallSiteInfo() == NULL)
-      {
-      TR_CallSiteInfo * const initialCallSiteInfo = new (PERSISTENT_NEW) TR_CallSiteInfo(comp(), persistentAlloc);
-      TR_ASSERT(profileInfo->getCallSiteInfo() == NULL, ""Profile already conatins a CallSiteInfo"");
-      profileInfo->setCallSiteInfo(initialCallSiteInfo);
-      profileInfo->clearInfo();
-      comp()->setCommittedCallSiteInfo(true);
-      }
-   else if (profileInfo->getCallSiteInfo()->getNumCallSites() != comp()->getNumInlinedCallSites())
-      {
-      TR_CallSiteInfo * const originalCallSiteInfo = profileInfo->getCallSiteInfo();
-      TR_ASSERT(originalCallSiteInfo != NULL, ""Existing CallSiteInfo should not be NULL."");
-      TR_CallSiteInfo * const updatedCallSiteInfo = new (PERSISTENT_NEW) TR_CallSiteInfo(comp(), persistentAlloc);
-      profileInfo->setCallSiteInfo(updatedCallSiteInfo);
-      // FIXME: originalCallSiteInfo and its _blocks array allocation appear to leak.
-      }
 
+   // Remove other block frequency profiler",what other block frequency profiler? this seems a bit cryptic,
80876182,3638a278b104b2a82fadb56b6d09e4e5988bbafa,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java,False,"@@ -260,6 +267,8 @@ MethodHandle cloneWithNewType(MethodType newType) {
 enforceArityLimit(kind, this.type);
 /* Must be called even laster as it uses the method type */
 this.thunks = computeThunks(thunkArg);
+/* Touch thunks.invokeExactThunk so that its constant pool entry is resolved by the time it is used by the JIT */
+long i = thunks.invokeExactThunk;","Special hardcoded fields/methods could be added to cold block marking, but this isn't done at present. Simply forcing the field to resolve in the constant pool is all that is needed. The dead local should be cleaned up by JIT compilation and so the load should cease to happen at that point. Having the field resolve rather than adding a special case to the JIT seems nicer to me, but happy to hear alternative arguments.",
81186932,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/BlockJProfiling.cpp,False,"@@ -971,8 +958,42 @@ void TR_JProfiling::addRecompilationTests(TR_BlockFrequencyInfo *blockFrequencyI
       }
    }
 
-int32_t TR_JProfiling::perform() 
+int32_t TR_BlockJProfiling::perform() 
    {
+   /**
+    * JProfiling Configuration
+    *
+    * JProfiling consists of two components: ValueJProfiling & BlockJProfiling
+    * BlockJProfiling will run early in the compilation, such that the CFG closely resembles the original program structure,
+    * whilst the ValueJProfiling pass runs later, as values may be introduced, eliminated or simplified.
+    *
+    * For non-profiling compilations, this can be enabled with the option TR_EnableJProfiling. Other control infrastructure
+    * may limit which compilations this is actually applied to. See the env option TR_DisableFilterOnJProfiling for more details.
+    *
+    * For profiling compilations, JProfiling can replace the existing JitProfiling instrumentation when either TR_EnableJProfiling
+    * or TR_EnableJProfilingInProfilingCompilations are set. However, this introduces some complexity as a compilation may
+    * switch to profiling part way though, potentially after BlockJProfiling should have run. In such a scenario, profiling compilations
+    * will ignore JProfiling and fallback on the prior implementation.",I believe the proper fix in this case is to abort the compilation and restart as a profiling compilation. The mid-compilation switch was always non-ideal and JProfiling just highlights why this is the case. I don't view this as a blocker. I believe @ncough had some conversations with @mpirvu to the effect that we all agree an abort and restart is warranted and that will avoid the whole mess. The comment can go once that is implemented.,
81187251,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/ValueJProfiling.cpp,False,"@@ -0,0 +1,883 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+#include ""ValueJProfiling.hpp""
+
+#include ""il/Block.hpp""
+#include ""infra/Cfg.hpp""
+#include ""infra/TRCfgEdge.hpp""
+#include ""infra/Checklist.hpp""
+#include ""infra/ILWalk.hpp""
+#include ""infra/List.hpp""
+#include ""optimizer/Optimization_inlines.hpp""
+#include ""il/Node_inlines.hpp""
+#include ""infra/Checklist.hpp""             // for TR::NodeChecklist
+#include ""ras/DebugCounter.hpp""
+#include ""runtime/J9Profiler.hpp""
+#include ""control/Recompilation.hpp""              // for TR_Recompilation, etc
+#include ""control/RecompilationInfo.hpp""              // for TR_Recompilation, etc
+#include ""codegen/CodeGenerator.hpp""
+#include ""optimizer/TransformUtil.hpp""            // for TransformUtil
+
+#define COLD_BLOCK_FREQ 6",That frequency should already be defined else where as a macro so we should use that global definition rather than duplicating the value of 6 either as a static const or a macro.,
81187981,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/ValueJProfiling.cpp,False,"@@ -0,0 +1,883 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+#include ""ValueJProfiling.hpp""
+
+#include ""il/Block.hpp""
+#include ""infra/Cfg.hpp""
+#include ""infra/TRCfgEdge.hpp""
+#include ""infra/Checklist.hpp""
+#include ""infra/ILWalk.hpp""
+#include ""infra/List.hpp""
+#include ""optimizer/Optimization_inlines.hpp""
+#include ""il/Node_inlines.hpp""
+#include ""infra/Checklist.hpp""             // for TR::NodeChecklist
+#include ""ras/DebugCounter.hpp""
+#include ""runtime/J9Profiler.hpp""
+#include ""control/Recompilation.hpp""              // for TR_Recompilation, etc
+#include ""control/RecompilationInfo.hpp""              // for TR_Recompilation, etc
+#include ""codegen/CodeGenerator.hpp""
+#include ""optimizer/TransformUtil.hpp""            // for TransformUtil
+
+#define COLD_BLOCK_FREQ 6
+
+// There are existing versions of these mappings, however, they will round up
+// types smaller than Int32
+TR::ILOpCodes
+directStore(TR::DataType dt)","The key here is the note about the round up - in Java sub-int sized values will be widened to int - this needs the specific width. This could potentially go somewhere else, but I am fine with it being here since it is an anomaly. I don't think we should be reaching up to OMR directly rather than going via the TR mapping - it is a dangerous precedent and leaves this code open to being broken by changes in OMR that could be completely unreleated. Java chose to replace the OMR definitions so this code needs to handle things its own way IMO. When we go to contribute this up to OMR then we can revisit the design.",
81189465,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/ValueJProfiling.cpp,False,"@@ -0,0 +1,883 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+#include ""ValueJProfiling.hpp""
+
+#include ""il/Block.hpp""
+#include ""infra/Cfg.hpp""
+#include ""infra/TRCfgEdge.hpp""
+#include ""infra/Checklist.hpp""
+#include ""infra/ILWalk.hpp""
+#include ""infra/List.hpp""
+#include ""optimizer/Optimization_inlines.hpp""
+#include ""il/Node_inlines.hpp""
+#include ""infra/Checklist.hpp""             // for TR::NodeChecklist
+#include ""ras/DebugCounter.hpp""
+#include ""runtime/J9Profiler.hpp""
+#include ""control/Recompilation.hpp""              // for TR_Recompilation, etc
+#include ""control/RecompilationInfo.hpp""              // for TR_Recompilation, etc
+#include ""codegen/CodeGenerator.hpp""
+#include ""optimizer/TransformUtil.hpp""            // for TransformUtil
+
+#define COLD_BLOCK_FREQ 6
+
+// There are existing versions of these mappings, however, they will round up
+// types smaller than Int32
+TR::ILOpCodes
+directStore(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::astore;
+      case TR::Int64:
+         return TR::lstore;
+      case TR::Int32:
+         return TR::istore;
+      case TR::Int16:
+         return TR::sstore;
+      case TR::Int8:
+         return TR::bstore;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for store"");
+      }
+   }
+
+TR::ILOpCodes
+indirectStore(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::astorei;
+      case TR::Int64:
+         return TR::lstorei;
+      case TR::Int32:
+         return TR::istorei;
+      case TR::Int16:
+         return TR::sstorei;
+      case TR::Int8:
+         return TR::bstorei;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for indirect store"");
+      }
+   }
+
+TR::ILOpCodes
+indirectLoad(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::aloadi;
+      case TR::Int64:
+         return TR::lloadi;
+      case TR::Int32:
+         return TR::iloadi;
+      case TR::Int16:
+         return TR::sloadi;
+      case TR::Int8:
+         return TR::bloadi;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for indirect load"");
+      }
+   }
+
+TR::ILOpCodes
+loadConst(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::aconst;
+      case TR::Int64:
+         return TR::lconst;
+      case TR::Int32:
+         return TR::iconst;
+      case TR::Int16:
+         return TR::sconst;
+      case TR::Int8:
+         return TR::bconst;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for const"");
+      }
+   }
+
+int32_t
+TR_ValueJProfiling::perform() 
+   {
+   /**
+    * JProfiling Configuration
+    *
+    * ValueJProfiling will insert value profiling trees and lower any existing placeholder
+    * profiling trees. It can operate in two different modes:
+    *
+    * For non-profiling compilations, placeholder trees are not expected. Instead, the optimization
+    * pass will instrument virtual calls, instanceofs and checkcasts for profiling.
+    *
+    * For profiling compilations, placeholder trees will be identified and lowered, assuming the compilation
+    * has been configured to use JProfiling.
+    */
+   if (comp()->getProfilingMode() == JProfiling)
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been enabled for profiling compilations, run ValueJProfiling\n"");
+      }
+   else if (comp()->getOption(TR_EnableJProfiling))
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been enabled, run ValueJProfiling\n"");
+      }
+   else 
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been disabled, skip ValueJProfiling\n"");
+      return 0;
+      }
+
+   // Lower all existing calls
+   lowerCalls();
+
+   if (comp()->isProfilingCompilation())
+      {
+      TR::Recompilation *recomp = comp()->getRecompilationInfo();
+      TR_ValueProfiler *profiler = (TR_ValueProfiler*) recomp->getValueProfiler();
+      TR_ASSERT(profiler, ""Recompilation should have a ValueProfiler in a profiling compilation"");
+      profiler->setPostLowering();
+      }
+   else
+      {
+      TR::NodeChecklist checklist(comp());
+
+      // Identify and instrument profiling candidates
+      for (TR::TreeTop *cursor = comp()->getStartTree(); cursor; cursor = cursor->getNextTreeTop())
+         performOnNode(cursor->getNode(), cursor, &checklist);
+      }
+
+   return 1;
+   }
+
+void
+TR_ValueJProfiling::performOnNode(TR::Node *node, TR::TreeTop *tt, TR::NodeChecklist *checklist)
+   {
+   if (checklist->contains(node))
+      return;
+   checklist->add(node);
+
+   if (node->getOpCode().isCall() && node->getOpCode().isIndirect())
+      {
+      addVFTProfiling(node->getFirstChild(), tt, false);
+      }
+   else if (node->getOpCodeValue() == TR::instanceof || node->getOpCodeValue() == TR::checkcast)
+      {
+      addVFTProfiling(node->getFirstChild(), tt, true);
+      }
+
+   for (int i = 0; i < node->getNumChildren(); ++i)
+      performOnNode(node->getChild(i), tt, checklist);
+   }
+
+void
+TR_ValueJProfiling::addVFTProfiling(TR::Node *address, TR::TreeTop *tt, bool addNullCheck)
+   {
+   TR::Node *vftNode = TR::Node::createWithSymRef(address, TR::aloadi, 1, address,
+      getSymRefTab()->findOrCreateVftSymbolRef());
+
+   TR::Node *check = NULL;
+   TR::Node *fallback = NULL;
+   if (addNullCheck)
+      {
+      check = TR::Node::createif(TR::ifacmpeq, address, TR::Node::aconst(address, 0));
+      fallback = TR::Node::aconst(address, 0);
+      }
+
+   TR_ValueProfileInfo *valueProfileInfo = TR_PersistentProfileInfo::get(comp())->findOrCreateValueProfileInfo(comp());
+   TR_AbstractHashTableProfilerInfo *info = (TR_AbstractHashTableProfilerInfo*) valueProfileInfo->getOrCreateProfilerInfo(address->getByteCodeInfo(), comp(), AddressInfo, HashTableProfiler);
+
+   addProfilingTrees(comp(), tt, vftNode, info, check, fallback, true, trace());
+   }
+
+/**
+ * Identify helper calls to TR_jProfileValue and TR_jProfileLongValue, lowering them
+ * into the fast, slow and helper paths.
+ */
+void
+TR_ValueJProfiling::lowerCalls()
+   {
+   TR::TreeTop *cursor = comp()->getStartTree();
+   while (cursor)
+      {
+      TR::Node * node = cursor->getNode();
+
+      if (node->isProfilingCode() &&
+          node->getOpCodeValue() == TR::treetop &&
+          node->getFirstChild()->getOpCode().isCall() &&
+          (node->getFirstChild()->getSymbolReference()->getReferenceNumber() == TR_jProfile32BitValue ||
+           node->getFirstChild()->getSymbolReference()->getReferenceNumber() == TR_jProfile64BitValue) &&
+          node->getFirstChild()->getNumChildren() == 3)
+         {
+         TR::TreeTop *nextTree = cursor->getNextTreeTop();
+         TR::Node *child = node->getFirstChild();
+
+         dumpOptDetails(comp(), ""%s Replacing profiling placeholder n%dn with value profiling trees\n"",
+            optDetailString(), child->getGlobalIndex());
+
+         // Extract the arguments and add the profiling trees
+         TR::Node *value = child->getFirstChild();
+         TR_AbstractHashTableProfilerInfo *table = (TR_AbstractHashTableProfilerInfo*) child->getSecondChild()->getAddress();
+         addProfilingTrees(comp(), cursor, value, table, NULL, NULL, true, trace());
+
+         // Remove the original trees and continue from the tree after the profiling
+         TR::TransformUtil::removeTree(comp(), cursor);
+         cursor = nextTree;
+         }
+      else
+         cursor = cursor->getNextTreeTop();
+      }
+   }
+
+/*
+ * Insert the trees and control flow to profile a node after an insertion point.
+ * The original block will be split after the insertion point.
+ *
+ * An optional mapping, with a test and fallback value is supported. An example use of
+ * this is a vft lookup using an address that could be null. A null check is therefore
+ * necessary, using a fallback value of 0.
+ *
+ * ------------------
+ * | ...            |
+ * | insertionPoint |
+ * | ...            |
+ * ------------------
+ * 
+ * Becomes:
+ *
+ * | ...               |                                        
+ * | insertionPoint    |                                        
+ * | uncommoning       |
+ * | optionalTest      |---------------
+ * ---------------------              |
+ *          |                         |
+ *          v                         v
+ * ---------------------    ---------------------                                       
+ * | originalValue     |    | fallbackValue     |                                      
+ * ---------------------    ---------------------                                      
+ * | store temp 1      |    | store temp 1      |                                      
+ * |  value            |    |  fallback         |                                      
+ * ---------------------    ---------------------
+ *          |                        |
+ *          |-------------------------
+ *          v
+ * ---------------------                                        
+ * | quickTest         |                                        
+ * ---------------------                                        
+ * | store temp 2      |                                        
+ * |  hash             |                                        
+ * |   load temp 1     |                                        
+ * | ifne              |----------------------
+ * |  =>load temp 1    |                     |
+ * |  indirect load    |                     v
+ * |   add             |           ---------------------
+ * |    keysArray      |           | slowTest          |
+ * |    mult           |           ---------------------
+ * |     =>hash        |           | store temp 3      |
+ * |     width         |           |   indirect load   |
+ * ---------------------           |     otherIndex    |
+ *          |                      | ifeq              |-------------------
+ *          v                      |   load temp 3     |                  |
+ * ---------------------           |   const 0         |                  v
+ * | quickInc          |           ---------------------        ------------------
+ * ---------------------                    |                   | helper         |
+ * | incMemory         |                    v                   ------------------
+ * |   add             |           ---------------------        | call helper    |
+ * |     countsArray   |           | slowInc           |        |   load temp 1  |
+ * |     mult          |           ---------------------        |   tableAddress |
+ * |       load temp 2 |           | incMemory         |        ------------------
+ * |       countWidth  |           |   add             |                 |
+ * ---------------------           |     countsArray   |                 |
+ *          |                      |     mult          |                 |
+ *          |                      |       load temp 3 |                 |
+ *          |                      |       countWidth  |                 |
+ *          |                      ---------------------                 |
+ *          |                                |                           |
+ *          |-------------------------------------------------------------
+ *          v
+ * ---------------------
+ * | uncommoning       |
+ * | ...               |
+ *
+ * \param insertionPoint Treetop to insert profiling code after.
+ * \param value Value to profile.
+ * \param table Persistent TR_HashMapInfo which will be filled and incremented during profiling.
+ * \param optionalTest Option test node capable of preventing evaluation of value and using a fallbackValue instead.
+ * \param fallbackValue Fallback value to use with the optional test.
+ * \param extendBlocks Generates the blocks as extended, defaults true.
+ * \param trace Enable tracing.
+ */
+bool
+TR_ValueJProfiling::addProfilingTrees(
+    TR::Compilation *comp,
+    TR::TreeTop *insertionPoint,
+    TR::Node *value,
+    TR_AbstractHashTableProfilerInfo *table,
+    TR::Node *optionalTest,
+    TR::Node *fallbackValue,
+    bool extendBlocks,
+    bool trace)
+   {
+   // Common types used in calculation
+   TR::DataType counterType = TR::Int32;
+   TR::DataType lockType    = TR::Int16;
+   TR::DataType systemType  = TR::Compiler->target.is64Bit() ? TR::Int64 : TR::Int32;
+
+   // Type to use in calculations and table access
+   TR::DataType roundedType    = value->getType();
+   if (roundedType == TR::Int8 || roundedType == TR::Int16)
+      roundedType = TR::Int32;
+
+   if (trace)
+      {
+      traceMsg(comp, ""Inserting value profiling trees:\n  Value n%dn At n%dn\n  Table: %p\n"",
+         value->getGlobalIndex(),
+         insertionPoint->getNode()->getGlobalIndex(),
+         table);
+      table->trace(comp);
+      traceMsg(comp, ""  Test: %p Fallback: %p\n"", optionalTest, fallbackValue);
+      }
+
+   TR::Block    *originalBlock = insertionPoint->getEnclosingBlock();
+   TR::Block    *extendedBlock = originalBlock;
+   while (extendedBlock->isExtensionOfPreviousBlock())
+      extendedBlock = extendedBlock->getPrevBlock();
+
+   if (trace)
+      {
+      traceMsg(comp, ""  Modifying block_%d"", originalBlock->getNumber());
+      if (extendedBlock && extendedBlock != originalBlock)
+         traceMsg(comp, "" extending block_%d"", extendedBlock->getNumber());
+      traceMsg(comp, "" with profiling\n"");
+      }
+
+   // Cache the last treetop in the CFG
+   TR::CFG *cfg = comp->getFlowGraph();
+   cfg->setStructure(0);
+   TR::Block *cursor = originalBlock, *prev = originalBlock;
+   while (cursor && cursor != cfg->getEnd() && cursor != cfg->getStart() && cursor->getNumber())
+      {
+      prev = cursor;
+      cursor = cursor->getNextBlock();
+      }
+   TR::TreeTop *lastTreeTop = prev->getExit();
+
+   // Example node to use when constructing others 
+   TR::Node *example = value;
+
+   /********************* original Block *********************/
+   if (trace)
+      traceMsg(comp, "" Profiled value n%dn into temp\n"", value->getGlobalIndex());
+
+   // Store the value and replace references to it, if no fallback value can overwrite its value
+   TR::SymbolReference *storedValueSymRef = NULL;
+   TR::TreeTop *storeValue = TR::TreeTop::create(comp, insertionPoint, storeNode(comp, value, storedValueSymRef));
+   if (!optionalTest)
+      replaceNode(comp, extendedBlock->getEntry(), storeValue->getNextTreeTop(),
+         value, TR::Node::createLoad(example, storeValue->getNode()->getSymbolReference()));
+
+   // Split after the store
+   TR::Block *quickTest = originalBlock->split(storeValue->getNextTreeTop(), cfg, true, true);
+
+   /********************* fallback Block *********************/
+
+   // Insert the optional test and split after it
+   if (optionalTest)
+      {
+      TR_ASSERT_FATAL(fallbackValue, ""If introducing an optional test, a fallback value must be specified"");
+      TR::TreeTop *testTree = TR::TreeTop::create(comp, insertionPoint, optionalTest);
+
+      TR::Block *mapping = originalBlock->split(testTree->getNextTreeTop(), cfg, true, true);
+      if (extendBlocks)
+         mapping->setIsExtensionOfPreviousBlock();
+      
+      // Create the fallback block and link it to the optional test
+      TR::Block *fallback = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+      fallback->setIsCold();
+      lastTreeTop->join(fallback->getEntry());
+      lastTreeTop = fallback->getExit();
+      cfg->addNode(fallback);
+      cfg->addEdge(originalBlock, fallback);
+      cfg->addEdge(fallback, quickTest);
+      testTree->getNode()->setBranchDestination(fallback->getEntry());     
+
+      if (trace)
+         traceMsg(comp, ""  Fallback block_%d store to symRef #%d of node %p in \n"", fallback->getNumber(),
+            storedValueSymRef->getReferenceNumber(), fallback);
+
+      // Store and return to the mainline
+      TR::TreeTop::create(comp, fallback->getEntry(), TR::Node::create(example, TR::Goto, 0, quickTest->getEntry()));
+      TR::TreeTop::create(comp, fallback->getEntry(), storeNode(comp, fallbackValue, storedValueSymRef));
+      }
+   else if (extendBlocks)
+      quickTest->setIsExtensionOfPreviousBlock();
+
+   /********************* quickTest Block *********************/
+   // If blocks aren't being extended, its necessary to create a load
+   TR::Node *quickTestValue = value;
+   if (!extendBlocks || optionalTest)
+      quickTestValue = TR::Node::createLoad(example, storedValueSymRef);
+   quickTestValue = convertType(quickTestValue, roundedType);
+
+   if (trace)
+      traceMsg(comp, ""  Hash calculation in block_%d\n"", quickTest->getNumber());
+
+   // Base address for the table accesses, simplifies codegen
+   TR::Node *address = TR::Node::aconst(example, table->getBaseAddress());
+   TR::Node *index = convertType(computeHash(comp, table, quickTestValue, address), systemType);
+   
+   if (trace)
+      traceMsg(comp, ""  Key test based on index n%dn\n"", quickTest->getNumber(), index->getGlobalIndex());
+
+   // Generate the check to ensure the value is already in the chosen slot
+   TR::Node *checkKey = TR::Node::createif(comp->il.opCodeForIfCompareNotEquals(roundedType), quickTestValue,
+      loadValue(comp, roundedType, address, index, systemConst(example, table->getKeysOffset())));
+   TR::TreeTop *checkKeyTree = TR::TreeTop::create(comp, quickTest->getEntry(), checkKey);
+
+   /********************* quickInc Block *********************/
+   // If we aren't extending the blocks, anchor stores for the table address and the value
+   TR::Node *quickIncAddress = address;
+   TR::Node *quickIncIndex = index;
+   if (!extendBlocks)
+      {
+      TR::SymbolReference *storedIndexSymRef = NULL;
+      TR::SymbolReference *storedAddressSymRef = NULL;
+      TR::TreeTop::create(comp, quickTest->getEntry(), storeNode(comp, index, storedIndexSymRef));
+      TR::TreeTop::create(comp, quickTest->getEntry(), storeNode(comp, address, storedAddressSymRef));
+      storedAddressSymRef->getSymbol()->setNotCollected();
+
+      quickIncIndex = TR::Node::createLoad(example, storedIndexSymRef);
+      quickIncAddress = TR::Node::createLoad(example, storedAddressSymRef);
+      }
+
+   // Split the block, creating a new block to hold the successful quick increment
+   TR::Block *quickInc = quickTest->split(checkKeyTree->getNextTreeTop(), cfg, true, true);
+   if (extendBlocks)
+      quickInc->setIsExtensionOfPreviousBlock();
+
+   if (trace)
+      traceMsg(comp, ""  Quick increment in block_%d\n"", quickInc->getNumber());
+
+   TR::Node *counterOffset = systemConst(example, table->getFreqOffset());
+   TR::TreeTop *incTree = TR::TreeTop::create(comp, quickInc->getEntry(),
+      incrementMemory(comp, counterType, effectiveAddress(counterType, quickIncAddress, quickIncIndex, counterOffset)));
+
+   // Split the block again, after the increment, so cold paths can merge back
+   TR::Block *mainlineReturn = quickInc->split(incTree->getNextTreeTop(), cfg, true, true);
+
+   /********************* slowTest Block *********************/
+   TR::Block *slowTest = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+   slowTest->setIsCold();
+   lastTreeTop->join(slowTest->getEntry());
+   lastTreeTop = slowTest->getExit();
+   cfg->addNode(slowTest);
+   cfg->addEdge(quickTest, slowTest);
+   cfg->addEdge(slowTest, mainlineReturn);
+   checkKey->setBranchDestination(slowTest->getEntry());
+
+   if (trace)
+      traceMsg(comp, ""  Lock test in block_%d\n"", slowTest->getNumber());
+
+   // Load the lock and test if its set
+   TR::Node *lockAddress = TR::Node::aconst(example, table->getBaseAddress() + table->getLockOffset());
+   TR::Node *lock = loadValue(comp, lockType, lockAddress);
+   TR::Node *checkTableLock = TR::Node::createif(TR::ifscmplt, lock, TR::Node::sconst(example, 0));
+   TR::TreeTop::create(comp, slowTest->getEntry(), checkTableLock);
+
+   /********************* slowInc Block *********************/
+   TR::Node *slowIncIndex = convertType(lock, systemType);
+   if (!extendBlocks)
+      {
+      TR::SymbolReference *storedLockSymRef = NULL;
+      TR::TreeTop::create(comp, slowTest->getEntry(), storeNode(comp, convertType(lock, systemType), storedLockSymRef));
+      slowIncIndex = TR::Node::createLoad(example, storedLockSymRef);
+      }
+
+   // Split the block, creating a new block to hold the other increment
+   TR::Block *slowInc = slowTest->split(slowTest->getExit(), cfg, true, true);
+   lastTreeTop = slowInc->getExit();
+   if (extendBlocks)
+      slowInc->setIsExtensionOfPreviousBlock();
+
+   if (trace)
+      traceMsg(comp, ""  Slow increment in block_%d\n"", slowInc->getNumber());
+
+   // Add the other increment and return to mainline
+   TR::TreeTop::create(comp, slowInc->getEntry(), TR::Node::create(example, TR::Goto, 0, mainlineReturn->getEntry()));
+   TR::Node *counterAddress = TR::Node::aconst(example, table->getBaseAddress() + table->getFreqOffset());
+   TR::TreeTop::create(comp, slowInc->getEntry(), incrementMemory(comp, counterType,
+      effectiveAddress(counterType, counterAddress, slowIncIndex)));
+
+   /********************* helper Block *********************/
+   // Build the helper call path
+   TR::Block *helper = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+   helper->setIsCold();
+   lastTreeTop->join(helper->getEntry());
+   lastTreeTop = helper->getExit();
+   cfg->addNode(helper);
+   cfg->addEdge(slowTest, helper);
+   cfg->addEdge(helper, mainlineReturn);
+   checkTableLock->setBranchDestination(helper->getEntry());
+
+   if (trace)
+      traceMsg(comp, ""  Helper call in block_%d\n"", helper->getNumber());
+
+   // Add the call to the helper and return to the mainline
+   TR::TreeTop::create(comp, helper->getEntry(), TR::Node::create(example, TR::Goto, 0, mainlineReturn->getEntry()));
+   TR::TreeTop *helperCallTreeTop = TR::TreeTop::create(comp, helper->getEntry(), createHelperCall(comp,
+      convertType(TR::Node::createLoad(example, storedValueSymRef), roundedType),
+      TR::Node::aconst(example, table->getBaseAddress())));
+
+   // Set profiling code flags
+   TR::NodeChecklist checklist(comp);
+   checklist.add(value);
+   TR::TreeTop *tt = quickTest->getEntry(), *end = mainlineReturn->getEntry(); 
+   while (tt && tt != end)
+      {
+      TR::Node *node = tt->getNode();
+      if (node->getOpCodeValue() != TR::BBStart && node->getOpCodeValue() != TR::BBEnd)
+         setProfilingCode(node, checklist);
+      tt = tt->getNextTreeTop();
+      }
+   tt = slowTest->getEntry();
+   end = NULL;
+   while (tt && tt != end)
+      {
+      TR::Node *node = tt->getNode();
+      if (node->getOpCodeValue() != TR::BBStart && node->getOpCodeValue() != TR::BBEnd)
+         setProfilingCode(node, checklist);
+      tt = tt->getNextTreeTop();
+      }
+
+   return true;
+   }
+
+/*
+ * Recursive call to replace origNode with newNode underneath a target node.
+ *
+ * \param check Node to search for reference to origNode.
+ * \param origNode Node to replace.
+ * \param newNode Node to use in its place.
+ * \param checklist Checklist of nodes that have already been searched.
+ */
+void
+TR_ValueJProfiling::replaceNode(TR::Node* check, TR::Node* origNode, TR::Node *newNode, TR::NodeChecklist &checklist)
+   {
+   if (checklist.contains(check))
+      return;
+   checklist.add(check);
+
+   for (uint32_t i = 0; i < check->getNumChildren(); ++i)
+      {
+      if (origNode && check->getChild(i) == origNode)
+         {
+         check->setAndIncChild(i, newNode);
+         origNode->decReferenceCount();
+         }
+      else
+         replaceNode(check->getChild(i), origNode, newNode, checklist);
+      }
+   }
+
+/*
+ * Replace all references to origNode under and after replaceStart with newNode.
+ *
+ * \param blockStart Start of the extended block containing replaceStart.
+ * \param origNode Node to replace.
+ * \param newNode Node to use in its place.
+ */
+void
+TR_ValueJProfiling::replaceNode(TR::Compilation *comp, TR::TreeTop *blockStart, TR::TreeTop *replaceStart,
+    TR::Node *origNode, TR::Node *newNode)
+   {
+   TR::NodeChecklist checklist(comp);
+   TR::TreeTop *tt = blockStart; 
+
+   // Collect all nodes seen before start of replace, these shouldn't be replaced
+   while (tt != replaceStart)
+      {
+      replaceNode(tt->getNode(), NULL, NULL, checklist);
+      tt = tt->getNextTreeTop();
+      }
+
+   // Begin replacing until the end of the extended block
+   while (tt)
+      {
+      if (tt->getNode()->getOpCodeValue() == TR::BBStart && !tt->getNode()->getBlock()->isExtensionOfPreviousBlock())
+         break;
+      replaceNode(tt->getNode(), origNode, newNode, checklist);
+      tt = tt->getNextTreeTop();
+      }
+   }
+
+/*
+ * Mark a node and its children as profiling code.
+ *
+ * \param node Node to process, marking it and its children.
+ * \param checklist Checklist of nodes already marked.
+ */
+void
+TR_ValueJProfiling::setProfilingCode(TR::Node *node, TR::NodeChecklist &checklist)
+   {
+   if (checklist.contains(node))
+      return;
+   checklist.add(node);
+
+   node->setIsProfilingCode();
+   for (uint32_t i = 0; i < node->getNumChildren(); ++i)
+      setProfilingCode(node->getChild(i), checklist);
+   }
+
+/*
+ * Generate the tree to store a value into a temporary symref. If no symref is specified, one will be generated.
+ *
+ * \param value Value to store.
+ * \param symRef Optional symref to store value into. Will be update to used symref if none specified.
+ */
+TR::Node *
+TR_ValueJProfiling::storeNode(TR::Compilation *comp, TR::Node *value, TR::SymbolReference* &symRef)
+   {
+   if (symRef == NULL)
+      symRef = comp->getSymRefTab()->createTemporary(comp->getMethodSymbol(), value->getDataType());
+
+   return TR::Node::createWithSymRef(value, directStore(value->getDataType()), 1, value, symRef);
+   }
+
+/*
+ * Given an address in X86's LEA form, generate a node structure to calculate a memory address for a desired
+ * data type. Address would be: base + width(dataType) * index + offset
+ *
+ * \param dataType Date type of value to address. Its width is used for calculations if index is specified.
+ * \param base Base address to load from.
+ * \param index Optional index.
+ * \param offset Optional offset from the base.
+ */
+TR::Node *
+TR_ValueJProfiling::effectiveAddress(TR::DataType dataType, TR::Node *base, TR::Node *index, TR::Node *offset)","I will let @ncough comment, but I don't think this style is a problem on other platforms - it exposes maximum richness and the optimizer will have an opportunity to rearrange if necessary as will the code generators.",
81204707,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/BlockJProfiling.cpp,False,"@@ -971,8 +958,42 @@ void TR_JProfiling::addRecompilationTests(TR_BlockFrequencyInfo *blockFrequencyI
       }
    }
 
-int32_t TR_JProfiling::perform() 
+int32_t TR_BlockJProfiling::perform() 
    {
+   /**
+    * JProfiling Configuration
+    *
+    * JProfiling consists of two components: ValueJProfiling & BlockJProfiling
+    * BlockJProfiling will run early in the compilation, such that the CFG closely resembles the original program structure,
+    * whilst the ValueJProfiling pass runs later, as values may be introduced, eliminated or simplified.
+    *
+    * For non-profiling compilations, this can be enabled with the option TR_EnableJProfiling. Other control infrastructure
+    * may limit which compilations this is actually applied to. See the env option TR_DisableFilterOnJProfiling for more details.
+    *
+    * For profiling compilations, JProfiling can replace the existing JitProfiling instrumentation when either TR_EnableJProfiling
+    * or TR_EnableJProfilingInProfilingCompilations are set. However, this introduces some complexity as a compilation may
+    * switch to profiling part way though, potentially after BlockJProfiling should have run. In such a scenario, profiling compilations
+    * will ignore JProfiling and fallback on the prior implementation.","Ideally, we would be able to put the profiling code into AOT code and relocate the counters so we don't even need that, but I agree one step at a time. Excessive aborts would be problematic, but given the low use of profiling compilations atm we should be fine. We should make sure that the vlog calls out such aborts very clearly so these events are easy to track and diagnose if a problem does occur.",
81338585,3638a278b104b2a82fadb56b6d09e4e5988bbafa,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java,False,"@@ -260,6 +267,8 @@ MethodHandle cloneWithNewType(MethodType newType) {
 enforceArityLimit(kind, this.type);
 /* Must be called even laster as it uses the method type */
 this.thunks = computeThunks(thunkArg);
+/* Touch thunks.invokeExactThunk so that its constant pool entry is resolved by the time it is used by the JIT */
+long i = thunks.invokeExactThunk;",One additional thought - should we construct an instance of this handle in the static init for the class? we could touch the field there then if we didn't want it in the constructor. Thoughts @DanHeidinga ?,
81591075,6f3c42f668223c91f02b10f1348e733f594db82e,runtime/vm/guardedstorage.c,False,"@@ -60,13 +69,22 @@ j9gs_initializeThread(J9VMThread *vmThread)
 gsControlBlock->designationRegister = 0;
 gsControlBlock->sectionMask = 0;
 gsControlBlock->paramListAddr = (uint64_t) &vmThread->gsParameters;
-vmThread->gsParameters.handlerAddr = (uint64_t)(uintptr_t)J9_BUILDER_SYMBOL(handleGuardedStorageEvent);
-
+if (1 == supportsGuardedStorageFacility) {
+vmThread->gsParameters.handlerAddr = (uint64_t)(uintptr_t)J9_BUILDER_SYMBOL(handleGuardedStorageEvent);
+} else {","I'm not an expert on this, but the feature would seem to run functionally correctly with software checks, it is just the performance overhead that would prevent us from using it in the 'real-world'. If the checks could be made cheaper then the software version could work. Perhaps rather than calling the option emulateGuardedStorage something like softGuardedStorage or something like that since it is doing guarded storage from what I understand, just not with the hardware instruction and trap that makes it performant?",
81672096,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/codegen/J9TreeEvaluator.cpp,False,"@@ -48,7 +48,7 @@ void traceInstanceOfOrCheckCastProfilingInfo(TR::CodeGenerator *cg, TR::Node *no
       return;
       }
 
-   TR_AddressInfo * valueInfo = (TR_AddressInfo *)valueProfileInfo->getValueInfo(bcInfo, comp, TR_ValueProfileInfoManager::justInterpreterProfileInfo);
+   TR_AddressInfo * valueInfo = (TR_AddressInfo *)valueProfileInfo->getValueInfo(bcInfo, comp, AddressInfo, TR_ValueProfileInfoManager::justInterpreterProfileInfo);",A static cast would be better here no?,
81672592,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/compile/J9Compilation.hpp,False,"@@ -164,8 +164,7 @@ class OMR_EXTENSIBLE Compilation : public OMR::CompilationConnector
 
    bool pendingPushLivenessDuringIlgen();
 
-   TR::list<TR_MethodValueProfileInfo*> &getMethodVPInfos() { return _methodVPInfoList; }
-   TR::list<TR_MethodValueProfileInfo*> &getMethodHWVPInfos() { return _methodHWVPInfoList; }
+   TR::list<TR_ExternalValueProfileInfo*> &getExternalVPInfos() { return _externalVPInfoList; }",A discussion comment in reply to this comment on why HWVPInfos can go - I assume it came from hardware profiling work and I'd just like to understand how we can clean this up without breaking anything.,
81674801,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/runtime/IProfiler.cpp,False,"@@ -1548,7 +1548,7 @@ TR_IProfiler::profilingSample (TR_OpaqueMethodBlock *method, uint32_t byteCodeIn
       if (!preferHashtableData)
          {
          // If I don't have data in IProfiler HT, choose the persistent source
-         if(!currentEntry || (currentEntry->getData() == NULL))
+         if(!currentEntry || (currentEntry->getData() == (uintptr_t) NULL))",no space before NULL,
81674842,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/runtime/IProfiler.cpp,False,"@@ -1561,7 +1561,7 @@ TR_IProfiler::profilingSample (TR_OpaqueMethodBlock *method, uint32_t byteCodeIn
                }
             }
          // If I don't have relevant data in the SCC, choose the data from IProfiler HT
-         else if(!persistentEntry || (persistentEntry->getData() == NULL))
+         else if(!persistentEntry || (persistentEntry->getData() == (uintptr_t) NULL))",no space before NULL,
81675668,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/runtime/J9Profiler.cpp,False,"@@ -894,29 +881,50 @@ TR_ValueProfileInfoManager::TR_ValueProfileInfoManager(TR::Compilation *comp)
    }
 
 TR_AbstractInfo *
-TR_ValueProfileInfoManager::getValueInfo(TR::Node *node, TR::Compilation *comp, uint32_t profileInfoKind, TR_ValueInfoType type)
+TR_ValueProfileInfoManager::getProfiledValueInfo(TR::Node *node, TR::Compilation *comp, TR_ValueInfoKind kind,
+      uint32_t source)
    {
-   return getValueInfo(node->getByteCodeInfo(), comp, profileInfoKind, type);
+   TR_ValueProfileInfoManager *manager = TR_ValueProfileInfoManager::get(comp);
+   return manager ? manager->getValueInfo(node, comp, kind, source) : NULL;
    }
 
 TR_AbstractInfo *
-TR_ValueProfileInfoManager::getValueInfo(TR_ByteCodeInfo &bcInfo, TR::Compilation *comp, uint32_t profileInfoKind, TR_ValueInfoType type)
+TR_ValueProfileInfoManager::getProfiledValueInfo(TR_ByteCodeInfo &bci, TR::Compilation *comp, TR_ValueInfoKind kind,
+      uint32_t source)
+   {
+   TR_ValueProfileInfoManager *manager = TR_ValueProfileInfoManager::get(comp);
+   return manager ? manager->getValueInfo(bci, comp, kind, source) : NULL;
+   }
+
+TR_AbstractInfo *
+TR_ValueProfileInfoManager::getValueInfo(TR::Node *node, TR::Compilation *comp, TR_ValueInfoKind kind,
+      uint32_t source)
+   {
+   return getValueInfo(node->getByteCodeInfo(), comp, kind, source);
+   }
+
+TR_AbstractInfo *
+TR_ValueProfileInfoManager::getValueInfo(TR_ByteCodeInfo &bcInfo, TR::Compilation *comp, TR_ValueInfoKind kind,
+      uint32_t source)
    {
    TR_AbstractInfo *info = NULL;
+   bool internal = _jitValueProfileInfo && (source == allProfileInfo || source == justJITProfileInfo);
+   bool external = source == allProfileInfo || source == justInterpreterProfileInfo;
 
-   if (_jitValueProfileInfo && (profileInfoKind != justInterpreterProfileInfo))
-      info = _jitValueProfileInfo->getValueInfo(bcInfo, comp, type);
+   if ((!info || info->getTotalFrequency() == 0) && internal)",in general it would be more neat to do internal && (....). That would have the benefit of testing the already computed bool first before potentially doing a deref which could be a savings if this runs a lot.,
81676698,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/runtime/J9ValueProfiler.hpp,False,"@@ -28,266 +28,842 @@
 #include ""env/TRMemory.hpp""  // for TR_Memory, etc
 #include ""env/jittypes.h""    // for TR_ByteCodeInfo, etc
 #include ""il/DataTypes.hpp""  // for DataTypes
-#include ""infra/Monitor.hpp"" // for TR::Monitor
+#include ""infra/CriticalSection.hpp"" // for OMR::CriticalSection
+#include ""compile/Compilation.hpp""
+#include ""infra/vector.hpp""         // for TR::vector
 
 extern TR::Monitor *vpMonitor;
 
-#define MAX_UNLOCKED_PROFILING_VALUES 5
+#ifdef TR_HOST_64BIT
+#define HIGH_ORDER_BIT (0x8000000000000000)
+#else
+#define HIGH_ORDER_BIT (0x80000000)
+#endif
+
+#define ARRAY_MAX_NUM_VALUES (5)
+#define LINKEDLIST_MAX_NUM_VALUES (20)
 
 class TR_ResolvedMethod;
-namespace TR { class Compilation; }
 template <class T> class List;
 template <class T> class ListElement;
 
+/**
+ * Profiling info consists of two class hierarchies: TR_AbstractInfo & TR_AbstractProfilerInfo
+ *
+ * TR_AbstractProfilerInfo is the persistent data structures use by the various profiling
+ * implementations. They can manage a variety of basic types, such as uint32_t and uint64_t.
+ * The class hierarchy, with T being uint32_t, uint64_t or TR_ByteInfo:
+ *
+ * TR_AbstractProfilerInfo
+ *    TR_LinkedListProfilerInfo<T>
+ *    TR_ArrayProfilerInfo<T>
+ *
+ * TR_AbstractInfo provides a common API for more complex data types, such as addresses and
+ * BigDecimals, consistent across the various sources of profiling information.
+ * The class hierarchy, with T being uint32_t, uint64_t or TR_ByteInfo:
+ *
+ * TR_AbstractInfo
+ *    TR_GenericValueInfo<T>
+ *       TR_AddressInfo
+ *       TR_BigDecimalInfo
+ */
+
+/**
+ * Kinds of value profiling information
+ */
+enum TR_ValueInfoKind
+   {
+   ValueInfo            = 0x00,","If these are not being used as individual bits why do we need to assign numbers in a flags style? Can't we use the default numbering or standard decimal numbering so we don't think a bit or will do something useful which is the usual intent between a hex value assignment eg 0x1, 0x2, 0x4, 0x8 etc.",
81676734,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/runtime/J9ValueProfiler.hpp,False,"@@ -28,266 +28,842 @@
 #include ""env/TRMemory.hpp""  // for TR_Memory, etc
 #include ""env/jittypes.h""    // for TR_ByteCodeInfo, etc
 #include ""il/DataTypes.hpp""  // for DataTypes
-#include ""infra/Monitor.hpp"" // for TR::Monitor
+#include ""infra/CriticalSection.hpp"" // for OMR::CriticalSection
+#include ""compile/Compilation.hpp""
+#include ""infra/vector.hpp""         // for TR::vector
 
 extern TR::Monitor *vpMonitor;
 
-#define MAX_UNLOCKED_PROFILING_VALUES 5
+#ifdef TR_HOST_64BIT
+#define HIGH_ORDER_BIT (0x8000000000000000)
+#else
+#define HIGH_ORDER_BIT (0x80000000)
+#endif
+
+#define ARRAY_MAX_NUM_VALUES (5)
+#define LINKEDLIST_MAX_NUM_VALUES (20)
 
 class TR_ResolvedMethod;
-namespace TR { class Compilation; }
 template <class T> class List;
 template <class T> class ListElement;
 
+/**
+ * Profiling info consists of two class hierarchies: TR_AbstractInfo & TR_AbstractProfilerInfo
+ *
+ * TR_AbstractProfilerInfo is the persistent data structures use by the various profiling
+ * implementations. They can manage a variety of basic types, such as uint32_t and uint64_t.
+ * The class hierarchy, with T being uint32_t, uint64_t or TR_ByteInfo:
+ *
+ * TR_AbstractProfilerInfo
+ *    TR_LinkedListProfilerInfo<T>
+ *    TR_ArrayProfilerInfo<T>
+ *
+ * TR_AbstractInfo provides a common API for more complex data types, such as addresses and
+ * BigDecimals, consistent across the various sources of profiling information.
+ * The class hierarchy, with T being uint32_t, uint64_t or TR_ByteInfo:
+ *
+ * TR_AbstractInfo
+ *    TR_GenericValueInfo<T>
+ *       TR_AddressInfo
+ *       TR_BigDecimalInfo
+ */
+
+/**
+ * Kinds of value profiling information
+ */
+enum TR_ValueInfoKind
+   {
+   ValueInfo            = 0x00,
+   LongValueInfo        = 0x01,
+   AddressInfo          = 0x02,
+   BigDecimalInfo       = 0x03,
+   StringInfo           = 0x04,
+   LastValueInfo        = 0x05,
+   };
 
-class TR_ExtraAbstractInfo
+/**
+ * Sources of JIT value profiling information
+ * This excludes external sources, such as HW and the interpreter
+ */
+enum TR_ValueInfoSource
    {
-   public:
-   TR_ALLOC(TR_Memory::PersistentProfileInfo)
+   LinkedListProfiler = 0x00,",Same as last enum,
81677858,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/ValueJProfiling.cpp,False,"@@ -0,0 +1,883 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+#include ""ValueJProfiling.hpp""
+
+#include ""il/Block.hpp""
+#include ""infra/Cfg.hpp""
+#include ""infra/TRCfgEdge.hpp""
+#include ""infra/Checklist.hpp""
+#include ""infra/ILWalk.hpp""
+#include ""infra/List.hpp""
+#include ""optimizer/Optimization_inlines.hpp""
+#include ""il/Node_inlines.hpp""
+#include ""infra/Checklist.hpp""             // for TR::NodeChecklist
+#include ""ras/DebugCounter.hpp""
+#include ""runtime/J9Profiler.hpp""
+#include ""control/Recompilation.hpp""              // for TR_Recompilation, etc
+#include ""control/RecompilationInfo.hpp""              // for TR_Recompilation, etc
+#include ""codegen/CodeGenerator.hpp""
+#include ""optimizer/TransformUtil.hpp""            // for TransformUtil
+
+#define COLD_BLOCK_FREQ 6
+
+// There are existing versions of these mappings, however, they will round up
+// types smaller than Int32
+TR::ILOpCodes
+directStore(TR::DataType dt)",Doxygen on these methods and the reason for their split from OMR is necessary.,
81678463,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/ValueJProfiling.cpp,False,"@@ -0,0 +1,883 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+#include ""ValueJProfiling.hpp""
+
+#include ""il/Block.hpp""
+#include ""infra/Cfg.hpp""
+#include ""infra/TRCfgEdge.hpp""
+#include ""infra/Checklist.hpp""
+#include ""infra/ILWalk.hpp""
+#include ""infra/List.hpp""
+#include ""optimizer/Optimization_inlines.hpp""
+#include ""il/Node_inlines.hpp""
+#include ""infra/Checklist.hpp""             // for TR::NodeChecklist
+#include ""ras/DebugCounter.hpp""
+#include ""runtime/J9Profiler.hpp""
+#include ""control/Recompilation.hpp""              // for TR_Recompilation, etc
+#include ""control/RecompilationInfo.hpp""              // for TR_Recompilation, etc
+#include ""codegen/CodeGenerator.hpp""
+#include ""optimizer/TransformUtil.hpp""            // for TransformUtil
+
+#define COLD_BLOCK_FREQ 6
+
+// There are existing versions of these mappings, however, they will round up
+// types smaller than Int32
+TR::ILOpCodes
+directStore(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::astore;
+      case TR::Int64:
+         return TR::lstore;
+      case TR::Int32:
+         return TR::istore;
+      case TR::Int16:
+         return TR::sstore;
+      case TR::Int8:
+         return TR::bstore;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for store"");
+      }
+   }
+
+TR::ILOpCodes
+indirectStore(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::astorei;
+      case TR::Int64:
+         return TR::lstorei;
+      case TR::Int32:
+         return TR::istorei;
+      case TR::Int16:
+         return TR::sstorei;
+      case TR::Int8:
+         return TR::bstorei;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for indirect store"");
+      }
+   }
+
+TR::ILOpCodes
+indirectLoad(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::aloadi;
+      case TR::Int64:
+         return TR::lloadi;
+      case TR::Int32:
+         return TR::iloadi;
+      case TR::Int16:
+         return TR::sloadi;
+      case TR::Int8:
+         return TR::bloadi;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for indirect load"");
+      }
+   }
+
+TR::ILOpCodes
+loadConst(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::aconst;
+      case TR::Int64:
+         return TR::lconst;
+      case TR::Int32:
+         return TR::iconst;
+      case TR::Int16:
+         return TR::sconst;
+      case TR::Int8:
+         return TR::bconst;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for const"");
+      }
+   }
+
+int32_t
+TR_ValueJProfiling::perform() 
+   {
+   /**
+    * JProfiling Configuration
+    *
+    * ValueJProfiling will insert value profiling trees and lower any existing placeholder
+    * profiling trees. It can operate in two different modes:
+    *
+    * For non-profiling compilations, placeholder trees are not expected. Instead, the optimization
+    * pass will instrument virtual calls, instanceofs and checkcasts for profiling.
+    *
+    * For profiling compilations, placeholder trees will be identified and lowered, assuming the compilation
+    * has been configured to use JProfiling.
+    */
+   if (comp()->getProfilingMode() == JProfiling)
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been enabled for profiling compilations, run ValueJProfiling\n"");
+      }
+   else if (comp()->getOption(TR_EnableJProfiling))
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been enabled, run ValueJProfiling\n"");
+      }
+   else 
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been disabled, skip ValueJProfiling\n"");
+      return 0;
+      }
+
+   // Lower all existing calls
+   lowerCalls();
+
+   if (comp()->isProfilingCompilation())
+      {
+      TR::Recompilation *recomp = comp()->getRecompilationInfo();
+      TR_ValueProfiler *profiler = (TR_ValueProfiler*) recomp->getValueProfiler();
+      TR_ASSERT(profiler, ""Recompilation should have a ValueProfiler in a profiling compilation"");
+      profiler->setPostLowering();
+      }
+   else
+      {
+      TR::NodeChecklist checklist(comp());
+
+      // Identify and instrument profiling candidates
+      for (TR::TreeTop *cursor = comp()->getStartTree(); cursor; cursor = cursor->getNextTreeTop())
+         performOnNode(cursor->getNode(), cursor, &checklist);
+      }
+
+   return 1;
+   }
+
+void
+TR_ValueJProfiling::performOnNode(TR::Node *node, TR::TreeTop *tt, TR::NodeChecklist *checklist)
+   {
+   if (checklist->contains(node))
+      return;
+   checklist->add(node);
+
+   if (node->getOpCode().isCall() && node->getOpCode().isIndirect())
+      {
+      addVFTProfiling(node->getFirstChild(), tt, false);
+      }
+   else if (node->getOpCodeValue() == TR::instanceof || node->getOpCodeValue() == TR::checkcast)
+      {
+      addVFTProfiling(node->getFirstChild(), tt, true);
+      }
+
+   for (int i = 0; i < node->getNumChildren(); ++i)
+      performOnNode(node->getChild(i), tt, checklist);
+   }
+
+void
+TR_ValueJProfiling::addVFTProfiling(TR::Node *address, TR::TreeTop *tt, bool addNullCheck)
+   {
+   TR::Node *vftNode = TR::Node::createWithSymRef(address, TR::aloadi, 1, address,
+      getSymRefTab()->findOrCreateVftSymbolRef());
+
+   TR::Node *check = NULL;
+   TR::Node *fallback = NULL;
+   if (addNullCheck)
+      {
+      check = TR::Node::createif(TR::ifacmpeq, address, TR::Node::aconst(address, 0));
+      fallback = TR::Node::aconst(address, 0);
+      }
+
+   TR_ValueProfileInfo *valueProfileInfo = TR_PersistentProfileInfo::get(comp())->findOrCreateValueProfileInfo(comp());
+   TR_AbstractHashTableProfilerInfo *info = (TR_AbstractHashTableProfilerInfo*) valueProfileInfo->getOrCreateProfilerInfo(address->getByteCodeInfo(), comp(), AddressInfo, HashTableProfiler);
+
+   addProfilingTrees(comp(), tt, vftNode, info, check, fallback, true, trace());
+   }
+
+/**
+ * Identify helper calls to TR_jProfileValue and TR_jProfileLongValue, lowering them
+ * into the fast, slow and helper paths.
+ */
+void
+TR_ValueJProfiling::lowerCalls()
+   {
+   TR::TreeTop *cursor = comp()->getStartTree();
+   while (cursor)
+      {
+      TR::Node * node = cursor->getNode();
+
+      if (node->isProfilingCode() &&
+          node->getOpCodeValue() == TR::treetop &&
+          node->getFirstChild()->getOpCode().isCall() &&
+          (node->getFirstChild()->getSymbolReference()->getReferenceNumber() == TR_jProfile32BitValue ||
+           node->getFirstChild()->getSymbolReference()->getReferenceNumber() == TR_jProfile64BitValue) &&
+          node->getFirstChild()->getNumChildren() == 3)
+         {
+         TR::TreeTop *nextTree = cursor->getNextTreeTop();
+         TR::Node *child = node->getFirstChild();
+
+         dumpOptDetails(comp(), ""%s Replacing profiling placeholder n%dn with value profiling trees\n"",
+            optDetailString(), child->getGlobalIndex());
+
+         // Extract the arguments and add the profiling trees
+         TR::Node *value = child->getFirstChild();
+         TR_AbstractHashTableProfilerInfo *table = (TR_AbstractHashTableProfilerInfo*) child->getSecondChild()->getAddress();
+         addProfilingTrees(comp(), cursor, value, table, NULL, NULL, true, trace());
+
+         // Remove the original trees and continue from the tree after the profiling
+         TR::TransformUtil::removeTree(comp(), cursor);
+         cursor = nextTree;
+         }
+      else
+         cursor = cursor->getNextTreeTop();
+      }
+   }
+
+/*
+ * Insert the trees and control flow to profile a node after an insertion point.
+ * The original block will be split after the insertion point.
+ *
+ * An optional mapping, with a test and fallback value is supported. An example use of
+ * this is a vft lookup using an address that could be null. A null check is therefore
+ * necessary, using a fallback value of 0.
+ *
+ * ------------------
+ * | ...            |
+ * | insertionPoint |
+ * | ...            |
+ * ------------------
+ * 
+ * Becomes:
+ *
+ * | ...               |                                        
+ * | insertionPoint    |                                        
+ * | uncommoning       |
+ * | optionalTest      |---------------
+ * ---------------------              |
+ *          |                         |
+ *          v                         v
+ * ---------------------    ---------------------                                       
+ * | originalValue     |    | fallbackValue     |                                      
+ * ---------------------    ---------------------                                      
+ * | store temp 1      |    | store temp 1      |                                      
+ * |  value            |    |  fallback         |                                      
+ * ---------------------    ---------------------
+ *          |                        |
+ *          |-------------------------
+ *          v
+ * ---------------------                                        
+ * | quickTest         |                                        
+ * ---------------------                                        
+ * | store temp 2      |                                        
+ * |  hash             |                                        
+ * |   load temp 1     |                                        
+ * | ifne              |----------------------
+ * |  =>load temp 1    |                     |
+ * |  indirect load    |                     v
+ * |   add             |           ---------------------
+ * |    keysArray      |           | slowTest          |
+ * |    mult           |           ---------------------
+ * |     =>hash        |           | store temp 3      |
+ * |     width         |           |   indirect load   |
+ * ---------------------           |     otherIndex    |
+ *          |                      | ifeq              |-------------------
+ *          v                      |   load temp 3     |                  |
+ * ---------------------           |   const 0         |                  v
+ * | quickInc          |           ---------------------        ------------------
+ * ---------------------                    |                   | helper         |
+ * | incMemory         |                    v                   ------------------
+ * |   add             |           ---------------------        | call helper    |
+ * |     countsArray   |           | slowInc           |        |   load temp 1  |
+ * |     mult          |           ---------------------        |   tableAddress |
+ * |       load temp 2 |           | incMemory         |        ------------------
+ * |       countWidth  |           |   add             |                 |
+ * ---------------------           |     countsArray   |                 |
+ *          |                      |     mult          |                 |
+ *          |                      |       load temp 3 |                 |
+ *          |                      |       countWidth  |                 |
+ *          |                      ---------------------                 |
+ *          |                                |                           |
+ *          |-------------------------------------------------------------
+ *          v
+ * ---------------------
+ * | uncommoning       |
+ * | ...               |
+ *
+ * \param insertionPoint Treetop to insert profiling code after.
+ * \param value Value to profile.
+ * \param table Persistent TR_HashMapInfo which will be filled and incremented during profiling.
+ * \param optionalTest Option test node capable of preventing evaluation of value and using a fallbackValue instead.
+ * \param fallbackValue Fallback value to use with the optional test.
+ * \param extendBlocks Generates the blocks as extended, defaults true.
+ * \param trace Enable tracing.
+ */
+bool
+TR_ValueJProfiling::addProfilingTrees(
+    TR::Compilation *comp,
+    TR::TreeTop *insertionPoint,
+    TR::Node *value,
+    TR_AbstractHashTableProfilerInfo *table,
+    TR::Node *optionalTest,
+    TR::Node *fallbackValue,
+    bool extendBlocks,
+    bool trace)
+   {
+   // Common types used in calculation
+   TR::DataType counterType = TR::Int32;
+   TR::DataType lockType    = TR::Int16;
+   TR::DataType systemType  = TR::Compiler->target.is64Bit() ? TR::Int64 : TR::Int32;
+
+   // Type to use in calculations and table access
+   TR::DataType roundedType    = value->getType();
+   if (roundedType == TR::Int8 || roundedType == TR::Int16)
+      roundedType = TR::Int32;
+
+   if (trace)
+      {
+      traceMsg(comp, ""Inserting value profiling trees:\n  Value n%dn At n%dn\n  Table: %p\n"",
+         value->getGlobalIndex(),
+         insertionPoint->getNode()->getGlobalIndex(),
+         table);
+      table->trace(comp);
+      traceMsg(comp, ""  Test: %p Fallback: %p\n"", optionalTest, fallbackValue);
+      }
+
+   TR::Block    *originalBlock = insertionPoint->getEnclosingBlock();
+   TR::Block    *extendedBlock = originalBlock;
+   while (extendedBlock->isExtensionOfPreviousBlock())
+      extendedBlock = extendedBlock->getPrevBlock();
+
+   if (trace)
+      {
+      traceMsg(comp, ""  Modifying block_%d"", originalBlock->getNumber());
+      if (extendedBlock && extendedBlock != originalBlock)
+         traceMsg(comp, "" extending block_%d"", extendedBlock->getNumber());
+      traceMsg(comp, "" with profiling\n"");
+      }
+
+   // Cache the last treetop in the CFG
+   TR::CFG *cfg = comp->getFlowGraph();
+   cfg->setStructure(0);
+   TR::Block *cursor = originalBlock, *prev = originalBlock;
+   while (cursor && cursor != cfg->getEnd() && cursor != cfg->getStart() && cursor->getNumber())
+      {
+      prev = cursor;
+      cursor = cursor->getNextBlock();
+      }
+   TR::TreeTop *lastTreeTop = prev->getExit();
+
+   // Example node to use when constructing others 
+   TR::Node *example = value;
+
+   /********************* original Block *********************/
+   if (trace)
+      traceMsg(comp, "" Profiled value n%dn into temp\n"", value->getGlobalIndex());
+
+   // Store the value and replace references to it, if no fallback value can overwrite its value
+   TR::SymbolReference *storedValueSymRef = NULL;
+   TR::TreeTop *storeValue = TR::TreeTop::create(comp, insertionPoint, storeNode(comp, value, storedValueSymRef));
+   if (!optionalTest)
+      replaceNode(comp, extendedBlock->getEntry(), storeValue->getNextTreeTop(),
+         value, TR::Node::createLoad(example, storeValue->getNode()->getSymbolReference()));
+
+   // Split after the store
+   TR::Block *quickTest = originalBlock->split(storeValue->getNextTreeTop(), cfg, true, true);
+
+   /********************* fallback Block *********************/
+
+   // Insert the optional test and split after it
+   if (optionalTest)
+      {
+      TR_ASSERT_FATAL(fallbackValue, ""If introducing an optional test, a fallback value must be specified"");
+      TR::TreeTop *testTree = TR::TreeTop::create(comp, insertionPoint, optionalTest);
+
+      TR::Block *mapping = originalBlock->split(testTree->getNextTreeTop(), cfg, true, true);
+      if (extendBlocks)
+         mapping->setIsExtensionOfPreviousBlock();
+      
+      // Create the fallback block and link it to the optional test
+      TR::Block *fallback = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+      fallback->setIsCold();
+      lastTreeTop->join(fallback->getEntry());
+      lastTreeTop = fallback->getExit();
+      cfg->addNode(fallback);
+      cfg->addEdge(originalBlock, fallback);
+      cfg->addEdge(fallback, quickTest);
+      testTree->getNode()->setBranchDestination(fallback->getEntry());     
+
+      if (trace)
+         traceMsg(comp, ""  Fallback block_%d store to symRef #%d of node %p in \n"", fallback->getNumber(),
+            storedValueSymRef->getReferenceNumber(), fallback);
+
+      // Store and return to the mainline
+      TR::TreeTop::create(comp, fallback->getEntry(), TR::Node::create(example, TR::Goto, 0, quickTest->getEntry()));
+      TR::TreeTop::create(comp, fallback->getEntry(), storeNode(comp, fallbackValue, storedValueSymRef));
+      }
+   else if (extendBlocks)
+      quickTest->setIsExtensionOfPreviousBlock();
+
+   /********************* quickTest Block *********************/
+   // If blocks aren't being extended, its necessary to create a load
+   TR::Node *quickTestValue = value;
+   if (!extendBlocks || optionalTest)
+      quickTestValue = TR::Node::createLoad(example, storedValueSymRef);
+   quickTestValue = convertType(quickTestValue, roundedType);
+
+   if (trace)
+      traceMsg(comp, ""  Hash calculation in block_%d\n"", quickTest->getNumber());
+
+   // Base address for the table accesses, simplifies codegen
+   TR::Node *address = TR::Node::aconst(example, table->getBaseAddress());
+   TR::Node *index = convertType(computeHash(comp, table, quickTestValue, address), systemType);
+   
+   if (trace)
+      traceMsg(comp, ""  Key test based on index n%dn\n"", quickTest->getNumber(), index->getGlobalIndex());
+
+   // Generate the check to ensure the value is already in the chosen slot
+   TR::Node *checkKey = TR::Node::createif(comp->il.opCodeForIfCompareNotEquals(roundedType), quickTestValue,
+      loadValue(comp, roundedType, address, index, systemConst(example, table->getKeysOffset())));
+   TR::TreeTop *checkKeyTree = TR::TreeTop::create(comp, quickTest->getEntry(), checkKey);
+
+   /********************* quickInc Block *********************/
+   // If we aren't extending the blocks, anchor stores for the table address and the value
+   TR::Node *quickIncAddress = address;
+   TR::Node *quickIncIndex = index;
+   if (!extendBlocks)
+      {
+      TR::SymbolReference *storedIndexSymRef = NULL;
+      TR::SymbolReference *storedAddressSymRef = NULL;
+      TR::TreeTop::create(comp, quickTest->getEntry(), storeNode(comp, index, storedIndexSymRef));
+      TR::TreeTop::create(comp, quickTest->getEntry(), storeNode(comp, address, storedAddressSymRef));
+      storedAddressSymRef->getSymbol()->setNotCollected();
+
+      quickIncIndex = TR::Node::createLoad(example, storedIndexSymRef);
+      quickIncAddress = TR::Node::createLoad(example, storedAddressSymRef);
+      }
+
+   // Split the block, creating a new block to hold the successful quick increment
+   TR::Block *quickInc = quickTest->split(checkKeyTree->getNextTreeTop(), cfg, true, true);
+   if (extendBlocks)
+      quickInc->setIsExtensionOfPreviousBlock();
+
+   if (trace)
+      traceMsg(comp, ""  Quick increment in block_%d\n"", quickInc->getNumber());
+
+   TR::Node *counterOffset = systemConst(example, table->getFreqOffset());
+   TR::TreeTop *incTree = TR::TreeTop::create(comp, quickInc->getEntry(),
+      incrementMemory(comp, counterType, effectiveAddress(counterType, quickIncAddress, quickIncIndex, counterOffset)));
+
+   // Split the block again, after the increment, so cold paths can merge back
+   TR::Block *mainlineReturn = quickInc->split(incTree->getNextTreeTop(), cfg, true, true);
+
+   /********************* slowTest Block *********************/
+   TR::Block *slowTest = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+   slowTest->setIsCold();
+   lastTreeTop->join(slowTest->getEntry());
+   lastTreeTop = slowTest->getExit();
+   cfg->addNode(slowTest);
+   cfg->addEdge(quickTest, slowTest);
+   cfg->addEdge(slowTest, mainlineReturn);
+   checkKey->setBranchDestination(slowTest->getEntry());
+
+   if (trace)
+      traceMsg(comp, ""  Lock test in block_%d\n"", slowTest->getNumber());
+
+   // Load the lock and test if its set
+   TR::Node *lockAddress = TR::Node::aconst(example, table->getBaseAddress() + table->getLockOffset());
+   TR::Node *lock = loadValue(comp, lockType, lockAddress);
+   TR::Node *checkTableLock = TR::Node::createif(TR::ifscmplt, lock, TR::Node::sconst(example, 0));
+   TR::TreeTop::create(comp, slowTest->getEntry(), checkTableLock);
+
+   /********************* slowInc Block *********************/
+   TR::Node *slowIncIndex = convertType(lock, systemType);
+   if (!extendBlocks)
+      {
+      TR::SymbolReference *storedLockSymRef = NULL;
+      TR::TreeTop::create(comp, slowTest->getEntry(), storeNode(comp, convertType(lock, systemType), storedLockSymRef));
+      slowIncIndex = TR::Node::createLoad(example, storedLockSymRef);
+      }
+
+   // Split the block, creating a new block to hold the other increment
+   TR::Block *slowInc = slowTest->split(slowTest->getExit(), cfg, true, true);
+   lastTreeTop = slowInc->getExit();
+   if (extendBlocks)
+      slowInc->setIsExtensionOfPreviousBlock();
+
+   if (trace)
+      traceMsg(comp, ""  Slow increment in block_%d\n"", slowInc->getNumber());
+
+   // Add the other increment and return to mainline
+   TR::TreeTop::create(comp, slowInc->getEntry(), TR::Node::create(example, TR::Goto, 0, mainlineReturn->getEntry()));
+   TR::Node *counterAddress = TR::Node::aconst(example, table->getBaseAddress() + table->getFreqOffset());
+   TR::TreeTop::create(comp, slowInc->getEntry(), incrementMemory(comp, counterType,
+      effectiveAddress(counterType, counterAddress, slowIncIndex)));
+
+   /********************* helper Block *********************/
+   // Build the helper call path
+   TR::Block *helper = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+   helper->setIsCold();
+   lastTreeTop->join(helper->getEntry());
+   lastTreeTop = helper->getExit();
+   cfg->addNode(helper);
+   cfg->addEdge(slowTest, helper);
+   cfg->addEdge(helper, mainlineReturn);
+   checkTableLock->setBranchDestination(helper->getEntry());
+
+   if (trace)
+      traceMsg(comp, ""  Helper call in block_%d\n"", helper->getNumber());
+
+   // Add the call to the helper and return to the mainline
+   TR::TreeTop::create(comp, helper->getEntry(), TR::Node::create(example, TR::Goto, 0, mainlineReturn->getEntry()));
+   TR::TreeTop *helperCallTreeTop = TR::TreeTop::create(comp, helper->getEntry(), createHelperCall(comp,
+      convertType(TR::Node::createLoad(example, storedValueSymRef), roundedType),
+      TR::Node::aconst(example, table->getBaseAddress())));
+
+   // Set profiling code flags
+   TR::NodeChecklist checklist(comp);
+   checklist.add(value);
+   TR::TreeTop *tt = quickTest->getEntry(), *end = mainlineReturn->getEntry(); 
+   while (tt && tt != end)
+      {
+      TR::Node *node = tt->getNode();
+      if (node->getOpCodeValue() != TR::BBStart && node->getOpCodeValue() != TR::BBEnd)
+         setProfilingCode(node, checklist);
+      tt = tt->getNextTreeTop();
+      }
+   tt = slowTest->getEntry();
+   end = NULL;
+   while (tt && tt != end)
+      {
+      TR::Node *node = tt->getNode();
+      if (node->getOpCodeValue() != TR::BBStart && node->getOpCodeValue() != TR::BBEnd)
+         setProfilingCode(node, checklist);
+      tt = tt->getNextTreeTop();
+      }
+
+   return true;
+   }
+
+/*
+ * Recursive call to replace origNode with newNode underneath a target node.
+ *
+ * \param check Node to search for reference to origNode.
+ * \param origNode Node to replace.
+ * \param newNode Node to use in its place.
+ * \param checklist Checklist of nodes that have already been searched.
+ */
+void
+TR_ValueJProfiling::replaceNode(TR::Node* check, TR::Node* origNode, TR::Node *newNode, TR::NodeChecklist &checklist)
+   {
+   if (checklist.contains(check))
+      return;
+   checklist.add(check);
+
+   for (uint32_t i = 0; i < check->getNumChildren(); ++i)
+      {
+      if (origNode && check->getChild(i) == origNode)
+         {
+         check->setAndIncChild(i, newNode);
+         origNode->decReferenceCount();
+         }
+      else
+         replaceNode(check->getChild(i), origNode, newNode, checklist);
+      }
+   }
+
+/*
+ * Replace all references to origNode under and after replaceStart with newNode.
+ *
+ * \param blockStart Start of the extended block containing replaceStart.
+ * \param origNode Node to replace.
+ * \param newNode Node to use in its place.
+ */
+void
+TR_ValueJProfiling::replaceNode(TR::Compilation *comp, TR::TreeTop *blockStart, TR::TreeTop *replaceStart,
+    TR::Node *origNode, TR::Node *newNode)
+   {
+   TR::NodeChecklist checklist(comp);
+   TR::TreeTop *tt = blockStart; 
+
+   // Collect all nodes seen before start of replace, these shouldn't be replaced
+   while (tt != replaceStart)
+      {
+      replaceNode(tt->getNode(), NULL, NULL, checklist);
+      tt = tt->getNextTreeTop();
+      }
+
+   // Begin replacing until the end of the extended block
+   while (tt)
+      {
+      if (tt->getNode()->getOpCodeValue() == TR::BBStart && !tt->getNode()->getBlock()->isExtensionOfPreviousBlock())
+         break;
+      replaceNode(tt->getNode(), origNode, newNode, checklist);
+      tt = tt->getNextTreeTop();
+      }
+   }
+
+/*
+ * Mark a node and its children as profiling code.
+ *
+ * \param node Node to process, marking it and its children.
+ * \param checklist Checklist of nodes already marked.
+ */
+void
+TR_ValueJProfiling::setProfilingCode(TR::Node *node, TR::NodeChecklist &checklist)
+   {
+   if (checklist.contains(node))
+      return;
+   checklist.add(node);
+
+   node->setIsProfilingCode();
+   for (uint32_t i = 0; i < node->getNumChildren(); ++i)
+      setProfilingCode(node->getChild(i), checklist);
+   }
+
+/*
+ * Generate the tree to store a value into a temporary symref. If no symref is specified, one will be generated.
+ *
+ * \param value Value to store.
+ * \param symRef Optional symref to store value into. Will be update to used symref if none specified.
+ */
+TR::Node *
+TR_ValueJProfiling::storeNode(TR::Compilation *comp, TR::Node *value, TR::SymbolReference* &symRef)
+   {
+   if (symRef == NULL)
+      symRef = comp->getSymRefTab()->createTemporary(comp->getMethodSymbol(), value->getDataType());
+
+   return TR::Node::createWithSymRef(value, directStore(value->getDataType()), 1, value, symRef);
+   }
+
+/*
+ * Given an address in X86's LEA form, generate a node structure to calculate a memory address for a desired
+ * data type. Address would be: base + width(dataType) * index + offset
+ *
+ * \param dataType Date type of value to address. Its width is used for calculations if index is specified.
+ * \param base Base address to load from.
+ * \param index Optional index.
+ * \param offset Optional offset from the base.
+ */
+TR::Node *
+TR_ValueJProfiling::effectiveAddress(TR::DataType dataType, TR::Node *base, TR::Node *index, TR::Node *offset)
+   {
+   if (offset)
+      {
+      if (offset->getDataType() == TR::Int64)
+         base = TR::Node::create(base, TR::aladd, 2, base, offset);
+      else if (offset->getDataType() == TR::Int32)
+         base = TR::Node::create(base, TR::aiadd, 2, base, offset);
+      else
+         TR_ASSERT_FATAL(0, ""Invalid type for address calculation integer"");
+      }
+
+   if (index)
+      {
+      uint8_t size = TR::DataType::getSize(dataType);
+      if (index->getDataType() == TR::Int64)
+         base = TR::Node::create(base, TR::aladd, 2, base, TR::Node::create(base, TR::lmul, 2, index, TR::Node::lconst(base, size)));
+      else if (index->getDataType() == TR::Int32)
+         base = TR::Node::create(base, TR::aiadd, 2, base, TR::Node::create(base, TR::imul, 2, index, TR::Node::iconst(base, size)));
+      else
+         TR_ASSERT_FATAL(0, ""Invalid type for address calculation integer"");
+      }
+
+   return base;
+   }
+
+/*
+ * Given an address in X86's LEA form, generate a node structure to load a value from the memory address of the desired
+ * data type. Address would be: base + width(dataType) * index + offset
+ *
+ * \param dataType Date type of value to load. Its width is used for calculations if index is specified.
+ * \param base Base address to load from.
+ * \param index Optional index.
+ * \param offset Optional offset from the base.
+ */
+TR::Node *
+TR_ValueJProfiling::loadValue(TR::Compilation *comp, TR::DataType dataType, TR::Node *base, TR::Node *index, TR::Node *offset)
+   {
+   base = effectiveAddress(dataType, base, index, offset);
+   TR::SymbolReference *symRef = comp->getSymRefTab()->findOrCreateArrayShadowSymbolRef(dataType, NULL);
+   TR::Node *result = TR::Node::createWithSymRef(base, indirectLoad(dataType), 1, base, symRef);
+
+   return result;
+   }
+
+/*
+ * Generate the helper call tree, which adds values to the table along the slowest path.
+ * Will return a treetop, with the call as its child.
+ *
+ * \param value Node representing the value to add to the table.
+ * \param table Address of the table's base.
+ */
+TR::Node *
+TR_ValueJProfiling::createHelperCall(TR::Compilation *comp, TR::Node *value, TR::Node *table)
+   {
+   TR::SymbolReference *profiler;
+   if (value->getDataType() == TR::Int32)
+      profiler = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_jProfile32BitValue, false, false, true);
+   else
+      profiler = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_jProfile64BitValue, false, false, true);
+
+#if defined(TR_HOST_POWER) || defined(TR_HOST_ARM)
+   profiler->getSymbol()->castToMethodSymbol()->setLinkage(TR_System);
+#else",this seems ugly can we avoid the nested case here and make this a more clean if elif else?,
81678661,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/ValueJProfiling.cpp,False,"@@ -0,0 +1,883 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+#include ""ValueJProfiling.hpp""
+
+#include ""il/Block.hpp""
+#include ""infra/Cfg.hpp""
+#include ""infra/TRCfgEdge.hpp""
+#include ""infra/Checklist.hpp""
+#include ""infra/ILWalk.hpp""
+#include ""infra/List.hpp""
+#include ""optimizer/Optimization_inlines.hpp""
+#include ""il/Node_inlines.hpp""
+#include ""infra/Checklist.hpp""             // for TR::NodeChecklist
+#include ""ras/DebugCounter.hpp""
+#include ""runtime/J9Profiler.hpp""
+#include ""control/Recompilation.hpp""              // for TR_Recompilation, etc
+#include ""control/RecompilationInfo.hpp""              // for TR_Recompilation, etc
+#include ""codegen/CodeGenerator.hpp""
+#include ""optimizer/TransformUtil.hpp""            // for TransformUtil
+
+#define COLD_BLOCK_FREQ 6
+
+// There are existing versions of these mappings, however, they will round up
+// types smaller than Int32
+TR::ILOpCodes
+directStore(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::astore;
+      case TR::Int64:
+         return TR::lstore;
+      case TR::Int32:
+         return TR::istore;
+      case TR::Int16:
+         return TR::sstore;
+      case TR::Int8:
+         return TR::bstore;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for store"");
+      }
+   }
+
+TR::ILOpCodes
+indirectStore(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::astorei;
+      case TR::Int64:
+         return TR::lstorei;
+      case TR::Int32:
+         return TR::istorei;
+      case TR::Int16:
+         return TR::sstorei;
+      case TR::Int8:
+         return TR::bstorei;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for indirect store"");
+      }
+   }
+
+TR::ILOpCodes
+indirectLoad(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::aloadi;
+      case TR::Int64:
+         return TR::lloadi;
+      case TR::Int32:
+         return TR::iloadi;
+      case TR::Int16:
+         return TR::sloadi;
+      case TR::Int8:
+         return TR::bloadi;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for indirect load"");
+      }
+   }
+
+TR::ILOpCodes
+loadConst(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::aconst;
+      case TR::Int64:
+         return TR::lconst;
+      case TR::Int32:
+         return TR::iconst;
+      case TR::Int16:
+         return TR::sconst;
+      case TR::Int8:
+         return TR::bconst;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for const"");
+      }
+   }
+
+int32_t
+TR_ValueJProfiling::perform() 
+   {
+   /**
+    * JProfiling Configuration
+    *
+    * ValueJProfiling will insert value profiling trees and lower any existing placeholder
+    * profiling trees. It can operate in two different modes:
+    *
+    * For non-profiling compilations, placeholder trees are not expected. Instead, the optimization
+    * pass will instrument virtual calls, instanceofs and checkcasts for profiling.
+    *
+    * For profiling compilations, placeholder trees will be identified and lowered, assuming the compilation
+    * has been configured to use JProfiling.
+    */
+   if (comp()->getProfilingMode() == JProfiling)
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been enabled for profiling compilations, run ValueJProfiling\n"");
+      }
+   else if (comp()->getOption(TR_EnableJProfiling))
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been enabled, run ValueJProfiling\n"");
+      }
+   else 
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been disabled, skip ValueJProfiling\n"");
+      return 0;
+      }
+
+   // Lower all existing calls
+   lowerCalls();
+
+   if (comp()->isProfilingCompilation())
+      {
+      TR::Recompilation *recomp = comp()->getRecompilationInfo();
+      TR_ValueProfiler *profiler = (TR_ValueProfiler*) recomp->getValueProfiler();
+      TR_ASSERT(profiler, ""Recompilation should have a ValueProfiler in a profiling compilation"");
+      profiler->setPostLowering();
+      }
+   else
+      {
+      TR::NodeChecklist checklist(comp());
+
+      // Identify and instrument profiling candidates
+      for (TR::TreeTop *cursor = comp()->getStartTree(); cursor; cursor = cursor->getNextTreeTop())
+         performOnNode(cursor->getNode(), cursor, &checklist);
+      }
+
+   return 1;
+   }
+
+void
+TR_ValueJProfiling::performOnNode(TR::Node *node, TR::TreeTop *tt, TR::NodeChecklist *checklist)
+   {
+   if (checklist->contains(node))
+      return;
+   checklist->add(node);
+
+   if (node->getOpCode().isCall() && node->getOpCode().isIndirect())
+      {
+      addVFTProfiling(node->getFirstChild(), tt, false);
+      }
+   else if (node->getOpCodeValue() == TR::instanceof || node->getOpCodeValue() == TR::checkcast)
+      {
+      addVFTProfiling(node->getFirstChild(), tt, true);
+      }
+
+   for (int i = 0; i < node->getNumChildren(); ++i)
+      performOnNode(node->getChild(i), tt, checklist);
+   }
+
+void
+TR_ValueJProfiling::addVFTProfiling(TR::Node *address, TR::TreeTop *tt, bool addNullCheck)
+   {
+   TR::Node *vftNode = TR::Node::createWithSymRef(address, TR::aloadi, 1, address,
+      getSymRefTab()->findOrCreateVftSymbolRef());
+
+   TR::Node *check = NULL;
+   TR::Node *fallback = NULL;
+   if (addNullCheck)
+      {
+      check = TR::Node::createif(TR::ifacmpeq, address, TR::Node::aconst(address, 0));
+      fallback = TR::Node::aconst(address, 0);
+      }
+
+   TR_ValueProfileInfo *valueProfileInfo = TR_PersistentProfileInfo::get(comp())->findOrCreateValueProfileInfo(comp());
+   TR_AbstractHashTableProfilerInfo *info = (TR_AbstractHashTableProfilerInfo*) valueProfileInfo->getOrCreateProfilerInfo(address->getByteCodeInfo(), comp(), AddressInfo, HashTableProfiler);
+
+   addProfilingTrees(comp(), tt, vftNode, info, check, fallback, true, trace());
+   }
+
+/**
+ * Identify helper calls to TR_jProfileValue and TR_jProfileLongValue, lowering them
+ * into the fast, slow and helper paths.
+ */
+void
+TR_ValueJProfiling::lowerCalls()
+   {
+   TR::TreeTop *cursor = comp()->getStartTree();
+   while (cursor)
+      {
+      TR::Node * node = cursor->getNode();
+
+      if (node->isProfilingCode() &&
+          node->getOpCodeValue() == TR::treetop &&
+          node->getFirstChild()->getOpCode().isCall() &&
+          (node->getFirstChild()->getSymbolReference()->getReferenceNumber() == TR_jProfile32BitValue ||
+           node->getFirstChild()->getSymbolReference()->getReferenceNumber() == TR_jProfile64BitValue) &&
+          node->getFirstChild()->getNumChildren() == 3)
+         {
+         TR::TreeTop *nextTree = cursor->getNextTreeTop();
+         TR::Node *child = node->getFirstChild();
+
+         dumpOptDetails(comp(), ""%s Replacing profiling placeholder n%dn with value profiling trees\n"",
+            optDetailString(), child->getGlobalIndex());
+
+         // Extract the arguments and add the profiling trees
+         TR::Node *value = child->getFirstChild();
+         TR_AbstractHashTableProfilerInfo *table = (TR_AbstractHashTableProfilerInfo*) child->getSecondChild()->getAddress();
+         addProfilingTrees(comp(), cursor, value, table, NULL, NULL, true, trace());
+
+         // Remove the original trees and continue from the tree after the profiling
+         TR::TransformUtil::removeTree(comp(), cursor);
+         cursor = nextTree;
+         }
+      else
+         cursor = cursor->getNextTreeTop();
+      }
+   }
+
+/*
+ * Insert the trees and control flow to profile a node after an insertion point.
+ * The original block will be split after the insertion point.
+ *
+ * An optional mapping, with a test and fallback value is supported. An example use of
+ * this is a vft lookup using an address that could be null. A null check is therefore
+ * necessary, using a fallback value of 0.
+ *
+ * ------------------
+ * | ...            |
+ * | insertionPoint |
+ * | ...            |
+ * ------------------
+ * 
+ * Becomes:
+ *
+ * | ...               |                                        
+ * | insertionPoint    |                                        
+ * | uncommoning       |
+ * | optionalTest      |---------------
+ * ---------------------              |
+ *          |                         |
+ *          v                         v
+ * ---------------------    ---------------------                                       
+ * | originalValue     |    | fallbackValue     |                                      
+ * ---------------------    ---------------------                                      
+ * | store temp 1      |    | store temp 1      |                                      
+ * |  value            |    |  fallback         |                                      
+ * ---------------------    ---------------------
+ *          |                        |
+ *          |-------------------------
+ *          v
+ * ---------------------                                        
+ * | quickTest         |                                        
+ * ---------------------                                        
+ * | store temp 2      |                                        
+ * |  hash             |                                        
+ * |   load temp 1     |                                        
+ * | ifne              |----------------------
+ * |  =>load temp 1    |                     |
+ * |  indirect load    |                     v
+ * |   add             |           ---------------------
+ * |    keysArray      |           | slowTest          |
+ * |    mult           |           ---------------------
+ * |     =>hash        |           | store temp 3      |
+ * |     width         |           |   indirect load   |
+ * ---------------------           |     otherIndex    |
+ *          |                      | ifeq              |-------------------
+ *          v                      |   load temp 3     |                  |
+ * ---------------------           |   const 0         |                  v
+ * | quickInc          |           ---------------------        ------------------
+ * ---------------------                    |                   | helper         |
+ * | incMemory         |                    v                   ------------------
+ * |   add             |           ---------------------        | call helper    |
+ * |     countsArray   |           | slowInc           |        |   load temp 1  |
+ * |     mult          |           ---------------------        |   tableAddress |
+ * |       load temp 2 |           | incMemory         |        ------------------
+ * |       countWidth  |           |   add             |                 |
+ * ---------------------           |     countsArray   |                 |
+ *          |                      |     mult          |                 |
+ *          |                      |       load temp 3 |                 |
+ *          |                      |       countWidth  |                 |
+ *          |                      ---------------------                 |
+ *          |                                |                           |
+ *          |-------------------------------------------------------------
+ *          v
+ * ---------------------
+ * | uncommoning       |
+ * | ...               |
+ *
+ * \param insertionPoint Treetop to insert profiling code after.
+ * \param value Value to profile.
+ * \param table Persistent TR_HashMapInfo which will be filled and incremented during profiling.
+ * \param optionalTest Option test node capable of preventing evaluation of value and using a fallbackValue instead.
+ * \param fallbackValue Fallback value to use with the optional test.
+ * \param extendBlocks Generates the blocks as extended, defaults true.
+ * \param trace Enable tracing.
+ */
+bool
+TR_ValueJProfiling::addProfilingTrees(
+    TR::Compilation *comp,
+    TR::TreeTop *insertionPoint,
+    TR::Node *value,
+    TR_AbstractHashTableProfilerInfo *table,
+    TR::Node *optionalTest,
+    TR::Node *fallbackValue,
+    bool extendBlocks,
+    bool trace)
+   {
+   // Common types used in calculation
+   TR::DataType counterType = TR::Int32;
+   TR::DataType lockType    = TR::Int16;
+   TR::DataType systemType  = TR::Compiler->target.is64Bit() ? TR::Int64 : TR::Int32;
+
+   // Type to use in calculations and table access
+   TR::DataType roundedType    = value->getType();
+   if (roundedType == TR::Int8 || roundedType == TR::Int16)
+      roundedType = TR::Int32;
+
+   if (trace)
+      {
+      traceMsg(comp, ""Inserting value profiling trees:\n  Value n%dn At n%dn\n  Table: %p\n"",
+         value->getGlobalIndex(),
+         insertionPoint->getNode()->getGlobalIndex(),
+         table);
+      table->trace(comp);
+      traceMsg(comp, ""  Test: %p Fallback: %p\n"", optionalTest, fallbackValue);
+      }
+
+   TR::Block    *originalBlock = insertionPoint->getEnclosingBlock();
+   TR::Block    *extendedBlock = originalBlock;
+   while (extendedBlock->isExtensionOfPreviousBlock())
+      extendedBlock = extendedBlock->getPrevBlock();
+
+   if (trace)
+      {
+      traceMsg(comp, ""  Modifying block_%d"", originalBlock->getNumber());
+      if (extendedBlock && extendedBlock != originalBlock)
+         traceMsg(comp, "" extending block_%d"", extendedBlock->getNumber());
+      traceMsg(comp, "" with profiling\n"");
+      }
+
+   // Cache the last treetop in the CFG
+   TR::CFG *cfg = comp->getFlowGraph();
+   cfg->setStructure(0);
+   TR::Block *cursor = originalBlock, *prev = originalBlock;
+   while (cursor && cursor != cfg->getEnd() && cursor != cfg->getStart() && cursor->getNumber())
+      {
+      prev = cursor;
+      cursor = cursor->getNextBlock();
+      }
+   TR::TreeTop *lastTreeTop = prev->getExit();
+
+   // Example node to use when constructing others 
+   TR::Node *example = value;
+
+   /********************* original Block *********************/
+   if (trace)
+      traceMsg(comp, "" Profiled value n%dn into temp\n"", value->getGlobalIndex());
+
+   // Store the value and replace references to it, if no fallback value can overwrite its value
+   TR::SymbolReference *storedValueSymRef = NULL;
+   TR::TreeTop *storeValue = TR::TreeTop::create(comp, insertionPoint, storeNode(comp, value, storedValueSymRef));
+   if (!optionalTest)
+      replaceNode(comp, extendedBlock->getEntry(), storeValue->getNextTreeTop(),
+         value, TR::Node::createLoad(example, storeValue->getNode()->getSymbolReference()));
+
+   // Split after the store
+   TR::Block *quickTest = originalBlock->split(storeValue->getNextTreeTop(), cfg, true, true);
+
+   /********************* fallback Block *********************/
+
+   // Insert the optional test and split after it
+   if (optionalTest)
+      {
+      TR_ASSERT_FATAL(fallbackValue, ""If introducing an optional test, a fallback value must be specified"");
+      TR::TreeTop *testTree = TR::TreeTop::create(comp, insertionPoint, optionalTest);
+
+      TR::Block *mapping = originalBlock->split(testTree->getNextTreeTop(), cfg, true, true);
+      if (extendBlocks)
+         mapping->setIsExtensionOfPreviousBlock();
+      
+      // Create the fallback block and link it to the optional test
+      TR::Block *fallback = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+      fallback->setIsCold();
+      lastTreeTop->join(fallback->getEntry());
+      lastTreeTop = fallback->getExit();
+      cfg->addNode(fallback);
+      cfg->addEdge(originalBlock, fallback);
+      cfg->addEdge(fallback, quickTest);
+      testTree->getNode()->setBranchDestination(fallback->getEntry());     
+
+      if (trace)
+         traceMsg(comp, ""  Fallback block_%d store to symRef #%d of node %p in \n"", fallback->getNumber(),
+            storedValueSymRef->getReferenceNumber(), fallback);
+
+      // Store and return to the mainline
+      TR::TreeTop::create(comp, fallback->getEntry(), TR::Node::create(example, TR::Goto, 0, quickTest->getEntry()));
+      TR::TreeTop::create(comp, fallback->getEntry(), storeNode(comp, fallbackValue, storedValueSymRef));
+      }
+   else if (extendBlocks)
+      quickTest->setIsExtensionOfPreviousBlock();
+
+   /********************* quickTest Block *********************/
+   // If blocks aren't being extended, its necessary to create a load
+   TR::Node *quickTestValue = value;
+   if (!extendBlocks || optionalTest)
+      quickTestValue = TR::Node::createLoad(example, storedValueSymRef);
+   quickTestValue = convertType(quickTestValue, roundedType);
+
+   if (trace)
+      traceMsg(comp, ""  Hash calculation in block_%d\n"", quickTest->getNumber());
+
+   // Base address for the table accesses, simplifies codegen
+   TR::Node *address = TR::Node::aconst(example, table->getBaseAddress());
+   TR::Node *index = convertType(computeHash(comp, table, quickTestValue, address), systemType);
+   
+   if (trace)
+      traceMsg(comp, ""  Key test based on index n%dn\n"", quickTest->getNumber(), index->getGlobalIndex());
+
+   // Generate the check to ensure the value is already in the chosen slot
+   TR::Node *checkKey = TR::Node::createif(comp->il.opCodeForIfCompareNotEquals(roundedType), quickTestValue,
+      loadValue(comp, roundedType, address, index, systemConst(example, table->getKeysOffset())));
+   TR::TreeTop *checkKeyTree = TR::TreeTop::create(comp, quickTest->getEntry(), checkKey);
+
+   /********************* quickInc Block *********************/
+   // If we aren't extending the blocks, anchor stores for the table address and the value
+   TR::Node *quickIncAddress = address;
+   TR::Node *quickIncIndex = index;
+   if (!extendBlocks)
+      {
+      TR::SymbolReference *storedIndexSymRef = NULL;
+      TR::SymbolReference *storedAddressSymRef = NULL;
+      TR::TreeTop::create(comp, quickTest->getEntry(), storeNode(comp, index, storedIndexSymRef));
+      TR::TreeTop::create(comp, quickTest->getEntry(), storeNode(comp, address, storedAddressSymRef));
+      storedAddressSymRef->getSymbol()->setNotCollected();
+
+      quickIncIndex = TR::Node::createLoad(example, storedIndexSymRef);
+      quickIncAddress = TR::Node::createLoad(example, storedAddressSymRef);
+      }
+
+   // Split the block, creating a new block to hold the successful quick increment
+   TR::Block *quickInc = quickTest->split(checkKeyTree->getNextTreeTop(), cfg, true, true);
+   if (extendBlocks)
+      quickInc->setIsExtensionOfPreviousBlock();
+
+   if (trace)
+      traceMsg(comp, ""  Quick increment in block_%d\n"", quickInc->getNumber());
+
+   TR::Node *counterOffset = systemConst(example, table->getFreqOffset());
+   TR::TreeTop *incTree = TR::TreeTop::create(comp, quickInc->getEntry(),
+      incrementMemory(comp, counterType, effectiveAddress(counterType, quickIncAddress, quickIncIndex, counterOffset)));
+
+   // Split the block again, after the increment, so cold paths can merge back
+   TR::Block *mainlineReturn = quickInc->split(incTree->getNextTreeTop(), cfg, true, true);
+
+   /********************* slowTest Block *********************/
+   TR::Block *slowTest = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+   slowTest->setIsCold();
+   lastTreeTop->join(slowTest->getEntry());
+   lastTreeTop = slowTest->getExit();
+   cfg->addNode(slowTest);
+   cfg->addEdge(quickTest, slowTest);
+   cfg->addEdge(slowTest, mainlineReturn);
+   checkKey->setBranchDestination(slowTest->getEntry());
+
+   if (trace)
+      traceMsg(comp, ""  Lock test in block_%d\n"", slowTest->getNumber());
+
+   // Load the lock and test if its set
+   TR::Node *lockAddress = TR::Node::aconst(example, table->getBaseAddress() + table->getLockOffset());
+   TR::Node *lock = loadValue(comp, lockType, lockAddress);
+   TR::Node *checkTableLock = TR::Node::createif(TR::ifscmplt, lock, TR::Node::sconst(example, 0));
+   TR::TreeTop::create(comp, slowTest->getEntry(), checkTableLock);
+
+   /********************* slowInc Block *********************/
+   TR::Node *slowIncIndex = convertType(lock, systemType);
+   if (!extendBlocks)
+      {
+      TR::SymbolReference *storedLockSymRef = NULL;
+      TR::TreeTop::create(comp, slowTest->getEntry(), storeNode(comp, convertType(lock, systemType), storedLockSymRef));
+      slowIncIndex = TR::Node::createLoad(example, storedLockSymRef);
+      }
+
+   // Split the block, creating a new block to hold the other increment
+   TR::Block *slowInc = slowTest->split(slowTest->getExit(), cfg, true, true);
+   lastTreeTop = slowInc->getExit();
+   if (extendBlocks)
+      slowInc->setIsExtensionOfPreviousBlock();
+
+   if (trace)
+      traceMsg(comp, ""  Slow increment in block_%d\n"", slowInc->getNumber());
+
+   // Add the other increment and return to mainline
+   TR::TreeTop::create(comp, slowInc->getEntry(), TR::Node::create(example, TR::Goto, 0, mainlineReturn->getEntry()));
+   TR::Node *counterAddress = TR::Node::aconst(example, table->getBaseAddress() + table->getFreqOffset());
+   TR::TreeTop::create(comp, slowInc->getEntry(), incrementMemory(comp, counterType,
+      effectiveAddress(counterType, counterAddress, slowIncIndex)));
+
+   /********************* helper Block *********************/
+   // Build the helper call path
+   TR::Block *helper = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+   helper->setIsCold();
+   lastTreeTop->join(helper->getEntry());
+   lastTreeTop = helper->getExit();
+   cfg->addNode(helper);
+   cfg->addEdge(slowTest, helper);
+   cfg->addEdge(helper, mainlineReturn);
+   checkTableLock->setBranchDestination(helper->getEntry());
+
+   if (trace)
+      traceMsg(comp, ""  Helper call in block_%d\n"", helper->getNumber());
+
+   // Add the call to the helper and return to the mainline
+   TR::TreeTop::create(comp, helper->getEntry(), TR::Node::create(example, TR::Goto, 0, mainlineReturn->getEntry()));
+   TR::TreeTop *helperCallTreeTop = TR::TreeTop::create(comp, helper->getEntry(), createHelperCall(comp,
+      convertType(TR::Node::createLoad(example, storedValueSymRef), roundedType),
+      TR::Node::aconst(example, table->getBaseAddress())));
+
+   // Set profiling code flags
+   TR::NodeChecklist checklist(comp);
+   checklist.add(value);
+   TR::TreeTop *tt = quickTest->getEntry(), *end = mainlineReturn->getEntry(); 
+   while (tt && tt != end)
+      {
+      TR::Node *node = tt->getNode();
+      if (node->getOpCodeValue() != TR::BBStart && node->getOpCodeValue() != TR::BBEnd)
+         setProfilingCode(node, checklist);
+      tt = tt->getNextTreeTop();
+      }
+   tt = slowTest->getEntry();
+   end = NULL;
+   while (tt && tt != end)
+      {
+      TR::Node *node = tt->getNode();
+      if (node->getOpCodeValue() != TR::BBStart && node->getOpCodeValue() != TR::BBEnd)
+         setProfilingCode(node, checklist);
+      tt = tt->getNextTreeTop();
+      }
+
+   return true;
+   }
+
+/*
+ * Recursive call to replace origNode with newNode underneath a target node.
+ *
+ * \param check Node to search for reference to origNode.
+ * \param origNode Node to replace.
+ * \param newNode Node to use in its place.
+ * \param checklist Checklist of nodes that have already been searched.
+ */
+void
+TR_ValueJProfiling::replaceNode(TR::Node* check, TR::Node* origNode, TR::Node *newNode, TR::NodeChecklist &checklist)
+   {
+   if (checklist.contains(check))
+      return;
+   checklist.add(check);
+
+   for (uint32_t i = 0; i < check->getNumChildren(); ++i)
+      {
+      if (origNode && check->getChild(i) == origNode)
+         {
+         check->setAndIncChild(i, newNode);
+         origNode->decReferenceCount();
+         }
+      else
+         replaceNode(check->getChild(i), origNode, newNode, checklist);
+      }
+   }
+
+/*
+ * Replace all references to origNode under and after replaceStart with newNode.
+ *
+ * \param blockStart Start of the extended block containing replaceStart.
+ * \param origNode Node to replace.
+ * \param newNode Node to use in its place.
+ */
+void
+TR_ValueJProfiling::replaceNode(TR::Compilation *comp, TR::TreeTop *blockStart, TR::TreeTop *replaceStart,
+    TR::Node *origNode, TR::Node *newNode)
+   {
+   TR::NodeChecklist checklist(comp);
+   TR::TreeTop *tt = blockStart; 
+
+   // Collect all nodes seen before start of replace, these shouldn't be replaced
+   while (tt != replaceStart)
+      {
+      replaceNode(tt->getNode(), NULL, NULL, checklist);
+      tt = tt->getNextTreeTop();
+      }
+
+   // Begin replacing until the end of the extended block
+   while (tt)
+      {
+      if (tt->getNode()->getOpCodeValue() == TR::BBStart && !tt->getNode()->getBlock()->isExtensionOfPreviousBlock())
+         break;
+      replaceNode(tt->getNode(), origNode, newNode, checklist);
+      tt = tt->getNextTreeTop();
+      }
+   }
+
+/*
+ * Mark a node and its children as profiling code.
+ *
+ * \param node Node to process, marking it and its children.
+ * \param checklist Checklist of nodes already marked.
+ */
+void
+TR_ValueJProfiling::setProfilingCode(TR::Node *node, TR::NodeChecklist &checklist)
+   {
+   if (checklist.contains(node))
+      return;
+   checklist.add(node);
+
+   node->setIsProfilingCode();
+   for (uint32_t i = 0; i < node->getNumChildren(); ++i)
+      setProfilingCode(node->getChild(i), checklist);
+   }
+
+/*
+ * Generate the tree to store a value into a temporary symref. If no symref is specified, one will be generated.
+ *
+ * \param value Value to store.
+ * \param symRef Optional symref to store value into. Will be update to used symref if none specified.
+ */
+TR::Node *
+TR_ValueJProfiling::storeNode(TR::Compilation *comp, TR::Node *value, TR::SymbolReference* &symRef)
+   {
+   if (symRef == NULL)
+      symRef = comp->getSymRefTab()->createTemporary(comp->getMethodSymbol(), value->getDataType());
+
+   return TR::Node::createWithSymRef(value, directStore(value->getDataType()), 1, value, symRef);
+   }
+
+/*
+ * Given an address in X86's LEA form, generate a node structure to calculate a memory address for a desired
+ * data type. Address would be: base + width(dataType) * index + offset
+ *
+ * \param dataType Date type of value to address. Its width is used for calculations if index is specified.
+ * \param base Base address to load from.
+ * \param index Optional index.
+ * \param offset Optional offset from the base.
+ */
+TR::Node *
+TR_ValueJProfiling::effectiveAddress(TR::DataType dataType, TR::Node *base, TR::Node *index, TR::Node *offset)
+   {
+   if (offset)
+      {
+      if (offset->getDataType() == TR::Int64)
+         base = TR::Node::create(base, TR::aladd, 2, base, offset);
+      else if (offset->getDataType() == TR::Int32)
+         base = TR::Node::create(base, TR::aiadd, 2, base, offset);
+      else
+         TR_ASSERT_FATAL(0, ""Invalid type for address calculation integer"");
+      }
+
+   if (index)
+      {
+      uint8_t size = TR::DataType::getSize(dataType);
+      if (index->getDataType() == TR::Int64)
+         base = TR::Node::create(base, TR::aladd, 2, base, TR::Node::create(base, TR::lmul, 2, index, TR::Node::lconst(base, size)));
+      else if (index->getDataType() == TR::Int32)
+         base = TR::Node::create(base, TR::aiadd, 2, base, TR::Node::create(base, TR::imul, 2, index, TR::Node::iconst(base, size)));
+      else
+         TR_ASSERT_FATAL(0, ""Invalid type for address calculation integer"");
+      }
+
+   return base;
+   }
+
+/*
+ * Given an address in X86's LEA form, generate a node structure to load a value from the memory address of the desired
+ * data type. Address would be: base + width(dataType) * index + offset
+ *
+ * \param dataType Date type of value to load. Its width is used for calculations if index is specified.
+ * \param base Base address to load from.
+ * \param index Optional index.
+ * \param offset Optional offset from the base.
+ */
+TR::Node *
+TR_ValueJProfiling::loadValue(TR::Compilation *comp, TR::DataType dataType, TR::Node *base, TR::Node *index, TR::Node *offset)
+   {
+   base = effectiveAddress(dataType, base, index, offset);
+   TR::SymbolReference *symRef = comp->getSymRefTab()->findOrCreateArrayShadowSymbolRef(dataType, NULL);
+   TR::Node *result = TR::Node::createWithSymRef(base, indirectLoad(dataType), 1, base, symRef);
+
+   return result;
+   }
+
+/*
+ * Generate the helper call tree, which adds values to the table along the slowest path.
+ * Will return a treetop, with the call as its child.
+ *
+ * \param value Node representing the value to add to the table.
+ * \param table Address of the table's base.
+ */
+TR::Node *
+TR_ValueJProfiling::createHelperCall(TR::Compilation *comp, TR::Node *value, TR::Node *table)
+   {
+   TR::SymbolReference *profiler;
+   if (value->getDataType() == TR::Int32)
+      profiler = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_jProfile32BitValue, false, false, true);
+   else
+      profiler = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_jProfile64BitValue, false, false, true);
+
+#if defined(TR_HOST_POWER) || defined(TR_HOST_ARM)
+   profiler->getSymbol()->castToMethodSymbol()->setLinkage(TR_System);
+#else
+#ifndef TR_HOST_X86
+   profiler->getSymbol()->castToMethodSymbol()->setPreservesAllRegisters();
+#endif
+   profiler->getSymbol()->castToMethodSymbol()->setSystemLinkageDispatch();
+#endif
+
+   TR::Node *helperCall = TR::Node::createWithSymRef(value, TR::call, 2, profiler);
+   helperCall->setAndIncChild(0, value);
+   helperCall->setAndIncChild(1, table);
+   return TR::Node::create(TR::treetop, 1, helperCall);
+   }
+
+/*
+ * Increment a memory address by 1. Used to increment the table's counters on both the match and other
+ * paths.
+ *
+ * \param counterType The memory addresses type, usually Int32 or Int64.
+ * \param address The memory address to increment.
+ */
+TR::Node *
+TR_ValueJProfiling::incrementMemory(TR::Compilation *comp, TR::DataType counterType, TR::Node *address)
+   {
+   TR::SymbolReference *symRef = comp->getSymRefTab()->findOrCreateArrayShadowSymbolRef(counterType, NULL);
+
+   TR::Node *load = TR::Node::createWithSymRef(address, indirectLoad(counterType), 1, address, symRef);
+   TR::Node *incCounter = TR::Node::create(address, counterType == TR::Int32 ? TR::iadd : TR::ladd, 2, load,
+      TR::Node::create(address, loadConst(counterType), 0, 1));
+   TR::Node *storeCounter = TR::Node::createWithSymRef(address, indirectStore(counterType), 2,
+      address, symRef);
+   storeCounter->setAndIncChild(1, incCounter);
+
+   return storeCounter;
+   }
+
+/*
+ * Generate a constant node matching the system's address width. Used for address calculations.
+ *
+ * \param example Example node to copy BCI.
+ * \param value Value to store in const.
+ */
+TR::Node *
+TR_ValueJProfiling::systemConst(TR::Node *example, uint64_t value)
+   {
+   TR::ILOpCodes constOp = TR::Compiler->target.is64Bit() ? TR::lconst : TR::iconst;
+   return TR::Node::create(example, constOp, 0, value);
+   }
+
+/*
+ * Its sometimes necessary to convert values to their rounded integer representation, in Int32
+ * or Int64, or to convert values to the system type, again in Int32 or Int64. This method
+ * handles those conversions as necessary. All conversions are unsigned.
+ *
+ * \param index The value to convert.
+ * \param dataType The datatype to convert to.
+ */
+TR::Node *
+TR_ValueJProfiling::convertType(TR::Node *index, TR::DataType dataType)",There isn't an OMR helper for this that could be used?,
81678969,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/ValueJProfiling.cpp,False,"@@ -0,0 +1,883 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+#include ""ValueJProfiling.hpp""
+
+#include ""il/Block.hpp""
+#include ""infra/Cfg.hpp""
+#include ""infra/TRCfgEdge.hpp""
+#include ""infra/Checklist.hpp""
+#include ""infra/ILWalk.hpp""
+#include ""infra/List.hpp""
+#include ""optimizer/Optimization_inlines.hpp""
+#include ""il/Node_inlines.hpp""
+#include ""infra/Checklist.hpp""             // for TR::NodeChecklist
+#include ""ras/DebugCounter.hpp""
+#include ""runtime/J9Profiler.hpp""
+#include ""control/Recompilation.hpp""              // for TR_Recompilation, etc
+#include ""control/RecompilationInfo.hpp""              // for TR_Recompilation, etc
+#include ""codegen/CodeGenerator.hpp""
+#include ""optimizer/TransformUtil.hpp""            // for TransformUtil
+
+#define COLD_BLOCK_FREQ 6
+
+// There are existing versions of these mappings, however, they will round up
+// types smaller than Int32
+TR::ILOpCodes
+directStore(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::astore;
+      case TR::Int64:
+         return TR::lstore;
+      case TR::Int32:
+         return TR::istore;
+      case TR::Int16:
+         return TR::sstore;
+      case TR::Int8:
+         return TR::bstore;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for store"");
+      }
+   }
+
+TR::ILOpCodes
+indirectStore(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::astorei;
+      case TR::Int64:
+         return TR::lstorei;
+      case TR::Int32:
+         return TR::istorei;
+      case TR::Int16:
+         return TR::sstorei;
+      case TR::Int8:
+         return TR::bstorei;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for indirect store"");
+      }
+   }
+
+TR::ILOpCodes
+indirectLoad(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::aloadi;
+      case TR::Int64:
+         return TR::lloadi;
+      case TR::Int32:
+         return TR::iloadi;
+      case TR::Int16:
+         return TR::sloadi;
+      case TR::Int8:
+         return TR::bloadi;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for indirect load"");
+      }
+   }
+
+TR::ILOpCodes
+loadConst(TR::DataType dt)
+   {
+   switch (dt)
+      {
+      case TR::Address:
+         return TR::aconst;
+      case TR::Int64:
+         return TR::lconst;
+      case TR::Int32:
+         return TR::iconst;
+      case TR::Int16:
+         return TR::sconst;
+      case TR::Int8:
+         return TR::bconst;
+      default:
+         TR_ASSERT_FATAL(0, ""Datatype not supported for const"");
+      }
+   }
+
+int32_t
+TR_ValueJProfiling::perform() 
+   {
+   /**
+    * JProfiling Configuration
+    *
+    * ValueJProfiling will insert value profiling trees and lower any existing placeholder
+    * profiling trees. It can operate in two different modes:
+    *
+    * For non-profiling compilations, placeholder trees are not expected. Instead, the optimization
+    * pass will instrument virtual calls, instanceofs and checkcasts for profiling.
+    *
+    * For profiling compilations, placeholder trees will be identified and lowered, assuming the compilation
+    * has been configured to use JProfiling.
+    */
+   if (comp()->getProfilingMode() == JProfiling)
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been enabled for profiling compilations, run ValueJProfiling\n"");
+      }
+   else if (comp()->getOption(TR_EnableJProfiling))
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been enabled, run ValueJProfiling\n"");
+      }
+   else 
+      {
+      if (trace())
+         traceMsg(comp(), ""JProfiling has been disabled, skip ValueJProfiling\n"");
+      return 0;
+      }
+
+   // Lower all existing calls
+   lowerCalls();
+
+   if (comp()->isProfilingCompilation())
+      {
+      TR::Recompilation *recomp = comp()->getRecompilationInfo();
+      TR_ValueProfiler *profiler = (TR_ValueProfiler*) recomp->getValueProfiler();
+      TR_ASSERT(profiler, ""Recompilation should have a ValueProfiler in a profiling compilation"");
+      profiler->setPostLowering();
+      }
+   else
+      {
+      TR::NodeChecklist checklist(comp());
+
+      // Identify and instrument profiling candidates
+      for (TR::TreeTop *cursor = comp()->getStartTree(); cursor; cursor = cursor->getNextTreeTop())
+         performOnNode(cursor->getNode(), cursor, &checklist);
+      }
+
+   return 1;
+   }
+
+void
+TR_ValueJProfiling::performOnNode(TR::Node *node, TR::TreeTop *tt, TR::NodeChecklist *checklist)
+   {
+   if (checklist->contains(node))
+      return;
+   checklist->add(node);
+
+   if (node->getOpCode().isCall() && node->getOpCode().isIndirect())
+      {
+      addVFTProfiling(node->getFirstChild(), tt, false);
+      }
+   else if (node->getOpCodeValue() == TR::instanceof || node->getOpCodeValue() == TR::checkcast)
+      {
+      addVFTProfiling(node->getFirstChild(), tt, true);
+      }
+
+   for (int i = 0; i < node->getNumChildren(); ++i)
+      performOnNode(node->getChild(i), tt, checklist);
+   }
+
+void
+TR_ValueJProfiling::addVFTProfiling(TR::Node *address, TR::TreeTop *tt, bool addNullCheck)
+   {
+   TR::Node *vftNode = TR::Node::createWithSymRef(address, TR::aloadi, 1, address,
+      getSymRefTab()->findOrCreateVftSymbolRef());
+
+   TR::Node *check = NULL;
+   TR::Node *fallback = NULL;
+   if (addNullCheck)
+      {
+      check = TR::Node::createif(TR::ifacmpeq, address, TR::Node::aconst(address, 0));
+      fallback = TR::Node::aconst(address, 0);
+      }
+
+   TR_ValueProfileInfo *valueProfileInfo = TR_PersistentProfileInfo::get(comp())->findOrCreateValueProfileInfo(comp());
+   TR_AbstractHashTableProfilerInfo *info = (TR_AbstractHashTableProfilerInfo*) valueProfileInfo->getOrCreateProfilerInfo(address->getByteCodeInfo(), comp(), AddressInfo, HashTableProfiler);
+
+   addProfilingTrees(comp(), tt, vftNode, info, check, fallback, true, trace());
+   }
+
+/**
+ * Identify helper calls to TR_jProfileValue and TR_jProfileLongValue, lowering them
+ * into the fast, slow and helper paths.
+ */
+void
+TR_ValueJProfiling::lowerCalls()
+   {
+   TR::TreeTop *cursor = comp()->getStartTree();
+   while (cursor)
+      {
+      TR::Node * node = cursor->getNode();
+
+      if (node->isProfilingCode() &&
+          node->getOpCodeValue() == TR::treetop &&
+          node->getFirstChild()->getOpCode().isCall() &&
+          (node->getFirstChild()->getSymbolReference()->getReferenceNumber() == TR_jProfile32BitValue ||
+           node->getFirstChild()->getSymbolReference()->getReferenceNumber() == TR_jProfile64BitValue) &&
+          node->getFirstChild()->getNumChildren() == 3)
+         {
+         TR::TreeTop *nextTree = cursor->getNextTreeTop();
+         TR::Node *child = node->getFirstChild();
+
+         dumpOptDetails(comp(), ""%s Replacing profiling placeholder n%dn with value profiling trees\n"",
+            optDetailString(), child->getGlobalIndex());
+
+         // Extract the arguments and add the profiling trees
+         TR::Node *value = child->getFirstChild();
+         TR_AbstractHashTableProfilerInfo *table = (TR_AbstractHashTableProfilerInfo*) child->getSecondChild()->getAddress();
+         addProfilingTrees(comp(), cursor, value, table, NULL, NULL, true, trace());
+
+         // Remove the original trees and continue from the tree after the profiling
+         TR::TransformUtil::removeTree(comp(), cursor);
+         cursor = nextTree;
+         }
+      else
+         cursor = cursor->getNextTreeTop();
+      }
+   }
+
+/*
+ * Insert the trees and control flow to profile a node after an insertion point.
+ * The original block will be split after the insertion point.
+ *
+ * An optional mapping, with a test and fallback value is supported. An example use of
+ * this is a vft lookup using an address that could be null. A null check is therefore
+ * necessary, using a fallback value of 0.
+ *
+ * ------------------
+ * | ...            |
+ * | insertionPoint |
+ * | ...            |
+ * ------------------
+ * 
+ * Becomes:
+ *
+ * | ...               |                                        
+ * | insertionPoint    |                                        
+ * | uncommoning       |
+ * | optionalTest      |---------------
+ * ---------------------              |
+ *          |                         |
+ *          v                         v
+ * ---------------------    ---------------------                                       
+ * | originalValue     |    | fallbackValue     |                                      
+ * ---------------------    ---------------------                                      
+ * | store temp 1      |    | store temp 1      |                                      
+ * |  value            |    |  fallback         |                                      
+ * ---------------------    ---------------------
+ *          |                        |
+ *          |-------------------------
+ *          v
+ * ---------------------                                        
+ * | quickTest         |                                        
+ * ---------------------                                        
+ * | store temp 2      |                                        
+ * |  hash             |                                        
+ * |   load temp 1     |                                        
+ * | ifne              |----------------------
+ * |  =>load temp 1    |                     |
+ * |  indirect load    |                     v
+ * |   add             |           ---------------------
+ * |    keysArray      |           | slowTest          |
+ * |    mult           |           ---------------------
+ * |     =>hash        |           | store temp 3      |
+ * |     width         |           |   indirect load   |
+ * ---------------------           |     otherIndex    |
+ *          |                      | ifeq              |-------------------
+ *          v                      |   load temp 3     |                  |
+ * ---------------------           |   const 0         |                  v
+ * | quickInc          |           ---------------------        ------------------
+ * ---------------------                    |                   | helper         |
+ * | incMemory         |                    v                   ------------------
+ * |   add             |           ---------------------        | call helper    |
+ * |     countsArray   |           | slowInc           |        |   load temp 1  |
+ * |     mult          |           ---------------------        |   tableAddress |
+ * |       load temp 2 |           | incMemory         |        ------------------
+ * |       countWidth  |           |   add             |                 |
+ * ---------------------           |     countsArray   |                 |
+ *          |                      |     mult          |                 |
+ *          |                      |       load temp 3 |                 |
+ *          |                      |       countWidth  |                 |
+ *          |                      ---------------------                 |
+ *          |                                |                           |
+ *          |-------------------------------------------------------------
+ *          v
+ * ---------------------
+ * | uncommoning       |
+ * | ...               |
+ *
+ * \param insertionPoint Treetop to insert profiling code after.
+ * \param value Value to profile.
+ * \param table Persistent TR_HashMapInfo which will be filled and incremented during profiling.
+ * \param optionalTest Option test node capable of preventing evaluation of value and using a fallbackValue instead.
+ * \param fallbackValue Fallback value to use with the optional test.
+ * \param extendBlocks Generates the blocks as extended, defaults true.
+ * \param trace Enable tracing.
+ */
+bool
+TR_ValueJProfiling::addProfilingTrees(
+    TR::Compilation *comp,
+    TR::TreeTop *insertionPoint,
+    TR::Node *value,
+    TR_AbstractHashTableProfilerInfo *table,
+    TR::Node *optionalTest,
+    TR::Node *fallbackValue,
+    bool extendBlocks,
+    bool trace)
+   {
+   // Common types used in calculation
+   TR::DataType counterType = TR::Int32;
+   TR::DataType lockType    = TR::Int16;
+   TR::DataType systemType  = TR::Compiler->target.is64Bit() ? TR::Int64 : TR::Int32;
+
+   // Type to use in calculations and table access
+   TR::DataType roundedType    = value->getType();
+   if (roundedType == TR::Int8 || roundedType == TR::Int16)
+      roundedType = TR::Int32;
+
+   if (trace)
+      {
+      traceMsg(comp, ""Inserting value profiling trees:\n  Value n%dn At n%dn\n  Table: %p\n"",
+         value->getGlobalIndex(),
+         insertionPoint->getNode()->getGlobalIndex(),
+         table);
+      table->trace(comp);
+      traceMsg(comp, ""  Test: %p Fallback: %p\n"", optionalTest, fallbackValue);
+      }
+
+   TR::Block    *originalBlock = insertionPoint->getEnclosingBlock();
+   TR::Block    *extendedBlock = originalBlock;
+   while (extendedBlock->isExtensionOfPreviousBlock())
+      extendedBlock = extendedBlock->getPrevBlock();
+
+   if (trace)
+      {
+      traceMsg(comp, ""  Modifying block_%d"", originalBlock->getNumber());
+      if (extendedBlock && extendedBlock != originalBlock)
+         traceMsg(comp, "" extending block_%d"", extendedBlock->getNumber());
+      traceMsg(comp, "" with profiling\n"");
+      }
+
+   // Cache the last treetop in the CFG
+   TR::CFG *cfg = comp->getFlowGraph();
+   cfg->setStructure(0);
+   TR::Block *cursor = originalBlock, *prev = originalBlock;
+   while (cursor && cursor != cfg->getEnd() && cursor != cfg->getStart() && cursor->getNumber())
+      {
+      prev = cursor;
+      cursor = cursor->getNextBlock();
+      }
+   TR::TreeTop *lastTreeTop = prev->getExit();
+
+   // Example node to use when constructing others 
+   TR::Node *example = value;
+
+   /********************* original Block *********************/
+   if (trace)
+      traceMsg(comp, "" Profiled value n%dn into temp\n"", value->getGlobalIndex());
+
+   // Store the value and replace references to it, if no fallback value can overwrite its value
+   TR::SymbolReference *storedValueSymRef = NULL;
+   TR::TreeTop *storeValue = TR::TreeTop::create(comp, insertionPoint, storeNode(comp, value, storedValueSymRef));
+   if (!optionalTest)
+      replaceNode(comp, extendedBlock->getEntry(), storeValue->getNextTreeTop(),
+         value, TR::Node::createLoad(example, storeValue->getNode()->getSymbolReference()));
+
+   // Split after the store
+   TR::Block *quickTest = originalBlock->split(storeValue->getNextTreeTop(), cfg, true, true);
+
+   /********************* fallback Block *********************/
+
+   // Insert the optional test and split after it
+   if (optionalTest)
+      {
+      TR_ASSERT_FATAL(fallbackValue, ""If introducing an optional test, a fallback value must be specified"");
+      TR::TreeTop *testTree = TR::TreeTop::create(comp, insertionPoint, optionalTest);
+
+      TR::Block *mapping = originalBlock->split(testTree->getNextTreeTop(), cfg, true, true);
+      if (extendBlocks)
+         mapping->setIsExtensionOfPreviousBlock();
+      
+      // Create the fallback block and link it to the optional test
+      TR::Block *fallback = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+      fallback->setIsCold();
+      lastTreeTop->join(fallback->getEntry());
+      lastTreeTop = fallback->getExit();
+      cfg->addNode(fallback);
+      cfg->addEdge(originalBlock, fallback);
+      cfg->addEdge(fallback, quickTest);
+      testTree->getNode()->setBranchDestination(fallback->getEntry());     
+
+      if (trace)
+         traceMsg(comp, ""  Fallback block_%d store to symRef #%d of node %p in \n"", fallback->getNumber(),
+            storedValueSymRef->getReferenceNumber(), fallback);
+
+      // Store and return to the mainline
+      TR::TreeTop::create(comp, fallback->getEntry(), TR::Node::create(example, TR::Goto, 0, quickTest->getEntry()));
+      TR::TreeTop::create(comp, fallback->getEntry(), storeNode(comp, fallbackValue, storedValueSymRef));
+      }
+   else if (extendBlocks)
+      quickTest->setIsExtensionOfPreviousBlock();
+
+   /********************* quickTest Block *********************/
+   // If blocks aren't being extended, its necessary to create a load
+   TR::Node *quickTestValue = value;
+   if (!extendBlocks || optionalTest)
+      quickTestValue = TR::Node::createLoad(example, storedValueSymRef);
+   quickTestValue = convertType(quickTestValue, roundedType);
+
+   if (trace)
+      traceMsg(comp, ""  Hash calculation in block_%d\n"", quickTest->getNumber());
+
+   // Base address for the table accesses, simplifies codegen
+   TR::Node *address = TR::Node::aconst(example, table->getBaseAddress());
+   TR::Node *index = convertType(computeHash(comp, table, quickTestValue, address), systemType);
+   
+   if (trace)
+      traceMsg(comp, ""  Key test based on index n%dn\n"", quickTest->getNumber(), index->getGlobalIndex());
+
+   // Generate the check to ensure the value is already in the chosen slot
+   TR::Node *checkKey = TR::Node::createif(comp->il.opCodeForIfCompareNotEquals(roundedType), quickTestValue,
+      loadValue(comp, roundedType, address, index, systemConst(example, table->getKeysOffset())));
+   TR::TreeTop *checkKeyTree = TR::TreeTop::create(comp, quickTest->getEntry(), checkKey);
+
+   /********************* quickInc Block *********************/
+   // If we aren't extending the blocks, anchor stores for the table address and the value
+   TR::Node *quickIncAddress = address;
+   TR::Node *quickIncIndex = index;
+   if (!extendBlocks)
+      {
+      TR::SymbolReference *storedIndexSymRef = NULL;
+      TR::SymbolReference *storedAddressSymRef = NULL;
+      TR::TreeTop::create(comp, quickTest->getEntry(), storeNode(comp, index, storedIndexSymRef));
+      TR::TreeTop::create(comp, quickTest->getEntry(), storeNode(comp, address, storedAddressSymRef));
+      storedAddressSymRef->getSymbol()->setNotCollected();
+
+      quickIncIndex = TR::Node::createLoad(example, storedIndexSymRef);
+      quickIncAddress = TR::Node::createLoad(example, storedAddressSymRef);
+      }
+
+   // Split the block, creating a new block to hold the successful quick increment
+   TR::Block *quickInc = quickTest->split(checkKeyTree->getNextTreeTop(), cfg, true, true);
+   if (extendBlocks)
+      quickInc->setIsExtensionOfPreviousBlock();
+
+   if (trace)
+      traceMsg(comp, ""  Quick increment in block_%d\n"", quickInc->getNumber());
+
+   TR::Node *counterOffset = systemConst(example, table->getFreqOffset());
+   TR::TreeTop *incTree = TR::TreeTop::create(comp, quickInc->getEntry(),
+      incrementMemory(comp, counterType, effectiveAddress(counterType, quickIncAddress, quickIncIndex, counterOffset)));
+
+   // Split the block again, after the increment, so cold paths can merge back
+   TR::Block *mainlineReturn = quickInc->split(incTree->getNextTreeTop(), cfg, true, true);
+
+   /********************* slowTest Block *********************/
+   TR::Block *slowTest = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+   slowTest->setIsCold();
+   lastTreeTop->join(slowTest->getEntry());
+   lastTreeTop = slowTest->getExit();
+   cfg->addNode(slowTest);
+   cfg->addEdge(quickTest, slowTest);
+   cfg->addEdge(slowTest, mainlineReturn);
+   checkKey->setBranchDestination(slowTest->getEntry());
+
+   if (trace)
+      traceMsg(comp, ""  Lock test in block_%d\n"", slowTest->getNumber());
+
+   // Load the lock and test if its set
+   TR::Node *lockAddress = TR::Node::aconst(example, table->getBaseAddress() + table->getLockOffset());
+   TR::Node *lock = loadValue(comp, lockType, lockAddress);
+   TR::Node *checkTableLock = TR::Node::createif(TR::ifscmplt, lock, TR::Node::sconst(example, 0));
+   TR::TreeTop::create(comp, slowTest->getEntry(), checkTableLock);
+
+   /********************* slowInc Block *********************/
+   TR::Node *slowIncIndex = convertType(lock, systemType);
+   if (!extendBlocks)
+      {
+      TR::SymbolReference *storedLockSymRef = NULL;
+      TR::TreeTop::create(comp, slowTest->getEntry(), storeNode(comp, convertType(lock, systemType), storedLockSymRef));
+      slowIncIndex = TR::Node::createLoad(example, storedLockSymRef);
+      }
+
+   // Split the block, creating a new block to hold the other increment
+   TR::Block *slowInc = slowTest->split(slowTest->getExit(), cfg, true, true);
+   lastTreeTop = slowInc->getExit();
+   if (extendBlocks)
+      slowInc->setIsExtensionOfPreviousBlock();
+
+   if (trace)
+      traceMsg(comp, ""  Slow increment in block_%d\n"", slowInc->getNumber());
+
+   // Add the other increment and return to mainline
+   TR::TreeTop::create(comp, slowInc->getEntry(), TR::Node::create(example, TR::Goto, 0, mainlineReturn->getEntry()));
+   TR::Node *counterAddress = TR::Node::aconst(example, table->getBaseAddress() + table->getFreqOffset());
+   TR::TreeTop::create(comp, slowInc->getEntry(), incrementMemory(comp, counterType,
+      effectiveAddress(counterType, counterAddress, slowIncIndex)));
+
+   /********************* helper Block *********************/
+   // Build the helper call path
+   TR::Block *helper = TR::Block::createEmptyBlock(comp, COLD_BLOCK_FREQ);
+   helper->setIsCold();
+   lastTreeTop->join(helper->getEntry());
+   lastTreeTop = helper->getExit();
+   cfg->addNode(helper);
+   cfg->addEdge(slowTest, helper);
+   cfg->addEdge(helper, mainlineReturn);
+   checkTableLock->setBranchDestination(helper->getEntry());
+
+   if (trace)
+      traceMsg(comp, ""  Helper call in block_%d\n"", helper->getNumber());
+
+   // Add the call to the helper and return to the mainline
+   TR::TreeTop::create(comp, helper->getEntry(), TR::Node::create(example, TR::Goto, 0, mainlineReturn->getEntry()));
+   TR::TreeTop *helperCallTreeTop = TR::TreeTop::create(comp, helper->getEntry(), createHelperCall(comp,
+      convertType(TR::Node::createLoad(example, storedValueSymRef), roundedType),
+      TR::Node::aconst(example, table->getBaseAddress())));
+
+   // Set profiling code flags
+   TR::NodeChecklist checklist(comp);
+   checklist.add(value);
+   TR::TreeTop *tt = quickTest->getEntry(), *end = mainlineReturn->getEntry(); 
+   while (tt && tt != end)
+      {
+      TR::Node *node = tt->getNode();
+      if (node->getOpCodeValue() != TR::BBStart && node->getOpCodeValue() != TR::BBEnd)
+         setProfilingCode(node, checklist);
+      tt = tt->getNextTreeTop();
+      }
+   tt = slowTest->getEntry();
+   end = NULL;
+   while (tt && tt != end)
+      {
+      TR::Node *node = tt->getNode();
+      if (node->getOpCodeValue() != TR::BBStart && node->getOpCodeValue() != TR::BBEnd)
+         setProfilingCode(node, checklist);
+      tt = tt->getNextTreeTop();
+      }
+
+   return true;
+   }
+
+/*
+ * Recursive call to replace origNode with newNode underneath a target node.
+ *
+ * \param check Node to search for reference to origNode.
+ * \param origNode Node to replace.
+ * \param newNode Node to use in its place.
+ * \param checklist Checklist of nodes that have already been searched.
+ */
+void
+TR_ValueJProfiling::replaceNode(TR::Node* check, TR::Node* origNode, TR::Node *newNode, TR::NodeChecklist &checklist)
+   {
+   if (checklist.contains(check))
+      return;
+   checklist.add(check);
+
+   for (uint32_t i = 0; i < check->getNumChildren(); ++i)
+      {
+      if (origNode && check->getChild(i) == origNode)
+         {
+         check->setAndIncChild(i, newNode);
+         origNode->decReferenceCount();
+         }
+      else
+         replaceNode(check->getChild(i), origNode, newNode, checklist);
+      }
+   }
+
+/*
+ * Replace all references to origNode under and after replaceStart with newNode.
+ *
+ * \param blockStart Start of the extended block containing replaceStart.
+ * \param origNode Node to replace.
+ * \param newNode Node to use in its place.
+ */
+void
+TR_ValueJProfiling::replaceNode(TR::Compilation *comp, TR::TreeTop *blockStart, TR::TreeTop *replaceStart,
+    TR::Node *origNode, TR::Node *newNode)
+   {
+   TR::NodeChecklist checklist(comp);
+   TR::TreeTop *tt = blockStart; 
+
+   // Collect all nodes seen before start of replace, these shouldn't be replaced
+   while (tt != replaceStart)
+      {
+      replaceNode(tt->getNode(), NULL, NULL, checklist);
+      tt = tt->getNextTreeTop();
+      }
+
+   // Begin replacing until the end of the extended block
+   while (tt)
+      {
+      if (tt->getNode()->getOpCodeValue() == TR::BBStart && !tt->getNode()->getBlock()->isExtensionOfPreviousBlock())
+         break;
+      replaceNode(tt->getNode(), origNode, newNode, checklist);
+      tt = tt->getNextTreeTop();
+      }
+   }
+
+/*
+ * Mark a node and its children as profiling code.
+ *
+ * \param node Node to process, marking it and its children.
+ * \param checklist Checklist of nodes already marked.
+ */
+void
+TR_ValueJProfiling::setProfilingCode(TR::Node *node, TR::NodeChecklist &checklist)
+   {
+   if (checklist.contains(node))
+      return;
+   checklist.add(node);
+
+   node->setIsProfilingCode();
+   for (uint32_t i = 0; i < node->getNumChildren(); ++i)
+      setProfilingCode(node->getChild(i), checklist);
+   }
+
+/*
+ * Generate the tree to store a value into a temporary symref. If no symref is specified, one will be generated.
+ *
+ * \param value Value to store.
+ * \param symRef Optional symref to store value into. Will be update to used symref if none specified.
+ */
+TR::Node *
+TR_ValueJProfiling::storeNode(TR::Compilation *comp, TR::Node *value, TR::SymbolReference* &symRef)
+   {
+   if (symRef == NULL)
+      symRef = comp->getSymRefTab()->createTemporary(comp->getMethodSymbol(), value->getDataType());
+
+   return TR::Node::createWithSymRef(value, directStore(value->getDataType()), 1, value, symRef);
+   }
+
+/*
+ * Given an address in X86's LEA form, generate a node structure to calculate a memory address for a desired
+ * data type. Address would be: base + width(dataType) * index + offset
+ *
+ * \param dataType Date type of value to address. Its width is used for calculations if index is specified.
+ * \param base Base address to load from.
+ * \param index Optional index.
+ * \param offset Optional offset from the base.
+ */
+TR::Node *
+TR_ValueJProfiling::effectiveAddress(TR::DataType dataType, TR::Node *base, TR::Node *index, TR::Node *offset)
+   {
+   if (offset)
+      {
+      if (offset->getDataType() == TR::Int64)
+         base = TR::Node::create(base, TR::aladd, 2, base, offset);
+      else if (offset->getDataType() == TR::Int32)
+         base = TR::Node::create(base, TR::aiadd, 2, base, offset);
+      else
+         TR_ASSERT_FATAL(0, ""Invalid type for address calculation integer"");
+      }
+
+   if (index)
+      {
+      uint8_t size = TR::DataType::getSize(dataType);
+      if (index->getDataType() == TR::Int64)
+         base = TR::Node::create(base, TR::aladd, 2, base, TR::Node::create(base, TR::lmul, 2, index, TR::Node::lconst(base, size)));
+      else if (index->getDataType() == TR::Int32)
+         base = TR::Node::create(base, TR::aiadd, 2, base, TR::Node::create(base, TR::imul, 2, index, TR::Node::iconst(base, size)));
+      else
+         TR_ASSERT_FATAL(0, ""Invalid type for address calculation integer"");
+      }
+
+   return base;
+   }
+
+/*
+ * Given an address in X86's LEA form, generate a node structure to load a value from the memory address of the desired
+ * data type. Address would be: base + width(dataType) * index + offset
+ *
+ * \param dataType Date type of value to load. Its width is used for calculations if index is specified.
+ * \param base Base address to load from.
+ * \param index Optional index.
+ * \param offset Optional offset from the base.
+ */
+TR::Node *
+TR_ValueJProfiling::loadValue(TR::Compilation *comp, TR::DataType dataType, TR::Node *base, TR::Node *index, TR::Node *offset)
+   {
+   base = effectiveAddress(dataType, base, index, offset);
+   TR::SymbolReference *symRef = comp->getSymRefTab()->findOrCreateArrayShadowSymbolRef(dataType, NULL);
+   TR::Node *result = TR::Node::createWithSymRef(base, indirectLoad(dataType), 1, base, symRef);
+
+   return result;
+   }
+
+/*
+ * Generate the helper call tree, which adds values to the table along the slowest path.
+ * Will return a treetop, with the call as its child.
+ *
+ * \param value Node representing the value to add to the table.
+ * \param table Address of the table's base.
+ */
+TR::Node *
+TR_ValueJProfiling::createHelperCall(TR::Compilation *comp, TR::Node *value, TR::Node *table)
+   {
+   TR::SymbolReference *profiler;
+   if (value->getDataType() == TR::Int32)
+      profiler = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_jProfile32BitValue, false, false, true);
+   else
+      profiler = comp->getSymRefTab()->findOrCreateRuntimeHelper(TR_jProfile64BitValue, false, false, true);
+
+#if defined(TR_HOST_POWER) || defined(TR_HOST_ARM)
+   profiler->getSymbol()->castToMethodSymbol()->setLinkage(TR_System);
+#else
+#ifndef TR_HOST_X86
+   profiler->getSymbol()->castToMethodSymbol()->setPreservesAllRegisters();
+#endif
+   profiler->getSymbol()->castToMethodSymbol()->setSystemLinkageDispatch();
+#endif
+
+   TR::Node *helperCall = TR::Node::createWithSymRef(value, TR::call, 2, profiler);
+   helperCall->setAndIncChild(0, value);
+   helperCall->setAndIncChild(1, table);
+   return TR::Node::create(TR::treetop, 1, helperCall);
+   }
+
+/*
+ * Increment a memory address by 1. Used to increment the table's counters on both the match and other
+ * paths.
+ *
+ * \param counterType The memory addresses type, usually Int32 or Int64.
+ * \param address The memory address to increment.
+ */
+TR::Node *
+TR_ValueJProfiling::incrementMemory(TR::Compilation *comp, TR::DataType counterType, TR::Node *address)
+   {
+   TR::SymbolReference *symRef = comp->getSymRefTab()->findOrCreateArrayShadowSymbolRef(counterType, NULL);
+
+   TR::Node *load = TR::Node::createWithSymRef(address, indirectLoad(counterType), 1, address, symRef);
+   TR::Node *incCounter = TR::Node::create(address, counterType == TR::Int32 ? TR::iadd : TR::ladd, 2, load,
+      TR::Node::create(address, loadConst(counterType), 0, 1));
+   TR::Node *storeCounter = TR::Node::createWithSymRef(address, indirectStore(counterType), 2,
+      address, symRef);
+   storeCounter->setAndIncChild(1, incCounter);
+
+   return storeCounter;
+   }
+
+/*
+ * Generate a constant node matching the system's address width. Used for address calculations.
+ *
+ * \param example Example node to copy BCI.
+ * \param value Value to store in const.
+ */
+TR::Node *
+TR_ValueJProfiling::systemConst(TR::Node *example, uint64_t value)
+   {
+   TR::ILOpCodes constOp = TR::Compiler->target.is64Bit() ? TR::lconst : TR::iconst;
+   return TR::Node::create(example, constOp, 0, value);
+   }
+
+/*
+ * Its sometimes necessary to convert values to their rounded integer representation, in Int32
+ * or Int64, or to convert values to the system type, again in Int32 or Int64. This method
+ * handles those conversions as necessary. All conversions are unsigned.
+ *
+ * \param index The value to convert.
+ * \param dataType The datatype to convert to.
+ */
+TR::Node *
+TR_ValueJProfiling::convertType(TR::Node *index, TR::DataType dataType)
+   {
+   if (index->getDataType() == dataType)
+      return index;
+   else if (dataType == TR::Int64) 
+      {
+      switch (index->getDataType())
+         {
+         case TR::Int64:
+            return index;
+         case TR::Int32:
+            return TR::Node::create(index, TR::iu2l, 1, index);
+         case TR::Int16:
+            return TR::Node::create(index, TR::su2l, 1, index);
+         case TR::Int8:
+            return TR::Node::create(index, TR::bu2l, 1, index);
+         case TR::Address:
+            return TR::Node::create(index, TR::a2l, 1, index);
+         default:
+            TR_ASSERT_FATAL(0, ""Unsupported source data type"");
+         }
+      }
+   else if (dataType == TR::Int32)
+      {
+      switch (index->getDataType())
+         {
+         case TR::Int64:
+            return TR::Node::create(index, TR::l2i, 1, index);
+         case TR::Int32:
+            return index;
+         case TR::Int16:
+            return TR::Node::create(index, TR::su2i, 1, index);
+         case TR::Int8:
+            return TR::Node::create(index, TR::bu2i, 1, index);
+         case TR::Address:
+            return TR::Node::create(index, TR::a2i, 1, index);
+         default:
+            TR_ASSERT_FATAL(0, ""Unsupported source data type"");
+         }
+      }
+
+   TR_ASSERT_FATAL(0, ""Unsupported target data type"");
+   return NULL;
+   }
+
+TR::Node *
+TR_ValueJProfiling::computeHash(TR::Compilation *comp, TR_AbstractHashTableProfilerInfo *table, TR::Node *value, TR::Node *baseAddr)
+   {
+   if (!baseAddr)
+      baseAddr = TR::Node::aconst(value, (uintptr_t) table);
+
+   TR::ILOpCodes shiftOp = table->getDataType() == TR::Int32 ? TR::iushr : TR::lushr;",might this look and read better as a setup of the whole thing for say Int64 and then a if Int32 overwrite them all and if something else assert? The repeated testing is a bit ugly and will be slower than necessary.,
81679115,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/optimizer/ValueJProfiling.hpp,False,"@@ -0,0 +1,84 @@
+/*******************************************************************************
+ * Copyright (c) 2000, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+#ifndef VALUEJPROFILING_INCL
+#define VALUEJPROFILING_INCL
+
+#include <stdint.h>                           // for int32_t
+#include ""optimizer/Optimization.hpp""         // for Optimization
+#include ""optimizer/OptimizationManager.hpp""  // for OptimizationManager
+#include ""infra/Checklist.hpp""                // fir NodeChecklist
+
+#include ""runtime/J9ValueProfiler.hpp""
+
+class TR_ValueJProfiling : public TR::Optimization
+   {
+   public:
+
+   TR_ValueJProfiling(TR::OptimizationManager *manager)
+      : TR::Optimization(manager)
+      {}
+   static TR::Optimization *create(TR::OptimizationManager *manager)
+      {
+      return new (manager->allocator()) TR_ValueJProfiling(manager);
+      }
+
+   virtual int32_t perform();
+   virtual const char *optDetailString() const throw();
+
+   void lowerCalls();
+   void addVFTProfiling(TR::Node *address, TR::TreeTop *tt, bool addNullCheck);
+   void performOnNode(TR::Node *node, TR::TreeTop *tt, TR::NodeChecklist *checklist);
+
+   static bool addProfilingTrees(
+      TR::Compilation *comp,
+      TR::TreeTop *insertionPoint,
+      TR::Node *value,
+      TR_AbstractHashTableProfilerInfo *table,
+      TR::Node *optionalTest = NULL,
+      TR::Node *fallbackValue = NULL,
+      bool extendBlocks = true,
+      bool trace = false);
+
+   private:
+   static const size_t DEFAULT_TABLE_BITS = 2;",Can we have a comment on what this means here please?,
81679357,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/runtime/J9ValueProfiler.hpp,False,"@@ -42,6 +42,8 @@ extern TR::Monitor *vpMonitor;
 
 #define ARRAY_MAX_NUM_VALUES (5)
 #define LINKEDLIST_MAX_NUM_VALUES (20)
+#define HASHTABLE_MAX_BITS  (8)",comments on these are warranted,
81679890,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/runtime/ValueProfiler.cpp,False,"@@ -188,13 +207,66 @@ TR_LinkedListProfilerInfo<TR_ByteInfo>::trace(TR::Compilation *comp)
    traceMsg(comp, ""   Num: %d Total Frequency: %d\n"", count, getTotalFrequency());
    }
 
+/**
+ * Lock access to the map, blocking if necessary.
+ */
+void
+TR_AbstractHashTableProfilerInfo::lock()
+   {
+   while (!tryLock())
+      {
+      // TODO: Does this need a yield?
+      }
+   }
+
+/**
+ * Try to lock access to the map.
+ *
+ * \param disableJITAccess This will trigger the short circuit test in JITed code.
+ */
+bool
+TR_AbstractHashTableProfilerInfo::tryLock(bool disableJITAccess)
+   {
+   // Set lock and, if desired, clear high bit in other index
+   MetaData locked = _metaData;
+   if (disableJITAccess)
+      locked.otherIndex &= ~HASHTABLE_LOCK_BIT;
+   locked.lock = 1;
+
+   // Current state must be unlocked
+   MetaData unlocked = _metaData;
+   unlocked.lock = 0;
+
+   return platformCompareSwap((uint32_t*) &_metaData, unlocked.rawData, locked.rawData);
+   }
+
+/**
+ * Unlock the map.
+ *
+ * \param enableJITAccess This will disable the short circuit test in JITed code.
+ */
+void
+TR_AbstractHashTableProfilerInfo::unlock(bool enableJITAccess)
+   {
+   // Clear lock and, if desired, set high bit in other index
+   MetaData unlocked = _metaData;
+   if (enableJITAccess)
+      unlocked.otherIndex |= HASHTABLE_LOCK_BIT;
+   unlocked.lock = 0;
+
+   // Overwrite what ever value is there
+   platformCompareSwap((uint32_t*) &_metaData, _metaData.rawData, unlocked.rawData);
+   }
+
 #if defined(TR_HOST_POWER)
 JIT_HELPER(_jitProfileValue);
 JIT_HELPER(_jitProfileLongValue);
 JIT_HELPER(_jitProfileBigDecimalValue);
 JIT_HELPER(_jitProfileStringValue);
 JIT_HELPER(_jitProfileAddress);
 JIT_HELPER(_jitProfileWarmCompilePICAddress);
+JIT_HELPER(_jProfileValue);",should we call this jProfileIntValue? That way if we contribute it up to OMR where profiling of sub int values may be warranted the additions don't require refactoring?,
81949166,3eac6b01e48ce5282ef73bf12b422e59020ca7ba,runtime/compiler/trj9/compile/J9Compilation.hpp,False,"@@ -164,8 +164,7 @@ class OMR_EXTENSIBLE Compilation : public OMR::CompilationConnector
 
    bool pendingPushLivenessDuringIlgen();
 
-   TR::list<TR_MethodValueProfileInfo*> &getMethodVPInfos() { return _methodVPInfoList; }
-   TR::list<TR_MethodValueProfileInfo*> &getMethodHWVPInfos() { return _methodHWVPInfoList; }
+   TR::list<TR_ExternalValueProfileInfo*> &getExternalVPInfos() { return _externalVPInfoList; }",@dsouzai you might be interested in this part of the change - any comments?,
85070498,d9d8064b92a7cdd41868f67cb7d23d1651fac78b,doc/compiler/JProfiling.md,False,"@@ -20,6 +20,124 @@ OpenJDK Assembly Exception [2].
 SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 -->
 
+# Value JProfiling
+
+JProfiling provides block frequency and value info profiling with low overhead.
+This documentation focuses on the value info profiling implementation.
+
+Value JProfiling relies on the insight that profiling information is only
+significant when a small set of highly frequent values exist for a variable,
+as these values enable optimization. Therefore, the implementation can avoid
+the overhead of full fidelity value profiling, whilst providing the same benefits,
+by only recording the most frequency values and detecting the case where
+there are none.
+
+## Implementation
+
+Each profiled variable receives a constant sized hash table and an *other*
+counter. The hash table maps a value to the frequency with which it
+is seen. When attempting to increment the frequency for a value, a hash
+table lookup is performed. If the value is found, its corresponding frequency
+is incremented. Otherwise, the value is either added to the table or
+the *other* counter is incremented, depending on if the table has
+reached its capacity.
+
+This approach limits the overhead introduced by profiling, as variables
+with a small set of highly frequent values will mostly consist of cheap
+hash table lookups and increments. Adding values to the table may be
+expensive, due to the computation and synchronization required, however
+this is limited by the tables capacity, with the remaining values
+being cheaply attributed to the *other* counter.
+
+The process of incrementing the frequency for an existing value or the
+*other* counter has been implemented in the IL, whilst the addition
+of values to the table is managed by a helper call. This avoids locality
+issues due to frequent calls and allows for other optimizations to further
+reduce the instrumentation's disruption to the mainline.
+
+There are various implementations of the hash function, all based around
+the X86 instruction `pext`. *N* bits are identified amongst the *N + 1* values
+held in the table, such that they can distinguish between then. These bits are
+extracted from the value and gathered into the low bits of an index, capable
+of addressing an array of length *2^N*. This index is used to extract values
+and frequencies from the hash table. The approach trades runtime performance
+for memory overhead, as the hash table size doubles for every additional value it
+is to support. These additional slots are mostly left unused.
+
+When adding a value to the table, the prior *N* selected bits are thrown
+out and a new set of *N + 1* bits are chosen, based on the table's existing
+contents and the new value. This may require rearrangement of the existing
+values if the bits change sufficiently. To ensure this rearrangement process
+won't race with other threads attempting to add to the table or increments
+from the jitted code, the table's is locked and its keys are manipulated
+to avoid any matches. This is achieved by backing up the values, setting
+the first slot to -1 and setting the rest to 0, relying on that fact
+that a value of 0 will always be placed on the first slot due to the
+hash function. Values are then rearranged in their backed up data structure
+and then committed back once the process has finished. Frequencies can
+be rearranged in place, as no increments should occur.
+
+During this process, other threads will increment the *other* counter so
+that the total frequency remains accurate. This process is complicated by 
+placing in the *other* counter in an unused slot. This is desirable, as a
+table with a capacity of 3 or greater will have at least one counter slot
+that is not in use. The frequency slot being used as the *other* counter
+cannot move during rearragnment, as it may race with other moves. To
+get around this, the final destination of the *other* counter is stashed
+and then performed as the final rearrangement.
+
+Once the values and frequencies have been rearranged, the new hash
+configuration can be committed and the addition is finished.
+If the table reached its capacity, the full flag is set and any new
+values seen in jitted code are attributed to the *other* counter.
+An additional optimization is made here, to cut down on memory accesses.
+The table is considered full when the index for the *other* counter
+is positive, so the tested value can be used immediately to increment
+the counter. In the event that its negative, the helper should be
+called to add a new value to the table.
+
+As the table populates based on the first distinct values that are
+seen, its possible to have ignored highly frequent values, for example due to
+an early phase change. To account for this, a thread inspects the hash
+tables and clears any with high *other* counters relative to that of the
+profiled values. If it decides that highly frequency values have been
+missed, it will reset the table and allow it to repopulate.
+
+Each table has a lock bit, which is locked when accessing data from a
+compilation thread, rearranging in the helper or clearing in the
+thread. Increments from the mainline do check this lock, to avoid",should this be 'do' or 'do not'?,
85070671,d9d8064b92a7cdd41868f67cb7d23d1651fac78b,doc/compiler/JProfiling.md,False,"@@ -20,6 +20,124 @@ OpenJDK Assembly Exception [2].
 SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 -->
 
+# Value JProfiling
+
+JProfiling provides block frequency and value info profiling with low overhead.
+This documentation focuses on the value info profiling implementation.
+
+Value JProfiling relies on the insight that profiling information is only
+significant when a small set of highly frequent values exist for a variable,
+as these values enable optimization. Therefore, the implementation can avoid
+the overhead of full fidelity value profiling, whilst providing the same benefits,
+by only recording the most frequency values and detecting the case where
+there are none.
+
+## Implementation
+
+Each profiled variable receives a constant sized hash table and an *other*
+counter. The hash table maps a value to the frequency with which it
+is seen. When attempting to increment the frequency for a value, a hash
+table lookup is performed. If the value is found, its corresponding frequency
+is incremented. Otherwise, the value is either added to the table or
+the *other* counter is incremented, depending on if the table has
+reached its capacity.
+
+This approach limits the overhead introduced by profiling, as variables
+with a small set of highly frequent values will mostly consist of cheap
+hash table lookups and increments. Adding values to the table may be
+expensive, due to the computation and synchronization required, however
+this is limited by the tables capacity, with the remaining values
+being cheaply attributed to the *other* counter.
+
+The process of incrementing the frequency for an existing value or the
+*other* counter has been implemented in the IL, whilst the addition
+of values to the table is managed by a helper call. This avoids locality
+issues due to frequent calls and allows for other optimizations to further
+reduce the instrumentation's disruption to the mainline.
+
+There are various implementations of the hash function, all based around
+the X86 instruction `pext`. *N* bits are identified amongst the *N + 1* values
+held in the table, such that they can distinguish between then. These bits are
+extracted from the value and gathered into the low bits of an index, capable
+of addressing an array of length *2^N*. This index is used to extract values
+and frequencies from the hash table. The approach trades runtime performance
+for memory overhead, as the hash table size doubles for every additional value it
+is to support. These additional slots are mostly left unused.
+
+When adding a value to the table, the prior *N* selected bits are thrown
+out and a new set of *N + 1* bits are chosen, based on the table's existing
+contents and the new value. This may require rearrangement of the existing
+values if the bits change sufficiently. To ensure this rearrangement process
+won't race with other threads attempting to add to the table or increments
+from the jitted code, the table's is locked and its keys are manipulated
+to avoid any matches. This is achieved by backing up the values, setting
+the first slot to -1 and setting the rest to 0, relying on that fact
+that a value of 0 will always be placed on the first slot due to the
+hash function. Values are then rearranged in their backed up data structure
+and then committed back once the process has finished. Frequencies can
+be rearranged in place, as no increments should occur.
+
+During this process, other threads will increment the *other* counter so
+that the total frequency remains accurate. This process is complicated by 
+placing in the *other* counter in an unused slot. This is desirable, as a
+table with a capacity of 3 or greater will have at least one counter slot
+that is not in use. The frequency slot being used as the *other* counter
+cannot move during rearragnment, as it may race with other moves. To
+get around this, the final destination of the *other* counter is stashed
+and then performed as the final rearrangement.
+
+Once the values and frequencies have been rearranged, the new hash
+configuration can be committed and the addition is finished.
+If the table reached its capacity, the full flag is set and any new
+values seen in jitted code are attributed to the *other* counter.
+An additional optimization is made here, to cut down on memory accesses.
+The table is considered full when the index for the *other* counter
+is positive, so the tested value can be used immediately to increment
+the counter. In the event that its negative, the helper should be
+called to add a new value to the table.
+
+As the table populates based on the first distinct values that are
+seen, its possible to have ignored highly frequent values, for example due to
+an early phase change. To account for this, a thread inspects the hash
+tables and clears any with high *other* counters relative to that of the
+profiled values. If it decides that highly frequency values have been
+missed, it will reset the table and allow it to repopulate.
+
+Each table has a lock bit, which is locked when accessing data from a
+compilation thread, rearranging in the helper or clearing in the
+thread. Increments from the mainline do check this lock, to avoid
+the overhead. Additionally, these increments are not atomic, due to
+the overhead, which may result in races. In testing, this did not affect",perhaps replace from overhead to the end of the sentence with 'overhead caused by synchronization'?,
85070781,d9d8064b92a7cdd41868f67cb7d23d1651fac78b,doc/compiler/JProfiling.md,False,"@@ -20,6 +20,124 @@ OpenJDK Assembly Exception [2].
 SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 -->
 
+# Value JProfiling
+
+JProfiling provides block frequency and value info profiling with low overhead.
+This documentation focuses on the value info profiling implementation.
+
+Value JProfiling relies on the insight that profiling information is only
+significant when a small set of highly frequent values exist for a variable,
+as these values enable optimization. Therefore, the implementation can avoid
+the overhead of full fidelity value profiling, whilst providing the same benefits,
+by only recording the most frequency values and detecting the case where
+there are none.
+
+## Implementation
+
+Each profiled variable receives a constant sized hash table and an *other*
+counter. The hash table maps a value to the frequency with which it
+is seen. When attempting to increment the frequency for a value, a hash
+table lookup is performed. If the value is found, its corresponding frequency
+is incremented. Otherwise, the value is either added to the table or
+the *other* counter is incremented, depending on if the table has
+reached its capacity.
+
+This approach limits the overhead introduced by profiling, as variables
+with a small set of highly frequent values will mostly consist of cheap
+hash table lookups and increments. Adding values to the table may be
+expensive, due to the computation and synchronization required, however
+this is limited by the tables capacity, with the remaining values
+being cheaply attributed to the *other* counter.
+
+The process of incrementing the frequency for an existing value or the
+*other* counter has been implemented in the IL, whilst the addition
+of values to the table is managed by a helper call. This avoids locality
+issues due to frequent calls and allows for other optimizations to further
+reduce the instrumentation's disruption to the mainline.
+
+There are various implementations of the hash function, all based around
+the X86 instruction `pext`. *N* bits are identified amongst the *N + 1* values
+held in the table, such that they can distinguish between then. These bits are
+extracted from the value and gathered into the low bits of an index, capable
+of addressing an array of length *2^N*. This index is used to extract values
+and frequencies from the hash table. The approach trades runtime performance
+for memory overhead, as the hash table size doubles for every additional value it
+is to support. These additional slots are mostly left unused.
+
+When adding a value to the table, the prior *N* selected bits are thrown
+out and a new set of *N + 1* bits are chosen, based on the table's existing
+contents and the new value. This may require rearrangement of the existing
+values if the bits change sufficiently. To ensure this rearrangement process
+won't race with other threads attempting to add to the table or increments
+from the jitted code, the table's is locked and its keys are manipulated
+to avoid any matches. This is achieved by backing up the values, setting
+the first slot to -1 and setting the rest to 0, relying on that fact
+that a value of 0 will always be placed on the first slot due to the
+hash function. Values are then rearranged in their backed up data structure
+and then committed back once the process has finished. Frequencies can
+be rearranged in place, as no increments should occur.
+
+During this process, other threads will increment the *other* counter so
+that the total frequency remains accurate. This process is complicated by 
+placing in the *other* counter in an unused slot. This is desirable, as a
+table with a capacity of 3 or greater will have at least one counter slot
+that is not in use. The frequency slot being used as the *other* counter
+cannot move during rearragnment, as it may race with other moves. To
+get around this, the final destination of the *other* counter is stashed
+and then performed as the final rearrangement.
+
+Once the values and frequencies have been rearranged, the new hash
+configuration can be committed and the addition is finished.
+If the table reached its capacity, the full flag is set and any new
+values seen in jitted code are attributed to the *other* counter.
+An additional optimization is made here, to cut down on memory accesses.
+The table is considered full when the index for the *other* counter
+is positive, so the tested value can be used immediately to increment
+the counter. In the event that its negative, the helper should be
+called to add a new value to the table.
+
+As the table populates based on the first distinct values that are
+seen, its possible to have ignored highly frequent values, for example due to
+an early phase change. To account for this, a thread inspects the hash
+tables and clears any with high *other* counters relative to that of the
+profiled values. If it decides that highly frequency values have been
+missed, it will reset the table and allow it to repopulate.
+
+Each table has a lock bit, which is locked when accessing data from a
+compilation thread, rearranging in the helper or clearing in the
+thread. Increments from the mainline do check this lock, to avoid
+the overhead. Additionally, these increments are not atomic, due to
+the overhead, which may result in races. In testing, this did not affect
+results sufficiently to negatively impact optimizations.
+It should be noted that, unlike the global monitor used by other profiling
+implementations, the lock is not reentrant.
+
+In addition to the `pext` hash function, other are supported. One approach",other => others,
85070963,d9d8064b92a7cdd41868f67cb7d23d1651fac78b,doc/compiler/JProfiling.md,False,"@@ -20,6 +20,124 @@ OpenJDK Assembly Exception [2].
 SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 -->
 
+# Value JProfiling
+
+JProfiling provides block frequency and value info profiling with low overhead.
+This documentation focuses on the value info profiling implementation.
+
+Value JProfiling relies on the insight that profiling information is only
+significant when a small set of highly frequent values exist for a variable,
+as these values enable optimization. Therefore, the implementation can avoid
+the overhead of full fidelity value profiling, whilst providing the same benefits,
+by only recording the most frequency values and detecting the case where
+there are none.
+
+## Implementation
+
+Each profiled variable receives a constant sized hash table and an *other*
+counter. The hash table maps a value to the frequency with which it
+is seen. When attempting to increment the frequency for a value, a hash
+table lookup is performed. If the value is found, its corresponding frequency
+is incremented. Otherwise, the value is either added to the table or
+the *other* counter is incremented, depending on if the table has
+reached its capacity.
+
+This approach limits the overhead introduced by profiling, as variables
+with a small set of highly frequent values will mostly consist of cheap
+hash table lookups and increments. Adding values to the table may be
+expensive, due to the computation and synchronization required, however
+this is limited by the tables capacity, with the remaining values
+being cheaply attributed to the *other* counter.
+
+The process of incrementing the frequency for an existing value or the
+*other* counter has been implemented in the IL, whilst the addition
+of values to the table is managed by a helper call. This avoids locality
+issues due to frequent calls and allows for other optimizations to further
+reduce the instrumentation's disruption to the mainline.
+
+There are various implementations of the hash function, all based around
+the X86 instruction `pext`. *N* bits are identified amongst the *N + 1* values
+held in the table, such that they can distinguish between then. These bits are
+extracted from the value and gathered into the low bits of an index, capable
+of addressing an array of length *2^N*. This index is used to extract values
+and frequencies from the hash table. The approach trades runtime performance
+for memory overhead, as the hash table size doubles for every additional value it
+is to support. These additional slots are mostly left unused.
+
+When adding a value to the table, the prior *N* selected bits are thrown
+out and a new set of *N + 1* bits are chosen, based on the table's existing
+contents and the new value. This may require rearrangement of the existing
+values if the bits change sufficiently. To ensure this rearrangement process
+won't race with other threads attempting to add to the table or increments
+from the jitted code, the table's is locked and its keys are manipulated
+to avoid any matches. This is achieved by backing up the values, setting
+the first slot to -1 and setting the rest to 0, relying on that fact
+that a value of 0 will always be placed on the first slot due to the
+hash function. Values are then rearranged in their backed up data structure
+and then committed back once the process has finished. Frequencies can
+be rearranged in place, as no increments should occur.
+
+During this process, other threads will increment the *other* counter so
+that the total frequency remains accurate. This process is complicated by 
+placing in the *other* counter in an unused slot. This is desirable, as a
+table with a capacity of 3 or greater will have at least one counter slot
+that is not in use. The frequency slot being used as the *other* counter
+cannot move during rearragnment, as it may race with other moves. To
+get around this, the final destination of the *other* counter is stashed
+and then performed as the final rearrangement.
+
+Once the values and frequencies have been rearranged, the new hash
+configuration can be committed and the addition is finished.
+If the table reached its capacity, the full flag is set and any new
+values seen in jitted code are attributed to the *other* counter.
+An additional optimization is made here, to cut down on memory accesses.
+The table is considered full when the index for the *other* counter
+is positive, so the tested value can be used immediately to increment
+the counter. In the event that its negative, the helper should be
+called to add a new value to the table.
+
+As the table populates based on the first distinct values that are
+seen, its possible to have ignored highly frequent values, for example due to
+an early phase change. To account for this, a thread inspects the hash
+tables and clears any with high *other* counters relative to that of the
+profiled values. If it decides that highly frequency values have been
+missed, it will reset the table and allow it to repopulate.
+
+Each table has a lock bit, which is locked when accessing data from a
+compilation thread, rearranging in the helper or clearing in the
+thread. Increments from the mainline do check this lock, to avoid
+the overhead. Additionally, these increments are not atomic, due to
+the overhead, which may result in races. In testing, this did not affect
+results sufficiently to negatively impact optimizations.
+It should be noted that, unlike the global monitor used by other profiling
+implementations, the lock is not reentrant.
+
+In addition to the `pext` hash function, other are supported. One approach
+uses an array of bytes specifying shifts to apply to the original value.
+This is implemented using existing opcodes and should be supported on all
+platforms. A more efficient implementation exists using the new `bitpermute`
+opcode, configured with an array of bytes specifying bit indices, rather
+than shifts. If supported by the codegen, the `bitpermute` approach will",perhaps name the query which must return true from the cg for the bitpermute to be used?,
85071101,d9d8064b92a7cdd41868f67cb7d23d1651fac78b,doc/compiler/JProfiling.md,False,"@@ -20,6 +20,124 @@ OpenJDK Assembly Exception [2].
 SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 -->
 
+# Value JProfiling
+
+JProfiling provides block frequency and value info profiling with low overhead.
+This documentation focuses on the value info profiling implementation.
+
+Value JProfiling relies on the insight that profiling information is only
+significant when a small set of highly frequent values exist for a variable,
+as these values enable optimization. Therefore, the implementation can avoid
+the overhead of full fidelity value profiling, whilst providing the same benefits,
+by only recording the most frequency values and detecting the case where
+there are none.
+
+## Implementation
+
+Each profiled variable receives a constant sized hash table and an *other*
+counter. The hash table maps a value to the frequency with which it
+is seen. When attempting to increment the frequency for a value, a hash
+table lookup is performed. If the value is found, its corresponding frequency
+is incremented. Otherwise, the value is either added to the table or
+the *other* counter is incremented, depending on if the table has
+reached its capacity.
+
+This approach limits the overhead introduced by profiling, as variables
+with a small set of highly frequent values will mostly consist of cheap
+hash table lookups and increments. Adding values to the table may be
+expensive, due to the computation and synchronization required, however
+this is limited by the tables capacity, with the remaining values
+being cheaply attributed to the *other* counter.
+
+The process of incrementing the frequency for an existing value or the
+*other* counter has been implemented in the IL, whilst the addition
+of values to the table is managed by a helper call. This avoids locality
+issues due to frequent calls and allows for other optimizations to further
+reduce the instrumentation's disruption to the mainline.
+
+There are various implementations of the hash function, all based around
+the X86 instruction `pext`. *N* bits are identified amongst the *N + 1* values
+held in the table, such that they can distinguish between then. These bits are
+extracted from the value and gathered into the low bits of an index, capable
+of addressing an array of length *2^N*. This index is used to extract values
+and frequencies from the hash table. The approach trades runtime performance
+for memory overhead, as the hash table size doubles for every additional value it
+is to support. These additional slots are mostly left unused.
+
+When adding a value to the table, the prior *N* selected bits are thrown
+out and a new set of *N + 1* bits are chosen, based on the table's existing
+contents and the new value. This may require rearrangement of the existing
+values if the bits change sufficiently. To ensure this rearrangement process
+won't race with other threads attempting to add to the table or increments
+from the jitted code, the table's is locked and its keys are manipulated
+to avoid any matches. This is achieved by backing up the values, setting
+the first slot to -1 and setting the rest to 0, relying on that fact
+that a value of 0 will always be placed on the first slot due to the
+hash function. Values are then rearranged in their backed up data structure
+and then committed back once the process has finished. Frequencies can
+be rearranged in place, as no increments should occur.
+
+During this process, other threads will increment the *other* counter so
+that the total frequency remains accurate. This process is complicated by 
+placing in the *other* counter in an unused slot. This is desirable, as a
+table with a capacity of 3 or greater will have at least one counter slot
+that is not in use. The frequency slot being used as the *other* counter
+cannot move during rearragnment, as it may race with other moves. To
+get around this, the final destination of the *other* counter is stashed
+and then performed as the final rearrangement.
+
+Once the values and frequencies have been rearranged, the new hash
+configuration can be committed and the addition is finished.
+If the table reached its capacity, the full flag is set and any new
+values seen in jitted code are attributed to the *other* counter.
+An additional optimization is made here, to cut down on memory accesses.
+The table is considered full when the index for the *other* counter
+is positive, so the tested value can be used immediately to increment
+the counter. In the event that its negative, the helper should be
+called to add a new value to the table.
+
+As the table populates based on the first distinct values that are
+seen, its possible to have ignored highly frequent values, for example due to
+an early phase change. To account for this, a thread inspects the hash
+tables and clears any with high *other* counters relative to that of the
+profiled values. If it decides that highly frequency values have been
+missed, it will reset the table and allow it to repopulate.
+
+Each table has a lock bit, which is locked when accessing data from a
+compilation thread, rearranging in the helper or clearing in the
+thread. Increments from the mainline do check this lock, to avoid
+the overhead. Additionally, these increments are not atomic, due to
+the overhead, which may result in races. In testing, this did not affect
+results sufficiently to negatively impact optimizations.
+It should be noted that, unlike the global monitor used by other profiling
+implementations, the lock is not reentrant.
+
+In addition to the `pext` hash function, other are supported. One approach
+uses an array of bytes specifying shifts to apply to the original value.
+This is implemented using existing opcodes and should be supported on all
+platforms. A more efficient implementation exists using the new `bitpermute`
+opcode, configured with an array of bytes specifying bit indices, rather
+than shifts. If supported by the codegen, the `bitpermute` approach will
+be used.
+
+## Configuration
+
+Value JProfiling can be used to replace JitProfiling. In this configuration,
+all existing requests for value profiling trees will insert placeholder
+JProfiling helper calls. The JProfilingValue optimization pass will run
+late in the opt strategy, lower these placeholders into the partial IL and",strategy and will lower,
85071184,d9d8064b92a7cdd41868f67cb7d23d1651fac78b,doc/compiler/JProfiling.md,False,"@@ -20,6 +20,124 @@ OpenJDK Assembly Exception [2].
 SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 -->
 
+# Value JProfiling
+
+JProfiling provides block frequency and value info profiling with low overhead.
+This documentation focuses on the value info profiling implementation.
+
+Value JProfiling relies on the insight that profiling information is only
+significant when a small set of highly frequent values exist for a variable,
+as these values enable optimization. Therefore, the implementation can avoid
+the overhead of full fidelity value profiling, whilst providing the same benefits,
+by only recording the most frequency values and detecting the case where
+there are none.
+
+## Implementation
+
+Each profiled variable receives a constant sized hash table and an *other*
+counter. The hash table maps a value to the frequency with which it
+is seen. When attempting to increment the frequency for a value, a hash
+table lookup is performed. If the value is found, its corresponding frequency
+is incremented. Otherwise, the value is either added to the table or
+the *other* counter is incremented, depending on if the table has
+reached its capacity.
+
+This approach limits the overhead introduced by profiling, as variables
+with a small set of highly frequent values will mostly consist of cheap
+hash table lookups and increments. Adding values to the table may be
+expensive, due to the computation and synchronization required, however
+this is limited by the tables capacity, with the remaining values
+being cheaply attributed to the *other* counter.
+
+The process of incrementing the frequency for an existing value or the
+*other* counter has been implemented in the IL, whilst the addition
+of values to the table is managed by a helper call. This avoids locality
+issues due to frequent calls and allows for other optimizations to further
+reduce the instrumentation's disruption to the mainline.
+
+There are various implementations of the hash function, all based around
+the X86 instruction `pext`. *N* bits are identified amongst the *N + 1* values
+held in the table, such that they can distinguish between then. These bits are
+extracted from the value and gathered into the low bits of an index, capable
+of addressing an array of length *2^N*. This index is used to extract values
+and frequencies from the hash table. The approach trades runtime performance
+for memory overhead, as the hash table size doubles for every additional value it
+is to support. These additional slots are mostly left unused.
+
+When adding a value to the table, the prior *N* selected bits are thrown
+out and a new set of *N + 1* bits are chosen, based on the table's existing
+contents and the new value. This may require rearrangement of the existing
+values if the bits change sufficiently. To ensure this rearrangement process
+won't race with other threads attempting to add to the table or increments
+from the jitted code, the table's is locked and its keys are manipulated
+to avoid any matches. This is achieved by backing up the values, setting
+the first slot to -1 and setting the rest to 0, relying on that fact
+that a value of 0 will always be placed on the first slot due to the
+hash function. Values are then rearranged in their backed up data structure
+and then committed back once the process has finished. Frequencies can
+be rearranged in place, as no increments should occur.
+
+During this process, other threads will increment the *other* counter so
+that the total frequency remains accurate. This process is complicated by 
+placing in the *other* counter in an unused slot. This is desirable, as a
+table with a capacity of 3 or greater will have at least one counter slot
+that is not in use. The frequency slot being used as the *other* counter
+cannot move during rearragnment, as it may race with other moves. To
+get around this, the final destination of the *other* counter is stashed
+and then performed as the final rearrangement.
+
+Once the values and frequencies have been rearranged, the new hash
+configuration can be committed and the addition is finished.
+If the table reached its capacity, the full flag is set and any new
+values seen in jitted code are attributed to the *other* counter.
+An additional optimization is made here, to cut down on memory accesses.
+The table is considered full when the index for the *other* counter
+is positive, so the tested value can be used immediately to increment
+the counter. In the event that its negative, the helper should be
+called to add a new value to the table.
+
+As the table populates based on the first distinct values that are
+seen, its possible to have ignored highly frequent values, for example due to
+an early phase change. To account for this, a thread inspects the hash
+tables and clears any with high *other* counters relative to that of the
+profiled values. If it decides that highly frequency values have been
+missed, it will reset the table and allow it to repopulate.
+
+Each table has a lock bit, which is locked when accessing data from a
+compilation thread, rearranging in the helper or clearing in the
+thread. Increments from the mainline do check this lock, to avoid
+the overhead. Additionally, these increments are not atomic, due to
+the overhead, which may result in races. In testing, this did not affect
+results sufficiently to negatively impact optimizations.
+It should be noted that, unlike the global monitor used by other profiling
+implementations, the lock is not reentrant.
+
+In addition to the `pext` hash function, other are supported. One approach
+uses an array of bytes specifying shifts to apply to the original value.
+This is implemented using existing opcodes and should be supported on all
+platforms. A more efficient implementation exists using the new `bitpermute`
+opcode, configured with an array of bytes specifying bit indices, rather
+than shifts. If supported by the codegen, the `bitpermute` approach will
+be used.
+
+## Configuration
+
+Value JProfiling can be used to replace JitProfiling. In this configuration,
+all existing requests for value profiling trees will insert placeholder
+JProfiling helper calls. The JProfilingValue optimization pass will run
+late in the opt strategy, lower these placeholders into the partial IL and
+helper implementation. This can be enabled with `enableJProfilingInProfilingCompilations`.
+Late swaps to profiling are not supported in this mode and will result in
+the compilation restarting.",a compilation abort and restart.,
69996450,0a9340bc75e72eff1d40f9cfb8f6d3cadc9bd781,runtime/tr.source/trj9/build/scripts/j9jit.rc,False,"@@ -40,12 +40,12 @@ BEGIN
 BEGIN
 VALUE ""CompanyName"", ""International Business Machines Corporation\0""
 VALUE ""FileDescription"", ""J9 Virtual Machine Runtime\0""
-VALUE ""FileVersion"", ""R2.8 ("" EsBuildVersionString "")\0""
-VALUE ""InternalName"", ""j9jit28\0""
-VALUE ""LegalCopyright"", "" ? Copyright (c) 1991, 2014 IBM Corp. and others\0""
-VALUE ""OriginalFilename"", ""j9jit28.dll\0""
+VALUE ""FileVersion"", ""R"" EsVersionString ""("" EsBuildVersionString "")\0""",Why introduce `EsVersionString` here when the `2.9` are hard coded everywhere else in this file?,
70001074,0a9340bc75e72eff1d40f9cfb8f6d3cadc9bd781,runtime/tr.source/trj9/build/scripts/j9jit.rc,True,"@@ -40,12 +40,12 @@ BEGIN
 BEGIN
 VALUE ""CompanyName"", ""International Business Machines Corporation\0""
 VALUE ""FileDescription"", ""J9 Virtual Machine Runtime\0""
-VALUE ""FileVersion"", ""R2.8 ("" EsBuildVersionString "")\0""
-VALUE ""InternalName"", ""j9jit28\0""
-VALUE ""LegalCopyright"", "" ? Copyright (c) 1991, 2014 IBM Corp. and others\0""
-VALUE ""OriginalFilename"", ""j9jit28.dll\0""
+VALUE ""FileVersion"", ""R"" EsVersionString ""("" EsBuildVersionString "")\0""","I considered replacing this file with j9jit.rc.ftl to gain direct access to all UMA properties, but decided against that because we're trying to stop using UMA.

I used a macro where I could find an existing definition. The expansion of `EsVersionString` is `""2.9""`; I couldn't find one that expanded to `""29""`. Would you prefer I leave those things hard-coded? (I don't have a strong preference either way.)",
70001959,0a9340bc75e72eff1d40f9cfb8f6d3cadc9bd781,runtime/tr.source/trj9/build/scripts/j9jit.rc,False,"@@ -40,12 +40,12 @@ BEGIN
 BEGIN
 VALUE ""CompanyName"", ""International Business Machines Corporation\0""
 VALUE ""FileDescription"", ""J9 Virtual Machine Runtime\0""
-VALUE ""FileVersion"", ""R2.8 ("" EsBuildVersionString "")\0""
-VALUE ""InternalName"", ""j9jit28\0""
-VALUE ""LegalCopyright"", "" ? Copyright (c) 1991, 2014 IBM Corp. and others\0""
-VALUE ""OriginalFilename"", ""j9jit28.dll\0""
+VALUE ""FileVersion"", ""R"" EsVersionString ""("" EsBuildVersionString "")\0""",I would leave it hard coded so the values will be consistent within the file.  ,
70229344,0a9340bc75e72eff1d40f9cfb8f6d3cadc9bd781,runtime/tr.source/trj9/build/scripts/j9jit.rc,True,"@@ -40,12 +40,12 @@ BEGIN
 BEGIN
 VALUE ""CompanyName"", ""International Business Machines Corporation\0""
 VALUE ""FileDescription"", ""J9 Virtual Machine Runtime\0""
-VALUE ""FileVersion"", ""R2.8 ("" EsBuildVersionString "")\0""
-VALUE ""InternalName"", ""j9jit28\0""
-VALUE ""LegalCopyright"", "" ? Copyright (c) 1991, 2014 IBM Corp. and others\0""
-VALUE ""OriginalFilename"", ""j9jit28.dll\0""
+VALUE ""FileVersion"", ""R"" EsVersionString ""("" EsBuildVersionString "")\0""",Use of `EsVersionString` removed.,
70300462,b5431c87fe0e7e11dcbd1d88a40ebf8da67f9047,buildspecs/j9.flags,False,"@@ -2316,4 +2316,8 @@ Pass J9PORT_SIG_OPTIONS_ZOS_USE_CEEHDLR into j9sig_set_options()  before the fir
 <description>Compile tracegenc and run it to generate tracefiles</description>
 <ifRemoved>Run java version of tracegenc</ifRemoved>
 </flag>
+<flag id=""windows_rebase"">",This flag should be either an `uma_` or `build_` flag.,
70307147,b5431c87fe0e7e11dcbd1d88a40ebf8da67f9047,buildspecs/j9.flags,True,"@@ -2316,4 +2316,8 @@ Pass J9PORT_SIG_OPTIONS_ZOS_USE_CEEHDLR into j9sig_set_options()  before the fir
 <description>Compile tracegenc and run it to generate tracefiles</description>
 <ifRemoved>Run java version of tracegenc</ifRemoved>
 </flag>
+<flag id=""windows_rebase"">",I renamed the flag uma_windows_rebase.,
70309717,b5431c87fe0e7e11dcbd1d88a40ebf8da67f9047,buildspecs/j9.flags,False,"@@ -2316,4 +2316,8 @@ Pass J9PORT_SIG_OPTIONS_ZOS_USE_CEEHDLR into j9sig_set_options()  before the fir
 <description>Compile tracegenc and run it to generate tracefiles</description>
 <ifRemoved>Run java version of tracegenc</ifRemoved>
 </flag>
+<flag id=""windows_rebase"">",The format in the file is `prefix_camelCaseFlag`.  Can you call this `uma_windowsRebase` to match the existing convention?,
70085944,3aaffa1a61c3466f4546021e67a0224d8fc565c5,jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java,False,"@@ -360,6 +360,20 @@ public static MethodType fromMethodDescriptorString(String methodDescriptor, Cla
 return mt;
 }
 
+/**
+ * Internal helper method for generating a MethodType from a descriptor string,
+ * and append an extra argument type.
+ * 
+ * VarHandle call sites use this method to generate the MethodType that matches
+ * the VarHandle method implementation (extra VarHandle argument).
+ */","Should there be a `@SuppressWarnings(""unused"")  /* Used by builder */` annotation on this method?",
70085944,3aaffa1a61c3466f4546021e67a0224d8fc565c5,jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java,False,"@@ -360,6 +360,20 @@ public static MethodType fromMethodDescriptorString(String methodDescriptor, Cla
 return mt;
 }
 
+/**
+ * Internal helper method for generating a MethodType from a descriptor string,
+ * and append an extra argument type.
+ * 
+ * VarHandle call sites use this method to generate the MethodType that matches
+ * the VarHandle method implementation (extra VarHandle argument).
+ */
+private static final MethodType fromMethodDescriptorStringAppendArg(String methodDescriptor, ClassLoader loader, Class<?> appendArgumentType) {
+MethodType result = fromMethodDescriptorString(methodDescriptor, loader);
+result = result.appendParameterTypes(appendArgumentType);","This will generate two MTs for every call.  Have you considered using `parseIntoClasses(methodDescriptor, classLoader);` from the implementation of `fromMethodDescriptorString` to avoid creating a second MT by accessing the parsed classes list?",
70085944,3aaffa1a61c3466f4546021e67a0224d8fc565c5,jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java,False,"@@ -317,7 +315,13 @@ int getModifiers() {
  * @return The {@link MethodType} corresponding to the provided {@link AccessMode}.
  */
 public final MethodType accessModeType(AccessMode accessMode) {
-return typeTable[accessMode.ordinal()];
+MethodType internalType = handleTable[accessMode.ordinal()].type;
+int numOfArguments = internalType.arguments.length;
+
+// Drop the internal VarHandle argument
+MethodType modifiedType = internalType.dropParameterTypes(numOfArguments - 1, numOfArguments);",This creates an MT on every call.  Do you have experience with how this API will be used?  It just went from a fast array access to an expensive MT creation...,
70324336,3aaffa1a61c3466f4546021e67a0224d8fc565c5,jcl/src/java.base/share/classes/java/lang/invoke/VarHandle.java,True,"@@ -317,7 +315,13 @@ int getModifiers() {
  * @return The {@link MethodType} corresponding to the provided {@link AccessMode}.
  */
 public final MethodType accessModeType(AccessMode accessMode) {
-return typeTable[accessMode.ordinal()];
+MethodType internalType = handleTable[accessMode.ordinal()].type;
+int numOfArguments = internalType.arguments.length;
+
+// Drop the internal VarHandle argument
+MethodType modifiedType = internalType.dropParameterTypes(numOfArguments - 1, numOfArguments);","It was used once in our VarHandle code, but it was unnecessary, so I will remove it. A `grep` shows that it's used a fair bit by the OpenJDK VarHandle implementation, which doesn't affect ours. The search didn't show any other uses in the JDK.",
70324522,3aaffa1a61c3466f4546021e67a0224d8fc565c5,jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java,True,"@@ -360,6 +360,20 @@ public static MethodType fromMethodDescriptorString(String methodDescriptor, Cla
 return mt;
 }
 
+/**
+ * Internal helper method for generating a MethodType from a descriptor string,
+ * and append an extra argument type.
+ * 
+ * VarHandle call sites use this method to generate the MethodType that matches
+ * the VarHandle method implementation (extra VarHandle argument).
+ */
+private static final MethodType fromMethodDescriptorStringAppendArg(String methodDescriptor, ClassLoader loader, Class<?> appendArgumentType) {
+MethodType result = fromMethodDescriptorString(methodDescriptor, loader);
+result = result.appendParameterTypes(appendArgumentType);","No, I didn't consider it. I'll see if I can make that work.",
70325302,3aaffa1a61c3466f4546021e67a0224d8fc565c5,jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java,True,"@@ -360,6 +360,20 @@ public static MethodType fromMethodDescriptorString(String methodDescriptor, Cla
 return mt;
 }
 
+/**
+ * Internal helper method for generating a MethodType from a descriptor string,
+ * and append an extra argument type.
+ * 
+ * VarHandle call sites use this method to generate the MethodType that matches
+ * the VarHandle method implementation (extra VarHandle argument).
+ */","I'll add it, although I would claim that it's not used by builder.",
70334584,3aaffa1a61c3466f4546021e67a0224d8fc565c5,jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java,True,"@@ -360,6 +360,20 @@ public static MethodType fromMethodDescriptorString(String methodDescriptor, Cla
 return mt;
 }
 
+/**
+ * Internal helper method for generating a MethodType from a descriptor string,
+ * and append an extra argument type.
+ * 
+ * VarHandle call sites use this method to generate the MethodType that matches
+ * the VarHandle method implementation (extra VarHandle argument).
+ */
+private static final MethodType fromMethodDescriptorStringAppendArg(String methodDescriptor, ClassLoader loader, Class<?> appendArgumentType) {
+MethodType result = fromMethodDescriptorString(methodDescriptor, loader);
+result = result.appendParameterTypes(appendArgumentType);",Fixed,
70334615,3aaffa1a61c3466f4546021e67a0224d8fc565c5,jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java,True,"@@ -360,6 +360,20 @@ public static MethodType fromMethodDescriptorString(String methodDescriptor, Cla
 return mt;
 }
 
+/**
+ * Internal helper method for generating a MethodType from a descriptor string,
+ * and append an extra argument type.
+ * 
+ * VarHandle call sites use this method to generate the MethodType that matches
+ * the VarHandle method implementation (extra VarHandle argument).
+ */",Fixed,
69941459,f3c18085fae65160b73578100ddf0be3c443a5ab,test/VM_Test/playlist.xml,False,"@@ -78,44 +78,6 @@
 
 <test>
 <featureIds>
-<featureId>113758</featureId>
-</featureIds>
-<testCaseName>recreateClassTest</testCaseName>
-<variations>
-<variation>NoOptions</variation>
-</variations>
-<command>
-$(JAVA_COMMAND) $(JVM_OPTIONS) \
--javaagent:$(Q)$(TEST_RESROOT)$(D)VM_Test.jar$(Q) \
--cp $(Q)$(LIB_DIR)$(D)junit4.jar$(P)$(LIB_DIR)$(D)asm-all.jar$(P)$(TEST_RESROOT)$(D)VM_Test.jar$(P)$(LIB_DIR)$(D)javassist.jar$(Q) \
-junit.textui.TestRunner com.ibm.j9.recreateclass.tests.RecreateClassTestSuite; \
-$(TEST_STATUS)</command>
-<tags>
-<tag>sanity</tag>
-</tags>
-<subsets>
-<subset>SE80</subset>
-</subsets>
-</test>
-
-<test>
-<featureIds>
-<featureId>133610</featureId>
-</featureIds>
-<testCaseName>CFdumptest</testCaseName>
-<command>$(JAVA_COMMAND) $(JVM_OPTIONS) \
--cp $(Q)$(TEST_RESROOT)$(D)VM_Test.jar$(P)$(LIB_DIR)$(D)junit4.jar$(Q) \
-junit.textui.TestRunner com.ibm.j9.cfdump.tests.CfdumpTestSuite; \
-$(TEST_STATUS)</command>
-<tags>
-<tag>sanity</tag>
-</tags>
-<subsets>
-<subset>SE80</subset>
-</subsets>
-</test>
-<test>
-<featureIds>","Please create another file and store the removed tests above into it (i.e., excluded_playlist.xml). We are working on generate .so for these tests in OpenJ9. Eventually, these tests will need to re-included and having excluded_playlist.xml is easier for us to re-included these tests back. Thanks.",
69973082,f3c18085fae65160b73578100ddf0be3c443a5ab,test/VM_Test/playlist.xml,True,"@@ -78,44 +78,6 @@
 
 <test>
 <featureIds>
-<featureId>113758</featureId>
-</featureIds>
-<testCaseName>recreateClassTest</testCaseName>
-<variations>
-<variation>NoOptions</variation>
-</variations>
-<command>
-$(JAVA_COMMAND) $(JVM_OPTIONS) \
--javaagent:$(Q)$(TEST_RESROOT)$(D)VM_Test.jar$(Q) \
--cp $(Q)$(LIB_DIR)$(D)junit4.jar$(P)$(LIB_DIR)$(D)asm-all.jar$(P)$(TEST_RESROOT)$(D)VM_Test.jar$(P)$(LIB_DIR)$(D)javassist.jar$(Q) \
-junit.textui.TestRunner com.ibm.j9.recreateclass.tests.RecreateClassTestSuite; \
-$(TEST_STATUS)</command>
-<tags>
-<tag>sanity</tag>
-</tags>
-<subsets>
-<subset>SE80</subset>
-</subsets>
-</test>
-
-<test>
-<featureIds>
-<featureId>133610</featureId>
-</featureIds>
-<testCaseName>CFdumptest</testCaseName>
-<command>$(JAVA_COMMAND) $(JVM_OPTIONS) \
--cp $(Q)$(TEST_RESROOT)$(D)VM_Test.jar$(P)$(LIB_DIR)$(D)junit4.jar$(Q) \
-junit.textui.TestRunner com.ibm.j9.cfdump.tests.CfdumpTestSuite; \
-$(TEST_STATUS)</command>
-<tags>
-<tag>sanity</tag>
-</tags>
-<subsets>
-<subset>SE80</subset>
-</subsets>
-</test>
-<test>
-<featureIds>",Good idea. I've added a test/VM_Test/excluded_playlist.xml file.,
70637262,901157dcccabde1d94e6b6973130eefdd9ea5901,runtime/vm/exceptionsupport.c,False,"@@ -940,6 +940,77 @@ setClassLoadingConstraintSignatureError(J9VMThread *currentThread, J9ClassLoader
 }
 
 
+void  
+setClassLoadingConstraintOverrideError(J9VMThread *currentThread, J9UTF8 *newClassNameUTF, J9ClassLoader *loader1, J9UTF8 *class1NameUTF, J9ClassLoader *loader2, J9UTF8 *class2NameUTF, J9UTF8 *exceptionClassNameUTF, U_8 *methodName, UDATA methodNameLength, U_8 *signature, UDATA signatureLength)
+{
+PORT_ACCESS_FROM_VMC(currentThread);
+char * msg = NULL;
+const char * nlsMessage;",nitpick: initial value?  Can we directly assign the `j9nls_` call to this?,
70637262,901157dcccabde1d94e6b6973130eefdd9ea5901,runtime/vm/exceptionsupport.c,False,"@@ -940,6 +940,77 @@ setClassLoadingConstraintSignatureError(J9VMThread *currentThread, J9ClassLoader
 }
 
 
+void  
+setClassLoadingConstraintOverrideError(J9VMThread *currentThread, J9UTF8 *newClassNameUTF, J9ClassLoader *loader1, J9UTF8 *class1NameUTF, J9ClassLoader *loader2, J9UTF8 *class2NameUTF, J9UTF8 *exceptionClassNameUTF, U_8 *methodName, UDATA methodNameLength, U_8 *signature, UDATA signatureLength)
+{
+PORT_ACCESS_FROM_VMC(currentThread);
+char * msg = NULL;
+const char * nlsMessage;
+
+nlsMessage = j9nls_lookup_message(J9NLS_DO_NOT_PRINT_MESSAGE_TAG | J9NLS_DO_NOT_APPEND_NEWLINE, J9NLS_VM_LOADING_CONSTRAINT_OVERRIDE_VIOLATION, NULL);
+if (nlsMessage != NULL) {
+/* Loader1 name and length */
+j9object_t loader1Object = loader1->classLoaderObject;
+J9Class * loader1Class = J9OBJECT_CLAZZ(currentThread, loader1Object);
+J9UTF8 * loader1ClassNameUTF = J9ROMCLASS_CLASSNAME(loader1Class->romClass);
+U_16 loader1ClassNameLength = J9UTF8_LENGTH(loader1ClassNameUTF);
+U_8 * loader1ClassName = J9UTF8_DATA(loader1ClassNameUTF);
+I_32 loader1Hash = objectHashCode(currentThread->javaVM, loader1Object);
+
+/* Loader2 name and length */
+j9object_t loader2Object = loader2->classLoaderObject;
+J9Class * loader2Class = J9OBJECT_CLAZZ(currentThread, loader2Object);
+J9UTF8 * loader2ClassNameUTF = J9ROMCLASS_CLASSNAME(loader2Class->romClass);
+U_16 loader2ClassNameLength = J9UTF8_LENGTH(loader2ClassNameUTF);
+U_8 * loader2ClassName = J9UTF8_DATA(loader2ClassNameUTF);
+I_32 loader2Hash = objectHashCode(currentThread->javaVM, loader2Object);
+
+/* Class1 name and length */
+U_16 class1ClassNameLength = J9UTF8_LENGTH(class1NameUTF);
+U_8 * class1ClassName = J9UTF8_DATA(class1NameUTF);
+
+/* Class2 name and length */
+U_16 class2ClassNameLength = J9UTF8_LENGTH(class2NameUTF);
+U_8 * class2ClassName = J9UTF8_DATA(class2NameUTF);
+
+/* ExceptionClass name and length */
+U_16 exceptionClassNameLength = J9UTF8_LENGTH(exceptionClassNameUTF);
+U_8 * exceptionClassName = J9UTF8_DATA(exceptionClassNameUTF);
+
+/* New class name and length */
+U_16 newClassNameLength = J9UTF8_LENGTH(newClassNameUTF);
+U_8 * newClassName = J9UTF8_DATA(newClassNameUTF);
+
+UDATA msgLen;",Nitpick: Initial value?,
70637262,901157dcccabde1d94e6b6973130eefdd9ea5901,runtime/vm/exceptionsupport.c,False,"@@ -940,6 +940,77 @@ setClassLoadingConstraintSignatureError(J9VMThread *currentThread, J9ClassLoader
 }
 
 
+void  
+setClassLoadingConstraintOverrideError(J9VMThread *currentThread, J9UTF8 *newClassNameUTF, J9ClassLoader *loader1, J9UTF8 *class1NameUTF, J9ClassLoader *loader2, J9UTF8 *class2NameUTF, J9UTF8 *exceptionClassNameUTF, U_8 *methodName, UDATA methodNameLength, U_8 *signature, UDATA signatureLength)
+{
+PORT_ACCESS_FROM_VMC(currentThread);
+char * msg = NULL;
+const char * nlsMessage;
+
+nlsMessage = j9nls_lookup_message(J9NLS_DO_NOT_PRINT_MESSAGE_TAG | J9NLS_DO_NOT_APPEND_NEWLINE, J9NLS_VM_LOADING_CONSTRAINT_OVERRIDE_VIOLATION, NULL);
+if (nlsMessage != NULL) {
+/* Loader1 name and length */
+j9object_t loader1Object = loader1->classLoaderObject;
+J9Class * loader1Class = J9OBJECT_CLAZZ(currentThread, loader1Object);
+J9UTF8 * loader1ClassNameUTF = J9ROMCLASS_CLASSNAME(loader1Class->romClass);
+U_16 loader1ClassNameLength = J9UTF8_LENGTH(loader1ClassNameUTF);
+U_8 * loader1ClassName = J9UTF8_DATA(loader1ClassNameUTF);
+I_32 loader1Hash = objectHashCode(currentThread->javaVM, loader1Object);
+
+/* Loader2 name and length */
+j9object_t loader2Object = loader2->classLoaderObject;
+J9Class * loader2Class = J9OBJECT_CLAZZ(currentThread, loader2Object);
+J9UTF8 * loader2ClassNameUTF = J9ROMCLASS_CLASSNAME(loader2Class->romClass);
+U_16 loader2ClassNameLength = J9UTF8_LENGTH(loader2ClassNameUTF);
+U_8 * loader2ClassName = J9UTF8_DATA(loader2ClassNameUTF);
+I_32 loader2Hash = objectHashCode(currentThread->javaVM, loader2Object);
+
+/* Class1 name and length */
+U_16 class1ClassNameLength = J9UTF8_LENGTH(class1NameUTF);
+U_8 * class1ClassName = J9UTF8_DATA(class1NameUTF);
+
+/* Class2 name and length */
+U_16 class2ClassNameLength = J9UTF8_LENGTH(class2NameUTF);
+U_8 * class2ClassName = J9UTF8_DATA(class2NameUTF);
+
+/* ExceptionClass name and length */
+U_16 exceptionClassNameLength = J9UTF8_LENGTH(exceptionClassNameUTF);
+U_8 * exceptionClassName = J9UTF8_DATA(exceptionClassNameUTF);
+
+/* New class name and length */
+U_16 newClassNameLength = J9UTF8_LENGTH(newClassNameUTF);
+U_8 * newClassName = J9UTF8_DATA(newClassNameUTF);
+
+UDATA msgLen;",This can just be merged with the line below to assign to it at creation,
70637262,901157dcccabde1d94e6b6973130eefdd9ea5901,runtime/vm/createramclass.cpp,False,"@@ -717,6 +736,7 @@ computeVTable(J9VMThread *vmStruct, J9Class *superclass, J9ROMClass *taggedClass
 if (NULL == vTableAddress) {
 if (maxSlots > vm->vTableScratchSize) {
 vTableAddress = (UDATA *)j9mem_allocate_memory(maxSlots, J9MEM_CATEGORY_CLASSES);
+vTableAllocated = true;",We never write this back to the `vm->vTableScratch`?,
70640481,901157dcccabde1d94e6b6973130eefdd9ea5901,runtime/vm/exceptionsupport.c,True,"@@ -940,6 +940,77 @@ setClassLoadingConstraintSignatureError(J9VMThread *currentThread, J9ClassLoader
 }
 
 
+void  
+setClassLoadingConstraintOverrideError(J9VMThread *currentThread, J9UTF8 *newClassNameUTF, J9ClassLoader *loader1, J9UTF8 *class1NameUTF, J9ClassLoader *loader2, J9UTF8 *class2NameUTF, J9UTF8 *exceptionClassNameUTF, U_8 *methodName, UDATA methodNameLength, U_8 *signature, UDATA signatureLength)
+{
+PORT_ACCESS_FROM_VMC(currentThread);
+char * msg = NULL;
+const char * nlsMessage;","Yes, this was copied code.",
70640558,901157dcccabde1d94e6b6973130eefdd9ea5901,runtime/vm/exceptionsupport.c,True,"@@ -940,6 +940,77 @@ setClassLoadingConstraintSignatureError(J9VMThread *currentThread, J9ClassLoader
 }
 
 
+void  
+setClassLoadingConstraintOverrideError(J9VMThread *currentThread, J9UTF8 *newClassNameUTF, J9ClassLoader *loader1, J9UTF8 *class1NameUTF, J9ClassLoader *loader2, J9UTF8 *class2NameUTF, J9UTF8 *exceptionClassNameUTF, U_8 *methodName, UDATA methodNameLength, U_8 *signature, UDATA signatureLength)
+{
+PORT_ACCESS_FROM_VMC(currentThread);
+char * msg = NULL;
+const char * nlsMessage;
+
+nlsMessage = j9nls_lookup_message(J9NLS_DO_NOT_PRINT_MESSAGE_TAG | J9NLS_DO_NOT_APPEND_NEWLINE, J9NLS_VM_LOADING_CONSTRAINT_OVERRIDE_VIOLATION, NULL);
+if (nlsMessage != NULL) {
+/* Loader1 name and length */
+j9object_t loader1Object = loader1->classLoaderObject;
+J9Class * loader1Class = J9OBJECT_CLAZZ(currentThread, loader1Object);
+J9UTF8 * loader1ClassNameUTF = J9ROMCLASS_CLASSNAME(loader1Class->romClass);
+U_16 loader1ClassNameLength = J9UTF8_LENGTH(loader1ClassNameUTF);
+U_8 * loader1ClassName = J9UTF8_DATA(loader1ClassNameUTF);
+I_32 loader1Hash = objectHashCode(currentThread->javaVM, loader1Object);
+
+/* Loader2 name and length */
+j9object_t loader2Object = loader2->classLoaderObject;
+J9Class * loader2Class = J9OBJECT_CLAZZ(currentThread, loader2Object);
+J9UTF8 * loader2ClassNameUTF = J9ROMCLASS_CLASSNAME(loader2Class->romClass);
+U_16 loader2ClassNameLength = J9UTF8_LENGTH(loader2ClassNameUTF);
+U_8 * loader2ClassName = J9UTF8_DATA(loader2ClassNameUTF);
+I_32 loader2Hash = objectHashCode(currentThread->javaVM, loader2Object);
+
+/* Class1 name and length */
+U_16 class1ClassNameLength = J9UTF8_LENGTH(class1NameUTF);
+U_8 * class1ClassName = J9UTF8_DATA(class1NameUTF);
+
+/* Class2 name and length */
+U_16 class2ClassNameLength = J9UTF8_LENGTH(class2NameUTF);
+U_8 * class2ClassName = J9UTF8_DATA(class2NameUTF);
+
+/* ExceptionClass name and length */
+U_16 exceptionClassNameLength = J9UTF8_LENGTH(exceptionClassNameUTF);
+U_8 * exceptionClassName = J9UTF8_DATA(exceptionClassNameUTF);
+
+/* New class name and length */
+U_16 newClassNameLength = J9UTF8_LENGTH(newClassNameUTF);
+U_8 * newClassName = J9UTF8_DATA(newClassNameUTF);
+
+UDATA msgLen;",Agreed - copied code again.,
70640990,901157dcccabde1d94e6b6973130eefdd9ea5901,runtime/vm/createramclass.cpp,True,"@@ -717,6 +736,7 @@ computeVTable(J9VMThread *vmStruct, J9Class *superclass, J9ROMClass *taggedClass
 if (NULL == vTableAddress) {
 if (maxSlots > vm->vTableScratchSize) {
 vTableAddress = (UDATA *)j9mem_allocate_memory(maxSlots, J9MEM_CATEGORY_CLASSES);
+vTableAllocated = true;",vTableScratch and vTableScratchSize are write-once on startup.,
70642085,901157dcccabde1d94e6b6973130eefdd9ea5901,runtime/vm/exceptionsupport.c,True,"@@ -940,6 +940,77 @@ setClassLoadingConstraintSignatureError(J9VMThread *currentThread, J9ClassLoader
 }
 
 
+void  
+setClassLoadingConstraintOverrideError(J9VMThread *currentThread, J9UTF8 *newClassNameUTF, J9ClassLoader *loader1, J9UTF8 *class1NameUTF, J9ClassLoader *loader2, J9UTF8 *class2NameUTF, J9UTF8 *exceptionClassNameUTF, U_8 *methodName, UDATA methodNameLength, U_8 *signature, UDATA signatureLength)
+{
+PORT_ACCESS_FROM_VMC(currentThread);
+char * msg = NULL;
+const char * nlsMessage;",Fixed all similar occurrences.,
70642157,901157dcccabde1d94e6b6973130eefdd9ea5901,runtime/vm/exceptionsupport.c,True,"@@ -940,6 +940,77 @@ setClassLoadingConstraintSignatureError(J9VMThread *currentThread, J9ClassLoader
 }
 
 
+void  
+setClassLoadingConstraintOverrideError(J9VMThread *currentThread, J9UTF8 *newClassNameUTF, J9ClassLoader *loader1, J9UTF8 *class1NameUTF, J9ClassLoader *loader2, J9UTF8 *class2NameUTF, J9UTF8 *exceptionClassNameUTF, U_8 *methodName, UDATA methodNameLength, U_8 *signature, UDATA signatureLength)
+{
+PORT_ACCESS_FROM_VMC(currentThread);
+char * msg = NULL;
+const char * nlsMessage;
+
+nlsMessage = j9nls_lookup_message(J9NLS_DO_NOT_PRINT_MESSAGE_TAG | J9NLS_DO_NOT_APPEND_NEWLINE, J9NLS_VM_LOADING_CONSTRAINT_OVERRIDE_VIOLATION, NULL);
+if (nlsMessage != NULL) {
+/* Loader1 name and length */
+j9object_t loader1Object = loader1->classLoaderObject;
+J9Class * loader1Class = J9OBJECT_CLAZZ(currentThread, loader1Object);
+J9UTF8 * loader1ClassNameUTF = J9ROMCLASS_CLASSNAME(loader1Class->romClass);
+U_16 loader1ClassNameLength = J9UTF8_LENGTH(loader1ClassNameUTF);
+U_8 * loader1ClassName = J9UTF8_DATA(loader1ClassNameUTF);
+I_32 loader1Hash = objectHashCode(currentThread->javaVM, loader1Object);
+
+/* Loader2 name and length */
+j9object_t loader2Object = loader2->classLoaderObject;
+J9Class * loader2Class = J9OBJECT_CLAZZ(currentThread, loader2Object);
+J9UTF8 * loader2ClassNameUTF = J9ROMCLASS_CLASSNAME(loader2Class->romClass);
+U_16 loader2ClassNameLength = J9UTF8_LENGTH(loader2ClassNameUTF);
+U_8 * loader2ClassName = J9UTF8_DATA(loader2ClassNameUTF);
+I_32 loader2Hash = objectHashCode(currentThread->javaVM, loader2Object);
+
+/* Class1 name and length */
+U_16 class1ClassNameLength = J9UTF8_LENGTH(class1NameUTF);
+U_8 * class1ClassName = J9UTF8_DATA(class1NameUTF);
+
+/* Class2 name and length */
+U_16 class2ClassNameLength = J9UTF8_LENGTH(class2NameUTF);
+U_8 * class2ClassName = J9UTF8_DATA(class2NameUTF);
+
+/* ExceptionClass name and length */
+U_16 exceptionClassNameLength = J9UTF8_LENGTH(exceptionClassNameUTF);
+U_8 * exceptionClassName = J9UTF8_DATA(exceptionClassNameUTF);
+
+/* New class name and length */
+U_16 newClassNameLength = J9UTF8_LENGTH(newClassNameUTF);
+U_8 * newClassName = J9UTF8_DATA(newClassNameUTF);
+
+UDATA msgLen;",Fixed all similar occurrences.,
70322142,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,False,"@@ -66,71 +70,112 @@ ReduceSynchronizedFieldLoad::inlineSynchronizedFieldLoad(TR::Node* node, TR::Cod
 
    // Search for the load memory reference from the previously evaluated load
    TR::Instruction* loadInstruction = cg->comp()->getAppendInstruction();
-   // Sanity check for loads
-   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad(), ""Expecting the append instruction to be a load"");
 
-   // Sanity check for instruction kind as we are doing an unsafe cast following this
-   TR_ASSERT_SAFE_FATAL(loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY, ""Expecting the append instruction to be a load of kind RX or RXY\n"");
+   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad() && (loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY), ""Expecting the append instruction to be a load of kind RX or RXY\n"");
 
    TR::MemoryReference* loadMemoryReference = static_cast<TR::S390RXInstruction*>(loadInstruction)->getMemoryReference();
 
    TR_ASSERT_SAFE_FATAL(loadMemoryReference->getIndexRegister() == NULL, ""Load memory reference must not have an index register\n"");
 
-   int32_t lockWordOffset = node->getChild(2)->getConst<int32_t>();
+   // Recreate the memory reference since the load instruction will be moved to the OOL code section and the register
+   // allocated to hold value of the base register of the memory reference may not be valid in the main line path
+   loadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
+
+   TR::Node* lockWordOffsetNode = node->getChild(2);
+
+   int32_t lockWordOffset = lockWordOffsetNode->getConst<int32_t>();
 
    TR::MemoryReference* lockMemoryReference = generateS390MemoryReference(objectRegister, lockWordOffset, cg);
 
    const bool generateCompressedLockWord = static_cast<TR_J9VMBase*>(cg->comp()->fe())->generateCompressedLockWord();
 
-   const bool generate32BitLoads = TR::Compiler->target.is32Bit() || (TR::Compiler->target.is64Bit() && generateCompressedLockWord && node->getChild(1)->getOpCodeValue() == TR::iloadi);
+   const bool is32BitLock = TR::Compiler->target.is32Bit() || generateCompressedLockWord;
+   const bool is32BitLoad = loadNode->getOpCodeValue() == TR::l2a || loadNode->getSymbolReference()->getSymbol()->getSize() == 4;
 
-   if (generate32BitLoads)
+   if (is32BitLock && is32BitLoad)
       {
-      TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, loadMemoryReference, lockMemoryReference);
 
-      if (node->getChild(1)->getOpCodeValue() == TR::l2a)
+      if (loadNode->getOpCodeValue() == TR::l2a)
          {
          generateRREInstruction(cg, TR::InstOpCode::LLGFR, node, loadRegister, loadRegister);
          }
       }
    else
       {
-      TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0 || (generateCompressedLockWord && (lockWordOffset & 3) == 0),
-            ""Lockword must be aligned on a double-word boundary or on a word boundary if the lockword is compressed\n"");
+      // LPDG requires memory references to be aligned to a double-wrod boundary",spelling nit.  `double-wrod`->`double-word`,
70322142,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,False,"@@ -66,71 +70,112 @@ ReduceSynchronizedFieldLoad::inlineSynchronizedFieldLoad(TR::Node* node, TR::Cod
 
    // Search for the load memory reference from the previously evaluated load
    TR::Instruction* loadInstruction = cg->comp()->getAppendInstruction();
-   // Sanity check for loads
-   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad(), ""Expecting the append instruction to be a load"");
 
-   // Sanity check for instruction kind as we are doing an unsafe cast following this
-   TR_ASSERT_SAFE_FATAL(loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY, ""Expecting the append instruction to be a load of kind RX or RXY\n"");
+   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad() && (loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY), ""Expecting the append instruction to be a load of kind RX or RXY\n"");
 
    TR::MemoryReference* loadMemoryReference = static_cast<TR::S390RXInstruction*>(loadInstruction)->getMemoryReference();
 
    TR_ASSERT_SAFE_FATAL(loadMemoryReference->getIndexRegister() == NULL, ""Load memory reference must not have an index register\n"");
 
-   int32_t lockWordOffset = node->getChild(2)->getConst<int32_t>();
+   // Recreate the memory reference since the load instruction will be moved to the OOL code section and the register
+   // allocated to hold value of the base register of the memory reference may not be valid in the main line path
+   loadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
+
+   TR::Node* lockWordOffsetNode = node->getChild(2);
+
+   int32_t lockWordOffset = lockWordOffsetNode->getConst<int32_t>();
 
    TR::MemoryReference* lockMemoryReference = generateS390MemoryReference(objectRegister, lockWordOffset, cg);
 
    const bool generateCompressedLockWord = static_cast<TR_J9VMBase*>(cg->comp()->fe())->generateCompressedLockWord();
 
-   const bool generate32BitLoads = TR::Compiler->target.is32Bit() || (TR::Compiler->target.is64Bit() && generateCompressedLockWord && node->getChild(1)->getOpCodeValue() == TR::iloadi);
+   const bool is32BitLock = TR::Compiler->target.is32Bit() || generateCompressedLockWord;
+   const bool is32BitLoad = loadNode->getOpCodeValue() == TR::l2a || loadNode->getSymbolReference()->getSymbol()->getSize() == 4;
 
-   if (generate32BitLoads)
+   if (is32BitLock && is32BitLoad)
       {
-      TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, loadMemoryReference, lockMemoryReference);
 
-      if (node->getChild(1)->getOpCodeValue() == TR::l2a)
+      if (loadNode->getOpCodeValue() == TR::l2a)
          {
          generateRREInstruction(cg, TR::InstOpCode::LLGFR, node, loadRegister, loadRegister);
          }
       }
    else
       {
-      TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0 || (generateCompressedLockWord && (lockWordOffset & 3) == 0),
-            ""Lockword must be aligned on a double-word boundary or on a word boundary if the lockword is compressed\n"");
+      // LPDG requires memory references to be aligned to a double-wrod boundary
+      TR::MemoryReference* alignedLockMemoryReference = lockMemoryReference;
+      TR::MemoryReference* alignedLoadMemoryReference = loadMemoryReference;
 
-      if ((loadMemoryReference->getOffset() & 7) != 0)
-         {
-         TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Integer field must be aligned on a word boundary\n"");
-
-         TR::MemoryReference* alignedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, -4, cg);
+      bool lockRegisterRequiresShift = false;
+      bool loadRegisterRequiresShift = false;
 
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, alignedLoadMemoryReference, lockMemoryReference);
+      bool lockRegisterRequires32BitLogicalSignExtension = false;
+      bool loadRegisterRequires32BitLogicalSignExtension = false;
 
-         // For 64-bit uncompressed lockwords, when the load memory reference is not aligned to double-word boundaries,
-         // the loaded value is at the lower 32-bit. We need an AND to zero out the high half of loadRegister.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLock)
+         {
+         if ((lockWordOffset & 7) == 0)
             {
-            generateRILInstruction(cg, TR::InstOpCode::NIHF, node, loadRegister, static_cast<uintptrj_t>(0));
+            lockRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((lockWordOffset & 3) == 0, ""Lockword must be aligned on a word boundary\n"");
+
+            lockRegisterRequires32BitLogicalSignExtension = true;
+            alignedLockMemoryReference = generateS390MemoryReference(*lockMemoryReference, -4, cg);
             }
          }
       else
          {
-         TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+         // This is because we must use LPDG to load a 64-bit value","Not sure why this comment is relevant.. As the assert text says, Lockword must be aligned to DW boundaries anyway.",
70322142,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,False,"@@ -205,11 +250,17 @@ ReduceSynchronizedFieldLoad::perform()
 
    if (cg->getS390ProcessorInfo()->supportsArch(TR_S390ProcessorInfo::TR_z196))
       {
-      if (!cg->comp()->getOption(TR_DisableSynchronizedFieldLoad))
+      // When concurrent scavenge is enabled we need to load the object reference using a read barrier however
+      // there is no guarded load alternative for the LPD instruction. As such this optimization cannot be carried
+      // out for object reference loads under concurrent scavenge.
+      if (!TR::Compiler->om.shouldGenerateReadBarriersForFieldLoads())","Unrelated to this change, but we just need to disable this optimization for reference fields loads when ConcurrentScavenge is enabled.   Other primitive type loads should be okay.",
70322142,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,False,"@@ -66,71 +70,112 @@ ReduceSynchronizedFieldLoad::inlineSynchronizedFieldLoad(TR::Node* node, TR::Cod
 
    // Search for the load memory reference from the previously evaluated load
    TR::Instruction* loadInstruction = cg->comp()->getAppendInstruction();
-   // Sanity check for loads
-   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad(), ""Expecting the append instruction to be a load"");
 
-   // Sanity check for instruction kind as we are doing an unsafe cast following this
-   TR_ASSERT_SAFE_FATAL(loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY, ""Expecting the append instruction to be a load of kind RX or RXY\n"");
+   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad() && (loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY), ""Expecting the append instruction to be a load of kind RX or RXY\n"");
 
    TR::MemoryReference* loadMemoryReference = static_cast<TR::S390RXInstruction*>(loadInstruction)->getMemoryReference();
 
    TR_ASSERT_SAFE_FATAL(loadMemoryReference->getIndexRegister() == NULL, ""Load memory reference must not have an index register\n"");
 
-   int32_t lockWordOffset = node->getChild(2)->getConst<int32_t>();
+   // Recreate the memory reference since the load instruction will be moved to the OOL code section and the register
+   // allocated to hold value of the base register of the memory reference may not be valid in the main line path
+   loadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
+
+   TR::Node* lockWordOffsetNode = node->getChild(2);
+
+   int32_t lockWordOffset = lockWordOffsetNode->getConst<int32_t>();
 
    TR::MemoryReference* lockMemoryReference = generateS390MemoryReference(objectRegister, lockWordOffset, cg);
 
    const bool generateCompressedLockWord = static_cast<TR_J9VMBase*>(cg->comp()->fe())->generateCompressedLockWord();
 
-   const bool generate32BitLoads = TR::Compiler->target.is32Bit() || (TR::Compiler->target.is64Bit() && generateCompressedLockWord && node->getChild(1)->getOpCodeValue() == TR::iloadi);
+   const bool is32BitLock = TR::Compiler->target.is32Bit() || generateCompressedLockWord;
+   const bool is32BitLoad = loadNode->getOpCodeValue() == TR::l2a || loadNode->getSymbolReference()->getSymbol()->getSize() == 4;
 
-   if (generate32BitLoads)
+   if (is32BitLock && is32BitLoad)
       {
-      TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, loadMemoryReference, lockMemoryReference);
 
-      if (node->getChild(1)->getOpCodeValue() == TR::l2a)
+      if (loadNode->getOpCodeValue() == TR::l2a)
          {
          generateRREInstruction(cg, TR::InstOpCode::LLGFR, node, loadRegister, loadRegister);
          }
       }
    else
       {
-      TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0 || (generateCompressedLockWord && (lockWordOffset & 3) == 0),
-            ""Lockword must be aligned on a double-word boundary or on a word boundary if the lockword is compressed\n"");
+      // LPDG requires memory references to be aligned to a double-wrod boundary
+      TR::MemoryReference* alignedLockMemoryReference = lockMemoryReference;
+      TR::MemoryReference* alignedLoadMemoryReference = loadMemoryReference;
 
-      if ((loadMemoryReference->getOffset() & 7) != 0)
-         {
-         TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Integer field must be aligned on a word boundary\n"");
-
-         TR::MemoryReference* alignedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, -4, cg);
+      bool lockRegisterRequiresShift = false;
+      bool loadRegisterRequiresShift = false;
 
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, alignedLoadMemoryReference, lockMemoryReference);
+      bool lockRegisterRequires32BitLogicalSignExtension = false;
+      bool loadRegisterRequires32BitLogicalSignExtension = false;
 
-         // For 64-bit uncompressed lockwords, when the load memory reference is not aligned to double-word boundaries,
-         // the loaded value is at the lower 32-bit. We need an AND to zero out the high half of loadRegister.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLock)
+         {
+         if ((lockWordOffset & 7) == 0)
             {
-            generateRILInstruction(cg, TR::InstOpCode::NIHF, node, loadRegister, static_cast<uintptrj_t>(0));
+            lockRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((lockWordOffset & 3) == 0, ""Lockword must be aligned on a word boundary\n"");
+
+            lockRegisterRequires32BitLogicalSignExtension = true;
+            alignedLockMemoryReference = generateS390MemoryReference(*lockMemoryReference, -4, cg);
             }
          }
       else
          {
-         TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+         // This is because we must use LPDG to load a 64-bit value
+         TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0, ""Lockword must be aligned on a double-word boundary\n"");
+         }
 
-         // We know we are generating for a 64-bit target. Furthermore we know the field we are loading is on a double-
-         // word boundary. However if we are loading an integer it only occupies 32-bits of storage, and since we must
-         // use LPDG to load the field it means the field will be generated in the most significant 32-bits of the
-         // loaded register. Hence we must carry out a right shift to move the loaded value into the least significant
-         // 32-bits of the respective register.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLoad)
+         {
+         if ((loadMemoryReference->getOffset() & 7) == 0)
             {
-            generateRSInstruction(cg, TR::InstOpCode::SRLG, node, loadRegister, loadRegister, 32);
+            loadRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Field must be aligned on a word boundary\n"");
+
+            loadRegisterRequires32BitLogicalSignExtension = true;","If we are loading an 32-bit int, do we still need to logical extend to zero out the upper 32-bits?",
70336658,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,True,"@@ -66,71 +70,112 @@ ReduceSynchronizedFieldLoad::inlineSynchronizedFieldLoad(TR::Node* node, TR::Cod
 
    // Search for the load memory reference from the previously evaluated load
    TR::Instruction* loadInstruction = cg->comp()->getAppendInstruction();
-   // Sanity check for loads
-   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad(), ""Expecting the append instruction to be a load"");
 
-   // Sanity check for instruction kind as we are doing an unsafe cast following this
-   TR_ASSERT_SAFE_FATAL(loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY, ""Expecting the append instruction to be a load of kind RX or RXY\n"");
+   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad() && (loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY), ""Expecting the append instruction to be a load of kind RX or RXY\n"");
 
    TR::MemoryReference* loadMemoryReference = static_cast<TR::S390RXInstruction*>(loadInstruction)->getMemoryReference();
 
    TR_ASSERT_SAFE_FATAL(loadMemoryReference->getIndexRegister() == NULL, ""Load memory reference must not have an index register\n"");
 
-   int32_t lockWordOffset = node->getChild(2)->getConst<int32_t>();
+   // Recreate the memory reference since the load instruction will be moved to the OOL code section and the register
+   // allocated to hold value of the base register of the memory reference may not be valid in the main line path
+   loadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
+
+   TR::Node* lockWordOffsetNode = node->getChild(2);
+
+   int32_t lockWordOffset = lockWordOffsetNode->getConst<int32_t>();
 
    TR::MemoryReference* lockMemoryReference = generateS390MemoryReference(objectRegister, lockWordOffset, cg);
 
    const bool generateCompressedLockWord = static_cast<TR_J9VMBase*>(cg->comp()->fe())->generateCompressedLockWord();
 
-   const bool generate32BitLoads = TR::Compiler->target.is32Bit() || (TR::Compiler->target.is64Bit() && generateCompressedLockWord && node->getChild(1)->getOpCodeValue() == TR::iloadi);
+   const bool is32BitLock = TR::Compiler->target.is32Bit() || generateCompressedLockWord;
+   const bool is32BitLoad = loadNode->getOpCodeValue() == TR::l2a || loadNode->getSymbolReference()->getSymbol()->getSize() == 4;
 
-   if (generate32BitLoads)
+   if (is32BitLock && is32BitLoad)
       {
-      TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, loadMemoryReference, lockMemoryReference);
 
-      if (node->getChild(1)->getOpCodeValue() == TR::l2a)
+      if (loadNode->getOpCodeValue() == TR::l2a)
          {
          generateRREInstruction(cg, TR::InstOpCode::LLGFR, node, loadRegister, loadRegister);
          }
       }
    else
       {
-      TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0 || (generateCompressedLockWord && (lockWordOffset & 3) == 0),
-            ""Lockword must be aligned on a double-word boundary or on a word boundary if the lockword is compressed\n"");
+      // LPDG requires memory references to be aligned to a double-wrod boundary",Fixed in 98f8017,
70336712,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,True,"@@ -66,71 +70,112 @@ ReduceSynchronizedFieldLoad::inlineSynchronizedFieldLoad(TR::Node* node, TR::Cod
 
    // Search for the load memory reference from the previously evaluated load
    TR::Instruction* loadInstruction = cg->comp()->getAppendInstruction();
-   // Sanity check for loads
-   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad(), ""Expecting the append instruction to be a load"");
 
-   // Sanity check for instruction kind as we are doing an unsafe cast following this
-   TR_ASSERT_SAFE_FATAL(loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY, ""Expecting the append instruction to be a load of kind RX or RXY\n"");
+   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad() && (loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY), ""Expecting the append instruction to be a load of kind RX or RXY\n"");
 
    TR::MemoryReference* loadMemoryReference = static_cast<TR::S390RXInstruction*>(loadInstruction)->getMemoryReference();
 
    TR_ASSERT_SAFE_FATAL(loadMemoryReference->getIndexRegister() == NULL, ""Load memory reference must not have an index register\n"");
 
-   int32_t lockWordOffset = node->getChild(2)->getConst<int32_t>();
+   // Recreate the memory reference since the load instruction will be moved to the OOL code section and the register
+   // allocated to hold value of the base register of the memory reference may not be valid in the main line path
+   loadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
+
+   TR::Node* lockWordOffsetNode = node->getChild(2);
+
+   int32_t lockWordOffset = lockWordOffsetNode->getConst<int32_t>();
 
    TR::MemoryReference* lockMemoryReference = generateS390MemoryReference(objectRegister, lockWordOffset, cg);
 
    const bool generateCompressedLockWord = static_cast<TR_J9VMBase*>(cg->comp()->fe())->generateCompressedLockWord();
 
-   const bool generate32BitLoads = TR::Compiler->target.is32Bit() || (TR::Compiler->target.is64Bit() && generateCompressedLockWord && node->getChild(1)->getOpCodeValue() == TR::iloadi);
+   const bool is32BitLock = TR::Compiler->target.is32Bit() || generateCompressedLockWord;
+   const bool is32BitLoad = loadNode->getOpCodeValue() == TR::l2a || loadNode->getSymbolReference()->getSymbol()->getSize() == 4;
 
-   if (generate32BitLoads)
+   if (is32BitLock && is32BitLoad)
       {
-      TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, loadMemoryReference, lockMemoryReference);
 
-      if (node->getChild(1)->getOpCodeValue() == TR::l2a)
+      if (loadNode->getOpCodeValue() == TR::l2a)
          {
          generateRREInstruction(cg, TR::InstOpCode::LLGFR, node, loadRegister, loadRegister);
          }
       }
    else
       {
-      TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0 || (generateCompressedLockWord && (lockWordOffset & 3) == 0),
-            ""Lockword must be aligned on a double-word boundary or on a word boundary if the lockword is compressed\n"");
+      // LPDG requires memory references to be aligned to a double-wrod boundary
+      TR::MemoryReference* alignedLockMemoryReference = lockMemoryReference;
+      TR::MemoryReference* alignedLoadMemoryReference = loadMemoryReference;
 
-      if ((loadMemoryReference->getOffset() & 7) != 0)
-         {
-         TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Integer field must be aligned on a word boundary\n"");
-
-         TR::MemoryReference* alignedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, -4, cg);
+      bool lockRegisterRequiresShift = false;
+      bool loadRegisterRequiresShift = false;
 
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, alignedLoadMemoryReference, lockMemoryReference);
+      bool lockRegisterRequires32BitLogicalSignExtension = false;
+      bool loadRegisterRequires32BitLogicalSignExtension = false;
 
-         // For 64-bit uncompressed lockwords, when the load memory reference is not aligned to double-word boundaries,
-         // the loaded value is at the lower 32-bit. We need an AND to zero out the high half of loadRegister.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLock)
+         {
+         if ((lockWordOffset & 7) == 0)
             {
-            generateRILInstruction(cg, TR::InstOpCode::NIHF, node, loadRegister, static_cast<uintptrj_t>(0));
+            lockRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((lockWordOffset & 3) == 0, ""Lockword must be aligned on a word boundary\n"");
+
+            lockRegisterRequires32BitLogicalSignExtension = true;
+            alignedLockMemoryReference = generateS390MemoryReference(*lockMemoryReference, -4, cg);
             }
          }
       else
          {
-         TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+         // This is because we must use LPDG to load a 64-bit value",Removed comment in 98f8017,
70336838,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,True,"@@ -205,11 +250,17 @@ ReduceSynchronizedFieldLoad::perform()
 
    if (cg->getS390ProcessorInfo()->supportsArch(TR_S390ProcessorInfo::TR_z196))
       {
-      if (!cg->comp()->getOption(TR_DisableSynchronizedFieldLoad))
+      // When concurrent scavenge is enabled we need to load the object reference using a read barrier however
+      // there is no guarded load alternative for the LPD instruction. As such this optimization cannot be carried
+      // out for object reference loads under concurrent scavenge.
+      if (!TR::Compiler->om.shouldGenerateReadBarriersForFieldLoads())",Might as well fix now. Fixed to allow primitive field loads under concurrent scavenge in 98f8017,
70337436,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,True,"@@ -66,71 +70,112 @@ ReduceSynchronizedFieldLoad::inlineSynchronizedFieldLoad(TR::Node* node, TR::Cod
 
    // Search for the load memory reference from the previously evaluated load
    TR::Instruction* loadInstruction = cg->comp()->getAppendInstruction();
-   // Sanity check for loads
-   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad(), ""Expecting the append instruction to be a load"");
 
-   // Sanity check for instruction kind as we are doing an unsafe cast following this
-   TR_ASSERT_SAFE_FATAL(loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY, ""Expecting the append instruction to be a load of kind RX or RXY\n"");
+   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad() && (loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY), ""Expecting the append instruction to be a load of kind RX or RXY\n"");
 
    TR::MemoryReference* loadMemoryReference = static_cast<TR::S390RXInstruction*>(loadInstruction)->getMemoryReference();
 
    TR_ASSERT_SAFE_FATAL(loadMemoryReference->getIndexRegister() == NULL, ""Load memory reference must not have an index register\n"");
 
-   int32_t lockWordOffset = node->getChild(2)->getConst<int32_t>();
+   // Recreate the memory reference since the load instruction will be moved to the OOL code section and the register
+   // allocated to hold value of the base register of the memory reference may not be valid in the main line path
+   loadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
+
+   TR::Node* lockWordOffsetNode = node->getChild(2);
+
+   int32_t lockWordOffset = lockWordOffsetNode->getConst<int32_t>();
 
    TR::MemoryReference* lockMemoryReference = generateS390MemoryReference(objectRegister, lockWordOffset, cg);
 
    const bool generateCompressedLockWord = static_cast<TR_J9VMBase*>(cg->comp()->fe())->generateCompressedLockWord();
 
-   const bool generate32BitLoads = TR::Compiler->target.is32Bit() || (TR::Compiler->target.is64Bit() && generateCompressedLockWord && node->getChild(1)->getOpCodeValue() == TR::iloadi);
+   const bool is32BitLock = TR::Compiler->target.is32Bit() || generateCompressedLockWord;
+   const bool is32BitLoad = loadNode->getOpCodeValue() == TR::l2a || loadNode->getSymbolReference()->getSymbol()->getSize() == 4;
 
-   if (generate32BitLoads)
+   if (is32BitLock && is32BitLoad)
       {
-      TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, loadMemoryReference, lockMemoryReference);
 
-      if (node->getChild(1)->getOpCodeValue() == TR::l2a)
+      if (loadNode->getOpCodeValue() == TR::l2a)
          {
          generateRREInstruction(cg, TR::InstOpCode::LLGFR, node, loadRegister, loadRegister);
          }
       }
    else
       {
-      TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0 || (generateCompressedLockWord && (lockWordOffset & 3) == 0),
-            ""Lockword must be aligned on a double-word boundary or on a word boundary if the lockword is compressed\n"");
+      // LPDG requires memory references to be aligned to a double-wrod boundary
+      TR::MemoryReference* alignedLockMemoryReference = lockMemoryReference;
+      TR::MemoryReference* alignedLoadMemoryReference = loadMemoryReference;
 
-      if ((loadMemoryReference->getOffset() & 7) != 0)
-         {
-         TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Integer field must be aligned on a word boundary\n"");
-
-         TR::MemoryReference* alignedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, -4, cg);
+      bool lockRegisterRequiresShift = false;
+      bool loadRegisterRequiresShift = false;
 
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, alignedLoadMemoryReference, lockMemoryReference);
+      bool lockRegisterRequires32BitLogicalSignExtension = false;
+      bool loadRegisterRequires32BitLogicalSignExtension = false;
 
-         // For 64-bit uncompressed lockwords, when the load memory reference is not aligned to double-word boundaries,
-         // the loaded value is at the lower 32-bit. We need an AND to zero out the high half of loadRegister.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLock)
+         {
+         if ((lockWordOffset & 7) == 0)
             {
-            generateRILInstruction(cg, TR::InstOpCode::NIHF, node, loadRegister, static_cast<uintptrj_t>(0));
+            lockRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((lockWordOffset & 3) == 0, ""Lockword must be aligned on a word boundary\n"");
+
+            lockRegisterRequires32BitLogicalSignExtension = true;
+            alignedLockMemoryReference = generateS390MemoryReference(*lockMemoryReference, -4, cg);
             }
          }
       else
          {
-         TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+         // This is because we must use LPDG to load a 64-bit value
+         TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0, ""Lockword must be aligned on a double-word boundary\n"");
+         }
 
-         // We know we are generating for a 64-bit target. Furthermore we know the field we are loading is on a double-
-         // word boundary. However if we are loading an integer it only occupies 32-bits of storage, and since we must
-         // use LPDG to load the field it means the field will be generated in the most significant 32-bits of the
-         // loaded register. Hence we must carry out a right shift to move the loaded value into the least significant
-         // 32-bits of the respective register.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLoad)
+         {
+         if ((loadMemoryReference->getOffset() & 7) == 0)
             {
-            generateRSInstruction(cg, TR::InstOpCode::SRLG, node, loadRegister, loadRegister, 32);
+            loadRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Field must be aligned on a word boundary\n"");
+
+            loadRegisterRequires32BitLogicalSignExtension = true;","Yes, because under compressedrefs shift of zero we need to load a full 64-bit uncompressed value. The `LPDG` will do a 32-bit load but we need to sign extend it. We behave similarly to what we would have generated for a normal load, which would have been a `LLGF`. In our case `LPDG` + `LLGFR`.",
70337774,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,True,"@@ -66,71 +70,112 @@ ReduceSynchronizedFieldLoad::inlineSynchronizedFieldLoad(TR::Node* node, TR::Cod
 
    // Search for the load memory reference from the previously evaluated load
    TR::Instruction* loadInstruction = cg->comp()->getAppendInstruction();
-   // Sanity check for loads
-   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad(), ""Expecting the append instruction to be a load"");
 
-   // Sanity check for instruction kind as we are doing an unsafe cast following this
-   TR_ASSERT_SAFE_FATAL(loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY, ""Expecting the append instruction to be a load of kind RX or RXY\n"");
+   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad() && (loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY), ""Expecting the append instruction to be a load of kind RX or RXY\n"");
 
    TR::MemoryReference* loadMemoryReference = static_cast<TR::S390RXInstruction*>(loadInstruction)->getMemoryReference();
 
    TR_ASSERT_SAFE_FATAL(loadMemoryReference->getIndexRegister() == NULL, ""Load memory reference must not have an index register\n"");
 
-   int32_t lockWordOffset = node->getChild(2)->getConst<int32_t>();
+   // Recreate the memory reference since the load instruction will be moved to the OOL code section and the register
+   // allocated to hold value of the base register of the memory reference may not be valid in the main line path
+   loadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
+
+   TR::Node* lockWordOffsetNode = node->getChild(2);
+
+   int32_t lockWordOffset = lockWordOffsetNode->getConst<int32_t>();
 
    TR::MemoryReference* lockMemoryReference = generateS390MemoryReference(objectRegister, lockWordOffset, cg);
 
    const bool generateCompressedLockWord = static_cast<TR_J9VMBase*>(cg->comp()->fe())->generateCompressedLockWord();
 
-   const bool generate32BitLoads = TR::Compiler->target.is32Bit() || (TR::Compiler->target.is64Bit() && generateCompressedLockWord && node->getChild(1)->getOpCodeValue() == TR::iloadi);
+   const bool is32BitLock = TR::Compiler->target.is32Bit() || generateCompressedLockWord;
+   const bool is32BitLoad = loadNode->getOpCodeValue() == TR::l2a || loadNode->getSymbolReference()->getSymbol()->getSize() == 4;
 
-   if (generate32BitLoads)
+   if (is32BitLock && is32BitLoad)
       {
-      TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, loadMemoryReference, lockMemoryReference);
 
-      if (node->getChild(1)->getOpCodeValue() == TR::l2a)
+      if (loadNode->getOpCodeValue() == TR::l2a)
          {
          generateRREInstruction(cg, TR::InstOpCode::LLGFR, node, loadRegister, loadRegister);
          }
       }
    else
       {
-      TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0 || (generateCompressedLockWord && (lockWordOffset & 3) == 0),
-            ""Lockword must be aligned on a double-word boundary or on a word boundary if the lockword is compressed\n"");
+      // LPDG requires memory references to be aligned to a double-wrod boundary
+      TR::MemoryReference* alignedLockMemoryReference = lockMemoryReference;
+      TR::MemoryReference* alignedLoadMemoryReference = loadMemoryReference;
 
-      if ((loadMemoryReference->getOffset() & 7) != 0)
-         {
-         TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Integer field must be aligned on a word boundary\n"");
-
-         TR::MemoryReference* alignedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, -4, cg);
+      bool lockRegisterRequiresShift = false;
+      bool loadRegisterRequiresShift = false;
 
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, alignedLoadMemoryReference, lockMemoryReference);
+      bool lockRegisterRequires32BitLogicalSignExtension = false;
+      bool loadRegisterRequires32BitLogicalSignExtension = false;
 
-         // For 64-bit uncompressed lockwords, when the load memory reference is not aligned to double-word boundaries,
-         // the loaded value is at the lower 32-bit. We need an AND to zero out the high half of loadRegister.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLock)
+         {
+         if ((lockWordOffset & 7) == 0)
             {
-            generateRILInstruction(cg, TR::InstOpCode::NIHF, node, loadRegister, static_cast<uintptrj_t>(0));
+            lockRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((lockWordOffset & 3) == 0, ""Lockword must be aligned on a word boundary\n"");
+
+            lockRegisterRequires32BitLogicalSignExtension = true;
+            alignedLockMemoryReference = generateS390MemoryReference(*lockMemoryReference, -4, cg);
             }
          }
       else
          {
-         TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+         // This is because we must use LPDG to load a 64-bit value
+         TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0, ""Lockword must be aligned on a double-word boundary\n"");
+         }
 
-         // We know we are generating for a 64-bit target. Furthermore we know the field we are loading is on a double-
-         // word boundary. However if we are loading an integer it only occupies 32-bits of storage, and since we must
-         // use LPDG to load the field it means the field will be generated in the most significant 32-bits of the
-         // loaded register. Hence we must carry out a right shift to move the loaded value into the least significant
-         // 32-bits of the respective register.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLoad)
+         {
+         if ((loadMemoryReference->getOffset() & 7) == 0)
             {
-            generateRSInstruction(cg, TR::InstOpCode::SRLG, node, loadRegister, loadRegister, 32);
+            loadRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Field must be aligned on a word boundary\n"");
+
+            loadRegisterRequires32BitLogicalSignExtension = true;","Note we would not generate the `SLLG` below because it is guarded by `loadNode->getFirstChild()->getOpCodeValue() == TR::lshl`. This node does not exist for compressedrefs shift of zero.

Though you may be right in that we are too strict right now. We should be able to avoid the `LLGFR` for non-Address datatypes. Thoughts?",
70401164,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,False,"@@ -66,71 +70,112 @@ ReduceSynchronizedFieldLoad::inlineSynchronizedFieldLoad(TR::Node* node, TR::Cod
 
    // Search for the load memory reference from the previously evaluated load
    TR::Instruction* loadInstruction = cg->comp()->getAppendInstruction();
-   // Sanity check for loads
-   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad(), ""Expecting the append instruction to be a load"");
 
-   // Sanity check for instruction kind as we are doing an unsafe cast following this
-   TR_ASSERT_SAFE_FATAL(loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY, ""Expecting the append instruction to be a load of kind RX or RXY\n"");
+   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad() && (loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY), ""Expecting the append instruction to be a load of kind RX or RXY\n"");
 
    TR::MemoryReference* loadMemoryReference = static_cast<TR::S390RXInstruction*>(loadInstruction)->getMemoryReference();
 
    TR_ASSERT_SAFE_FATAL(loadMemoryReference->getIndexRegister() == NULL, ""Load memory reference must not have an index register\n"");
 
-   int32_t lockWordOffset = node->getChild(2)->getConst<int32_t>();
+   // Recreate the memory reference since the load instruction will be moved to the OOL code section and the register
+   // allocated to hold value of the base register of the memory reference may not be valid in the main line path
+   loadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
+
+   TR::Node* lockWordOffsetNode = node->getChild(2);
+
+   int32_t lockWordOffset = lockWordOffsetNode->getConst<int32_t>();
 
    TR::MemoryReference* lockMemoryReference = generateS390MemoryReference(objectRegister, lockWordOffset, cg);
 
    const bool generateCompressedLockWord = static_cast<TR_J9VMBase*>(cg->comp()->fe())->generateCompressedLockWord();
 
-   const bool generate32BitLoads = TR::Compiler->target.is32Bit() || (TR::Compiler->target.is64Bit() && generateCompressedLockWord && node->getChild(1)->getOpCodeValue() == TR::iloadi);
+   const bool is32BitLock = TR::Compiler->target.is32Bit() || generateCompressedLockWord;
+   const bool is32BitLoad = loadNode->getOpCodeValue() == TR::l2a || loadNode->getSymbolReference()->getSymbol()->getSize() == 4;
 
-   if (generate32BitLoads)
+   if (is32BitLock && is32BitLoad)
       {
-      TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, loadMemoryReference, lockMemoryReference);
 
-      if (node->getChild(1)->getOpCodeValue() == TR::l2a)
+      if (loadNode->getOpCodeValue() == TR::l2a)
          {
          generateRREInstruction(cg, TR::InstOpCode::LLGFR, node, loadRegister, loadRegister);
          }
       }
    else
       {
-      TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0 || (generateCompressedLockWord && (lockWordOffset & 3) == 0),
-            ""Lockword must be aligned on a double-word boundary or on a word boundary if the lockword is compressed\n"");
+      // LPDG requires memory references to be aligned to a double-wrod boundary
+      TR::MemoryReference* alignedLockMemoryReference = lockMemoryReference;
+      TR::MemoryReference* alignedLoadMemoryReference = loadMemoryReference;
 
-      if ((loadMemoryReference->getOffset() & 7) != 0)
-         {
-         TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Integer field must be aligned on a word boundary\n"");
-
-         TR::MemoryReference* alignedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, -4, cg);
+      bool lockRegisterRequiresShift = false;
+      bool loadRegisterRequiresShift = false;
 
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, alignedLoadMemoryReference, lockMemoryReference);
+      bool lockRegisterRequires32BitLogicalSignExtension = false;
+      bool loadRegisterRequires32BitLogicalSignExtension = false;
 
-         // For 64-bit uncompressed lockwords, when the load memory reference is not aligned to double-word boundaries,
-         // the loaded value is at the lower 32-bit. We need an AND to zero out the high half of loadRegister.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLock)
+         {
+         if ((lockWordOffset & 7) == 0)
             {
-            generateRILInstruction(cg, TR::InstOpCode::NIHF, node, loadRegister, static_cast<uintptrj_t>(0));
+            lockRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((lockWordOffset & 3) == 0, ""Lockword must be aligned on a word boundary\n"");
+
+            lockRegisterRequires32BitLogicalSignExtension = true;
+            alignedLockMemoryReference = generateS390MemoryReference(*lockMemoryReference, -4, cg);
             }
          }
       else
          {
-         TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+         // This is because we must use LPDG to load a 64-bit value
+         TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0, ""Lockword must be aligned on a double-word boundary\n"");
+         }
 
-         // We know we are generating for a 64-bit target. Furthermore we know the field we are loading is on a double-
-         // word boundary. However if we are loading an integer it only occupies 32-bits of storage, and since we must
-         // use LPDG to load the field it means the field will be generated in the most significant 32-bits of the
-         // loaded register. Hence we must carry out a right shift to move the loaded value into the least significant
-         // 32-bits of the respective register.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLoad)
+         {
+         if ((loadMemoryReference->getOffset() & 7) == 0)
             {
-            generateRSInstruction(cg, TR::InstOpCode::SRLG, node, loadRegister, loadRegister, 32);
+            loadRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Field must be aligned on a word boundary\n"");
+
+            loadRegisterRequires32BitLogicalSignExtension = true;","Yeah, I was thinking for primitive integer types the LLGFR is unnecessary.  However, I wonder how this interacts with our fancy load evaluator.  In some cases, we do extension as part of the load evaluation.",
70681452,86c30475541c567c2bf017474ca244d88901dd18,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,True,"@@ -66,71 +70,112 @@ ReduceSynchronizedFieldLoad::inlineSynchronizedFieldLoad(TR::Node* node, TR::Cod
 
    // Search for the load memory reference from the previously evaluated load
    TR::Instruction* loadInstruction = cg->comp()->getAppendInstruction();
-   // Sanity check for loads
-   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad(), ""Expecting the append instruction to be a load"");
 
-   // Sanity check for instruction kind as we are doing an unsafe cast following this
-   TR_ASSERT_SAFE_FATAL(loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY, ""Expecting the append instruction to be a load of kind RX or RXY\n"");
+   TR_ASSERT_SAFE_FATAL(loadInstruction->isLoad() && (loadInstruction->getKind() == OMR::Instruction::Kind::IsRX || loadInstruction->getKind() == OMR::Instruction::Kind::IsRXY), ""Expecting the append instruction to be a load of kind RX or RXY\n"");
 
    TR::MemoryReference* loadMemoryReference = static_cast<TR::S390RXInstruction*>(loadInstruction)->getMemoryReference();
 
    TR_ASSERT_SAFE_FATAL(loadMemoryReference->getIndexRegister() == NULL, ""Load memory reference must not have an index register\n"");
 
-   int32_t lockWordOffset = node->getChild(2)->getConst<int32_t>();
+   // Recreate the memory reference since the load instruction will be moved to the OOL code section and the register
+   // allocated to hold value of the base register of the memory reference may not be valid in the main line path
+   loadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
+
+   TR::Node* lockWordOffsetNode = node->getChild(2);
+
+   int32_t lockWordOffset = lockWordOffsetNode->getConst<int32_t>();
 
    TR::MemoryReference* lockMemoryReference = generateS390MemoryReference(objectRegister, lockWordOffset, cg);
 
    const bool generateCompressedLockWord = static_cast<TR_J9VMBase*>(cg->comp()->fe())->generateCompressedLockWord();
 
-   const bool generate32BitLoads = TR::Compiler->target.is32Bit() || (TR::Compiler->target.is64Bit() && generateCompressedLockWord && node->getChild(1)->getOpCodeValue() == TR::iloadi);
+   const bool is32BitLock = TR::Compiler->target.is32Bit() || generateCompressedLockWord;
+   const bool is32BitLoad = loadNode->getOpCodeValue() == TR::l2a || loadNode->getSymbolReference()->getSymbol()->getSize() == 4;
 
-   if (generate32BitLoads)
+   if (is32BitLock && is32BitLoad)
       {
-      TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+      generateSSFInstruction(cg, TR::InstOpCode::LPD, node, registerPair, loadMemoryReference, lockMemoryReference);
 
-      if (node->getChild(1)->getOpCodeValue() == TR::l2a)
+      if (loadNode->getOpCodeValue() == TR::l2a)
          {
          generateRREInstruction(cg, TR::InstOpCode::LLGFR, node, loadRegister, loadRegister);
          }
       }
    else
       {
-      TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0 || (generateCompressedLockWord && (lockWordOffset & 3) == 0),
-            ""Lockword must be aligned on a double-word boundary or on a word boundary if the lockword is compressed\n"");
+      // LPDG requires memory references to be aligned to a double-wrod boundary
+      TR::MemoryReference* alignedLockMemoryReference = lockMemoryReference;
+      TR::MemoryReference* alignedLoadMemoryReference = loadMemoryReference;
 
-      if ((loadMemoryReference->getOffset() & 7) != 0)
-         {
-         TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Integer field must be aligned on a word boundary\n"");
-
-         TR::MemoryReference* alignedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, -4, cg);
+      bool lockRegisterRequiresShift = false;
+      bool loadRegisterRequiresShift = false;
 
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, alignedLoadMemoryReference, lockMemoryReference);
+      bool lockRegisterRequires32BitLogicalSignExtension = false;
+      bool loadRegisterRequires32BitLogicalSignExtension = false;
 
-         // For 64-bit uncompressed lockwords, when the load memory reference is not aligned to double-word boundaries,
-         // the loaded value is at the lower 32-bit. We need an AND to zero out the high half of loadRegister.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLock)
+         {
+         if ((lockWordOffset & 7) == 0)
             {
-            generateRILInstruction(cg, TR::InstOpCode::NIHF, node, loadRegister, static_cast<uintptrj_t>(0));
+            lockRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((lockWordOffset & 3) == 0, ""Lockword must be aligned on a word boundary\n"");
+
+            lockRegisterRequires32BitLogicalSignExtension = true;
+            alignedLockMemoryReference = generateS390MemoryReference(*lockMemoryReference, -4, cg);
             }
          }
       else
          {
-         TR::MemoryReference* reusedLoadMemoryReference = generateS390MemoryReference(*loadMemoryReference, 0, cg);
-
-         generateSSFInstruction(cg, TR::InstOpCode::LPDG, node, registerPair, reusedLoadMemoryReference, lockMemoryReference);
+         // This is because we must use LPDG to load a 64-bit value
+         TR_ASSERT_SAFE_FATAL((lockWordOffset & 7) == 0, ""Lockword must be aligned on a double-word boundary\n"");
+         }
 
-         // We know we are generating for a 64-bit target. Furthermore we know the field we are loading is on a double-
-         // word boundary. However if we are loading an integer it only occupies 32-bits of storage, and since we must
-         // use LPDG to load the field it means the field will be generated in the most significant 32-bits of the
-         // loaded register. Hence we must carry out a right shift to move the loaded value into the least significant
-         // 32-bits of the respective register.
-         if (node->getChild(1)->getOpCodeValue() == TR::iloadi)
+      if (is32BitLoad)
+         {
+         if ((loadMemoryReference->getOffset() & 7) == 0)
             {
-            generateRSInstruction(cg, TR::InstOpCode::SRLG, node, loadRegister, loadRegister, 32);
+            loadRegisterRequiresShift = true;
+            }
+         else
+            {
+            // This is because we must use LPDG to load a 32-bit value using displacement -4
+            TR_ASSERT_SAFE_FATAL((loadMemoryReference->getOffset() & 3) == 0, ""Field must be aligned on a word boundary\n"");
+
+            loadRegisterRequires32BitLogicalSignExtension = true;","I made the modification in 86c3047 to only generate the extension for address data types. This should address all the review comments. Let me know if there is anything else.

As for the fancy load evaluator the patterns we match here explicitly only permit simple load immediates for primitive types. We do not handle (yet) at least any sign extensions etc. for primitives at least.",
70851825,24c0233af8fb7d4f6b52028380c225871dfa17e0,runtime/rasdump/dmpagent.c,False,"@@ -321,9 +321,9 @@ static const J9RASdumpSpec rasDumpSpecs[] =
   400,
 
   J9RAS_DUMP_DO_EXCLUSIVE_VM_ACCESS
-#ifndef J9ZOS390
+#if !defined(J9ZOS390) || !defined(J9ZTPF)",This should be && not ||. I'll have to revert this change.,
70887267,ffc155f1420cf370ba3a3303bde80162c8343339,runtime/tr.source/trj9/optimizer/SPMDPreCheck.cpp,False,"@@ -78,7 +78,7 @@ bool SPMDPreCheck::isSPMDCandidate(TR::Compilation *comp, TR_RegionStructure *lo
              }
 
           // unsafe opcode - we will skip LAR and SPMD
-          traceMsg(comp, ""SPMD PRE-CHECK FAILURE: found disallowed opcode %s at treetop %p in loop %d\n"", comp->getDebug()->getName(node->getOpCodeValue()), tt, loop->getNumber());
+          traceMsg(comp, ""SPMD PRE-CHECK FAILURE: found disallowed opcode %s at treetop %p in loop %d\n"", comp->getDebug()->getName(node->getOpCodeValue()), node, loop->getNumber());","`node` is not a treetop though. Would it be better if the trace message said ""found disallowed opcode %s at node %p""? Or even better print both the treetop and the node?",
70889787,ffc155f1420cf370ba3a3303bde80162c8343339,runtime/tr.source/trj9/optimizer/SPMDPreCheck.cpp,True,"@@ -78,7 +78,7 @@ bool SPMDPreCheck::isSPMDCandidate(TR::Compilation *comp, TR_RegionStructure *lo
              }
 
           // unsafe opcode - we will skip LAR and SPMD
-          traceMsg(comp, ""SPMD PRE-CHECK FAILURE: found disallowed opcode %s at treetop %p in loop %d\n"", comp->getDebug()->getName(node->getOpCodeValue()), tt, loop->getNumber());
+          traceMsg(comp, ""SPMD PRE-CHECK FAILURE: found disallowed opcode %s at treetop %p in loop %d\n"", comp->getDebug()->getName(node->getOpCodeValue()), node, loop->getNumber());","That's a good point, I'll modify the message for clarity",
70938560,9baf148fb4b0912efa716cdb85c81aba5756fdf0,runtime/tr.source/trj9/runtime/MetaData.cpp,False,"@@ -1465,7 +1465,7 @@ createMethodMetaData(
 
    data->startPC = (UDATA)comp->cg()->getCodeStart();
    data->endPC = (UDATA)comp->cg()->getCodeEnd();
-   data->startColdPC = (UDATA)comp->cg()->getColdCodeStart();
+   data->startColdPC = (UDATA)0;
 
    if (data->startColdPC)",i assume you'll fold this away in a subsequent commit? :),
70940537,9baf148fb4b0912efa716cdb85c81aba5756fdf0,runtime/tr.source/trj9/runtime/MetaData.cpp,True,"@@ -1465,7 +1465,7 @@ createMethodMetaData(
 
    data->startPC = (UDATA)comp->cg()->getCodeStart();
    data->endPC = (UDATA)comp->cg()->getCodeEnd();
-   data->startColdPC = (UDATA)comp->cg()->getColdCodeStart();
+   data->startColdPC = (UDATA)0;
 
    if (data->startColdPC)","Yes, I'm doing this very conservatively, but I could fix this one up right away because its clearly dead.",
70941718,9baf148fb4b0912efa716cdb85c81aba5756fdf0,runtime/tr.source/trj9/runtime/MetaData.cpp,True,"@@ -1465,7 +1465,7 @@ createMethodMetaData(
 
    data->startPC = (UDATA)comp->cg()->getCodeStart();
    data->endPC = (UDATA)comp->cg()->getCodeEnd();
-   data->startColdPC = (UDATA)comp->cg()->getColdCodeStart();
+   data->startColdPC = (UDATA)0;
 
    if (data->startColdPC)",Fixed,
70998663,4ac4cdc8164d6563392b6c89814ff12b154a0d9b,runtime/vm/createramclass.cpp,False,"@@ -530,8 +540,9 @@ addInterfaceMethods(J9VMThread *vmStruct, J9ClassLoader *classLoader, J9Class *i
 existing_entry = previous_entry;
 J9EquivalentEntry * new_entry = (J9EquivalentEntry*) pool_newElement(equivalentSets);
 if (NULL == new_entry) {
+/* OOM will be thrown */
 setNativeOutOfMemoryError(vmStruct, 0, 0);",`setNativeOutOfMemoryError` should this have been removed like the call above?,
71014441,4ac4cdc8164d6563392b6c89814ff12b154a0d9b,runtime/vm/createramclass.cpp,True,"@@ -530,8 +540,9 @@ addInterfaceMethods(J9VMThread *vmStruct, J9ClassLoader *classLoader, J9Class *i
 existing_entry = previous_entry;
 J9EquivalentEntry * new_entry = (J9EquivalentEntry*) pool_newElement(equivalentSets);
 if (NULL == new_entry) {
+/* OOM will be thrown */
 setNativeOutOfMemoryError(vmStruct, 0, 0);","Arg, yep.",
71014508,4ac4cdc8164d6563392b6c89814ff12b154a0d9b,runtime/vm/createramclass.cpp,True,"@@ -530,8 +540,9 @@ addInterfaceMethods(J9VMThread *vmStruct, J9ClassLoader *classLoader, J9Class *i
 existing_entry = previous_entry;
 J9EquivalentEntry * new_entry = (J9EquivalentEntry*) pool_newElement(equivalentSets);
 if (NULL == new_entry) {
+/* OOM will be thrown */
 setNativeOutOfMemoryError(vmStruct, 0, 0);",Fixed.,
71022412,4ac4cdc8164d6563392b6c89814ff12b154a0d9b,runtime/vm/createramclass.cpp,False,"@@ -559,7 +569,14 @@ addInterfaceMethods(J9VMThread *vmStruct, J9ClassLoader *classLoader, J9Class *i
 vTableMethodClassNameUTF = J9ROMCLASS_CLASSNAME(methodClass->romClass);
 }
 J9UTF8 *interfaceClassNameUTF = J9ROMCLASS_CLASSNAME(interfaceClass->romClass);
-setClassLoadingConstraintOverrideError(vmStruct, J9ROMCLASS_CLASSNAME(romClass), vTableMethodLoader, vTableMethodClassNameUTF, interfaceLoader, interfaceClassNameUTF, interfaceClassNameUTF, J9UTF8_DATA(vTableMethodNameUTF), J9UTF8_LENGTH(vTableMethodNameUTF), J9UTF8_DATA(vTableMethodSigUTF), J9UTF8_LENGTH(vTableMethodSigUTF));
+/* LinkageError will be thrown */
+errorData->loader1 = vTableMethodLoader;
+errorData->class1NameUTF = vTableMethodClassNameUTF;
+errorData->loader2 = interfaceLoader;
+errorData->class2NameUTF = interfaceClassNameUTF;
+errorData->exceptionClassNameUTF = interfaceClassNameUTF;
+errorData->methodNameUTF = vTableMethodNameUTF;
+errorData->methodSigUTF = vTableMethodSigUTF;","for code clarity, should this `goto fail` rather than `goto done`?  ",
71039695,4ac4cdc8164d6563392b6c89814ff12b154a0d9b,runtime/vm/createramclass.cpp,True,"@@ -559,7 +569,14 @@ addInterfaceMethods(J9VMThread *vmStruct, J9ClassLoader *classLoader, J9Class *i
 vTableMethodClassNameUTF = J9ROMCLASS_CLASSNAME(methodClass->romClass);
 }
 J9UTF8 *interfaceClassNameUTF = J9ROMCLASS_CLASSNAME(interfaceClass->romClass);
-setClassLoadingConstraintOverrideError(vmStruct, J9ROMCLASS_CLASSNAME(romClass), vTableMethodLoader, vTableMethodClassNameUTF, interfaceLoader, interfaceClassNameUTF, interfaceClassNameUTF, J9UTF8_DATA(vTableMethodNameUTF), J9UTF8_LENGTH(vTableMethodNameUTF), J9UTF8_DATA(vTableMethodSigUTF), J9UTF8_LENGTH(vTableMethodSigUTF));
+/* LinkageError will be thrown */
+errorData->loader1 = vTableMethodLoader;
+errorData->class1NameUTF = vTableMethodClassNameUTF;
+errorData->loader2 = interfaceLoader;
+errorData->class2NameUTF = interfaceClassNameUTF;
+errorData->exceptionClassNameUTF = interfaceClassNameUTF;
+errorData->methodNameUTF = vTableMethodNameUTF;
+errorData->methodSigUTF = vTableMethodSigUTF;",Agreed - fixed.,
71214301,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {",Please add a comment that describes the purpose of these fast paths in the code.  The commit comment info is good and should be here in the source as well.,
71214301,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {
+if (regex != null && substitute != null && regex.lengthInternal() == 1 && !hasMetaChars(regex)) {
+int substituteLength = substitute.lengthInternal();
+int length = lengthInternal();
+int newCharIndex = 0;",This variable should move into the scopes where it is used to make it easier to reason about it's life time.,
71214301,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {
+if (regex != null && substitute != null && regex.lengthInternal() == 1 && !hasMetaChars(regex)) {
+int substituteLength = substitute.lengthInternal();
+int length = lengthInternal();
+int newCharIndex = 0;
+if (substituteLength < 2) {
+if (enableCompression && isCompressed() && (substituteLength == 0 || substitute.isCompressed())) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length];
+/*[ELSE]*/
+char[] newChars = new char[(length + 1) >> 1];
+/*[ENDIF]*/
+byte toReplace = helpers.getByteFromArrayByIndex(regex, 0);
+byte replacement = substituteLength == 1 ? helpers.getByteFromArrayByIndex(substitute, 0) : (byte)-1;",Why is replacement set to `-1` if `substituteLength ==1`?  Won't that right an incorrect value into the `newChars` on line 4295?,
71214301,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {
+if (regex != null && substitute != null && regex.lengthInternal() == 1 && !hasMetaChars(regex)) {
+int substituteLength = substitute.lengthInternal();
+int length = lengthInternal();
+int newCharIndex = 0;
+if (substituteLength < 2) {
+if (enableCompression && isCompressed() && (substituteLength == 0 || substitute.isCompressed())) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length];
+/*[ELSE]*/
+char[] newChars = new char[(length + 1) >> 1];
+/*[ENDIF]*/
+byte toReplace = helpers.getByteFromArrayByIndex(regex, 0);
+byte replacement = substituteLength == 1 ? helpers.getByteFromArrayByIndex(substitute, 0) : (byte)-1;
+for (int i = 0; i < length; ++i) {
+byte current = helpers.getByteFromArrayByIndex(value, i);
+if (current != toReplace) {
+helpers.putByteInArrayByIndex(newChars, newCharIndex++, current);
+} else if (substituteLength == 1) {
+helpers.putByteInArrayByIndex(newChars, newCharIndex++, replacement);
+}
+}
+return new String(newChars, 0, newCharIndex, true);
+} else if (!enableCompression || !isCompressed()) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length << 1];
+/*[ELSE]*/
+char[] newChars = new char[length];
+/*[ENDIF]*/
+char toReplace = regex.charAtInternal(0);
+char replacement = substituteLength == 1 ? substitute.charAtInternal(0) : (char)-1; ",Same concern about `-1` here as well.,
71260160,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {
+if (regex != null && substitute != null && regex.lengthInternal() == 1 && !hasMetaChars(regex)) {
+int substituteLength = substitute.lengthInternal();
+int length = lengthInternal();
+int newCharIndex = 0;
+if (substituteLength < 2) {
+if (enableCompression && isCompressed() && (substituteLength == 0 || substitute.isCompressed())) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length];
+/*[ELSE]*/
+char[] newChars = new char[(length + 1) >> 1];
+/*[ENDIF]*/
+byte toReplace = helpers.getByteFromArrayByIndex(regex, 0);
+byte replacement = substituteLength == 1 ? helpers.getByteFromArrayByIndex(substitute, 0) : (byte)-1;",the -1 will only happen when subsituteLength == 0 and so 4295 will never see the value. -1 is just a dummy value that is more obviously bad than 0 should the logic ever break,
71260248,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {
+if (regex != null && substitute != null && regex.lengthInternal() == 1 && !hasMetaChars(regex)) {
+int substituteLength = substitute.lengthInternal();
+int length = lengthInternal();
+int newCharIndex = 0;
+if (substituteLength < 2) {
+if (enableCompression && isCompressed() && (substituteLength == 0 || substitute.isCompressed())) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length];
+/*[ELSE]*/
+char[] newChars = new char[(length + 1) >> 1];
+/*[ENDIF]*/
+byte toReplace = helpers.getByteFromArrayByIndex(regex, 0);
+byte replacement = substituteLength == 1 ? helpers.getByteFromArrayByIndex(substitute, 0) : (byte)-1;
+for (int i = 0; i < length; ++i) {
+byte current = helpers.getByteFromArrayByIndex(value, i);
+if (current != toReplace) {
+helpers.putByteInArrayByIndex(newChars, newCharIndex++, current);
+} else if (substituteLength == 1) {
+helpers.putByteInArrayByIndex(newChars, newCharIndex++, replacement);
+}
+}
+return new String(newChars, 0, newCharIndex, true);
+} else if (!enableCompression || !isCompressed()) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length << 1];
+/*[ELSE]*/
+char[] newChars = new char[length];
+/*[ENDIF]*/
+char toReplace = regex.charAtInternal(0);
+char replacement = substituteLength == 1 ? substitute.charAtInternal(0) : (char)-1; ",same reasoning as above to say the -1 is never used/seen,
71261536,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,True,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {",added,
71262837,3fcaa350f275b2847858152c851952a5e1c2b2a9,jcl/src/java.base/share/classes/java/lang/String.java,False,"@@ -4273,8 +4273,50 @@ public boolean matches(String expr) {
  *
  * @since 1.4
  */
-public String replaceAll(String expr, String substitute) {
-return Pattern.compile(expr).matcher(this).replaceAll(substitute);
+public String replaceAll(String regex, String substitute) {
+if (regex != null && substitute != null && regex.lengthInternal() == 1 && !hasMetaChars(regex)) {
+int substituteLength = substitute.lengthInternal();
+int length = lengthInternal();
+int newCharIndex = 0;
+if (substituteLength < 2) {
+if (enableCompression && isCompressed() && (substituteLength == 0 || substitute.isCompressed())) {
+/*[IF Sidecar19-SE]*/
+byte[] newChars = new byte[length];
+/*[ELSE]*/
+char[] newChars = new char[(length + 1) >> 1];
+/*[ENDIF]*/
+byte toReplace = helpers.getByteFromArrayByIndex(regex, 0);
+byte replacement = substituteLength == 1 ? helpers.getByteFromArrayByIndex(substitute, 0) : (byte)-1;","Thanks for clarifying.  Can you add a comment to that effect?  Might be clearer if broken up like:
```
byte replacement = -1;  // assign dummy value that will never be used
if (substituteLength == 1) {
   replacement = helpers.getByteFromArrayByIndex(substitute, 0);
}
```",
67219661,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/platform/host/s390-ztpf64-gcc.mk,False,"@@ -0,0 +1,26 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others",Is this initial date correct?  The code here dates back to the 2000?,
67219661,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/rules/ztpf-gcc/common.mk,False,"@@ -0,0 +1,72 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others",Are the dates accurate here?,
67219661,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/rules/ztpf-gcc/filetypes.mk,False,"@@ -0,0 +1,235 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others",Is 2000 the correct start date?,
67219661,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/rules/ztpf-gcc/filetypes.mk,False,"@@ -0,0 +1,235 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+
+#
+# These are the rules to compile files of type "".x"" into object files
+# as well as to generate clean and cleandeps rules
+#
+
+#
+# Compile .c file into .o file
+#
+define DEF_RULE.c
+
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(C_CMD) $$(C_FLAGS) $$(patsubst %,-D%,$$(C_DEFINES)) $$(patsubst %,-I'%',$$(C_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.c
+
+RULE.c=$(eval $(DEF_RULE.c))
+
+#
+# Compile .cpp file into .o file
+#
+define DEF_RULE.cpp
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(CXX_CMD) $$(CXX_FLAGS) $$(patsubst %,-D%,$$(CXX_DEFINES)) $$(patsubst %,-I'%',$$(CXX_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.cpp
+
+RULE.cpp=$(eval $(DEF_RULE.cpp))
+
+#
+# Compile .s file into .o file
+#
+define DEF_RULE.s
+$(1): $(2) | jit_createdirs
+$$(S_CMD) $$(S_FLAGS) $$(patsubst %,--defsym %=1,$$(S_DEFINES)) $$(patsubst %,-I'%',$$(S_INCLUDES)) -o $$@ $$<
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+endef # DEF_RULE.s
+
+RULE.s=$(eval $(DEF_RULE.s))
+
+##### START X SPECIFIC RULES #####",`START X SPECIFIC RULES` is this necessary in a ztpf file?,
67219661,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/rules/ztpf-gcc/filetypes.mk,False,"@@ -0,0 +1,235 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+
+#
+# These are the rules to compile files of type "".x"" into object files
+# as well as to generate clean and cleandeps rules
+#
+
+#
+# Compile .c file into .o file
+#
+define DEF_RULE.c
+
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(C_CMD) $$(C_FLAGS) $$(patsubst %,-D%,$$(C_DEFINES)) $$(patsubst %,-I'%',$$(C_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.c
+
+RULE.c=$(eval $(DEF_RULE.c))
+
+#
+# Compile .cpp file into .o file
+#
+define DEF_RULE.cpp
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(CXX_CMD) $$(CXX_FLAGS) $$(patsubst %,-D%,$$(CXX_DEFINES)) $$(patsubst %,-I'%',$$(CXX_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.cpp
+
+RULE.cpp=$(eval $(DEF_RULE.cpp))
+
+#
+# Compile .s file into .o file
+#
+define DEF_RULE.s
+$(1): $(2) | jit_createdirs
+$$(S_CMD) $$(S_FLAGS) $$(patsubst %,--defsym %=1,$$(S_DEFINES)) $$(patsubst %,-I'%',$$(S_INCLUDES)) -o $$@ $$<
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+endef # DEF_RULE.s
+
+RULE.s=$(eval $(DEF_RULE.s))
+
+##### START X SPECIFIC RULES #####
+ifeq ($(HOST_ARCH),x)
+
+# TODO - Fix MASM2GAS to have a little more sane output file behavior
+#
+# Compile .asm file into .o file
+# (By changing it to a .s file and then assembling it)
+#
+define DEF_RULE.asm
+$(1).s: $(2) | jit_createdirs
+$$(PERL_PATH) $$(ASM_SCRIPT) $$(ASM_FLAGS) $$(patsubst %,-I'%',$$(ASM_INCLUDES)) -o$$(dir $$@) $$<
+-mv $$(dir $$@)$$(notdir $$(basename $$<).s) $$@
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1).s
+
+$(call RULE.s,$(1),$(1).s)
+endef # DEF_RULE.asm
+
+RULE.asm=$(eval $(DEF_RULE.asm))
+
+#
+# Compile .pasm file into .o file
+#
+define DEF_RULE.pasm
+$(1).asm: $(2) | jit_createdirs
+$$(PASM_CMD) $$(PASM_FLAGS) $$(patsubst %,-I'%',$$(PASM_INCLUDES)) -o $$@ -x assembler-with-cpp -E -P $$<
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1).asm
+
+$(call RULE.asm,$(1),$(1).asm)
+endef # DEF_RULE.pasm
+
+RULE.pasm=$(eval $(DEF_RULE.pasm))
+
+endif # ($(HOST_ARCH),x)
+##### END X SPECIFIC RULES #####
+
+##### START PPC SPECIFIC RULES #####",Is this section necessary in a ztpf file?,
67219661,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/rules/ztpf-gcc/filetypes.mk,False,"@@ -0,0 +1,235 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+
+#
+# These are the rules to compile files of type "".x"" into object files
+# as well as to generate clean and cleandeps rules
+#
+
+#
+# Compile .c file into .o file
+#
+define DEF_RULE.c
+
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(C_CMD) $$(C_FLAGS) $$(patsubst %,-D%,$$(C_DEFINES)) $$(patsubst %,-I'%',$$(C_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.c
+
+RULE.c=$(eval $(DEF_RULE.c))
+
+#
+# Compile .cpp file into .o file
+#
+define DEF_RULE.cpp
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(CXX_CMD) $$(CXX_FLAGS) $$(patsubst %,-D%,$$(CXX_DEFINES)) $$(patsubst %,-I'%',$$(CXX_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.cpp
+
+RULE.cpp=$(eval $(DEF_RULE.cpp))
+
+#
+# Compile .s file into .o file
+#
+define DEF_RULE.s
+$(1): $(2) | jit_createdirs
+$$(S_CMD) $$(S_FLAGS) $$(patsubst %,--defsym %=1,$$(S_DEFINES)) $$(patsubst %,-I'%',$$(S_INCLUDES)) -o $$@ $$<
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+endef # DEF_RULE.s
+
+RULE.s=$(eval $(DEF_RULE.s))
+
+##### START X SPECIFIC RULES #####
+ifeq ($(HOST_ARCH),x)
+
+# TODO - Fix MASM2GAS to have a little more sane output file behavior
+#
+# Compile .asm file into .o file
+# (By changing it to a .s file and then assembling it)
+#
+define DEF_RULE.asm
+$(1).s: $(2) | jit_createdirs
+$$(PERL_PATH) $$(ASM_SCRIPT) $$(ASM_FLAGS) $$(patsubst %,-I'%',$$(ASM_INCLUDES)) -o$$(dir $$@) $$<
+-mv $$(dir $$@)$$(notdir $$(basename $$<).s) $$@
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1).s
+
+$(call RULE.s,$(1),$(1).s)
+endef # DEF_RULE.asm
+
+RULE.asm=$(eval $(DEF_RULE.asm))
+
+#
+# Compile .pasm file into .o file
+#
+define DEF_RULE.pasm
+$(1).asm: $(2) | jit_createdirs
+$$(PASM_CMD) $$(PASM_FLAGS) $$(patsubst %,-I'%',$$(PASM_INCLUDES)) -o $$@ -x assembler-with-cpp -E -P $$<
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1).asm
+
+$(call RULE.asm,$(1),$(1).asm)
+endef # DEF_RULE.pasm
+
+RULE.pasm=$(eval $(DEF_RULE.pasm))
+
+endif # ($(HOST_ARCH),x)
+##### END X SPECIFIC RULES #####
+
+##### START PPC SPECIFIC RULES #####
+ifeq ($(HOST_ARCH),p) 
+
+#
+# Compile .ipp file into .o file
+#
+define DEF_RULE.ipp
+$(1).s: $(2) | jit_createdirs
+$$(IPP_CMD) $$(IPP_FLAGS) 's/\!/\#/g' $$< > $$@
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1).s
+
+$(call RULE.s,$(1),$(1).s)
+endef # DEF_RULE.ipp
+
+RULE.ipp=$(eval $(DEF_RULE.ipp))
+
+#
+# Compile .spp file into .o file
+#
+define DEF_RULE.spp
+$(1).ipp: $(2) | jit_createdirs
+$$(SPP_CMD) $$(SPP_FLAGS) $$(patsubst %,-D%,$$(SPP_DEFINES)) $$(patsubst %,-I'%',$$(SPP_INCLUDES)) -o $$@ -x assembler-with-cpp -E -P $$<
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1).ipp
+
+$(call RULE.ipp,$(1),$(1).ipp)
+endef # DEF_RULE.spp
+
+RULE.spp=$(eval $(DEF_RULE.spp))
+
+endif # ($(HOST_ARCH),p) 
+##### END PPC SPECIFIC RULES #####
+
+##### START Z SPECIFIC RULES #####
+ifeq ($(HOST_ARCH),z)
+
+#
+# Compile .m4 file into .o file
+#
+define DEF_RULE.m4
+$(1).s: $(2) | jit_createdirs
+$$(PERL_PATH) $$(ZASM_SCRIPT) $$<
+$$(M4_CMD) $$(M4_FLAGS) $$(patsubst %,-I'%',$$(M4_INCLUDES)) $$(patsubst %,-D%,$$(M4_DEFINES)) $$< > $$@
+$$(PERL_PATH) $$(ZASM_SCRIPT) $$@
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1).s
+
+$(call RULE.s,$(1),$(1).s)
+endef # DEF_RULE.m4
+
+RULE.m4=$(eval $(DEF_RULE.m4))
+
+endif # ($(HOST_ARCH),z)
+##### END Z SPECIFIC RULES #####
+
+##### START ARM SPECIFIC RULES #####",Same question about this section - can it be removed?,
67219661,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/toolcfg/host/ztpf.mk,False,"@@ -0,0 +1,26 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others",start date?,
67232510,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/platform/host/s390-ztpf64-gcc.mk,True,"@@ -0,0 +1,26 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others","Thanks, since I've only just created the file, there's no need for two dates in the copyright statement.
",
67232730,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/rules/ztpf-gcc/common.mk,True,"@@ -0,0 +1,72 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others",There should only be one copyright date.,
67232746,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/rules/ztpf-gcc/filetypes.mk,True,"@@ -0,0 +1,235 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others",There should only be one copyright date.,
67232787,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/rules/ztpf-gcc/filetypes.mk,True,"@@ -0,0 +1,235 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+
+#
+# These are the rules to compile files of type "".x"" into object files
+# as well as to generate clean and cleandeps rules
+#
+
+#
+# Compile .c file into .o file
+#
+define DEF_RULE.c
+
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(C_CMD) $$(C_FLAGS) $$(patsubst %,-D%,$$(C_DEFINES)) $$(patsubst %,-I'%',$$(C_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.c
+
+RULE.c=$(eval $(DEF_RULE.c))
+
+#
+# Compile .cpp file into .o file
+#
+define DEF_RULE.cpp
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(CXX_CMD) $$(CXX_FLAGS) $$(patsubst %,-D%,$$(CXX_DEFINES)) $$(patsubst %,-I'%',$$(CXX_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.cpp
+
+RULE.cpp=$(eval $(DEF_RULE.cpp))
+
+#
+# Compile .s file into .o file
+#
+define DEF_RULE.s
+$(1): $(2) | jit_createdirs
+$$(S_CMD) $$(S_FLAGS) $$(patsubst %,--defsym %=1,$$(S_DEFINES)) $$(patsubst %,-I'%',$$(S_INCLUDES)) -o $$@ $$<
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+endef # DEF_RULE.s
+
+RULE.s=$(eval $(DEF_RULE.s))
+
+##### START X SPECIFIC RULES #####",Not necessary.,
67232810,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/rules/ztpf-gcc/filetypes.mk,True,"@@ -0,0 +1,235 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+
+#
+# These are the rules to compile files of type "".x"" into object files
+# as well as to generate clean and cleandeps rules
+#
+
+#
+# Compile .c file into .o file
+#
+define DEF_RULE.c
+
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(C_CMD) $$(C_FLAGS) $$(patsubst %,-D%,$$(C_DEFINES)) $$(patsubst %,-I'%',$$(C_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.c
+
+RULE.c=$(eval $(DEF_RULE.c))
+
+#
+# Compile .cpp file into .o file
+#
+define DEF_RULE.cpp
+$(1): $(2) $(1)$(DEPSUFF) | jit_createdirs
+$$(CXX_CMD) $$(CXX_FLAGS) $$(patsubst %,-D%,$$(CXX_DEFINES)) $$(patsubst %,-I'%',$$(CXX_INCLUDES)) -MMD -MF $$@$$(DEPSUFF) -MT $$@ -MP -o $$@ -c $$<
+
+$(1)$(DEPSUFF): ;
+
+-include $(1)$(DEPSUFF)
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+jit_cleandeps::
+rm -f $(1)$(DEPSUFF)
+
+endef # DEF_RULE.cpp
+
+RULE.cpp=$(eval $(DEF_RULE.cpp))
+
+#
+# Compile .s file into .o file
+#
+define DEF_RULE.s
+$(1): $(2) | jit_createdirs
+$$(S_CMD) $$(S_FLAGS) $$(patsubst %,--defsym %=1,$$(S_DEFINES)) $$(patsubst %,-I'%',$$(S_INCLUDES)) -o $$@ $$<
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1)
+
+endef # DEF_RULE.s
+
+RULE.s=$(eval $(DEF_RULE.s))
+
+##### START X SPECIFIC RULES #####
+ifeq ($(HOST_ARCH),x)
+
+# TODO - Fix MASM2GAS to have a little more sane output file behavior
+#
+# Compile .asm file into .o file
+# (By changing it to a .s file and then assembling it)
+#
+define DEF_RULE.asm
+$(1).s: $(2) | jit_createdirs
+$$(PERL_PATH) $$(ASM_SCRIPT) $$(ASM_FLAGS) $$(patsubst %,-I'%',$$(ASM_INCLUDES)) -o$$(dir $$@) $$<
+-mv $$(dir $$@)$$(notdir $$(basename $$<).s) $$@
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1).s
+
+$(call RULE.s,$(1),$(1).s)
+endef # DEF_RULE.asm
+
+RULE.asm=$(eval $(DEF_RULE.asm))
+
+#
+# Compile .pasm file into .o file
+#
+define DEF_RULE.pasm
+$(1).asm: $(2) | jit_createdirs
+$$(PASM_CMD) $$(PASM_FLAGS) $$(patsubst %,-I'%',$$(PASM_INCLUDES)) -o $$@ -x assembler-with-cpp -E -P $$<
+
+JIT_DIR_LIST+=$(dir $(1))
+
+jit_cleanobjs::
+rm -f $(1).asm
+
+$(call RULE.asm,$(1),$(1).asm)
+endef # DEF_RULE.pasm
+
+RULE.pasm=$(eval $(DEF_RULE.pasm))
+
+endif # ($(HOST_ARCH),x)
+##### END X SPECIFIC RULES #####
+
+##### START PPC SPECIFIC RULES #####",Not necessary...,
67232857,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/toolcfg/host/ztpf.mk,True,"@@ -0,0 +1,26 @@
+# Copyright (c) 2000, 2017 IBM Corp. and others",There should only be one copyright date.,
69627067,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/z/env/J9CPU.cpp,False,"@@ -41,6 +41,7 @@
 
 #if defined(J9ZTPF)
 #include <tpf/c_pi1dt.h> // for access to machine type.
+#include <<tpf/c_cinfc.h> // for access to CINFC core tables.",Is this a typo? There seems to be an extra `<` in the path. Also why is this include needed exactly? There are no other code modifications that make use of the structures defined in this header.,
69883037,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/z/env/J9CPU.cpp,True,"@@ -41,6 +41,7 @@
 
 #if defined(J9ZTPF)
 #include <tpf/c_pi1dt.h> // for access to machine type.
+#include <<tpf/c_cinfc.h> // for access to CINFC core tables.",Seems I cannot type; yes it is a typo. This include is needed to access a previously added field; copy/paste also is an issue for me.,
70088375,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/z/env/J9CPU.cpp,False,"@@ -205,33 +206,17 @@ CPU::TO_PORTLIB_get390zLinuxMachineType()
    const int PROC_HEADER_SIZE = sizeof(procHeader) - 1;
 
 #if defined(J9ZTPF)
-   TR_S390MachineType ret_machine = TR_Z10;  /* return value, z/TPF default */
    struct pi1dt *pid;
-   /* machine hardware name */
+   /*
+    * Use the model number from the in-core processor ID table, accessed
+    * via CINFC_CMMPID as the machine type.
+    * The z/TPF OS has strict requirements on supported z/Architecture hardware.
+    * As a result, the model number will necessarily match a valid TR_S390MachineType.
+    * Note - S390MachineTypes, declared above as a static const integer, contains the
+    * hex representation of the (decimal) model number found in the processors ID table.","Minor comment nit.  `S390MachineTypes` you described in an static const integer array containing the recognized machine types.   Are you referencing the `TR_S390MachineType` enum instead (https://github.com/eclipse/omr/blob/master/compiler/env/ProcessorInfo.hpp#L28-L61).  Also, not sure about the hex representation part... they are just binary integers. :) ",
70088375,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/toolcfg/ztpf-gcc/common.mk,False,"@@ -0,0 +1,300 @@
+# Copyright (c) 2017, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+#
+# Explicitly set shell
+#
+SHELL=/bin/sh
+
+#
+# These are the prefixes and suffixes that all GNU tools use for things
+#
+OBJSUFF=.o
+ARSUFF=.a
+SOSUFF=.so
+EXESUFF=
+LIBPREFIX=lib
+DEPSUFF=.depend.mk
+
+#
+# Paths for default programs on the platform
+# Most rules will use these default programs, but they can be overwritten individually if,
+# for example, you want to compile .spp files with a different C++ compiler than you use
+# to compile .cpp files
+#
+
+AS_PATH?=tpf-as
+M4_PATH?=m4
+SED_PATH?=sed
+AR_PATH?=ar
+PERL_PATH?=perl
+
+#
+# z/Architecture arch and tune level
+# z/TPF uses z10 as minminum supported z/Architecture.
+# mtune of z9-109 allows builtin versions of memcpy, etc.
+# instead of calling ""arch-optimized"" glibc functions.","This rational seems backwards to me -- and setting a tune to a level older than arch is odd.  Why would tune invoke arch-optimized glibc functions instead?  Are those compatible to run on z10 (min arch)?   

I would think you are leaving some performance on the table by not tuning to z196 or newer, as that level introduced the out of order pipeline.  However, I guess this gain may be offset by the less efficient memcpy, etc? ",
70342196,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/z/env/J9CPU.cpp,True,"@@ -205,33 +206,17 @@ CPU::TO_PORTLIB_get390zLinuxMachineType()
    const int PROC_HEADER_SIZE = sizeof(procHeader) - 1;
 
 #if defined(J9ZTPF)
-   TR_S390MachineType ret_machine = TR_Z10;  /* return value, z/TPF default */
    struct pi1dt *pid;
-   /* machine hardware name */
+   /*
+    * Use the model number from the in-core processor ID table, accessed
+    * via CINFC_CMMPID as the machine type.
+    * The z/TPF OS has strict requirements on supported z/Architecture hardware.
+    * As a result, the model number will necessarily match a valid TR_S390MachineType.
+    * Note - S390MachineTypes, declared above as a static const integer, contains the
+    * hex representation of the (decimal) model number found in the processors ID table.","The value that z/TPF picks up - the model number - matches TR_S390MachineType but not the binary integer. For example, model 2827 (ec12) was loaded into a register and compared against the value in the memory location for S390MachineTypes which is xB0B.  I can take the comment out but I wanted anyone on the Pok. team to be aware of why the checks are removed from this version of J9CPU.cpp",
70657028,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/z/env/J9CPU.cpp,False,"@@ -205,33 +206,17 @@ CPU::TO_PORTLIB_get390zLinuxMachineType()
    const int PROC_HEADER_SIZE = sizeof(procHeader) - 1;
 
 #if defined(J9ZTPF)
-   TR_S390MachineType ret_machine = TR_Z10;  /* return value, z/TPF default */
    struct pi1dt *pid;
-   /* machine hardware name */
+   /*
+    * Use the model number from the in-core processor ID table, accessed
+    * via CINFC_CMMPID as the machine type.
+    * The z/TPF OS has strict requirements on supported z/Architecture hardware.
+    * As a result, the model number will necessarily match a valid TR_S390MachineType.
+    * Note - S390MachineTypes, declared above as a static const integer, contains the
+    * hex representation of the (decimal) model number found in the processors ID table.","Hmm.. okay.   2827 == 0xB0B.... the representation in registers or memory should be identical in bits.  If you had left the checks in there, did you observe check failures?  ",
70665626,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/toolcfg/ztpf-gcc/common.mk,True,"@@ -0,0 +1,300 @@
+# Copyright (c) 2017, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+#
+# Explicitly set shell
+#
+SHELL=/bin/sh
+
+#
+# These are the prefixes and suffixes that all GNU tools use for things
+#
+OBJSUFF=.o
+ARSUFF=.a
+SOSUFF=.so
+EXESUFF=
+LIBPREFIX=lib
+DEPSUFF=.depend.mk
+
+#
+# Paths for default programs on the platform
+# Most rules will use these default programs, but they can be overwritten individually if,
+# for example, you want to compile .spp files with a different C++ compiler than you use
+# to compile .cpp files
+#
+
+AS_PATH?=tpf-as
+M4_PATH?=m4
+SED_PATH?=sed
+AR_PATH?=ar
+PERL_PATH?=perl
+
+#
+# z/Architecture arch and tune level
+# z/TPF uses z10 as minminum supported z/Architecture.
+# mtune of z9-109 allows builtin versions of memcpy, etc.
+# instead of calling ""arch-optimized"" glibc functions.","it is the opposite, Joran. The compiler will not create builtin_memcpy because the latest z/Architecture optimizations for memory moves were put into glibc (I think version 2.21) However, we are on a much older version, 2.3. We don't have those optimizations. There is a huge difference without a builtin_memcpy and without memory move optimizations for z/architecture in glibc.
",
70673192,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/toolcfg/ztpf-gcc/common.mk,False,"@@ -0,0 +1,300 @@
+# Copyright (c) 2017, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+#
+# Explicitly set shell
+#
+SHELL=/bin/sh
+
+#
+# These are the prefixes and suffixes that all GNU tools use for things
+#
+OBJSUFF=.o
+ARSUFF=.a
+SOSUFF=.so
+EXESUFF=
+LIBPREFIX=lib
+DEPSUFF=.depend.mk
+
+#
+# Paths for default programs on the platform
+# Most rules will use these default programs, but they can be overwritten individually if,
+# for example, you want to compile .spp files with a different C++ compiler than you use
+# to compile .cpp files
+#
+
+AS_PATH?=tpf-as
+M4_PATH?=m4
+SED_PATH?=sed
+AR_PATH?=ar
+PERL_PATH?=perl
+
+#
+# z/Architecture arch and tune level
+# z/TPF uses z10 as minminum supported z/Architecture.
+# mtune of z9-109 allows builtin versions of memcpy, etc.
+# instead of calling ""arch-optimized"" glibc functions.",OK.  Thanks for the extra insight.,
70677410,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/toolcfg/ztpf-gcc/common.mk,False,"@@ -0,0 +1,300 @@
+# Copyright (c) 2017, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+#
+# Explicitly set shell
+#
+SHELL=/bin/sh
+
+#
+# These are the prefixes and suffixes that all GNU tools use for things
+#
+OBJSUFF=.o
+ARSUFF=.a
+SOSUFF=.so
+EXESUFF=
+LIBPREFIX=lib
+DEPSUFF=.depend.mk
+
+#
+# Paths for default programs on the platform
+# Most rules will use these default programs, but they can be overwritten individually if,
+# for example, you want to compile .spp files with a different C++ compiler than you use
+# to compile .cpp files
+#
+
+AS_PATH?=tpf-as
+M4_PATH?=m4
+SED_PATH?=sed
+AR_PATH?=ar
+PERL_PATH?=perl
+
+#
+# z/Architecture arch and tune level
+# z/TPF uses z10 as minminum supported z/Architecture.
+# mtune of z9-109 allows builtin versions of memcpy, etc.
+# instead of calling ""arch-optimized"" glibc functions.
+#
+
+ARCHLEVEL?=z10
+TUNELEVEL?=z9-109
+
+CC_PATH?=tpf-gcc
+CXX_PATH?=tpf-g++
+
+# This is the script that's used to generate TRBuildName.cpp
+GENERATE_VERSION_SCRIPT?=$(JIT_SCRIPT_DIR)/generateVersion.pl
+
+# This is the script to preprocess ARM assembly files
+ARMASM_SCRIPT?=$(JIT_SCRIPT_DIR)/armasm2gas.sed",Is this needed?,
70677410,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/z/env/J9CPU.cpp,False,"@@ -205,33 +206,17 @@ CPU::TO_PORTLIB_get390zLinuxMachineType()
    const int PROC_HEADER_SIZE = sizeof(procHeader) - 1;
 
 #if defined(J9ZTPF)
-   TR_S390MachineType ret_machine = TR_Z10;  /* return value, z/TPF default */
    struct pi1dt *pid;
-   /* machine hardware name */
+   /*
+    * Use the model number from the in-core processor ID table, accessed
+    * via CINFC_CMMPID as the machine type.
+    * The z/TPF OS has strict requirements on supported z/Architecture hardware.
+    * As a result, the model number will necessarily match a valid TR_S390MachineType.
+    * Note - S390MachineTypes, declared above as a static const integer, contains the
+    * hex representation of the (decimal) model number found in the processors ID table.
+    */
    pid = (struct pi1dt *)cinfc_fast(CINFC_CMMPID);
-   int machine = (int)(pid->pi1pids.pi1mslr.pi1mod);
-
-   // Scan list of unsupported machines - We do not initialize the JIT for such hardware.
-   for (int i = 0; i < sizeof(S390UnsupportedMachineTypes) / sizeof(int); ++i)
-      {
-      if (machine == S390UnsupportedMachineTypes[i])
-         {
-         PORT_ACCESS_FROM_ENV(jitConfig->javaVM);
-         j9nls_printf(jitConfig->javaVM->portLibrary, J9NLS_ERROR, J9NLS_J9JIT_390_UNSUPPORTED_HARDWARE, machine);
-         TR_ASSERT(0,""Hardware is not supported."");
-         throw TR::CompilationException();
-         }
-      }
-
-   // Scan list of supported machines.
-   for (int i = 0; i < sizeof(S390MachineTypes) / sizeof(int); ++i)
-      {
-      if (machine == S390MachineTypes[i])
-         {
-         ret_machine = (TR_S390MachineType)machine;
-         }
-      }
-
+   TR_S390MachineType ret_machine = (TR_S390MachineType)(pid->pi1pids.pi1mslr.pi1mod);",Are you certain `pid->pi1pids.pi1mslr.pi1mod` will always contain a valid processor ID? What happens if this value is not contained within the list of enumerations in `TR_S390MachineType`? Then the value of `ret_machine` is technically undefined. Will this break things?,
70941335,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/build/toolcfg/ztpf-gcc/common.mk,True,"@@ -0,0 +1,300 @@
+# Copyright (c) 2017, 2017 IBM Corp. and others
+#
+# This program and the accompanying materials are made available under
+# the terms of the Eclipse Public License 2.0 which accompanies this
+# distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+# or the Apache License, Version 2.0 which accompanies this distribution and
+# is available at https://www.apache.org/licenses/LICENSE-2.0.
+#
+# This Source Code may also be made available under the following
+# Secondary Licenses when the conditions for such availability set
+# forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+# General Public License, version 2 with the GNU Classpath
+# Exception [1] and GNU General Public License, version 2 with the
+# OpenJDK Assembly Exception [2].
+#
+# [1] https://www.gnu.org/software/classpath/license.html
+# [2] http://openjdk.java.net/legal/assembly-exception.html
+#
+# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+#
+# Explicitly set shell
+#
+SHELL=/bin/sh
+
+#
+# These are the prefixes and suffixes that all GNU tools use for things
+#
+OBJSUFF=.o
+ARSUFF=.a
+SOSUFF=.so
+EXESUFF=
+LIBPREFIX=lib
+DEPSUFF=.depend.mk
+
+#
+# Paths for default programs on the platform
+# Most rules will use these default programs, but they can be overwritten individually if,
+# for example, you want to compile .spp files with a different C++ compiler than you use
+# to compile .cpp files
+#
+
+AS_PATH?=tpf-as
+M4_PATH?=m4
+SED_PATH?=sed
+AR_PATH?=ar
+PERL_PATH?=perl
+
+#
+# z/Architecture arch and tune level
+# z/TPF uses z10 as minminum supported z/Architecture.
+# mtune of z9-109 allows builtin versions of memcpy, etc.
+# instead of calling ""arch-optimized"" glibc functions.
+#
+
+ARCHLEVEL?=z10
+TUNELEVEL?=z9-109
+
+CC_PATH?=tpf-gcc
+CXX_PATH?=tpf-g++
+
+# This is the script that's used to generate TRBuildName.cpp
+GENERATE_VERSION_SCRIPT?=$(JIT_SCRIPT_DIR)/generateVersion.pl
+
+# This is the script to preprocess ARM assembly files
+ARMASM_SCRIPT?=$(JIT_SCRIPT_DIR)/armasm2gas.sed",no.,
70946834,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/z/env/J9CPU.cpp,True,"@@ -205,33 +206,17 @@ CPU::TO_PORTLIB_get390zLinuxMachineType()
    const int PROC_HEADER_SIZE = sizeof(procHeader) - 1;
 
 #if defined(J9ZTPF)
-   TR_S390MachineType ret_machine = TR_Z10;  /* return value, z/TPF default */
    struct pi1dt *pid;
-   /* machine hardware name */
+   /*
+    * Use the model number from the in-core processor ID table, accessed
+    * via CINFC_CMMPID as the machine type.
+    * The z/TPF OS has strict requirements on supported z/Architecture hardware.
+    * As a result, the model number will necessarily match a valid TR_S390MachineType.
+    * Note - S390MachineTypes, declared above as a static const integer, contains the
+    * hex representation of the (decimal) model number found in the processors ID table.
+    */
    pid = (struct pi1dt *)cinfc_fast(CINFC_CMMPID);
-   int machine = (int)(pid->pi1pids.pi1mslr.pi1mod);
-
-   // Scan list of unsupported machines - We do not initialize the JIT for such hardware.
-   for (int i = 0; i < sizeof(S390UnsupportedMachineTypes) / sizeof(int); ++i)
-      {
-      if (machine == S390UnsupportedMachineTypes[i])
-         {
-         PORT_ACCESS_FROM_ENV(jitConfig->javaVM);
-         j9nls_printf(jitConfig->javaVM->portLibrary, J9NLS_ERROR, J9NLS_J9JIT_390_UNSUPPORTED_HARDWARE, machine);
-         TR_ASSERT(0,""Hardware is not supported."");
-         throw TR::CompilationException();
-         }
-      }
-
-   // Scan list of supported machines.
-   for (int i = 0; i < sizeof(S390MachineTypes) / sizeof(int); ++i)
-      {
-      if (machine == S390MachineTypes[i])
-         {
-         ret_machine = (TR_S390MachineType)machine;
-         }
-      }
-
+   TR_S390MachineType ret_machine = (TR_S390MachineType)(pid->pi1pids.pi1mslr.pi1mod);","While we get the data at ipl time from the store cpuid instruction (STIDP)  there is no reason to think that this area in main storage couldn't be corrupted at any time.  I will reset the code to do what z/os essentially does; get the character representation of the model, convert it to integer via atoi and then test the integrity of the result.",
70952001,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/z/env/J9CPU.cpp,False,"@@ -205,33 +206,17 @@ CPU::TO_PORTLIB_get390zLinuxMachineType()
    const int PROC_HEADER_SIZE = sizeof(procHeader) - 1;
 
 #if defined(J9ZTPF)
-   TR_S390MachineType ret_machine = TR_Z10;  /* return value, z/TPF default */
    struct pi1dt *pid;
-   /* machine hardware name */
+   /*
+    * Use the model number from the in-core processor ID table, accessed
+    * via CINFC_CMMPID as the machine type.
+    * The z/TPF OS has strict requirements on supported z/Architecture hardware.
+    * As a result, the model number will necessarily match a valid TR_S390MachineType.
+    * Note - S390MachineTypes, declared above as a static const integer, contains the
+    * hex representation of the (decimal) model number found in the processors ID table.
+    */
    pid = (struct pi1dt *)cinfc_fast(CINFC_CMMPID);
-   int machine = (int)(pid->pi1pids.pi1mslr.pi1mod);
-
-   // Scan list of unsupported machines - We do not initialize the JIT for such hardware.
-   for (int i = 0; i < sizeof(S390UnsupportedMachineTypes) / sizeof(int); ++i)
-      {
-      if (machine == S390UnsupportedMachineTypes[i])
-         {
-         PORT_ACCESS_FROM_ENV(jitConfig->javaVM);
-         j9nls_printf(jitConfig->javaVM->portLibrary, J9NLS_ERROR, J9NLS_J9JIT_390_UNSUPPORTED_HARDWARE, machine);
-         TR_ASSERT(0,""Hardware is not supported."");
-         throw TR::CompilationException();
-         }
-      }
-
-   // Scan list of supported machines.
-   for (int i = 0; i < sizeof(S390MachineTypes) / sizeof(int); ++i)
-      {
-      if (machine == S390MachineTypes[i])
-         {
-         ret_machine = (TR_S390MachineType)machine;
-         }
-      }
-
+   TR_S390MachineType ret_machine = (TR_S390MachineType)(pid->pi1pids.pi1mslr.pi1mod);","Or simply iterate through the list of machines we support like the code did previously:

```
-   // Scan list of supported machines.
-   for (int i = 0; i < sizeof(S390MachineTypes) / sizeof(int); ++i)
-      {
-      if (machine == S390MachineTypes[i])
-         {
-         ret_machine = (TR_S390MachineType)machine;
-         }
-      }
```

This ensures `ret_machine` always has a valid enum value.",
71655109,e9f2f9c12e51f1689b4d7c759ba11d0978190a4b,jcl/src/java.base/share/classes/java/lang/Class.java,False,"@@ -2390,8 +2396,11 @@ static ClassLoader currentClassLoader() {
  * @since 1.5
  */
 public Annotation[] getAnnotations() {
-Collection<Annotation> annotations = getAnnotationCache().annotationMap.values();
-return annotations.toArray(new Annotation[annotations.size()]);
+LinkedHashMap<Class<? extends Annotation>, Annotation> map = getAnnotationCache().annotationMap;
+if (map != null) {
+return map.values().toArray(EMPTY_ANNOTATION_ARRAY);",Passing in the EMPTY_ANNOTATION_ARRAY may be less efficient than passing in an Annotation[] of the correct size. It means the code needs to call Array.newInstance() to create an array of the correct type and size.,
71184006,fb3975b0fb119d7f7775a6529b1d64f1f1652274,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -321,15 +325,16 @@ public static void test_dropArgumentsToMatch_normal_sublist_boolean() throws Thr
  */
 @Test(groups = { ""level.extended"" })
 public static void test_dropArgumentsToMatch_normal_sublist_byte() throws Throwable {
-MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte.class, byte.class));
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte[].class, byte.class));
 
 /* Method with rtype = String, ptype = [boolean, char, int, long, byte, String] */
 MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, byte.class, String.class);
 
 h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
 
 Hash_Methods hm = new Hash_Methods();
-Assert.assertEquals(h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d""), ""ab"", ""Method handle did not return expected result"");
+byte[] input = new String(""ab"").getBytes();","The original code was:
```
h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d"")
```

Does a minimal change like this pass on an ebcdic system?
```
h1.invoke(hm, (byte)'a', true, 'c', 1, 2, (byte)'b', ""d"")
```

The code here mixes the ascii number for the character and the actual character value.  Always converting the char into a byte in the code should be correct for any charset, I think.",
71208242,fb3975b0fb119d7f7775a6529b1d64f1f1652274,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,True,"@@ -321,15 +325,16 @@ public static void test_dropArgumentsToMatch_normal_sublist_boolean() throws Thr
  */
 @Test(groups = { ""level.extended"" })
 public static void test_dropArgumentsToMatch_normal_sublist_byte() throws Throwable {
-MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte.class, byte.class));
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte[].class, byte.class));
 
 /* Method with rtype = String, ptype = [boolean, char, int, long, byte, String] */
 MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, byte.class, String.class);
 
 h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
 
 Hash_Methods hm = new Hash_Methods();
-Assert.assertEquals(h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d""), ""ab"", ""Method handle did not return expected result"");
+byte[] input = new String(""ab"").getBytes();","the dynamic casting of `char` to `byte` won't work directly since EBCDIC system value for readable letters (A-Z, a-z, 0-9) are in the range of 128 - 255, which is out of range for a `byte` (which is signed) to store and results in a negative value after casting (undefined characters when casted back to `String`).",
71533071,fb3975b0fb119d7f7775a6529b1d64f1f1652274,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,False,"@@ -321,15 +325,16 @@ public static void test_dropArgumentsToMatch_normal_sublist_boolean() throws Thr
  */
 @Test(groups = { ""level.extended"" })
 public static void test_dropArgumentsToMatch_normal_sublist_byte() throws Throwable {
-MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte.class, byte.class));
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte[].class, byte.class));
 
 /* Method with rtype = String, ptype = [boolean, char, int, long, byte, String] */
 MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, byte.class, String.class);
 
 h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
 
 Hash_Methods hm = new Hash_Methods();
-Assert.assertEquals(h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d""), ""ab"", ""Method handle did not return expected result"");
+byte[] input = new String(""ab"").getBytes();","I'm hesitating on this PR as it changes the meaning of the test case.  The point of this test case is to validate the `dropArgumentsToMatch` using `byte`, not `byte[]`.

Can you modify the test case in a way to preserves using a `byte` as the signature types?  Feel free to drop the use of converting this to a String.  

",
71569289,fb3975b0fb119d7f7775a6529b1d64f1f1652274,test/Jsr292/src/com/ibm/j9/jsr292/api/MethodHandleAPI_dropArgumentsToMatch.java,True,"@@ -321,15 +325,16 @@ public static void test_dropArgumentsToMatch_normal_sublist_boolean() throws Thr
  */
 @Test(groups = { ""level.extended"" })
 public static void test_dropArgumentsToMatch_normal_sublist_byte() throws Throwable {
-MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte.class, byte.class));
+MethodHandle h1 = MethodHandles.lookup().findVirtual(Hash_Methods.class, ""hash_byte"", MethodType.methodType(String.class, byte[].class, byte.class));
 
 /* Method with rtype = String, ptype = [boolean, char, int, long, byte, String] */
 MethodType typeList = MethodType.methodType(String.class, boolean.class, char.class, int.class, long.class, byte.class, String.class);
 
 h1 = MethodHandles.dropArgumentsToMatch(h1, 2, typeList.parameterList(), 4);
 
 Hash_Methods hm = new Hash_Methods();
-Assert.assertEquals(h1.invoke(hm, (byte)97, true, 'c', 1, 2, (byte)98, ""d""), ""ab"", ""Method handle did not return expected result"");
+byte[] input = new String(""ab"").getBytes();","The `byte` testing is preserved through the second part of the `byte[]` (`input[input.length-1]`) passed to the hash method, the goal of this test is to confirm the alignment when relocating different size parameters.

The reason for getting `byte[]` from `String` is to maintain the readability of the test result, as EBCDIC will translate `""ab""` to negative `byte` value while dynamic casting `(byte)'a'` produces the ASCII code of 'a'

the assert can still be done similar to
`hash_byte( (byte)'a', (byte)'b' ) == String(new byte[] { (byte)'a', (byte)'b' })`
which is less readable as the actual string build from the byte array is ""/<?>"" since 0x61 is undefined in EBCDIC",
71381417,9eb6639add340fad709ca6e2236cecfca3c0a6a0,runtime/tr.source/trj9/ilgen/Walker.cpp,False,"@@ -2186,7 +2186,7 @@ TR_J9ByteCodeIlGenerator::genTreeTop(TR::Node * n)
             // stashed
             //
             _couldOSRAtNextBC = true;
-            if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall())
+            if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall() && n->getFirstChild()->getReferenceCount() == 1)","There's a lot of complexity in this code.  Is it worthwhile to document why the `referenceCount() == 1` check is required here in a comment?

Also the `n->getFirstChild()->getOpCode().isCall()` check must already be `true` due to the if statement on line 2177 that includes this exact condition.  Can this if condition be simplified?",
71383858,9eb6639add340fad709ca6e2236cecfca3c0a6a0,runtime/tr.source/trj9/ilgen/Walker.cpp,True,"@@ -2186,7 +2186,7 @@ TR_J9ByteCodeIlGenerator::genTreeTop(TR::Node * n)
             // stashed
             //
             _couldOSRAtNextBC = true;
-            if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall())
+            if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall() && n->getFirstChild()->getReferenceCount() == 1)","I added a comment to specify we are only interested in the first reference to the call.

I agree, this section of code has grow to be quite complex recently, as it must identify and prepare for all possible OSR points, but the `n->getFirstChild()->getOpCode().isCall()` won't always be `true`. Other types of OpCodes are managed by this section of code.",
71385050,9eb6639add340fad709ca6e2236cecfca3c0a6a0,runtime/tr.source/trj9/ilgen/Walker.cpp,False,"@@ -2186,7 +2186,7 @@ TR_J9ByteCodeIlGenerator::genTreeTop(TR::Node * n)
             // stashed
             //
             _couldOSRAtNextBC = true;
-            if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall())
+            if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall() && n->getFirstChild()->getReferenceCount() == 1)",You're right.  I misread the code above ,
71680221,9eb6639add340fad709ca6e2236cecfca3c0a6a0,runtime/tr.source/trj9/ilgen/Walker.cpp,False,"@@ -2188,13 +2188,20 @@ TR_J9ByteCodeIlGenerator::genTreeTop(TR::Node * n)
             _couldOSRAtNextBC = true;
             if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall())
                {
-               // The current stack should contain the current method's state prior to the call,
-               // with the call's arguments popped off. If this call is later inlined, it may
-               // contain an OSR transition. Therefore, it is necessary to save the current
-               // method's state now, so that it is available when the transition is made.
-               handlePendingPushSaveSideEffects(n);
-               saveStack(-1);
-               stashPendingPushLivenessForOSR();
+               // Calls are only OSR points for their first evaluation. Other references to the call,
+               // that are also anchored under checks or treetops, are not OSR points. This can be
+               // identified based on its reference count.
+               //
+               if (n->getFirstChild()->getReferenceCount() == 1)","So the logic here is that we are generating IL and so when we generate code for the call node tree top, it must have a reference count of 1 ""currently"" even if it's reference count could become more than 1 ""eventually"", correct ?

In which case I'm a bit worried if we are 100% sure that there is not some situation in which a second reference to the call node could have been created before the treetop node for the call node was created; a secondary worry is that in the event of such a reference being innocently created would result in a functional bug in the future (missing pending push stores). 
",
71697326,9eb6639add340fad709ca6e2236cecfca3c0a6a0,runtime/tr.source/trj9/ilgen/Walker.cpp,True,"@@ -2188,13 +2188,20 @@ TR_J9ByteCodeIlGenerator::genTreeTop(TR::Node * n)
             _couldOSRAtNextBC = true;
             if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall())
                {
-               // The current stack should contain the current method's state prior to the call,
-               // with the call's arguments popped off. If this call is later inlined, it may
-               // contain an OSR transition. Therefore, it is necessary to save the current
-               // method's state now, so that it is available when the transition is made.
-               handlePendingPushSaveSideEffects(n);
-               saveStack(-1);
-               stashPendingPushLivenessForOSR();
+               // Calls are only OSR points for their first evaluation. Other references to the call,
+               // that are also anchored under checks or treetops, are not OSR points. This can be
+               // identified based on its reference count.
+               //
+               if (n->getFirstChild()->getReferenceCount() == 1)","This is a valid concern. Calls must be placed under their own tree, as they have side-effects, however, there is nothing to guarantee the call's node is processed by `genTreeTop` before being referenced under another node.

I cannot find a point where `genInvoke` or one of its callers are managing several nodes that could potentially reference the call. Moreover, in testing, only `checkcast` has failed this check so far, which is the desired effect.

I can understand if the evidence above is not sufficient, or if this is not a restriction on IlGen we wish to make. Another potential approach might be to use a checklist on the node index or their BCI, but this would incur additional overhead.",
71715045,9eb6639add340fad709ca6e2236cecfca3c0a6a0,runtime/tr.source/trj9/ilgen/Walker.cpp,False,"@@ -2188,13 +2188,20 @@ TR_J9ByteCodeIlGenerator::genTreeTop(TR::Node * n)
             _couldOSRAtNextBC = true;
             if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall())
                {
-               // The current stack should contain the current method's state prior to the call,
-               // with the call's arguments popped off. If this call is later inlined, it may
-               // contain an OSR transition. Therefore, it is necessary to save the current
-               // method's state now, so that it is available when the transition is made.
-               handlePendingPushSaveSideEffects(n);
-               saveStack(-1);
-               stashPendingPushLivenessForOSR();
+               // Calls are only OSR points for their first evaluation. Other references to the call,
+               // that are also anchored under checks or treetops, are not OSR points. This can be
+               // identified based on its reference count.
+               //
+               if (n->getFirstChild()->getReferenceCount() == 1)",I'm not concerned about the overhead of a checklist solution if it results in a more robust solution. So I would suggest exploring that option at least to see what it looks like rather than commit this change as it is.,
71731598,9eb6639add340fad709ca6e2236cecfca3c0a6a0,runtime/tr.source/trj9/ilgen/Walker.cpp,True,"@@ -2188,13 +2188,20 @@ TR_J9ByteCodeIlGenerator::genTreeTop(TR::Node * n)
             _couldOSRAtNextBC = true;
             if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall())
                {
-               // The current stack should contain the current method's state prior to the call,
-               // with the call's arguments popped off. If this call is later inlined, it may
-               // contain an OSR transition. Therefore, it is necessary to save the current
-               // method's state now, so that it is available when the transition is made.
-               handlePendingPushSaveSideEffects(n);
-               saveStack(-1);
-               stashPendingPushLivenessForOSR();
+               // Calls are only OSR points for their first evaluation. Other references to the call,
+               // that are also anchored under checks or treetops, are not OSR points. This can be
+               // identified based on its reference count.
+               //
+               if (n->getFirstChild()->getReferenceCount() == 1)","A stack allocated node checklist has been added. In testing, it behaves the same as the reference count check and should be more robust.",
71848343,9eb6639add340fad709ca6e2236cecfca3c0a6a0,runtime/tr.source/trj9/ilgen/Walker.cpp,False,"@@ -2188,13 +2188,20 @@ TR_J9ByteCodeIlGenerator::genTreeTop(TR::Node * n)
             _couldOSRAtNextBC = true;
             if ((n->getOpCode().isCheck() || n->getOpCodeValue() == TR::treetop) && n->getFirstChild()->getOpCode().isCall())
                {
-               // The current stack should contain the current method's state prior to the call,
-               // with the call's arguments popped off. If this call is later inlined, it may
-               // contain an OSR transition. Therefore, it is necessary to save the current
-               // method's state now, so that it is available when the transition is made.
-               handlePendingPushSaveSideEffects(n);
-               saveStack(-1);
-               stashPendingPushLivenessForOSR();
+               // Calls are only OSR points for their first evaluation. Other references to the call,
+               // that are also anchored under checks or treetops, are not OSR points. This can be
+               // identified based on its reference count.
+               //
+               if (n->getFirstChild()->getReferenceCount() == 1)",Thanks this looks good to me now but it's probably good to get @andrewcraik to review again since it's changed since he looked at it last.,
71882930,8c752c2ed3ad079cafa218a743b5d84b7b0a7e1c,runtime/tr.source/trj9/z/env/J9CPU.cpp,True,"@@ -205,33 +206,17 @@ CPU::TO_PORTLIB_get390zLinuxMachineType()
    const int PROC_HEADER_SIZE = sizeof(procHeader) - 1;
 
 #if defined(J9ZTPF)
-   TR_S390MachineType ret_machine = TR_Z10;  /* return value, z/TPF default */
    struct pi1dt *pid;
-   /* machine hardware name */
+   /*
+    * Use the model number from the in-core processor ID table, accessed
+    * via CINFC_CMMPID as the machine type.
+    * The z/TPF OS has strict requirements on supported z/Architecture hardware.
+    * As a result, the model number will necessarily match a valid TR_S390MachineType.
+    * Note - S390MachineTypes, declared above as a static const integer, contains the
+    * hex representation of the (decimal) model number found in the processors ID table.",@joransiu I updated the code to do what I should have done from the start... sprintf the data from core as character data and then convert it via atoi(). z/os kinda had to do the same thing although the data is already sprintf()'ed into uname. Then the checks work; otherwise they would fail. ,
71860429,9349cca600add4dd397d1976d49676bc2be9d981,runtime/oti/xhelpers.m4,False,"@@ -26,6 +26,8 @@ ifdef({WIN32},{
 
 ifdef({ASM_J9VM_ENV_DATA64},{
 
+define({SHORT_JMP},{short})
+",Should this not be outside the 64-bit ifdef?,
71865920,9349cca600add4dd397d1976d49676bc2be9d981,runtime/oti/xhelpers.m4,True,"@@ -26,6 +26,8 @@ ifdef({WIN32},{
 
 ifdef({ASM_J9VM_ENV_DATA64},{
 
+define({SHORT_JMP},{short})
+",Good point - updated in new commit,
70330267,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -366,6 +414,14 @@ public void testJarArguments() {
 assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
 }
 
+private Path trimLeadingSlash(URL fileURL) {",Use `Paths.get(url.toURI()).toFile()` instead of function.,
70330802,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -65,10 +68,13 @@
 private static final String FILE_SEPARATOR = System.getProperty(""file.separator"");
 private static final String USER_DIR = System.getProperty(""user.dir"");
 private static final String OS_NAME_PROPERTY = System.getProperty(""os.name"");
+private static final String VMARGS_JAR = ""vmargs_SE80.jar"";
 private static final String XJIT = ""-Xjit"";
 private static final String XINT = ""-Xint"";
 private static final String XPROD = ""-Xprod"";
 /* set to true if the implicit VM arguments take priority over IBM_JAVA_OPTIONS and JAVA_TOOL_OPTIONS */
+private static final String HELLO_WORLD = ""#!/bin/sh\n""","Likely clearer to name this `HELLO_WORLD_SCRIPT`.  If changing this anyway, then I merge the two lines into a single one.
",
70330802,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -86,6 +92,7 @@
 private static final String[] TEST_ARG_LIST = {""-Dtest.option1=testJavaToolOptions1"", ""-Dtest.option2=testJavaToolOptions2"", 
 ""-Dtest.option3=testJavaToolOptions3"", ""-Dtest.option4=testJavaToolOptions4""};
 private static final String OPTIONS_FILE_SUFFIX = "".test_options_file"";
+private static final String cmdlineArg = ""-DcmdlineArg"";",Why the different naming convention for this `static final String`?  All the others are uppercase,
70330802,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -333,15 +340,56 @@ public void testCrNocr() {
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(VMARGS_JAR+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", jarPath.toString()}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,","`posns` please void truncated names like this unless they are commonly used / referenced.  It's better for the reader of the code if this is called `positions` as they don't have to guess at the meaning of the name.

The use of `env` earlier is fine though as its a very common abbreviation.",
70330802,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -333,15 +340,56 @@ public void testCrNocr() {
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(VMARGS_JAR+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", jarPath.toString()}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
+longProp});
+assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
+assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
+/* environment variables should come after implicit arguments */
+int toolsPosn = posns.get(javaToolOptionsArg);
+int ibmPropPosn = posns.get(ibmJavaOptionsArg);
+int fooBarPropPosn = posns.get(fooBar);
+int longPropPosn = posns.get(longProp);
+Integer cmdlineArgPosn = posns.get(cmdlineArg);",Why `Integer` for this argument when `int` is used for all the others?,
70336679,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -366,6 +414,14 @@ public void testJarArguments() {
 assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
 }
 
+private Path trimLeadingSlash(URL fileURL) {","Actually I did:
Paths.get(jarUrl.toURI()).toFile().toPath()
because Files.copy() takes a Path not a File.
This pull request is getting pretty old, so I should retest.  Please stand by.",
70330802,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -333,15 +340,56 @@ public void testCrNocr() {
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(VMARGS_JAR+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", jarPath.toString()}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
+longProp});
+assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
+assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
+/* environment variables should come after implicit arguments */
+int toolsPosn = posns.get(javaToolOptionsArg);
+int ibmPropPosn = posns.get(ibmJavaOptionsArg);
+int fooBarPropPosn = posns.get(fooBar);
+int longPropPosn = posns.get(longProp);
+Integer cmdlineArgPosn = posns.get(cmdlineArg);
+assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
+assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {
+final String HWVMARGS = ""hwvmargs.jar"";
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(HWVMARGS+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+
+try {
+File outFile = new File(HWVMARGS);
+outFile.delete();
+FileOutputStream outStream = new FileOutputStream(outFile);
+outStream.write(HELLO_WORLD.getBytes());
+Files.copy(jarPath, outStream);
+outStream.close();
+} catch (IOException e) {","If the exception is thrown, then the test will fail and the stack trace will be available unless we're using a custom test runner of some sort?

This code isn't necessary - let the test throw and the built in mechanisms deal with unexpected exceptions.",
70330802,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -333,15 +340,56 @@ public void testCrNocr() {
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(VMARGS_JAR+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", jarPath.toString()}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
+longProp});
+assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
+assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
+/* environment variables should come after implicit arguments */
+int toolsPosn = posns.get(javaToolOptionsArg);
+int ibmPropPosn = posns.get(ibmJavaOptionsArg);
+int fooBarPropPosn = posns.get(fooBar);
+int longPropPosn = posns.get(longProp);
+Integer cmdlineArgPosn = posns.get(cmdlineArg);
+assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
+assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {
+final String HWVMARGS = ""hwvmargs.jar"";
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(HWVMARGS+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+
+try {
+File outFile = new File(HWVMARGS);
+outFile.delete();
+FileOutputStream outStream = new FileOutputStream(outFile);
+outStream.write(HELLO_WORLD.getBytes());
+Files.copy(jarPath, outStream);","Using http://download.java.net/java/jdk9/docs/api/java/nio/file/Files.html#copy-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...- would avoid having to create the FileOutputStream yourself, avoid the delete() call, etc.",
70330802,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -333,15 +340,56 @@ public void testCrNocr() {
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(VMARGS_JAR+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", jarPath.toString()}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
+longProp});
+assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
+assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
+/* environment variables should come after implicit arguments */
+int toolsPosn = posns.get(javaToolOptionsArg);
+int ibmPropPosn = posns.get(ibmJavaOptionsArg);
+int fooBarPropPosn = posns.get(fooBar);
+int longPropPosn = posns.get(longProp);
+Integer cmdlineArgPosn = posns.get(cmdlineArg);
+assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
+assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {","Is the only difference between the two tests the jar file being validated?  If that's the case, can you create a common helper that does 90% of the work and is passed the path to the Jar file the ProcessBuilder should use?",
70551803,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -65,10 +68,13 @@
 private static final String FILE_SEPARATOR = System.getProperty(""file.separator"");
 private static final String USER_DIR = System.getProperty(""user.dir"");
 private static final String OS_NAME_PROPERTY = System.getProperty(""os.name"");
+private static final String VMARGS_JAR = ""vmargs_SE80.jar"";
 private static final String XJIT = ""-Xjit"";
 private static final String XINT = ""-Xint"";
 private static final String XPROD = ""-Xprod"";
 /* set to true if the implicit VM arguments take priority over IBM_JAVA_OPTIONS and JAVA_TOOL_OPTIONS */
+private static final String HELLO_WORLD = ""#!/bin/sh\n""",Okay.,
70557696,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -333,15 +340,56 @@ public void testCrNocr() {
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(VMARGS_JAR+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", jarPath.toString()}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
+longProp});
+assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
+assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
+/* environment variables should come after implicit arguments */
+int toolsPosn = posns.get(javaToolOptionsArg);
+int ibmPropPosn = posns.get(ibmJavaOptionsArg);
+int fooBarPropPosn = posns.get(fooBar);
+int longPropPosn = posns.get(longProp);
+Integer cmdlineArgPosn = posns.get(cmdlineArg);
+assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
+assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {",Okay,
70569046,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -86,6 +92,7 @@
 private static final String[] TEST_ARG_LIST = {""-Dtest.option1=testJavaToolOptions1"", ""-Dtest.option2=testJavaToolOptions2"", 
 ""-Dtest.option3=testJavaToolOptions3"", ""-Dtest.option4=testJavaToolOptions4""};
 private static final String OPTIONS_FILE_SUFFIX = "".test_options_file"";
+private static final String cmdlineArg = ""-DcmdlineArg"";",Fixed.,
70569816,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -333,15 +340,56 @@ public void testCrNocr() {
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(VMARGS_JAR+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", jarPath.toString()}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
+longProp});
+assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
+assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
+/* environment variables should come after implicit arguments */
+int toolsPosn = posns.get(javaToolOptionsArg);
+int ibmPropPosn = posns.get(ibmJavaOptionsArg);
+int fooBarPropPosn = posns.get(fooBar);
+int longPropPosn = posns.get(longProp);
+Integer cmdlineArgPosn = posns.get(cmdlineArg);","Missed that and a bunch of others.  Fixing.  Note that some need to be Integers for the benefit of assertEquals(Object, Object);",
70571232,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -333,15 +340,56 @@ public void testCrNocr() {
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(VMARGS_JAR+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", jarPath.toString()}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
+longProp});
+assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
+assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
+/* environment variables should come after implicit arguments */
+int toolsPosn = posns.get(javaToolOptionsArg);
+int ibmPropPosn = posns.get(ibmJavaOptionsArg);
+int fooBarPropPosn = posns.get(fooBar);
+int longPropPosn = posns.get(longProp);
+Integer cmdlineArgPosn = posns.get(cmdlineArg);
+assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
+assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
+assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {
+final String HWVMARGS = ""hwvmargs.jar"";
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(VMARGS_JAR);
+assertNotNull(HWVMARGS+"" not found"", jarUrl);
+Path jarPath = trimLeadingSlash(jarUrl);
+
+try {
+File outFile = new File(HWVMARGS);
+outFile.delete();
+FileOutputStream outStream = new FileOutputStream(outFile);
+outStream.write(HELLO_WORLD.getBytes());
+Files.copy(jarPath, outStream);","As discussed, I need to open the stream so I can shoot the shell script into the file.",
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -65,10 +70,12 @@
 private static final String FILE_SEPARATOR = System.getProperty(""file.separator"");
 private static final String USER_DIR = System.getProperty(""user.dir"");
 private static final String OS_NAME_PROPERTY = System.getProperty(""os.name"");
+private static String vmargsJarFilename;",It's generally better to group like kinds of variables together.  So the `static final` fields would be grouped together and the mutable ones would be a separate grouping.  It makes it easier to find them when reading the code.,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -282,6 +293,7 @@ public void testXcheckMemory() {
 
 /* test IBM_JAVA_OPTIONS environment variable */
 
+@SuppressWarnings(""boxing"")","Please don't add `@SuppressWarnings(""boxing"")`.  Just fix the warnings =)",
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -290,14 +302,13 @@ public void testIbmJavaOptions() {
 ArrayList<String> actualArguments = runAndGetArgumentList(pb);
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {ibmJavaOptionsArg});
 assertTrue(""missing argument: ""+ibmJavaOptionsArg, posns.containsKey(ibmJavaOptionsArg));
-Integer ibmOptionsPosn = posns.get(ibmJavaOptionsArg);
 /* environment variables should come after implicit arguments */
-int extDirsPosn = posns.get(DJAVA_HOME);
-assertTrue(IBM_JAVA_OPTIONS+ "" should come last"", ibmOptionsPosn > extDirsPosn); 
+assertTrue(IBM_JAVA_OPTIONS+ "" should come last"", posns.get(ibmJavaOptionsArg) > posns.get(DJAVA_HOME)); 
 }
 
 /* test IBM_JAVA_OPTIONS environment variable */
 
+@SuppressWarnings(""boxing"")","Please don't add `@SuppressWarnings(""boxing"")`.  Just fix the warnings =)",
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -306,14 +317,13 @@ public void testArgEncodingInIbmJavaOptions() {
 ArrayList<String> actualArguments = runAndGetArgumentList(pb);
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {ibmJavaOptionsArg});
 assertTrue(""missing argument: ""+ibmJavaOptionsArg, posns.containsKey(ibmJavaOptionsArg));
-Integer ibmOptionsPosn = posns.get(ibmJavaOptionsArg);
 /* environment variables should come after implicit arguments */
-int extDirsPosn = posns.get(DJAVA_HOME);
-assertTrue(IBM_JAVA_OPTIONS+ "" should come last"", ibmOptionsPosn > extDirsPosn); /* this will fail on current VMs */
+assertTrue(IBM_JAVA_OPTIONS+ "" should come last"", posns.get(ibmJavaOptionsArg) > posns.get(DJAVA_HOME));
 }
 
 
 
+@SuppressWarnings(""boxing"")","Please don't add `@SuppressWarnings(""boxing"")`.  Just fix the warnings =)",
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -325,49 +335,57 @@ public void testCrNocr() {
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {XCOMPRESSEDREFS, XNOCOMPRESSEDREFS});
 assertTrue(""missing argument: ""+crArg, posns.containsKey(crArg));
 assertTrue(""missing argument: ""+noCrArg, posns.containsKey(noCrArg));
-Integer crArgPosn = posns.get(crArg);
-Integer noCrArgPosn = posns.get(noCrArg);
-assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, crArgPosn < noCrArgPosn);
+assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, posns.get(crArg) < posns.get(noCrArg));
 }
 
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+assertNotNull(vmargsJarFilename+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+checkJarArgs(jarPath.toString());
+} catch (URISyntaxException e) {",Just let this throw.  The test framework will automatically fail the test for you.,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -325,49 +335,57 @@ public void testCrNocr() {
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {XCOMPRESSEDREFS, XNOCOMPRESSEDREFS});
 assertTrue(""missing argument: ""+crArg, posns.containsKey(crArg));
 assertTrue(""missing argument: ""+noCrArg, posns.containsKey(noCrArg));
-Integer crArgPosn = posns.get(crArg);
-Integer noCrArgPosn = posns.get(noCrArg);
-assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, crArgPosn < noCrArgPosn);
+assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, posns.get(crArg) < posns.get(noCrArg));
 }
 
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+assertNotNull(vmargsJarFilename+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+checkJarArgs(jarPath.toString());
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
 }
-ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", testJar}, null);
-Map<String, String> env = pb.environment();
-String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
-env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
-String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
-env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
-ArrayList<String> actualArguments = runAndGetArgumentList(pb);
-String fooBar = ""-Dfoo=bar"";
-String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
-HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
-longProp});
-assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
-assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
-/* environment variables should come after implicit arguments */
-int toolsPosn = posns.get(javaToolOptionsArg);
-int ibmPropPosn = posns.get(ibmJavaOptionsArg);
-int fooBarPropPosn = posns.get(fooBar);
-int longPropPosn = posns.get(longProp);
-Integer cmdlineArgPosn = posns.get(cmdlineArg);
-assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
-assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {
+final String HWVMARGS = ""hwvmargs.jar"";
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+final String pathString = HWVMARGS;
+assertNotNull(pathString+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+} catch (URISyntaxException e) {",Just let this throw.  The test framework will fail the test for you,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -325,49 +335,57 @@ public void testCrNocr() {
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {XCOMPRESSEDREFS, XNOCOMPRESSEDREFS});
 assertTrue(""missing argument: ""+crArg, posns.containsKey(crArg));
 assertTrue(""missing argument: ""+noCrArg, posns.containsKey(noCrArg));
-Integer crArgPosn = posns.get(crArg);
-Integer noCrArgPosn = posns.get(noCrArg);
-assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, crArgPosn < noCrArgPosn);
+assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, posns.get(crArg) < posns.get(noCrArg));
 }
 
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+assertNotNull(vmargsJarFilename+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+checkJarArgs(jarPath.toString());
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
 }
-ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", testJar}, null);
-Map<String, String> env = pb.environment();
-String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
-env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
-String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
-env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
-ArrayList<String> actualArguments = runAndGetArgumentList(pb);
-String fooBar = ""-Dfoo=bar"";
-String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
-HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
-longProp});
-assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
-assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
-/* environment variables should come after implicit arguments */
-int toolsPosn = posns.get(javaToolOptionsArg);
-int ibmPropPosn = posns.get(ibmJavaOptionsArg);
-int fooBarPropPosn = posns.get(fooBar);
-int longPropPosn = posns.get(longProp);
-Integer cmdlineArgPosn = posns.get(cmdlineArg);
-assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
-assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {
+final String HWVMARGS = ""hwvmargs.jar"";
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+final String pathString = HWVMARGS;
+assertNotNull(pathString+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
+}
+
+try {
+",nitpick: unnecessary blank lines,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -325,49 +335,57 @@ public void testCrNocr() {
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {XCOMPRESSEDREFS, XNOCOMPRESSEDREFS});
 assertTrue(""missing argument: ""+crArg, posns.containsKey(crArg));
 assertTrue(""missing argument: ""+noCrArg, posns.containsKey(noCrArg));
-Integer crArgPosn = posns.get(crArg);
-Integer noCrArgPosn = posns.get(noCrArg);
-assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, crArgPosn < noCrArgPosn);
+assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, posns.get(crArg) < posns.get(noCrArg));
 }
 
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+assertNotNull(vmargsJarFilename+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+checkJarArgs(jarPath.toString());
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
 }
-ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", testJar}, null);
-Map<String, String> env = pb.environment();
-String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
-env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
-String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
-env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
-ArrayList<String> actualArguments = runAndGetArgumentList(pb);
-String fooBar = ""-Dfoo=bar"";
-String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
-HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
-longProp});
-assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
-assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
-/* environment variables should come after implicit arguments */
-int toolsPosn = posns.get(javaToolOptionsArg);
-int ibmPropPosn = posns.get(ibmJavaOptionsArg);
-int fooBarPropPosn = posns.get(fooBar);
-int longPropPosn = posns.get(longProp);
-Integer cmdlineArgPosn = posns.get(cmdlineArg);
-assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
-assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {
+final String HWVMARGS = ""hwvmargs.jar"";
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+final String pathString = HWVMARGS;
+assertNotNull(pathString+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
+}
+
+try {
+
+File outFile = new File(pathString);
+outFile.delete();
+FileOutputStream outStream = new FileOutputStream(outFile);
+outStream.write(HELLO_WORLD_SCRIPT.getBytes());
+Files.copy(jarPath, outStream);
+outStream.close();
+} catch (IOException e) {",Just let this throw - the test framework will fail the test for you,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -428,6 +444,7 @@ public void testMultipleArgumentsInEnvVars() {
 
 /* test environment variables which map to JVM options */
 
+@SuppressWarnings(""boxing"")",Don't suppress warnings.,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -633,6 +649,7 @@ public void testCommandlineArgumentsWithLeadingAndTrailingSpaces() {
 
 /* IBM_JAVA_OPTIONS should take priority over JAVA_TOOL_OPTIONS */
 
+@SuppressWarnings(""boxing"")",Same as above,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -801,6 +814,7 @@ public void testServiceMultipleArgs() {
 
 /* -Xservice arguments should come after cmdline arguments */
 
+@SuppressWarnings(""boxing"")",Same as above,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -828,6 +842,7 @@ public void testCmdlineServiceArgsOrdering() {
 
 /* environment variable arguments should come before cmdline arguments */
 
+@SuppressWarnings(""boxing"")",same as above,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -1056,6 +1067,7 @@ public void testEmptyArgument() {
 
 /* options specified in IBM_JAVA_OPTIONS or JAVA_TOOL_OPTIONS should take precedence over inferred arguments created by the VM */
 
+@SuppressWarnings(""boxing"")",same as above,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -1216,6 +1226,7 @@ public void testMemoryLeaks() {
 }
 
 
+@SuppressWarnings(""boxing"")",same as above,
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -1507,6 +1516,33 @@ private void checkArgumentSequence(String[] expectedArguments,
 }
 }
 
+@SuppressWarnings(""boxing"")
+private void checkJarArgs(final String pathString) {
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {DASH_D_CMDLINE_ARG, ""-jar"", pathString}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, DASH_D_CMDLINE_ARG, fooBar,","When breaking a line like this, break it at a logical point:
```
HashMap<String, Integer> posns = checkArguments(actualArguments,
                new String[] {javaToolOptionsArg, ibmJavaOptionsArg, DASH_D_CMDLINE_ARG, fooBar, longProp});
```",
70865467,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -1507,6 +1516,33 @@ private void checkArgumentSequence(String[] expectedArguments,
 }
 }
 
+@SuppressWarnings(""boxing"")
+private void checkJarArgs(final String pathString) {
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {DASH_D_CMDLINE_ARG, ""-jar"", pathString}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, DASH_D_CMDLINE_ARG, fooBar,","Also, please don't use names like `posn`.  Stick with common abbreviations or full words.",
70895706,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -325,49 +335,57 @@ public void testCrNocr() {
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {XCOMPRESSEDREFS, XNOCOMPRESSEDREFS});
 assertTrue(""missing argument: ""+crArg, posns.containsKey(crArg));
 assertTrue(""missing argument: ""+noCrArg, posns.containsKey(noCrArg));
-Integer crArgPosn = posns.get(crArg);
-Integer noCrArgPosn = posns.get(noCrArg);
-assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, crArgPosn < noCrArgPosn);
+assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, posns.get(crArg) < posns.get(noCrArg));
 }
 
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+assertNotNull(vmargsJarFilename+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+checkJarArgs(jarPath.toString());
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
 }
-ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", testJar}, null);
-Map<String, String> env = pb.environment();
-String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
-env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
-String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
-env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
-ArrayList<String> actualArguments = runAndGetArgumentList(pb);
-String fooBar = ""-Dfoo=bar"";
-String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
-HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
-longProp});
-assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
-assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
-/* environment variables should come after implicit arguments */
-int toolsPosn = posns.get(javaToolOptionsArg);
-int ibmPropPosn = posns.get(ibmJavaOptionsArg);
-int fooBarPropPosn = posns.get(fooBar);
-int longPropPosn = posns.get(longProp);
-Integer cmdlineArgPosn = posns.get(cmdlineArg);
-assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
-assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {
+final String HWVMARGS = ""hwvmargs.jar"";
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+final String pathString = HWVMARGS;
+assertNotNull(pathString+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+} catch (URISyntaxException e) {","But I lose the context, i.e. the problematic URL.  That's why I catch and rethrow.",
70896040,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -325,49 +335,57 @@ public void testCrNocr() {
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {XCOMPRESSEDREFS, XNOCOMPRESSEDREFS});
 assertTrue(""missing argument: ""+crArg, posns.containsKey(crArg));
 assertTrue(""missing argument: ""+noCrArg, posns.containsKey(noCrArg));
-Integer crArgPosn = posns.get(crArg);
-Integer noCrArgPosn = posns.get(noCrArg);
-assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, crArgPosn < noCrArgPosn);
+assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, posns.get(crArg) < posns.get(noCrArg));
 }
 
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+assertNotNull(vmargsJarFilename+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+checkJarArgs(jarPath.toString());
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
 }
-ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", testJar}, null);
-Map<String, String> env = pb.environment();
-String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
-env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
-String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
-env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
-ArrayList<String> actualArguments = runAndGetArgumentList(pb);
-String fooBar = ""-Dfoo=bar"";
-String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
-HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
-longProp});
-assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
-assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
-/* environment variables should come after implicit arguments */
-int toolsPosn = posns.get(javaToolOptionsArg);
-int ibmPropPosn = posns.get(ibmJavaOptionsArg);
-int fooBarPropPosn = posns.get(fooBar);
-int longPropPosn = posns.get(longProp);
-Integer cmdlineArgPosn = posns.get(cmdlineArg);
-assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
-assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {
+final String HWVMARGS = ""hwvmargs.jar"";
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+final String pathString = HWVMARGS;
+assertNotNull(pathString+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
+}
+
+try {
+
+File outFile = new File(pathString);
+outFile.delete();
+FileOutputStream outStream = new FileOutputStream(outFile);
+outStream.write(HELLO_WORLD_SCRIPT.getBytes());
+Files.copy(jarPath, outStream);
+outStream.close();
+} catch (IOException e) {",Same reply as above. I want to record the path for diagnostic purposes.,
70896127,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -828,6 +842,7 @@ public void testCmdlineServiceArgsOrdering() {
 
 /* environment variable arguments should come before cmdline arguments */
 
+@SuppressWarnings(""boxing"")",Okay.,
70896143,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -633,6 +649,7 @@ public void testCommandlineArgumentsWithLeadingAndTrailingSpaces() {
 
 /* IBM_JAVA_OPTIONS should take priority over JAVA_TOOL_OPTIONS */
 
+@SuppressWarnings(""boxing"")",Okay.,
70896155,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -428,6 +444,7 @@ public void testMultipleArgumentsInEnvVars() {
 
 /* test environment variables which map to JVM options */
 
+@SuppressWarnings(""boxing"")",Okay.,
70896162,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -325,49 +335,57 @@ public void testCrNocr() {
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {XCOMPRESSEDREFS, XNOCOMPRESSEDREFS});
 assertTrue(""missing argument: ""+crArg, posns.containsKey(crArg));
 assertTrue(""missing argument: ""+noCrArg, posns.containsKey(noCrArg));
-Integer crArgPosn = posns.get(crArg);
-Integer noCrArgPosn = posns.get(noCrArg);
-assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, crArgPosn < noCrArgPosn);
+assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, posns.get(crArg) < posns.get(noCrArg));
 }
 
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+assertNotNull(vmargsJarFilename+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+checkJarArgs(jarPath.toString());
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
 }
-ProcessBuilder pb = makeProcessBuilder(null, new String[] {cmdlineArg, ""-jar"", testJar}, null);
-Map<String, String> env = pb.environment();
-String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
-env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
-String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
-env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
-ArrayList<String> actualArguments = runAndGetArgumentList(pb);
-String fooBar = ""-Dfoo=bar"";
-String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
-HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, cmdlineArg, fooBar,
-longProp});
-assertTrue(""missing argument: ""+fooBar, posns.containsKey(fooBar));
-assertTrue(""missing argument: ""+longProp, posns.containsKey(longProp));
-/* environment variables should come after implicit arguments */
-int toolsPosn = posns.get(javaToolOptionsArg);
-int ibmPropPosn = posns.get(ibmJavaOptionsArg);
-int fooBarPropPosn = posns.get(fooBar);
-int longPropPosn = posns.get(longProp);
-Integer cmdlineArgPosn = posns.get(cmdlineArg);
-assertTrue(""Wrong order of properties"", ibmPropPosn == toolsPosn + 1);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < ibmPropPosn);
-assertTrue(""Wrong order of properties"", fooBarPropPosn < cmdlineArgPosn);
-assertTrue(""Wrong order of properties"", longPropPosn == fooBarPropPosn + 1);
+}
+
+/**
+ * Test getting VM arguments from a JAR file prefixed by a shell script.
+ */
+public void testExecutableJarArguments() {
+final String HWVMARGS = ""hwvmargs.jar"";
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+final String pathString = HWVMARGS;
+assertNotNull(pathString+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+} catch (URISyntaxException e) {
+fail(""cannot convert ""+jarUrl.toString()+"" to path"", e);
+}
+
+try {
+",Okay.,
70896186,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -1056,6 +1067,7 @@ public void testEmptyArgument() {
 
 /* options specified in IBM_JAVA_OPTIONS or JAVA_TOOL_OPTIONS should take precedence over inferred arguments created by the VM */
 
+@SuppressWarnings(""boxing"")",Okay.,
70896213,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -1216,6 +1226,7 @@ public void testMemoryLeaks() {
 }
 
 
+@SuppressWarnings(""boxing"")",Okay.,
70896257,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -1507,6 +1516,33 @@ private void checkArgumentSequence(String[] expectedArguments,
 }
 }
 
+@SuppressWarnings(""boxing"")
+private void checkJarArgs(final String pathString) {
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {DASH_D_CMDLINE_ARG, ""-jar"", pathString}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, DASH_D_CMDLINE_ARG, fooBar,",Okay.,
70896283,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -1507,6 +1516,33 @@ private void checkArgumentSequence(String[] expectedArguments,
 }
 }
 
+@SuppressWarnings(""boxing"")
+private void checkJarArgs(final String pathString) {
+ProcessBuilder pb = makeProcessBuilder(null, new String[] {DASH_D_CMDLINE_ARG, ""-jar"", pathString}, null);
+Map<String, String> env = pb.environment();
+String javaToolOptionsArg = ""-DjavaToolOptionsArg"";
+env.put(JAVA_TOOL_OPTIONS, javaToolOptionsArg );
+String ibmJavaOptionsArg = ""-DibmJavaOptionsArg"";
+env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg );
+ArrayList<String> actualArguments = runAndGetArgumentList(pb);
+String fooBar = ""-Dfoo=bar"";
+String longProp = ""-Da.long.system.property=this is a long system property value to demonstrate long JVM arguments in the manifest file"";
+HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {javaToolOptionsArg, ibmJavaOptionsArg, DASH_D_CMDLINE_ARG, fooBar,",Okay.,
70903408,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -65,10 +70,12 @@
 private static final String FILE_SEPARATOR = System.getProperty(""file.separator"");
 private static final String USER_DIR = System.getProperty(""user.dir"");
 private static final String OS_NAME_PROPERTY = System.getProperty(""os.name"");
+private static String vmargsJarFilename;","I was missing the ""final"".",
70903629,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -325,49 +335,57 @@ public void testCrNocr() {
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {XCOMPRESSEDREFS, XNOCOMPRESSEDREFS});
 assertTrue(""missing argument: ""+crArg, posns.containsKey(crArg));
 assertTrue(""missing argument: ""+noCrArg, posns.containsKey(noCrArg));
-Integer crArgPosn = posns.get(crArg);
-Integer noCrArgPosn = posns.get(noCrArg);
-assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, crArgPosn < noCrArgPosn);
+assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, posns.get(crArg) < posns.get(noCrArg));
 }
 
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+assertNotNull(vmargsJarFilename+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+checkJarArgs(jarPath.toString());
+} catch (URISyntaxException e) {",Please see response below.,
71642991,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -53,8 +58,8 @@
  * Jazz 60902: Rewrite JVM options constructor code to fix PMR 13464,422,000.
  * Test argument processing by running the VM with various combinations of command line arguments, options files, and environment variables.
  */
+@SuppressWarnings(""nls"")",We should never add `@SuppressWarnings` to code.  A PR should either ignore existing warnings or actually address them.  Suppressing them just hides the problem,
71642991,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -1037,8 +1038,8 @@ public void testOptionsFileInEnvironmentVariable() {
 String[] expectedArgs = null;
 /* new VM args processing puts the options file argument in the list for consistency */
 expectedArgs = new String[] {javaOptFileArg, javaOptFileContent, ibmOptFileArg, ibmOptFileContent};
-HashMap<String, Integer> posns = checkArguments(actualArguments, expectedArgs);
-checkArgumentSequence(expectedArgs, posns, true);
+HashMap<String, Integer> argumentPositions = checkArguments(actualArguments, expectedArgs);",Formatting - tabbed too far,
71642991,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -304,12 +312,10 @@ public void testArgEncodingInIbmJavaOptions() {
 String ibmJavaOptionsArg = ""-Xargencoding"";
 env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg);
 ArrayList<String> actualArguments = runAndGetArgumentList(pb);
-HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {ibmJavaOptionsArg});
-assertTrue(""missing argument: ""+ibmJavaOptionsArg, posns.containsKey(ibmJavaOptionsArg));
-Integer ibmOptionsPosn = posns.get(ibmJavaOptionsArg);
+HashMap<String, Integer> argumentPositions = checkArguments(actualArguments, new String[] {ibmJavaOptionsArg});
+assertTrue(""missing argument: ""+ibmJavaOptionsArg, argumentPositions.containsKey(ibmJavaOptionsArg));
 /* environment variables should come after implicit arguments */
-int extDirsPosn = posns.get(DJAVA_HOME);
-assertTrue(IBM_JAVA_OPTIONS+ "" should come last"", ibmOptionsPosn > extDirsPosn); /* this will fail on current VMs */
+assertTrue(IBM_JAVA_OPTIONS+ "" should come last"", argumentPositions.get(ibmJavaOptionsArg).intValue() > argumentPositions.get(DJAVA_HOME).intValue());
 }","Since this function is being changed anyway, can you fix the indenting on this `}`?",
71642991,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -325,49 +335,57 @@ public void testCrNocr() {
 HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {XCOMPRESSEDREFS, XNOCOMPRESSEDREFS});
 assertTrue(""missing argument: ""+crArg, posns.containsKey(crArg));
 assertTrue(""missing argument: ""+noCrArg, posns.containsKey(noCrArg));
-Integer crArgPosn = posns.get(crArg);
-Integer noCrArgPosn = posns.get(noCrArg);
-assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, crArgPosn < noCrArgPosn);
+assertTrue(noCrArg+ "" should come after ""+DJAVA_HOME, posns.get(crArg) < posns.get(noCrArg));
 }
 
 /* test options in runnable jar files */
 
 public void testJarArguments() {
-String cmdlineArg = ""-DcmdlineArg"";
-String testJar = System.getProperty(""org.openj9.test.vmArguments.testJar"");
-URL jarUrl = ClassLoader.getSystemClassLoader().getResource(""vmargs.jar"");
-assertNotNull(""vmargs.jar not found"", jarUrl);
-testJar = jarUrl.getFile();
-if (isWindows() && testJar.startsWith(""/"")) {
-testJar = testJar.substring(1); /* annoying habit of getResource() to put a / at the front of the path */
+URL jarUrl = ClassLoader.getSystemClassLoader().getResource(vmargsJarFilename);
+assertNotNull(vmargsJarFilename+"" not found"", jarUrl);
+Path jarPath = null;
+try {
+jarPath = Paths.get(jarUrl.toURI()).toFile().toPath();
+checkJarArgs(jarPath.toString());
+} catch (URISyntaxException e) {",This exception should never occur in practice given that the test runs and passes before it's merged.  This additional try/catch is extra code making the intent of the test less clear.,
71642991,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,False,"@@ -1456,7 +1453,7 @@ private int runAndGetExitStatus(ProcessBuilder pb) {
 int p = 0;
 for (String a: actualArguments) {
 if (a.startsWith(m)) {
-argPositions.put(m, p);
+argPositions.put(m, new Integer(p));","`Integer.valueOf(int)` is usually a better choice as it avoids allocation for ints in the cached range: https://docs.oracle.com/javase/9/docs/api/java/lang/Integer.html#valueOf-int-

This is fine here though.",
71954702,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -1456,7 +1453,7 @@ private int runAndGetExitStatus(ProcessBuilder pb) {
 int p = 0;
 for (String a: actualArguments) {
 if (a.startsWith(m)) {
-argPositions.put(m, p);
+argPositions.put(m, new Integer(p));",Cool.  Thanks.,
71954917,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -1037,8 +1038,8 @@ public void testOptionsFileInEnvironmentVariable() {
 String[] expectedArgs = null;
 /* new VM args processing puts the options file argument in the list for consistency */
 expectedArgs = new String[] {javaOptFileArg, javaOptFileContent, ibmOptFileArg, ibmOptFileContent};
-HashMap<String, Integer> posns = checkArguments(actualArguments, expectedArgs);
-checkArgumentSequence(expectedArgs, posns, true);
+HashMap<String, Integer> argumentPositions = checkArguments(actualArguments, expectedArgs);","Oops. Indentation fixed.
Catch block removed.",
71955792,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -304,12 +312,10 @@ public void testArgEncodingInIbmJavaOptions() {
 String ibmJavaOptionsArg = ""-Xargencoding"";
 env.put(IBM_JAVA_OPTIONS, ibmJavaOptionsArg);
 ArrayList<String> actualArguments = runAndGetArgumentList(pb);
-HashMap<String, Integer> posns = checkArguments(actualArguments, new String[] {ibmJavaOptionsArg});
-assertTrue(""missing argument: ""+ibmJavaOptionsArg, posns.containsKey(ibmJavaOptionsArg));
-Integer ibmOptionsPosn = posns.get(ibmJavaOptionsArg);
+HashMap<String, Integer> argumentPositions = checkArguments(actualArguments, new String[] {ibmJavaOptionsArg});
+assertTrue(""missing argument: ""+ibmJavaOptionsArg, argumentPositions.containsKey(ibmJavaOptionsArg));
 /* environment variables should come after implicit arguments */
-int extDirsPosn = posns.get(DJAVA_HOME);
-assertTrue(IBM_JAVA_OPTIONS+ "" should come last"", ibmOptionsPosn > extDirsPosn); /* this will fail on current VMs */
+assertTrue(IBM_JAVA_OPTIONS+ "" should come last"", argumentPositions.get(ibmJavaOptionsArg).intValue() > argumentPositions.get(DJAVA_HOME).intValue());
 }",Done.,
71956234,9dffcb0bddd90fb07386c5a8258154605dfd3eaf,test/Java8andUp/src/org/openj9/test/vmArguments/VmArgumentTests.java,True,"@@ -53,8 +58,8 @@
  * Jazz 60902: Rewrite JVM options constructor code to fix PMR 13464,422,000.
  * Test argument processing by running the VM with various combinations of command line arguments, options files, and environment variables.
  */
+@SuppressWarnings(""nls"")",Removed.,
70833929,ca866c54214160ca9b6d070f54470c549b916c26,jcl/src/java.base/share/classes/java/lang/invoke/StaticFieldVarHandle.java,False,"@@ -132,1349 +135,1915 @@
  */
 @SuppressWarnings(""unused"")
 static class StaticFieldVarHandleOperations extends VarHandleOperations {
+private static final JITHelpers jitHelpers = JITHelpers.getHelpers();
+
+static void ensureClassIsInitialized(Class<?> clazz) {",Mark this method as `final` if possible.  It means the JIT won't have to guard the callsites against future class loads,
70833929,ca866c54214160ca9b6d070f54470c549b916c26,jcl/src/java.base/share/classes/java/lang/invoke/StaticFieldVarHandle.java,False,"@@ -132,1349 +135,1915 @@
  */
 @SuppressWarnings(""unused"")
 static class StaticFieldVarHandleOperations extends VarHandleOperations {
+private static final JITHelpers jitHelpers = JITHelpers.getHelpers();
+
+static void ensureClassIsInitialized(Class<?> clazz) {
+if (jitHelpers.getClassInitializeStatus(clazz) != VM.J9CLASS_INIT_SUCCEEDED) {
+_unsafe.ensureClassInitialized(clazz);
+}
+}
+
 static final class OpObject extends StaticFieldVarHandleOperations {
 private static final Object get(StaticFieldVarHandle varHandle) {
-return _unsafe.getObject(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObject(definingClass, varHandle.vmslot);
 }
 
 private static final void set(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObject(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObject(definingClass, varHandle.vmslot, value);
 }
 
 private static final Object getVolatile(StaticFieldVarHandle varHandle) {
-return _unsafe.getObjectVolatile(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObjectVolatile(definingClass, varHandle.vmslot);
 }
 
 private static final void setVolatile(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObjectVolatile(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObjectVolatile(definingClass, varHandle.vmslot, value);
 }
 
 private static final Object getOpaque(StaticFieldVarHandle varHandle) {
-return _unsafe.getObjectOpaque(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObjectOpaque(definingClass, varHandle.vmslot);
 }
 
 private static final void setOpaque(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObjectOpaque(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObjectOpaque(definingClass, varHandle.vmslot, value);
 }
 
 private static final Object getAcquire(StaticFieldVarHandle varHandle) {
-return _unsafe.getObjectAcquire(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObjectAcquire(definingClass, varHandle.vmslot);
 }
 
 private static final void setRelease(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObjectRelease(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObjectRelease(definingClass, varHandle.vmslot, value);
 }
 
 private static final boolean compareAndSet(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.compareAndSetObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndSetObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.compareAndSwapObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndSwapObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final Object compareAndExchange(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.compareAndExchangeObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndExchangeObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.compareAndExchangeObjectVolatile(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndExchangeObjectVolatile(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final Object compareAndExchangeAcquire(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
-return _unsafe.compareAndExchangeObjectAcquire(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.compareAndExchangeObjectAcquire(definingClass, varHandle.vmslot, testValue, newValue);
 }
 
 private static final Object compareAndExchangeRelease(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
-return _unsafe.compareAndExchangeObjectRelease(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.compareAndExchangeObjectRelease(definingClass, varHandle.vmslot, testValue, newValue);
 }
 
 private static final boolean weakCompareAndSet(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectPlain(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectPlain(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final boolean weakCompareAndSetAcquire(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectAcquire(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectAcquire(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObjectAcquire(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObjectAcquire(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final boolean weakCompareAndSetRelease(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectRelease(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectRelease(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObjectRelease(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObjectRelease(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final boolean weakCompareAndSetPlain(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectPlain(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectPlain(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final Object getAndSet(Object value, StaticFieldVarHandle varHandle) {
-return _unsafe.getAndSetObject(varHandle.definingClass, varHandle.vmslot, value); 
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getAndSetObject(definingClass, varHandle.vmslot, value); 
 }
 
 private static final Object getAndSetAcquire(Object value, StaticFieldVarHandle varHandle) {
-return _unsafe.getAndSetObjectAcquire(varHandle.definingClass, varHandle.vmslot, value); 
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getAndSetObjectAcquire(definingClass, varHandle.vmslot, value); 
 }
 
 private static final Object getAndSetRelease(Object value, StaticFieldVarHandle varHandle) {
-return _unsafe.getAndSetObjectRelease(varHandle.definingClass, varHandle.vmslot, value); 
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getAndSetObjectRelease(definingClass, varHandle.vmslot, value); 
 }
 
 private static final Object getAndAdd(Object value, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);",Is there a test case that shows that the `operationNotSupported()` cases should trigger initialization?  Applies here and throughout the file.,
70967864,ca866c54214160ca9b6d070f54470c549b916c26,jcl/src/java.base/share/classes/java/lang/invoke/StaticFieldVarHandle.java,True,"@@ -132,1349 +135,1915 @@
  */
 @SuppressWarnings(""unused"")
 static class StaticFieldVarHandleOperations extends VarHandleOperations {
+private static final JITHelpers jitHelpers = JITHelpers.getHelpers();
+
+static void ensureClassIsInitialized(Class<?> clazz) {
+if (jitHelpers.getClassInitializeStatus(clazz) != VM.J9CLASS_INIT_SUCCEEDED) {
+_unsafe.ensureClassInitialized(clazz);
+}
+}
+
 static final class OpObject extends StaticFieldVarHandleOperations {
 private static final Object get(StaticFieldVarHandle varHandle) {
-return _unsafe.getObject(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObject(definingClass, varHandle.vmslot);
 }
 
 private static final void set(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObject(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObject(definingClass, varHandle.vmslot, value);
 }
 
 private static final Object getVolatile(StaticFieldVarHandle varHandle) {
-return _unsafe.getObjectVolatile(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObjectVolatile(definingClass, varHandle.vmslot);
 }
 
 private static final void setVolatile(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObjectVolatile(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObjectVolatile(definingClass, varHandle.vmslot, value);
 }
 
 private static final Object getOpaque(StaticFieldVarHandle varHandle) {
-return _unsafe.getObjectOpaque(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObjectOpaque(definingClass, varHandle.vmslot);
 }
 
 private static final void setOpaque(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObjectOpaque(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObjectOpaque(definingClass, varHandle.vmslot, value);
 }
 
 private static final Object getAcquire(StaticFieldVarHandle varHandle) {
-return _unsafe.getObjectAcquire(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObjectAcquire(definingClass, varHandle.vmslot);
 }
 
 private static final void setRelease(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObjectRelease(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObjectRelease(definingClass, varHandle.vmslot, value);
 }
 
 private static final boolean compareAndSet(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.compareAndSetObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndSetObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.compareAndSwapObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndSwapObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final Object compareAndExchange(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.compareAndExchangeObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndExchangeObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.compareAndExchangeObjectVolatile(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndExchangeObjectVolatile(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final Object compareAndExchangeAcquire(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
-return _unsafe.compareAndExchangeObjectAcquire(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.compareAndExchangeObjectAcquire(definingClass, varHandle.vmslot, testValue, newValue);
 }
 
 private static final Object compareAndExchangeRelease(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
-return _unsafe.compareAndExchangeObjectRelease(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.compareAndExchangeObjectRelease(definingClass, varHandle.vmslot, testValue, newValue);
 }
 
 private static final boolean weakCompareAndSet(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectPlain(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectPlain(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final boolean weakCompareAndSetAcquire(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectAcquire(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectAcquire(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObjectAcquire(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObjectAcquire(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final boolean weakCompareAndSetRelease(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectRelease(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectRelease(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObjectRelease(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObjectRelease(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final boolean weakCompareAndSetPlain(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectPlain(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectPlain(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final Object getAndSet(Object value, StaticFieldVarHandle varHandle) {
-return _unsafe.getAndSetObject(varHandle.definingClass, varHandle.vmslot, value); 
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getAndSetObject(definingClass, varHandle.vmslot, value); 
 }
 
 private static final Object getAndSetAcquire(Object value, StaticFieldVarHandle varHandle) {
-return _unsafe.getAndSetObjectAcquire(varHandle.definingClass, varHandle.vmslot, value); 
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getAndSetObjectAcquire(definingClass, varHandle.vmslot, value); 
 }
 
 private static final Object getAndSetRelease(Object value, StaticFieldVarHandle varHandle) {
-return _unsafe.getAndSetObjectRelease(varHandle.definingClass, varHandle.vmslot, value); 
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getAndSetObjectRelease(definingClass, varHandle.vmslot, value); 
 }
 
 private static final Object getAndAdd(Object value, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);","A little eager with the ""search-and-replace"". I'll write a test case.",
71975435,ca866c54214160ca9b6d070f54470c549b916c26,jcl/src/java.base/share/classes/java/lang/invoke/StaticFieldVarHandle.java,True,"@@ -132,1349 +135,1915 @@
  */
 @SuppressWarnings(""unused"")
 static class StaticFieldVarHandleOperations extends VarHandleOperations {
+private static final JITHelpers jitHelpers = JITHelpers.getHelpers();
+
+static void ensureClassIsInitialized(Class<?> clazz) {
+if (jitHelpers.getClassInitializeStatus(clazz) != VM.J9CLASS_INIT_SUCCEEDED) {
+_unsafe.ensureClassInitialized(clazz);
+}
+}
+
 static final class OpObject extends StaticFieldVarHandleOperations {
 private static final Object get(StaticFieldVarHandle varHandle) {
-return _unsafe.getObject(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObject(definingClass, varHandle.vmslot);
 }
 
 private static final void set(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObject(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObject(definingClass, varHandle.vmslot, value);
 }
 
 private static final Object getVolatile(StaticFieldVarHandle varHandle) {
-return _unsafe.getObjectVolatile(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObjectVolatile(definingClass, varHandle.vmslot);
 }
 
 private static final void setVolatile(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObjectVolatile(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObjectVolatile(definingClass, varHandle.vmslot, value);
 }
 
 private static final Object getOpaque(StaticFieldVarHandle varHandle) {
-return _unsafe.getObjectOpaque(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObjectOpaque(definingClass, varHandle.vmslot);
 }
 
 private static final void setOpaque(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObjectOpaque(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObjectOpaque(definingClass, varHandle.vmslot, value);
 }
 
 private static final Object getAcquire(StaticFieldVarHandle varHandle) {
-return _unsafe.getObjectAcquire(varHandle.definingClass, varHandle.vmslot);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getObjectAcquire(definingClass, varHandle.vmslot);
 }
 
 private static final void setRelease(Object value, StaticFieldVarHandle varHandle) {
-_unsafe.putObjectRelease(varHandle.definingClass, varHandle.vmslot, value);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+_unsafe.putObjectRelease(definingClass, varHandle.vmslot, value);
 }
 
 private static final boolean compareAndSet(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.compareAndSetObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndSetObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.compareAndSwapObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndSwapObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final Object compareAndExchange(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.compareAndExchangeObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndExchangeObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.compareAndExchangeObjectVolatile(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.compareAndExchangeObjectVolatile(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final Object compareAndExchangeAcquire(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
-return _unsafe.compareAndExchangeObjectAcquire(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.compareAndExchangeObjectAcquire(definingClass, varHandle.vmslot, testValue, newValue);
 }
 
 private static final Object compareAndExchangeRelease(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
-return _unsafe.compareAndExchangeObjectRelease(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.compareAndExchangeObjectRelease(definingClass, varHandle.vmslot, testValue, newValue);
 }
 
 private static final boolean weakCompareAndSet(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectPlain(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectPlain(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final boolean weakCompareAndSetAcquire(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectAcquire(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectAcquire(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObjectAcquire(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObjectAcquire(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final boolean weakCompareAndSetRelease(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectRelease(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectRelease(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObjectRelease(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObjectRelease(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final boolean weakCompareAndSetPlain(Object testValue, Object newValue, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
 /*[IF Sidecar19-SE-B174]*/
-return _unsafe.weakCompareAndSetObjectPlain(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSetObjectPlain(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ELSE]
-return _unsafe.weakCompareAndSwapObject(varHandle.definingClass, varHandle.vmslot, testValue, newValue);
+return _unsafe.weakCompareAndSwapObject(definingClass, varHandle.vmslot, testValue, newValue);
 /*[ENDIF]*/
 }
 
 private static final Object getAndSet(Object value, StaticFieldVarHandle varHandle) {
-return _unsafe.getAndSetObject(varHandle.definingClass, varHandle.vmslot, value); 
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getAndSetObject(definingClass, varHandle.vmslot, value); 
 }
 
 private static final Object getAndSetAcquire(Object value, StaticFieldVarHandle varHandle) {
-return _unsafe.getAndSetObjectAcquire(varHandle.definingClass, varHandle.vmslot, value); 
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getAndSetObjectAcquire(definingClass, varHandle.vmslot, value); 
 }
 
 private static final Object getAndSetRelease(Object value, StaticFieldVarHandle varHandle) {
-return _unsafe.getAndSetObjectRelease(varHandle.definingClass, varHandle.vmslot, value); 
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);
+return _unsafe.getAndSetObjectRelease(definingClass, varHandle.vmslot, value); 
 }
 
 private static final Object getAndAdd(Object value, StaticFieldVarHandle varHandle) {
+Class<?> definingClass = varHandle.definingClass;
+ensureClassIsInitialized(definingClass);","I wrote a test case and ran it on HotSpot. It appears that HotSpot initializes the class on lookup, and not on invocation as the API specifies.

I've updated this implementation to not initialize the class if it's not used (i.e. if we throw an exception). This is already the behaviour when we throw `UnsupportedOperationException` for mutating access modes on final fields.",
71975527,ca866c54214160ca9b6d070f54470c549b916c26,jcl/src/java.base/share/classes/java/lang/invoke/StaticFieldVarHandle.java,True,"@@ -132,1349 +135,1915 @@
  */
 @SuppressWarnings(""unused"")
 static class StaticFieldVarHandleOperations extends VarHandleOperations {
+private static final JITHelpers jitHelpers = JITHelpers.getHelpers();
+
+static void ensureClassIsInitialized(Class<?> clazz) {",Fixed,
70082041,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,False,"@@ -1218,73 +1226,148 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Get Java version info from 'classlib.properties' file
+ * Attempt loading 'classlib.properties' file, if found, 'shape' & 'version' values are retrieved,
+ * and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly. 
+ * J2SE_xx | J2SE_SHAPE_xx will be returned.
+ *
+ * @return jvm SE Version value",Please include the behavior when classlib.properties isn't found.,
70082530,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,False,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */","You can use B7 for the value, but the #define needs a better name, like J2SE_18_3",
70082627,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,False,"@@ -1218,73 +1226,148 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Get Java version info from 'classlib.properties' file
+ * Attempt loading 'classlib.properties' file, if found, 'shape' & 'version' values are retrieved,
+ * and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly. 
+ * J2SE_xx | J2SE_SHAPE_xx will be returned.
+ *
+ * @return jvm SE Version value
  */
 static UDATA
 getVersionFromClasslibPropertiesFile(void)
 {
-if (-1 != jvmSEVersion) {
-return jvmSEVersion;
-} else {
-PORT_ACCESS_FROM_PORT(&j9portLibrary);
-J9StringBuffer * propsPathBuffer = NULL;
-j9props_file_t classlibProps;
-const char* shape;
-const char* version;
-UDATA decoded, finalVersion = 0;
-
-propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
-propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
-
-classlibProps = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
-
-free(propsPathBuffer);
-propsPathBuffer = NULL;
-
-if (NULL == classlibProps) {
-#ifdef DEBUG
-printf(""Could not open %s\n"", classlibProps);
-#endif
-return J2SE_LATEST|J2SE_SHAPE_LATEST;
-}
-
-shape = props_file_get(classlibProps, ""shape"");
+PORT_ACCESS_FROM_PORT(&j9portLibrary);
+J9StringBuffer *propsPathBuffer = NULL;
+j9props_file_t propsFile = NULL;
+UDATA finalVersion = 0;
+
+propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
+propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
+propsFile = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
+free(propsPathBuffer);
+propsPathBuffer = NULL;
+
+if (NULL != propsFile) {
+const char *shape = NULL;
+const char *version = NULL;
+UDATA decoded = 0;
+
+shape = props_file_get(propsFile, ""shape"");
 if (NULL == shape) {
-#ifdef DEBUG
-printf(""No 'shape' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'shape' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
-version = props_file_get(classlibProps, ""version"");
+version = props_file_get(propsFile, ""version"");
 if (NULL == version) {
-#ifdef DEBUG
-printf(""No 'version' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'version' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
 decoded = decodeSetting(""shape"", shape, SHAPE_SETTINGS, NUM_SHAPE_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
 decoded = decodeSetting(""version"", version, VERSION_SETTINGS, NUM_VERSION_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
-bail:
-props_file_close(classlibProps);
+bail:
+props_file_close(propsFile);
+} else {
+#ifdef DEBUG
+printf(""Could not open %s\n"", propsFile);
+#endif
+}
+
+return finalVersion;
+}
+
+/**
+ * Get Java version info from 'release' file
+ * Attempt loading 'release' file, if found, 'JAVA_VERSION' value is retrieved, and decoded as following:
+ * ""1.8.0_xxx""--- Java 8 (J2SE_18 | J2SE_SHAPE_SUN)
+ * ""9""--- Java 9 (J2SE_19 | J2SE_SHAPE_B165)
+ * ""10""--- Java 18.3 (J2SE_B7 | J2SE_SHAPE_B1803)
+ * Others--- (�J2SE_LATEST | J2SE_SHAPE_LATEST)","There appears to be a non-ascii character before ""J2SE_LATEST""",
70082757,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,False,"@@ -1218,73 +1226,148 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Get Java version info from 'classlib.properties' file
+ * Attempt loading 'classlib.properties' file, if found, 'shape' & 'version' values are retrieved,
+ * and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly. 
+ * J2SE_xx | J2SE_SHAPE_xx will be returned.
+ *
+ * @return jvm SE Version value
  */
 static UDATA
 getVersionFromClasslibPropertiesFile(void)
 {
-if (-1 != jvmSEVersion) {
-return jvmSEVersion;
-} else {
-PORT_ACCESS_FROM_PORT(&j9portLibrary);
-J9StringBuffer * propsPathBuffer = NULL;
-j9props_file_t classlibProps;
-const char* shape;
-const char* version;
-UDATA decoded, finalVersion = 0;
-
-propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
-propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
-
-classlibProps = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
-
-free(propsPathBuffer);
-propsPathBuffer = NULL;
-
-if (NULL == classlibProps) {
-#ifdef DEBUG
-printf(""Could not open %s\n"", classlibProps);
-#endif
-return J2SE_LATEST|J2SE_SHAPE_LATEST;
-}
-
-shape = props_file_get(classlibProps, ""shape"");
+PORT_ACCESS_FROM_PORT(&j9portLibrary);
+J9StringBuffer *propsPathBuffer = NULL;
+j9props_file_t propsFile = NULL;
+UDATA finalVersion = 0;
+
+propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
+propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
+propsFile = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
+free(propsPathBuffer);
+propsPathBuffer = NULL;
+
+if (NULL != propsFile) {
+const char *shape = NULL;
+const char *version = NULL;
+UDATA decoded = 0;
+
+shape = props_file_get(propsFile, ""shape"");
 if (NULL == shape) {
-#ifdef DEBUG
-printf(""No 'shape' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'shape' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
-version = props_file_get(classlibProps, ""version"");
+version = props_file_get(propsFile, ""version"");
 if (NULL == version) {
-#ifdef DEBUG
-printf(""No 'version' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'version' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
 decoded = decodeSetting(""shape"", shape, SHAPE_SETTINGS, NUM_SHAPE_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
 decoded = decodeSetting(""version"", version, VERSION_SETTINGS, NUM_VERSION_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
-bail:
-props_file_close(classlibProps);
+bail:
+props_file_close(propsFile);
+} else {
+#ifdef DEBUG
+printf(""Could not open %s\n"", propsFile);
+#endif
+}
+
+return finalVersion;
+}
+
+/**
+ * Get Java version info from 'release' file
+ * Attempt loading 'release' file, if found, 'JAVA_VERSION' value is retrieved, and decoded as following:
+ * ""1.8.0_xxx""--- Java 8 (J2SE_18 | J2SE_SHAPE_SUN)
+ * ""9""--- Java 9 (J2SE_19 | J2SE_SHAPE_B165)
+ * ""10""--- Java 18.3 (J2SE_B7 | J2SE_SHAPE_B1803)
+ * Others--- (�J2SE_LATEST | J2SE_SHAPE_LATEST)
+ * Note: 'release' file contains JAVA_VERSION=""10"" for Java 18.3 at this moment.
+ *
+ * @return jvm SE Version value",Please include the behavior when the release file isn't found.,
70083687,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,False,"@@ -1218,73 +1226,148 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Get Java version info from 'classlib.properties' file
+ * Attempt loading 'classlib.properties' file, if found, 'shape' & 'version' values are retrieved,
+ * and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly. 
+ * J2SE_xx | J2SE_SHAPE_xx will be returned.","This is a better description for @return, but add the behavior when classlib.properties isn't found.",
70083813,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,False,"@@ -1218,73 +1226,148 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Get Java version info from 'classlib.properties' file
+ * Attempt loading 'classlib.properties' file, if found, 'shape' & 'version' values are retrieved,
+ * and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly. 
+ * J2SE_xx | J2SE_SHAPE_xx will be returned.
+ *
+ * @return jvm SE Version value
  */
 static UDATA
 getVersionFromClasslibPropertiesFile(void)
 {
-if (-1 != jvmSEVersion) {
-return jvmSEVersion;
-} else {
-PORT_ACCESS_FROM_PORT(&j9portLibrary);
-J9StringBuffer * propsPathBuffer = NULL;
-j9props_file_t classlibProps;
-const char* shape;
-const char* version;
-UDATA decoded, finalVersion = 0;
-
-propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
-propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
-
-classlibProps = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
-
-free(propsPathBuffer);
-propsPathBuffer = NULL;
-
-if (NULL == classlibProps) {
-#ifdef DEBUG
-printf(""Could not open %s\n"", classlibProps);
-#endif
-return J2SE_LATEST|J2SE_SHAPE_LATEST;
-}
-
-shape = props_file_get(classlibProps, ""shape"");
+PORT_ACCESS_FROM_PORT(&j9portLibrary);
+J9StringBuffer *propsPathBuffer = NULL;
+j9props_file_t propsFile = NULL;
+UDATA finalVersion = 0;
+
+propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
+propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
+propsFile = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
+free(propsPathBuffer);
+propsPathBuffer = NULL;
+
+if (NULL != propsFile) {
+const char *shape = NULL;
+const char *version = NULL;
+UDATA decoded = 0;
+
+shape = props_file_get(propsFile, ""shape"");
 if (NULL == shape) {
-#ifdef DEBUG
-printf(""No 'shape' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'shape' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
-version = props_file_get(classlibProps, ""version"");
+version = props_file_get(propsFile, ""version"");
 if (NULL == version) {
-#ifdef DEBUG
-printf(""No 'version' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'version' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
 decoded = decodeSetting(""shape"", shape, SHAPE_SETTINGS, NUM_SHAPE_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
 decoded = decodeSetting(""version"", version, VERSION_SETTINGS, NUM_VERSION_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
-bail:
-props_file_close(classlibProps);
+bail:
+props_file_close(propsFile);
+} else {
+#ifdef DEBUG
+printf(""Could not open %s\n"", propsFile);
+#endif
+}
+
+return finalVersion;
+}
+
+/**
+ * Get Java version info from 'release' file
+ * Attempt loading 'release' file, if found, 'JAVA_VERSION' value is retrieved, and decoded as following:
+ * ""1.8.0_xxx""--- Java 8 (J2SE_18 | J2SE_SHAPE_SUN)
+ * ""9""--- Java 9 (J2SE_19 | J2SE_SHAPE_B165)
+ * ""10""--- Java 18.3 (J2SE_B7 | J2SE_SHAPE_B1803)
+ * Others--- (�J2SE_LATEST | J2SE_SHAPE_LATEST)
+ * Note: 'release' file contains JAVA_VERSION=""10"" for Java 18.3 at this moment.
+ *
+ * @return jvm SE Version value",Please update the @return as per the comments on getVersionFromClasslibPropertiesFile().,
70083868,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,False,"@@ -1218,73 +1226,148 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Get Java version info from 'classlib.properties' file
+ * Attempt loading 'classlib.properties' file, if found, 'shape' & 'version' values are retrieved,
+ * and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly. 
+ * J2SE_xx | J2SE_SHAPE_xx will be returned.
+ *
+ * @return jvm SE Version value
  */
 static UDATA
 getVersionFromClasslibPropertiesFile(void)
 {
-if (-1 != jvmSEVersion) {
-return jvmSEVersion;
-} else {
-PORT_ACCESS_FROM_PORT(&j9portLibrary);
-J9StringBuffer * propsPathBuffer = NULL;
-j9props_file_t classlibProps;
-const char* shape;
-const char* version;
-UDATA decoded, finalVersion = 0;
-
-propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
-propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
-
-classlibProps = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
-
-free(propsPathBuffer);
-propsPathBuffer = NULL;
-
-if (NULL == classlibProps) {
-#ifdef DEBUG
-printf(""Could not open %s\n"", classlibProps);
-#endif
-return J2SE_LATEST|J2SE_SHAPE_LATEST;
-}
-
-shape = props_file_get(classlibProps, ""shape"");
+PORT_ACCESS_FROM_PORT(&j9portLibrary);
+J9StringBuffer *propsPathBuffer = NULL;
+j9props_file_t propsFile = NULL;
+UDATA finalVersion = 0;
+
+propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
+propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
+propsFile = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
+free(propsPathBuffer);
+propsPathBuffer = NULL;
+
+if (NULL != propsFile) {
+const char *shape = NULL;
+const char *version = NULL;
+UDATA decoded = 0;
+
+shape = props_file_get(propsFile, ""shape"");
 if (NULL == shape) {
-#ifdef DEBUG
-printf(""No 'shape' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'shape' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
-version = props_file_get(classlibProps, ""version"");
+version = props_file_get(propsFile, ""version"");
 if (NULL == version) {
-#ifdef DEBUG
-printf(""No 'version' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'version' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
 decoded = decodeSetting(""shape"", shape, SHAPE_SETTINGS, NUM_SHAPE_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
 decoded = decodeSetting(""version"", version, VERSION_SETTINGS, NUM_VERSION_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
-bail:
-props_file_close(classlibProps);
+bail:
+props_file_close(propsFile);
+} else {
+#ifdef DEBUG
+printf(""Could not open %s\n"", propsFile);
+#endif
+}
+
+return finalVersion;
+}
+
+/**
+ * Get Java version info from 'release' file
+ * Attempt loading 'release' file, if found, 'JAVA_VERSION' value is retrieved, and decoded as following:
+ * ""1.8.0_xxx""--- Java 8 (J2SE_18 | J2SE_SHAPE_SUN)
+ * ""9""--- Java 9 (J2SE_19 | J2SE_SHAPE_B165)
+ * ""10""--- Java 18.3 (J2SE_B7 | J2SE_SHAPE_B1803)
+ * Others--- (�J2SE_LATEST | J2SE_SHAPE_LATEST)
+ * Note: 'release' file contains JAVA_VERSION=""10"" for Java 18.3 at this moment.
+ *
+ * @return jvm SE Version value
+ */
+static UDATA
+getVersionFromReleaseFile(void)
+{
+PORT_ACCESS_FROM_PORT(&j9portLibrary);
+J9StringBuffer *propsPathBuffer = NULL;
+j9props_file_t propsFile = NULL;
+UDATA finalVersion = 0;
+
+propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9Buffer));
+propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""release"");
+propsFile = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
+free(propsPathBuffer);
+propsPathBuffer = NULL;
+if (NULL != propsFile) {
+const char *version = props_file_get(propsFile, ""JAVA_VERSION"");
+if (NULL != version) {
+#defineJAVA_VERSION_8""\""1.8.0""/* its usual format is ""1.8.0_xxx"" */
+if (!strncmp(version, JAVA_VERSION_8, strlen(JAVA_VERSION_8))) {
+#undefJAVA_VERSION_8
+finalVersion = J2SE_18 | J2SE_SHAPE_SUN;
+} else if (!strcmp(version, ""\""9\"""")) {
+finalVersion = J2SE_19 | J2SE_SHAPE_B165;
+} else if (!strcmp(version, ""\""10\"""")) {
+finalVersion = J2SE_B7 | J2SE_SHAPE_B1803;
+} else {
+/* Assume latest Java version and shape */
+finalVersion = J2SE_LATEST | J2SE_SHAPE_LATEST;
+}
+} else {
+#ifdef DEBUG
+printf(""No 'JAVA_VERSION' property in %s\n"", propsFile);
+#endif
+}
+props_file_close(propsFile);
+} else {
+#ifdef DEBUG
+printf(""Could not open %s\n"", propsFile);
+#endif
+}
+
+return finalVersion;
+}
+
+/**
+ * Get Java version of running JVM
+ * Attempt loading the 'classlib.properties' file first, otherwise try 'release' file,
+ * if neither of files is found, J2SE_LATEST | J2SE_SHAPE_LATEST will be returned.
+ *
+ * @return jvmSEVersion value",Please update the @return as per the comments on getVersionFromClasslibPropertiesFile(). jvmSEVersion is an internal implementation detail.,
70085552,efcaf3548175d7c0407235314233a94860b2ccc9,jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java,False,"@@ -116,7 +116,13 @@ static BasicType basicType(Class<?> cls) {
 }
 /*[IF Java18.3]*/
 enum Kind {
-PLACEHOLDER;
+CONVERT,
+SPREAD,
+COLLECT,
+GUARD,
+GUARD_WITH_CATCH,
+LOOP,
+TRY_FINALLY",If this change was a separate Pull Request I would have merged it. It doesn't need to be mixed in with the unrelated changes to determine the java version.,
70246725,efcaf3548175d7c0407235314233a94860b2ccc9,jcl/src/java.base/share/classes/java/lang/invoke/LambdaForm.java,True,"@@ -116,7 +116,13 @@ static BasicType basicType(Class<?> cls) {
 }
 /*[IF Java18.3]*/
 enum Kind {
-PLACEHOLDER;
+CONVERT,
+SPREAD,
+COLLECT,
+GUARD,
+GUARD_WITH_CATCH,
+LOOP,
+TRY_FINALLY","To fix `Java 18.3` compile/build errors, this `j.l.i.LambdaForm.Kind` enum change need to be applied with other part of this pull request. Agreed, this change can be in a separate PR for quick reviewing/merging. Created https://github.com/eclipse/openj9/pull/377.",
70257103,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,True,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */","`J2SE_18_3` was my initial choice, just felt it is easy to confuse with `J2SE_18`.",
70862438,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,False,"@@ -1218,73 +1226,149 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Attempt loading 'classlib.properties' file, and get Java version info.
+ * If found, 'version' and 'shape' values are retrieved, and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly.
+ * 'J2SE_xx | J2SE_SHAPE_xx' will be returned;
+ * If not found, 0 is returned.
+ *
+ * @return jvm SE Version value","I don't like this statement, its not necessarily obvious what ""jvm SE Version value"" is. I think it would be clearer to say 'J2SE_xx | J2SE_SHAPE_xx' or 0 is returned, where xx is the value found via the configuration file. This feedback also applies to the other functions in this pull request.",
70863575,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,False,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */","We can brainstorm to find a better name. 
J2SE_2018_3 ?
",
70867122,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,True,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */",How about `JAVA_18_3` which differentiate from earlier name conversion `J2SE_xx`?,
70869103,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,False,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */","Then its not or less obvious that JAVA_* and J2SE_* are related constants that are used interchangeably. Since 18.3 is short form for March 2018, I figure using 2018 would be clear and could not be confused with 18 meaning Java 8.",
70872994,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,False,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */","@We are using this definition to differentiate implementations in the code like ""if (J2SE_VERSION(vm) >= J2SE_19)"". J2SE_B7 would be larger then any of them (the check uses unsigned, does not it?) including 1.9.",
70874649,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,True,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */",`J2SE_2018_3` works for me.,
70877120,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,True,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */","@dmitripivkine right, that's the purpose, `Java 18.3 (0xB700)` should be superset of `Java 9 (0x1900)`.",
70879281,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,False,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */",What we are going to do with Java 10 (0x1A00 I assume) ?,
70880337,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/oti/j2sever.h,True,"@@ -27,24 +27,17 @@
  * note: J2SE_15 needed for shared classes cache introspection but not supported by JVM.
  */
 /*
- * Note: J2SE_LATEST has to be updated to highest Java version supported by VM
- *  This allows JVM operates with latest version when classlib.properties doesn't present.
- * Additional note:
- *  J2SE_LATEST will be kept as J2SE_19 while Java 18.3 raw build is being built.
- *  When a separate Java 18.3 binary is required, a #ifdef flag will be introduced to define
- *  J2SE_LATEST to different values accordingly such as following:
- *  #if J9VM_JAVA9_BUILD > 9
- *  #define J2SE_LATEST  J2SE_1803
- *  #else
- *  #define J2SE_LATEST  J2SE_19
- *  #endif
+ * Note: J2SE_LATEST is the highest Java version supported by VM.
+ *  This allows JVM operates with latest version when neither classlib.properties
+ *  nor release file presents.
  */
 #define J2SE_15  0x1500
 #define J2SE_16  0x1600
 #define J2SE_17  0x1700
 #define J2SE_18  0x1800
 #define J2SE_19  0x1900
-#define J2SE_LATEST  J2SE_19
+#define J2SE_B7  0xB700/* 0xB7 is 183 which refers to Java 18.3 */","`Java 18.3` is `Java 10` (the next version we thought). 
https://mreinhold.org/blog/forward-faster
https://blogs.oracle.com/java-platform-group/faster-and-easier-use-and-redistribution-of-java-se",
70977523,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,True,"@@ -1218,73 +1226,149 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Attempt loading 'classlib.properties' file, and get Java version info.
+ * If found, 'version' and 'shape' values are retrieved, and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly.
+ * 'J2SE_xx | J2SE_SHAPE_xx' will be returned;
+ * If not found, 0 is returned.
+ *
+ * @return jvm SE Version value","Changeset has been updated, pls have another look.",
71862993,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/makelib/mkconstants.mk.ftl,False,"@@ -24,7 +24,10 @@
 </#list>
 
 # Define the Java Version we are compiling
+# Ensure VERSION_MAJOR hence JAVA_SPEC_VERSION not empty
+ifndef VERSION_MAJOR
 VERSION_MAJOR:=9",This can be more simply expressed as `VERSION_MAJOR ?= 9`; there's no need for `ifndef`.,
71888265,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/makelib/mkconstants.mk.ftl,True,"@@ -24,7 +24,10 @@
 </#list>
 
 # Define the Java Version we are compiling
+# Ensure VERSION_MAJOR hence JAVA_SPEC_VERSION not empty
+ifndef VERSION_MAJOR
 VERSION_MAJOR:=9",Updated with comments.,
71936054,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/makelib/mkconstants.mk.ftl,False,"@@ -24,10 +24,12 @@
 </#list>
 
 # Define the Java Version we are compiling
+# This VERSION_MAJOR variable will be overridden by command line option 
+# when there is one such as VERSION_MAJOR=xx.","I don't think `VERSION_MAJOR` will always be defined on the command line (in all recursive calls to make), so the definition needs to use `?=`, not `:=`.",
71977114,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/makelib/mkconstants.mk.ftl,False,"@@ -24,10 +24,12 @@
 </#list>
 
 # Define the Java Version we are compiling
+# This VERSION_MAJOR variable will be overridden by command line option 
+# when there is one such as VERSION_MAJOR=xx.",I have been convinced that `:=` is fine (perhaps even preferred).,
71977503,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,False,"@@ -1218,73 +1226,156 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Attempt loading 'classlib.properties' file, and get Java version info.
+ * If the file is found, 'version' and 'shape' values are retrieved
+ * and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly.
+ * 'J2SE_xx | J2SE_SHAPE_xx' is returned;
+ * Otherwise, 0 is returned.
+ *
+ * @return'J2SE_xx | J2SE_SHAPE_xx' decoded from 'version' and 'shape' values in 'classlib.properties';
+ *or 0 if otherwise.
  */
 static UDATA
 getVersionFromClasslibPropertiesFile(void)
 {
-if (-1 != jvmSEVersion) {
-return jvmSEVersion;
-} else {
-PORT_ACCESS_FROM_PORT(&j9portLibrary);
-J9StringBuffer * propsPathBuffer = NULL;
-j9props_file_t classlibProps;
-const char* shape;
-const char* version;
-UDATA decoded, finalVersion = 0;
-
-propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
-propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
-
-classlibProps = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
-
-free(propsPathBuffer);
-propsPathBuffer = NULL;
-
-if (NULL == classlibProps) {
-#ifdef DEBUG
-printf(""Could not open %s\n"", classlibProps);
-#endif
-return J2SE_LATEST|J2SE_SHAPE_LATEST;
-}
-
-shape = props_file_get(classlibProps, ""shape"");
+PORT_ACCESS_FROM_PORT(&j9portLibrary);
+J9StringBuffer *propsPathBuffer = NULL;
+j9props_file_t propsFile = NULL;
+UDATA finalVersion = 0;
+
+propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
+propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
+propsFile = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
+free(propsPathBuffer);
+propsPathBuffer = NULL;
+
+if (NULL != propsFile) {
+const char *shape = NULL;
+const char *version = NULL;
+UDATA decoded = 0;
+
+shape = props_file_get(propsFile, ""shape"");
 if (NULL == shape) {
-#ifdef DEBUG
-printf(""No 'shape' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'shape' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
-version = props_file_get(classlibProps, ""version"");
+version = props_file_get(propsFile, ""version"");
 if (NULL == version) {
-#ifdef DEBUG
-printf(""No 'version' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'version' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
 decoded = decodeSetting(""shape"", shape, SHAPE_SETTINGS, NUM_SHAPE_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
 decoded = decodeSetting(""version"", version, VERSION_SETTINGS, NUM_VERSION_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
-bail:
-props_file_close(classlibProps);
+bail:
+props_file_close(propsFile);
+} else {
+#ifdef DEBUG
+printf(""Could not open %s\n"", propsFile);
+#endif
+}
+
+return finalVersion;
+}
+
+/**
+ * Attempt loading 'release' file, and get Java version info.
+ * If the file is found, 'JAVA_VERSION' value is retrieved and decoded as following:
+ * ""1.8.0_xxx""--- Java 8, 'J2SE_18 | J2SE_SHAPE_SUN';
+ * ""9""--- Java 9, 'J2SE_19 | J2SE_SHAPE_B165';
+ * ""10""--- Java 18.3, 'J2SE_2018_3 | J2SE_SHAPE_B1803';
+ * Others--- Latest Java, 'J2SE_LATEST | J2SE_SHAPE_LATEST'.
+ * Note: 'release' file contains JAVA_VERSION=""10"" for Java 18.3 at this moment.
+ * Otherwise, 0 is returned.
+ *
+ * @return 'J2SE_18 | J2SE_SHAPE_SUN', 'J2SE_19 | J2SE_SHAPE_B165',
+ *'J2SE_2018_3 | J2SE_SHAPE_B1803', 'J2SE_LATEST | J2SE_SHAPE_LATEST'
+ *according to the 'JAVA_VERSION' value found in 'release';
+ *or 0 if otherwise.
+ */
+static UDATA
+getVersionFromReleaseFile(void)
+{
+PORT_ACCESS_FROM_PORT(&j9portLibrary);
+J9StringBuffer *propsPathBuffer = NULL;
+j9props_file_t propsFile = NULL;
+UDATA finalVersion = 0;
+
+propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9Buffer));
+propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""release"");
+propsFile = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
+free(propsPathBuffer);
+propsPathBuffer = NULL;
+if (NULL != propsFile) {
+const char *version = props_file_get(propsFile, ""JAVA_VERSION"");
+if (NULL != version) {
+#defineJAVA_VERSION_8""\""1.8.0""/* its usual format is ""1.8.0_xxx"" */
+if (!strncmp(version, JAVA_VERSION_8, strlen(JAVA_VERSION_8))) {",Using `sizeof(JAVA_VERSION_8) - 1` avoids the runtime function call to `strlen`.,
71987298,efcaf3548175d7c0407235314233a94860b2ccc9,runtime/j9vm/jvm.c,True,"@@ -1218,73 +1226,156 @@ decodeSetting(const char* key, const char* value, VersionSetting* settings, IDAT
 }
 
 /**
- * Loads the classlib.properties file and initialize the bootstrap
- * classpath based on data found there.
- * @param vm
- * @param cursor
- * @return TRUE on success, FALSE otherwise.
+ * Attempt loading 'classlib.properties' file, and get Java version info.
+ * If the file is found, 'version' and 'shape' values are retrieved
+ * and decoded as J2SE_xx and J2SE_SHAPE_xx accordingly.
+ * 'J2SE_xx | J2SE_SHAPE_xx' is returned;
+ * Otherwise, 0 is returned.
+ *
+ * @return'J2SE_xx | J2SE_SHAPE_xx' decoded from 'version' and 'shape' values in 'classlib.properties';
+ *or 0 if otherwise.
  */
 static UDATA
 getVersionFromClasslibPropertiesFile(void)
 {
-if (-1 != jvmSEVersion) {
-return jvmSEVersion;
-} else {
-PORT_ACCESS_FROM_PORT(&j9portLibrary);
-J9StringBuffer * propsPathBuffer = NULL;
-j9props_file_t classlibProps;
-const char* shape;
-const char* version;
-UDATA decoded, finalVersion = 0;
-
-propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
-propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
-
-classlibProps = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
-
-free(propsPathBuffer);
-propsPathBuffer = NULL;
-
-if (NULL == classlibProps) {
-#ifdef DEBUG
-printf(""Could not open %s\n"", classlibProps);
-#endif
-return J2SE_LATEST|J2SE_SHAPE_LATEST;
-}
-
-shape = props_file_get(classlibProps, ""shape"");
+PORT_ACCESS_FROM_PORT(&j9portLibrary);
+J9StringBuffer *propsPathBuffer = NULL;
+j9props_file_t propsFile = NULL;
+UDATA finalVersion = 0;
+
+propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9libBuffer));
+propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""classlib.properties"");
+propsFile = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
+free(propsPathBuffer);
+propsPathBuffer = NULL;
+
+if (NULL != propsFile) {
+const char *shape = NULL;
+const char *version = NULL;
+UDATA decoded = 0;
+
+shape = props_file_get(propsFile, ""shape"");
 if (NULL == shape) {
-#ifdef DEBUG
-printf(""No 'shape' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'shape' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
-version = props_file_get(classlibProps, ""version"");
+version = props_file_get(propsFile, ""version"");
 if (NULL == version) {
-#ifdef DEBUG
-printf(""No 'version' property in %s\n"", classlibProps);
-#endif
+#ifdef DEBUG
+printf(""No 'version' property in %s\n"", propsFile);
+#endif
 goto bail;
 }
 
 decoded = decodeSetting(""shape"", shape, SHAPE_SETTINGS, NUM_SHAPE_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
 decoded = decodeSetting(""version"", version, VERSION_SETTINGS, NUM_VERSION_SETTINGS);
-if (decoded == 0) {
+if (0 == decoded) {
 goto bail;
 }
 finalVersion |= decoded;
 
-bail:
-props_file_close(classlibProps);
+bail:
+props_file_close(propsFile);
+} else {
+#ifdef DEBUG
+printf(""Could not open %s\n"", propsFile);
+#endif
+}
+
+return finalVersion;
+}
+
+/**
+ * Attempt loading 'release' file, and get Java version info.
+ * If the file is found, 'JAVA_VERSION' value is retrieved and decoded as following:
+ * ""1.8.0_xxx""--- Java 8, 'J2SE_18 | J2SE_SHAPE_SUN';
+ * ""9""--- Java 9, 'J2SE_19 | J2SE_SHAPE_B165';
+ * ""10""--- Java 18.3, 'J2SE_2018_3 | J2SE_SHAPE_B1803';
+ * Others--- Latest Java, 'J2SE_LATEST | J2SE_SHAPE_LATEST'.
+ * Note: 'release' file contains JAVA_VERSION=""10"" for Java 18.3 at this moment.
+ * Otherwise, 0 is returned.
+ *
+ * @return 'J2SE_18 | J2SE_SHAPE_SUN', 'J2SE_19 | J2SE_SHAPE_B165',
+ *'J2SE_2018_3 | J2SE_SHAPE_B1803', 'J2SE_LATEST | J2SE_SHAPE_LATEST'
+ *according to the 'JAVA_VERSION' value found in 'release';
+ *or 0 if otherwise.
+ */
+static UDATA
+getVersionFromReleaseFile(void)
+{
+PORT_ACCESS_FROM_PORT(&j9portLibrary);
+J9StringBuffer *propsPathBuffer = NULL;
+j9props_file_t propsFile = NULL;
+UDATA finalVersion = 0;
+
+propsPathBuffer = jvmBufferCat(propsPathBuffer, jvmBufferData(j9Buffer));
+propsPathBuffer = jvmBufferCat(propsPathBuffer, DIR_SEPARATOR_STR ""release"");
+propsFile = props_file_open(PORTLIB, jvmBufferData(propsPathBuffer), NULL, 0);
+free(propsPathBuffer);
+propsPathBuffer = NULL;
+if (NULL != propsFile) {
+const char *version = props_file_get(propsFile, ""JAVA_VERSION"");
+if (NULL != version) {
+#defineJAVA_VERSION_8""\""1.8.0""/* its usual format is ""1.8.0_xxx"" */
+if (!strncmp(version, JAVA_VERSION_8, strlen(JAVA_VERSION_8))) {",Fixed. Pls have another look.,
71990625,111c29a7b98c426d3b8c69f33ca2ee378bc3208b,runtime/tr.source/trj9/optimizer/J9TransformUtil.cpp,True,"@@ -1393,7 +1393,7 @@ TR::Node * J9::TransformUtil::calculateOffsetFromIndexInContiguousArray(TR::Comp
 
    if (shift)
       {
-      TR::Node *shiftNode = TR::Node::create(constOp, 0);","To me, it looks a bit funny if you do it that way, but this could just be the way that my brain likes repetition close together. 
",
71988752,111c29a7b98c426d3b8c69f33ca2ee378bc3208b,runtime/tr.source/trj9/optimizer/J9TransformUtil.cpp,False,"@@ -1393,7 +1393,7 @@ TR::Node * J9::TransformUtil::calculateOffsetFromIndexInContiguousArray(TR::Comp
 
    if (shift)
       {
-      TR::Node *shiftNode = TR::Node::create(constOp, 0);",Would the code be more clear if we reduce the scope of `constOp` now and push it closer to its use?,
71646202,c5fa2f9ce2e1953db51c2f964a6dea14856d0291,runtime/vm/visible.c,False,"@@ -52,6 +52,14 @@ checkVisibility(J9VMThread *currentThread, J9Class* sourceClass, J9Class* destCl
 Trc_VM_checkVisibility_Entry(currentThread, sourceClass, destClass, modifiers);
 sourceClass = J9_CURRENT_CLASS(sourceClass);
 destClass = J9_CURRENT_CLASS(destClass);
+
+if (J9ROMCLASS_IS_ARRAY(sourceClass->romClass)) {",This code probably belongs in the caller.  ,
71646202,c5fa2f9ce2e1953db51c2f964a6dea14856d0291,runtime/vm/resolvesupport.cpp,False,"@@ -1588,6 +1588,36 @@ resolveMethodTypeRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIn
 }
 }
 
+/* perform visibility checks for the returnType and all parameters */
+if (methodType != NULL) {
+/* check returnType */
+J9Class *senderClass = ramCP->ramClass;
+J9Class *returnTypeClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9VMJAVALANGINVOKEMETHODTYPE_RETURNTYPE(vmThread, methodType));
+bool illegalAccessError = false;
+
+if (J9_VISIBILITY_ALLOWED != checkVisibility(vmThread, senderClass, returnTypeClass, returnTypeClass->romClass->modifiers, resolveFlags)) {
+illegalAccessError = true;
+} else {
+/* check paramTypes */
+j9object_t argTypesObject = J9VMJAVALANGINVOKEMETHODTYPE_ARGUMENTS(vmThread, methodType);
+U_32 typeCount = J9INDEXABLEOBJECT_SIZE(vmThread, argTypesObject);
+for (UDATA i = 0; i < typeCount; i++) {
+J9Class *paramClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9JAVAARRAYOFOBJECT_LOAD(vmThread, argTypesObject, i));
+
+if (J9_VISIBILITY_ALLOWED != checkVisibility(vmThread, senderClass, paramClass, paramClass->romClass->modifiers, resolveFlags)) {
+illegalAccessError = true;
+}
+}
+}
+if (illegalAccessError) {
+j9object_t lookupSigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(lookupSig), J9UTF8_LENGTH(lookupSig), 0);","Can a more specific error message be added?  Ideally highlighting the class that fails the access check?

And there should be a tracepoint here as well.",
71889068,c5fa2f9ce2e1953db51c2f964a6dea14856d0291,runtime/vm/resolvesupport.cpp,False,"@@ -1588,6 +1588,36 @@ resolveMethodTypeRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIn
 }
 }
 
+/* perform visibility checks for the returnType and all parameters */
+if (methodType != NULL) {",Pls put the rvalue on the left for inequality comparison. ,
71890974,c5fa2f9ce2e1953db51c2f964a6dea14856d0291,runtime/vm/resolvesupport.cpp,False,"@@ -1588,6 +1588,36 @@ resolveMethodTypeRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIn
 }
 }
 
+/* perform visibility checks for the returnType and all parameters */
+if (methodType != NULL) {
+/* check returnType */
+J9Class *senderClass = ramCP->ramClass;
+J9Class *returnTypeClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9VMJAVALANGINVOKEMETHODTYPE_RETURNTYPE(vmThread, methodType));
+bool illegalAccessError = false;
+
+if (J9_VISIBILITY_ALLOWED != checkVisibility(vmThread, senderClass, returnTypeClass, returnTypeClass->romClass->modifiers, resolveFlags)) {
+illegalAccessError = true;
+} else {
+/* check paramTypes */
+j9object_t argTypesObject = J9VMJAVALANGINVOKEMETHODTYPE_ARGUMENTS(vmThread, methodType);
+U_32 typeCount = J9INDEXABLEOBJECT_SIZE(vmThread, argTypesObject);
+for (UDATA i = 0; i < typeCount; i++) {
+J9Class *paramClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9JAVAARRAYOFOBJECT_LOAD(vmThread, argTypesObject, i));
+
+if (J9_VISIBILITY_ALLOWED != checkVisibility(vmThread, senderClass, paramClass, paramClass->romClass->modifiers, resolveFlags)) {
+illegalAccessError = true;
+}
+}
+}
+if (illegalAccessError) {
+j9object_t lookupSigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(lookupSig), J9UTF8_LENGTH(lookupSig), 0);
+if (NULL == vmThread->currentException) {
+setCurrentException(vmThread, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, (UDATA*)lookupSigString);
+}","This code block setting exception with `lookupSigString` seems to be used in quite a few other places as well, can it become a helper method?",
72004292,c5fa2f9ce2e1953db51c2f964a6dea14856d0291,runtime/vm/resolvesupport.cpp,True,"@@ -1588,6 +1588,36 @@ resolveMethodTypeRefInto(J9VMThread *vmThread, J9ConstantPool *ramCP, UDATA cpIn
 }
 }
 
+/* perform visibility checks for the returnType and all parameters */
+if (methodType != NULL) {
+/* check returnType */
+J9Class *senderClass = ramCP->ramClass;
+J9Class *returnTypeClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9VMJAVALANGINVOKEMETHODTYPE_RETURNTYPE(vmThread, methodType));
+bool illegalAccessError = false;
+
+if (J9_VISIBILITY_ALLOWED != checkVisibility(vmThread, senderClass, returnTypeClass, returnTypeClass->romClass->modifiers, resolveFlags)) {
+illegalAccessError = true;
+} else {
+/* check paramTypes */
+j9object_t argTypesObject = J9VMJAVALANGINVOKEMETHODTYPE_ARGUMENTS(vmThread, methodType);
+U_32 typeCount = J9INDEXABLEOBJECT_SIZE(vmThread, argTypesObject);
+for (UDATA i = 0; i < typeCount; i++) {
+J9Class *paramClass = J9VM_J9CLASS_FROM_HEAPCLASS(vmThread, J9JAVAARRAYOFOBJECT_LOAD(vmThread, argTypesObject, i));
+
+if (J9_VISIBILITY_ALLOWED != checkVisibility(vmThread, senderClass, paramClass, paramClass->romClass->modifiers, resolveFlags)) {
+illegalAccessError = true;
+}
+}
+}
+if (illegalAccessError) {
+j9object_t lookupSigString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread, J9UTF8_DATA(lookupSig), J9UTF8_LENGTH(lookupSig), 0);
+if (NULL == vmThread->currentException) {
+setCurrentException(vmThread, J9VMCONSTANTPOOL_JAVALANGILLEGALACCESSERROR, (UDATA*)lookupSigString);
+}","I changed the exception string code, it uses illegalAccessMessage(...) now",
72065968,c5fa2f9ce2e1953db51c2f964a6dea14856d0291,runtime/vm/j9vm.tdf,False,"@@ -759,3 +759,7 @@ TraceEvent=Trc_VM_CreateRAMClassFromROMClass_nestTopLoaded Overhead=1 Level=3 Te
 TraceException=Trc_VM_CreateRAMClassFromROMClass_nestTopNotSamePackage Overhead=1 Level=1 Template=""The nest top class (RAM class=%p, class loader=%p, this class loader=%p) is not in the same package.""
 TraceException=Trc_VM_CreateRAMClassFromROMClass_nestTopNotSameClassLoader Overhead=1 Level=1 Template=""The nest top class (RAM class=%p, class loader=%p, this class loader=%p) has not been loaded by the same class loader.""
 TraceException=Trc_VM_CreateRAMClassFromROMClass_nestTopNotVerified Overhead=1 Level=1 Template=""The nest top (nest top class=%p, class loader=%p, this class loader=%p) does not claim the nest member (nest member=%p).""
+
+TraceEntry=Trc_VM_sendResolveMethodTypeRefInto_Entry Overhead=1 Level=5 Template=""sendResolveMethodTypeRefInto ramCP=%p cpIndex=%zu resolveFlags=%zu""
+TraceException=Trc_VM_sendResolveMethodTypeRefInto_Exception Overhead=1 Level=5 Template=""Sender class=%p cannot access receiver class=%p, errorCode=%zi.""","We want to ensure that the exception is logged in the trace buffer so the exception should be level=1, not 5.  The enter / exits can stay at level 5.",
72072822,c5fa2f9ce2e1953db51c2f964a6dea14856d0291,runtime/vm/j9vm.tdf,True,"@@ -759,3 +759,7 @@ TraceEvent=Trc_VM_CreateRAMClassFromROMClass_nestTopLoaded Overhead=1 Level=3 Te
 TraceException=Trc_VM_CreateRAMClassFromROMClass_nestTopNotSamePackage Overhead=1 Level=1 Template=""The nest top class (RAM class=%p, class loader=%p, this class loader=%p) is not in the same package.""
 TraceException=Trc_VM_CreateRAMClassFromROMClass_nestTopNotSameClassLoader Overhead=1 Level=1 Template=""The nest top class (RAM class=%p, class loader=%p, this class loader=%p) has not been loaded by the same class loader.""
 TraceException=Trc_VM_CreateRAMClassFromROMClass_nestTopNotVerified Overhead=1 Level=1 Template=""The nest top (nest top class=%p, class loader=%p, this class loader=%p) does not claim the nest member (nest member=%p).""
+
+TraceEntry=Trc_VM_sendResolveMethodTypeRefInto_Entry Overhead=1 Level=5 Template=""sendResolveMethodTypeRefInto ramCP=%p cpIndex=%zu resolveFlags=%zu""
+TraceException=Trc_VM_sendResolveMethodTypeRefInto_Exception Overhead=1 Level=5 Template=""Sender class=%p cannot access receiver class=%p, errorCode=%zi.""","fixed
",
72328104,a50c21b244adaff58a6ff021827ad0f7ebb7f955,runtime/makelib/targets.mk.ftl,False,"@@ -95,6 +95,7 @@ ifeq ($(UMA_TARGET_TYPE),EXE)
 endif
 
 CFLAGS+=-DJAVA_SPEC_VERSION=$(VERSION_MAJOR)
+CXXFLAGS+=-DJAVA_SPEC_VERSION=$(VERSION_MAJOR)",Perhaps it should be in `CPPFLAGS` too?,
72335220,a50c21b244adaff58a6ff021827ad0f7ebb7f955,runtime/makelib/targets.mk.ftl,True,"@@ -95,6 +95,7 @@ ifeq ($(UMA_TARGET_TYPE),EXE)
 endif
 
 CFLAGS+=-DJAVA_SPEC_VERSION=$(VERSION_MAJOR)
+CXXFLAGS+=-DJAVA_SPEC_VERSION=$(VERSION_MAJOR)",I should've seen that.  Done.,
72188981,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/codegen/J9CodeGenerator.cpp,False,"@@ -666,7 +666,10 @@ J9::CodeGenerator::lowerTreesPreChildrenVisit(TR::Node *parent, TR::TreeTop *tre
       if (self()->comp()->useCompressedPointers())
          {
          TR::MethodSymbol *methodSymbol = parent->getSymbol()->castToMethodSymbol();
+         // Unsafe could be the jdk.internal JNI method or the sun.misc ordinary method wrapper,",Please include that this is the case in Java 9 up - 8 and earlier will have the sun.misc.Unsafe as the native.,
72189132,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/optimizer/InlinerTempForJ9.cpp,False,"@@ -349,57 +349,71 @@ TR_J9InlinerPolicy::mustBeInlinedEvenInDebug(TR_ResolvedMethod * calleeMethod, T
    return false;
    }
 
+/* Identify methods for which the benefits of inlining them into the caller",Please format this for doxygen,
72189240,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/optimizer/InlinerTempForJ9.cpp,False,"@@ -349,57 +349,71 @@ TR_J9InlinerPolicy::mustBeInlinedEvenInDebug(TR_ResolvedMethod * calleeMethod, T
    return false;
    }
 
+/* Identify methods for which the benefits of inlining them into the caller
+   are particularly significant.
+*/
 bool
 TR_J9InlinerPolicy::alwaysWorthInlining(TR_ResolvedMethod * calleeMethod, TR::Node *callNode)
    {
-   if (calleeMethod && isInlineableJNI(calleeMethod, callNode))
+   // if we are passed a null calleeMethod then we can only return false",This is obvious from the code.,
72189589,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/optimizer/InlinerTempForJ9.cpp,False,"@@ -349,57 +349,71 @@ TR_J9InlinerPolicy::mustBeInlinedEvenInDebug(TR_ResolvedMethod * calleeMethod, T
    return false;
    }
 
+/* Identify methods for which the benefits of inlining them into the caller
+   are particularly significant.
+*/
 bool
 TR_J9InlinerPolicy::alwaysWorthInlining(TR_ResolvedMethod * calleeMethod, TR::Node *callNode)
    {
-   if (calleeMethod && isInlineableJNI(calleeMethod, callNode))
+   // if we are passed a null calleeMethod then we can only return false
+   if (!calleeMethod) return false;
+
+   if (isInlineableJNI(calleeMethod, callNode))
       return true;
 
-   if (calleeMethod && calleeMethod->isDAAWrapperMethod())
+   if (calleeMethod->isDAAWrapperMethod())
       return true;
 
-   if (calleeMethod)
+   switch (calleeMethod->convertToMethod()->getMandatoryRecognizedMethod())
       {
-      switch (calleeMethod->convertToMethod()->getMandatoryRecognizedMethod())
-         {
-         case TR::java_lang_invoke_MethodHandle_asType:
-         case TR::java_lang_invoke_MethodHandle_invokeExactTargetAddress:
-            return true;
-         default:
-          break;
-         }
-
-      // we rely on inlining compareAndSwap so we see the inner native call and can special case it
-      // get/putLongVolatile is not supported by all codegens so we want to inline to expose the native
-      // if we haven't special cased it in the walker
-      switch (calleeMethod->getRecognizedMethod())
-         {
-         case TR::java_lang_J9VMInternals_fastIdentityHashCode:
-         case TR::java_lang_Class_getSuperclass:
-         case TR::java_lang_String_regionMatches:
-         case TR::java_lang_Class_newInstance:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapIntInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapLongInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapObjectInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapIntInArray:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapLongInArray:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapObjectInArray:
-         case TR::com_ibm_jit_JITHelpers_jitHelpers:
-         case TR::java_lang_String_charAtInternal_I:
-         case TR::java_lang_String_charAtInternal_IB:
-         case TR::java_lang_String_length:
-         case TR::java_lang_String_lengthInternal:
-         case TR::java_lang_String_isCompressed:
-         case TR::java_lang_StringBuffer_capacityInternal:
-         case TR::java_lang_StringBuffer_lengthInternalUnsynchronized:
-         case TR::java_lang_StringBuilder_capacityInternal:
-         case TR::java_lang_StringBuilder_lengthInternal:
-         case TR::java_util_HashMap_get:
-         case TR::java_util_HashMap_getNode:
-            return true;
-         default:
-          break;
-         }
+      case TR::java_lang_invoke_MethodHandle_asType:
+      case TR::java_lang_invoke_MethodHandle_invokeExactTargetAddress:
+         return true;
+      default:
+       break;",formatting,
72189958,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/optimizer/InlinerTempForJ9.cpp,False,"@@ -349,57 +349,71 @@ TR_J9InlinerPolicy::mustBeInlinedEvenInDebug(TR_ResolvedMethod * calleeMethod, T
    return false;
    }
 
+/* Identify methods for which the benefits of inlining them into the caller
+   are particularly significant.
+*/
 bool
 TR_J9InlinerPolicy::alwaysWorthInlining(TR_ResolvedMethod * calleeMethod, TR::Node *callNode)
    {
-   if (calleeMethod && isInlineableJNI(calleeMethod, callNode))
+   // if we are passed a null calleeMethod then we can only return false
+   if (!calleeMethod) return false;
+
+   if (isInlineableJNI(calleeMethod, callNode))
       return true;
 
-   if (calleeMethod && calleeMethod->isDAAWrapperMethod())
+   if (calleeMethod->isDAAWrapperMethod())
       return true;
 
-   if (calleeMethod)
+   switch (calleeMethod->convertToMethod()->getMandatoryRecognizedMethod())
       {
-      switch (calleeMethod->convertToMethod()->getMandatoryRecognizedMethod())
-         {
-         case TR::java_lang_invoke_MethodHandle_asType:
-         case TR::java_lang_invoke_MethodHandle_invokeExactTargetAddress:
-            return true;
-         default:
-          break;
-         }
-
-      // we rely on inlining compareAndSwap so we see the inner native call and can special case it
-      // get/putLongVolatile is not supported by all codegens so we want to inline to expose the native
-      // if we haven't special cased it in the walker
-      switch (calleeMethod->getRecognizedMethod())
-         {
-         case TR::java_lang_J9VMInternals_fastIdentityHashCode:
-         case TR::java_lang_Class_getSuperclass:
-         case TR::java_lang_String_regionMatches:
-         case TR::java_lang_Class_newInstance:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapIntInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapLongInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapObjectInObject:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapIntInArray:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapLongInArray:
-         case TR::com_ibm_jit_JITHelpers_compareAndSwapObjectInArray:
-         case TR::com_ibm_jit_JITHelpers_jitHelpers:
-         case TR::java_lang_String_charAtInternal_I:
-         case TR::java_lang_String_charAtInternal_IB:
-         case TR::java_lang_String_length:
-         case TR::java_lang_String_lengthInternal:
-         case TR::java_lang_String_isCompressed:
-         case TR::java_lang_StringBuffer_capacityInternal:
-         case TR::java_lang_StringBuffer_lengthInternalUnsynchronized:
-         case TR::java_lang_StringBuilder_capacityInternal:
-         case TR::java_lang_StringBuilder_lengthInternal:
-         case TR::java_util_HashMap_get:
-         case TR::java_util_HashMap_getNode:
-            return true;
-         default:
-          break;
-         }
+      case TR::java_lang_invoke_MethodHandle_asType:
+      case TR::java_lang_invoke_MethodHandle_invokeExactTargetAddress:
+         return true;
+      default:
+       break;
+      }
+
+   // we rely on inlining compareAndSwap so we see the inner native call and can special case it",redundant - the comment belongs with the specific list of enum entries that have the special handling. so please move this down there / incorporate into the other ocmments you added there,
72190356,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/x/codegen/J9TreeEvaluator.cpp,False,"@@ -13004,6 +13004,8 @@ inlineAtomicStampedReference_doubleWordSet(
    return true;
    }
 
+// Note that this function must have behaviour consistent with the OMR function",This should either be properly doxygen'd or the comment moved into the method body and not put in the place where doxygen would go.,
72190975,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/x/codegen/J9TreeEvaluator.cpp,False,"@@ -13021,6 +13023,9 @@ inlineCompareAndSwapNative(
 
    TR_X86OpCodes op;
 
+   TR::SymbolReference *callSymRef = node->getSymbolReference();
+   TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();",I don't think these locals are necessary node->getSymbolReference()->getSymbol()->castToMethodSymbol() should be a fine chain if you need to test native-ness. Do we need to worry about a NULL return from castToMethodSymbol()? Move any locals necessary for null checking down near the use rather than declaring them up here.,
72210105,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/x/codegen/J9TreeEvaluator.cpp,True,"@@ -13021,6 +13023,9 @@ inlineCompareAndSwapNative(
 
    TR_X86OpCodes op;
 
+   TR::SymbolReference *callSymRef = node->getSymbolReference();
+   TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();",I thought there was a requirement to keep decls at the top of the block in order to keep some older compilers happy?,
72214427,85fec49e187952330cee8e8e378c7cd86b1517fd,runtime/tr.source/trj9/x/codegen/J9TreeEvaluator.cpp,False,"@@ -13021,6 +13023,9 @@ inlineCompareAndSwapNative(
 
    TR_X86OpCodes op;
 
+   TR::SymbolReference *callSymRef = node->getSymbolReference();
+   TR::MethodSymbol *methodSymbol = callSymRef->getSymbol()->castToMethodSymbol();","True for C, but not so for the version of C++ used in the compiler. You could create a block with {}s to limit the scope if you wanted to.",
72581388,048b8ad2185f73d380db81e9ad0756925f9e0814,test/TestConfig/scripts/testKitGen/testKitGen.pl,False,"@@ -84,9 +84,7 @@
 }
 
 if ( !$graphSpecs ) {
-$graphSpecs =
-""aix_ppc,aix_ppc-64,aix_ppc-64_cmprssptrs,aix_ppc-64_cmprssptrs_purec,aix_ppc-64_purec,aix_ppc_purec,linux_390,linux_390-64,linux_390-64_cmprssptrs,linux_390-64_cmprssptrs_purec,linux_390-64_cs,linux_390-64_purec,linux_390_purec,linux_arm,linux_ppc-64_cmprssptrs_le,linux_ppc-64_cmprssptrs_le_cs,linux_ppc-64_cmprssptrs_le_purec,linux_ppc-64_le,linux_ppc-64_le_purec,linux_x86,linux_x86-64,linux_x86-64_cmprssptrs,linux_x86-64_cmprssptrs_cs,linux_x86-64_cmprssptrs_purec,linux_x86-64_purec,linux_x86_purec,win_x86,win_x86-64,win_x86-64_cmprssptrs,win_x86-64_cmprssptrs_purec,win_x86-64_purec,win_x86_purec,zos_390,zos_390-64,zos_390-64_cmprssptrs,zos_390-64_cmprssptrs_cs,zos_390-64_cmprssptrs_purec,zos_390-64_purec,zos_390_purec"";
-print ""graphSpecs is not provided. Set graphSpecs = $graphSpecs\n"";
+die ""Please provide graphSpecs!""","Lines 89 and 90 say provide graphSpecs (plural), but we only ever want a single spec to be supplied at a time, so less confusing to say ""Please provide graphSpec""",
72815501,a8b66214a203d1a81e37814d7e9acae96e9bfb58,sourcetools/buildj9tools.mk,False,"@@ -30,13 +30,16 @@
 #   DEST_DIR: the location to copy the J9 Java tools generated binaries
 ################################################################################
 
+include ../../spec.gmk
+","This is making an assumption on position and existence of a spec.gmk which I don't think is the case for all uses, for example a compilation where openjdk extensions do not exist.",
72815501,a8b66214a203d1a81e37814d7e9acae96e9bfb58,sourcetools/buildj9tools.mk,False,"@@ -46,7 +49,7 @@ ifdef DEV_TOOLS
   JAVA_BIN  ?= $(DEV_TOOLS)/ibm-jdk-1.8.0/bin
 else
   # requires Java 8 or 9
-  JAVA      := java8
+  JAVA      := java$(PREV_JAVA)",Makes the asumptions that javaN is available on all machines that utilize run this code which may or may not be the case.,
72829732,a8b66214a203d1a81e37814d7e9acae96e9bfb58,sourcetools/buildj9tools.mk,True,"@@ -30,13 +30,16 @@
 #   DEST_DIR: the location to copy the J9 Java tools generated binaries
 ################################################################################
 
+include ../../spec.gmk
+","That spec.gmk exists inside the build/linuxetc directory, and that file definitely exists on a Hotspot build I have. It exists in that directory, with the variable in it.

Note that buildj9tools.mk is copied two layers deeper than spec.gmk (build/linuxetc/vm/sourcetools), so the ../../spec.gmk should work, and I'm not aware of a Java where that is not the case.",
72830192,a8b66214a203d1a81e37814d7e9acae96e9bfb58,sourcetools/buildj9tools.mk,False,"@@ -30,13 +30,16 @@
 #   DEST_DIR: the location to copy the J9 Java tools generated binaries
 ################################################################################
 
+include ../../spec.gmk
+","It might be reasonable to make that include conditional:
```
ifdef SPEC
include $(SPEC)
endif
```",
72833455,a8b66214a203d1a81e37814d7e9acae96e9bfb58,sourcetools/buildj9tools.mk,True,"@@ -30,13 +30,16 @@
 #   DEST_DIR: the location to copy the J9 Java tools generated binaries
 ################################################################################
 
+include ../../spec.gmk
+","Sure. We should put in a default for VERSION_SPECIFICATION if we can't include spec.gmk. If you plan to build java 8 with openj9, I recommend setting the default VERSION_SPECIFICATION value to 7.",
72835080,a8b66214a203d1a81e37814d7e9acae96e9bfb58,sourcetools/buildj9tools.mk,False,"@@ -30,13 +30,16 @@
 #   DEST_DIR: the location to copy the J9 Java tools generated binaries
 ################################################################################
 
+include ../../spec.gmk
+",Why could we not use the default -source and -target values for either java7 or java8 sdk used to compile?  Do this cause some of of problem?  I don't see why spec level details cannot be removed and use the JAVA_BIN passed from where its called from ( runtime/buildtools.mk ).  ,
72836068,a8b66214a203d1a81e37814d7e9acae96e9bfb58,sourcetools/buildj9tools.mk,False,"@@ -45,8 +48,8 @@ else
 ifdef DEV_TOOLS
   JAVA_BIN  ?= $(DEV_TOOLS)/ibm-jdk-1.8.0/bin
 else
-  # requires Java 8 or 9
-  JAVA      := java8
+  # requires previous or identical Java version
+  JAVA      := java$(PREV_JAVA)","If we're considering changes here, I think it's time to stop assuming users have tools called `java8` (or `java7`) available.
In fact, if `BOOT_JDK` is defined, we should simply use it instead of looking elsewhere.",
72845119,a8b66214a203d1a81e37814d7e9acae96e9bfb58,sourcetools/buildj9tools.mk,False,"@@ -30,13 +30,16 @@
 #   DEST_DIR: the location to copy the J9 Java tools generated binaries
 ################################################################################
 
+include ../../spec.gmk
+","As it is currently written, `VERSION_SPECIFICATION` defaults to 7.
The version requirement is dictated by the source files we need to compile (which was recently downgraded from 8 to 7). I don't see why we can't just always set `-source` and `-target` to 7.",
72337771,87f77217624f9c734693b74d21ed134ce4eab784,runtime/codert_vm/cnathelp.cpp,False,"@@ -2491,7 +2491,7 @@ fast_jitCollapseJNIReferenceFrame(J9VMThread *currentThread)
 }
 
 UDATA J9FASTCALL
-#if defined(J9VM_ARCH_X86)
+#if defined(J9VM_ARCH_X86) || defined(J9VM_ARCH_S390)
 /* TODO Will be cleaned once all platforms adopt the correct parameter order */
 fast_jitInstanceOf(J9VMThread *currentThread, j9object_t object, J9Class *castClass)
 #else /* J9VM_ARCH_X86 */",This comment may need be updated as well.,
72496014,87f77217624f9c734693b74d21ed134ce4eab784,runtime/codert_vm/cnathelp.cpp,True,"@@ -2491,12 +2491,12 @@ fast_jitCollapseJNIReferenceFrame(J9VMThread *currentThread)
 }
 
 UDATA J9FASTCALL
-#if defined(J9VM_ARCH_X86)
+#if defined(J9VM_ARCH_X86) || defined(J9VM_ARCH_S390)
 /* TODO Will be cleaned once all platforms adopt the correct parameter order */
 fast_jitInstanceOf(J9VMThread *currentThread, j9object_t object, J9Class *castClass)
-#else /* J9VM_ARCH_X86 */
+#else /* J9VM_ARCH_X86 || J9VM_ARCH_S390*/",@0dvictor  Added the condition for #if in comment as well. ,
72589025,87f77217624f9c734693b74d21ed134ce4eab784,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.hpp,False,"@@ -122,50 +122,6 @@ class S390CHelperLinkage : public TR::Linkage
       return buildDirectDispatch(callNode, NULL, returnReg);
       }
 
-   /** \brief
-    *       Overloaded function that builds the direct dispatch sequence for given node using C Helper linkage
-    *       using already evaluated parameters from paramInRegister and is passed stores result in returnReg
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param &paramInRegister
-    *       A stack of TR::Register* which will be used to prepare arguments for helper call instead of evaluating children of callNode
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister, TR::Register *returnReg=NULL)
-   {
-   return buildDirectDispatch(callNode, NULL, paramInRegister, returnReg);
-   }
-
-   /** \brief
-    *       Overloaded function to be used within internal control flow to build the direct dispatch sequence for given node using C Helper linkage
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param **deps
-    *       A register dependency condition which will be filled with helper call condition so that consumer can combine with the dependency condition
-    *       of internal control flow and attach it to merge label
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL)
-   {
-   TR_Stack<TR::Register*> paramInRegisters(cg()->trMemory());
-   return buildDirectDispatch(callNode, deps, paramInRegisters, returnReg);
-   }
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg);
+   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL);","Do you think reordering `deps` and `returnReg` would be more intuitive given that we have an API above defined as `buildDirectDispatch(TR::Node *callNode, TR::Register *returnReg)`? The order of parameters may then be consistent.",
72594556,87f77217624f9c734693b74d21ed134ce4eab784,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.hpp,True,"@@ -122,50 +122,6 @@ class S390CHelperLinkage : public TR::Linkage
       return buildDirectDispatch(callNode, NULL, returnReg);
       }
 
-   /** \brief
-    *       Overloaded function that builds the direct dispatch sequence for given node using C Helper linkage
-    *       using already evaluated parameters from paramInRegister and is passed stores result in returnReg
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param &paramInRegister
-    *       A stack of TR::Register* which will be used to prepare arguments for helper call instead of evaluating children of callNode
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister, TR::Register *returnReg=NULL)
-   {
-   return buildDirectDispatch(callNode, NULL, paramInRegister, returnReg);
-   }
-
-   /** \brief
-    *       Overloaded function to be used within internal control flow to build the direct dispatch sequence for given node using C Helper linkage
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param **deps
-    *       A register dependency condition which will be filled with helper call condition so that consumer can combine with the dependency condition
-    *       of internal control flow and attach it to merge label
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL)
-   {
-   TR_Stack<TR::Register*> paramInRegisters(cg()->trMemory());
-   return buildDirectDispatch(callNode, deps, paramInRegisters, returnReg);
-   }
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg);
+   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL);","Thanks for pointing this out, It does look more intuitive the way you said.  Let me try and change it. 
Currently we are encountering following uses of the interface. 
```
1. buildDirectDispatch(node) -> Standard API
2. buildDirectDispatch(node, register) -> If result register is already allocated
3. buildDirectDispatch(node, &deps, register=NULL) -> It is called within ICF and can be used same if we have already allocated register)
``` ",
72598965,87f77217624f9c734693b74d21ed134ce4eab784,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.hpp,True,"@@ -122,50 +122,6 @@ class S390CHelperLinkage : public TR::Linkage
       return buildDirectDispatch(callNode, NULL, returnReg);
       }
 
-   /** \brief
-    *       Overloaded function that builds the direct dispatch sequence for given node using C Helper linkage
-    *       using already evaluated parameters from paramInRegister and is passed stores result in returnReg
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param &paramInRegister
-    *       A stack of TR::Register* which will be used to prepare arguments for helper call instead of evaluating children of callNode
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister, TR::Register *returnReg=NULL)
-   {
-   return buildDirectDispatch(callNode, NULL, paramInRegister, returnReg);
-   }
-
-   /** \brief
-    *       Overloaded function to be used within internal control flow to build the direct dispatch sequence for given node using C Helper linkage
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param **deps
-    *       A register dependency condition which will be filled with helper call condition so that consumer can combine with the dependency condition
-    *       of internal control flow and attach it to merge label
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL)
-   {
-   TR_Stack<TR::Register*> paramInRegisters(cg()->trMemory());
-   return buildDirectDispatch(callNode, deps, paramInRegisters, returnReg);
-   }
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg);
+   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL);","Ok, So checked how it looks if we change the order
```
TR::Register* buildDirectDispatch(TR::Node *node, TR::Register *register, TR::RegisterDependencyConditions ** deps = static_cast<TR::RegisterDependencyConditions**>(NULL));

TR::Register * buildDirectDispatch(TR::Node *node)
{
return buildDirectDispatch(node, NULL, static_cast<TR::RegisterDependencyConditions**>(NULL));
}
TR::Register *buildDirectDispatch(TR::Node *node, TR::RegisterDependencyConditions **deps)
{
return buildDirectDispatch(node, NULL, deps);
}
``` 
Even in this way we are ending up with 3 overridden functions. I doubt if this makes that more difference.
",
72603132,87f77217624f9c734693b74d21ed134ce4eab784,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.hpp,False,"@@ -122,50 +122,6 @@ class S390CHelperLinkage : public TR::Linkage
       return buildDirectDispatch(callNode, NULL, returnReg);
       }
 
-   /** \brief
-    *       Overloaded function that builds the direct dispatch sequence for given node using C Helper linkage
-    *       using already evaluated parameters from paramInRegister and is passed stores result in returnReg
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param &paramInRegister
-    *       A stack of TR::Register* which will be used to prepare arguments for helper call instead of evaluating children of callNode
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister, TR::Register *returnReg=NULL)
-   {
-   return buildDirectDispatch(callNode, NULL, paramInRegister, returnReg);
-   }
-
-   /** \brief
-    *       Overloaded function to be used within internal control flow to build the direct dispatch sequence for given node using C Helper linkage
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param **deps
-    *       A register dependency condition which will be filled with helper call condition so that consumer can combine with the dependency condition
-    *       of internal control flow and attach it to merge label
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL)
-   {
-   TR_Stack<TR::Register*> paramInRegisters(cg()->trMemory());
-   return buildDirectDispatch(callNode, deps, paramInRegisters, returnReg);
-   }
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg);
+   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL);","@r30shah I understand we cannot get away without three overridden functions. All I was pointing towards was that if we have possible permutation of three parameters `A`, `B`, and `C` defining three APIs as:

```
foo(A);
foo(A,B);
foo(A,B,C);
```

May be more intuitive for the user looking for the appropriate API to use than what we have now, which is:

```
foo(A);
foo(A,B);
foo(A,C,B);
```

i.e. `B` is not consistently declared as the second parameter in two of the APIs. Defining a consistent parameter order may help the user to look for a specific API as the APIs evolve and grow. Take a look at `generateS390MemoryReference` as an example here:

https://github.com/eclipse/omr/blob/b4feac5d4f5380845c22e47e4268a934b8498a00/compiler/z/codegen/OMRMemoryReference.hpp#L461-L474

The parameter ordering is not consistent at all. The `cg` parameter sometimes comes first, sometimes second, sometimes last, etc. and there are 13 such overloads. Do we believe a user may have an easier time finding the right API to use if all the parameters were consistently ordered?",
72653828,87f77217624f9c734693b74d21ed134ce4eab784,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.hpp,True,"@@ -122,50 +122,6 @@ class S390CHelperLinkage : public TR::Linkage
       return buildDirectDispatch(callNode, NULL, returnReg);
       }
 
-   /** \brief
-    *       Overloaded function that builds the direct dispatch sequence for given node using C Helper linkage
-    *       using already evaluated parameters from paramInRegister and is passed stores result in returnReg
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param &paramInRegister
-    *       A stack of TR::Register* which will be used to prepare arguments for helper call instead of evaluating children of callNode
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister, TR::Register *returnReg=NULL)
-   {
-   return buildDirectDispatch(callNode, NULL, paramInRegister, returnReg);
-   }
-
-   /** \brief
-    *       Overloaded function to be used within internal control flow to build the direct dispatch sequence for given node using C Helper linkage
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param **deps
-    *       A register dependency condition which will be filled with helper call condition so that consumer can combine with the dependency condition
-    *       of internal control flow and attach it to merge label
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL)
-   {
-   TR_Stack<TR::Register*> paramInRegisters(cg()->trMemory());
-   return buildDirectDispatch(callNode, deps, paramInRegisters, returnReg);
-   }
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg);
+   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL);","@fjeremic I got your point. And what we have `generateS390MemoryReference` is really inconsistent and I agree with the point that user would have difficult time to find correct signature to call. 
I would say this case is little different as neither `TR::Register*` nor `TR::RegisterDependencyConditons**` is consistently second parameter. 
I want to be able to call 
`buildDirectDispatch(node)`
`buildDirectDispatch(node, &deps)`
`buildDirectDispatch(node, register)`
`buildDirectDispatch(node, &deps, register)`
And the way I achieve this is by declaring function like,
`TR::Register * buildDirectDispatch(TR::Node *node, TR::RegisterDependencyConditions **deps, TR::Register *reg=NULL`
This was I can call the same function `buildDirectDispatch(node, &deps)` with reg initialized to `NULL` as per declaration.
And Declared `TR::Register *buildDirectDispatch(TR::Node *node, TR::Register *reg)` is used to call dispatch function without dependency conditions.",
72677204,87f77217624f9c734693b74d21ed134ce4eab784,runtime/tr.source/trj9/z/codegen/J9S390CHelperLinkage.hpp,False,"@@ -122,50 +122,6 @@ class S390CHelperLinkage : public TR::Linkage
       return buildDirectDispatch(callNode, NULL, returnReg);
       }
 
-   /** \brief
-    *       Overloaded function that builds the direct dispatch sequence for given node using C Helper linkage
-    *       using already evaluated parameters from paramInRegister and is passed stores result in returnReg
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param &paramInRegister
-    *       A stack of TR::Register* which will be used to prepare arguments for helper call instead of evaluating children of callNode
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register* buildDirectDispatch(TR::Node *callNode, TR_Stack<TR::Register*>& paramInRegister, TR::Register *returnReg=NULL)
-   {
-   return buildDirectDispatch(callNode, NULL, paramInRegister, returnReg);
-   }
-
-   /** \brief
-    *       Overloaded function to be used within internal control flow to build the direct dispatch sequence for given node using C Helper linkage
-    *
-    *  \param callNode
-    *       TR::Node* for which helper dispatch sequence will be generated
-    *
-    *  \param **deps
-    *       A register dependency condition which will be filled with helper call condition so that consumer can combine with the dependency condition
-    *       of internal control flow and attach it to merge label
-    * 
-    *  \param returnReg
-    *       TR::Register* allocated by consumer of this API. If passed dispatch sequence will use this register to store return value from helper
-    *       instead from allocating new register.
-    *
-    *  \return
-    *      Returns TR::Register* which contains return value from helper call
-    */  
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL)
-   {
-   TR_Stack<TR::Register*> paramInRegisters(cg()->trMemory());
-   return buildDirectDispatch(callNode, deps, paramInRegisters, returnReg);
-   }
-   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR_Stack<TR::Register*>& paramInRegisters, TR::Register *returnReg);
+   TR::Register *buildDirectDispatch(TR::Node *callNode, TR::RegisterDependencyConditions** deps, TR::Register *returnReg=NULL);","I see, so there are four permutations. I have overlooked the fact that in `buildDirectDispatch(node, register)` the `register` parameter does not have a `NULL` default. Thanks for the explanation @r30shah!",
72885694,a8b66214a203d1a81e37814d7e9acae96e9bfb58,sourcetools/buildj9tools.mk,True,"@@ -30,13 +30,16 @@
 #   DEST_DIR: the location to copy the J9 Java tools generated binaries
 ################################################################################
 
+include ../../spec.gmk
+","Keith is correct in that PREV_JAVA will currently default to 7.

Also, as for the conditional, gnu.org says:

If you want make to simply ignore a makefile which does not exist or cannot be remade, with no error message, use the -include directive instead of include, like this:

\-include filenames�
",
73204514,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.",Should `**Get the source**` be a link to the Get the Source section?,
73204514,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*",Please remove the `rm -rf ....` line.  Users don't want their APT package listings deleted on their machines.  This is only done in Docker to keep the images small.,
73204514,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.",`contain` -> `contains`,
73204514,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following command:
+```
+ln -s g++ /usr/bin/c++ \
+  && ln -s g++-4.8 /usr/bin/g++ \
+  && ln -s gcc /usr/bin/cc \
+  && ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into the /root directory:","We should say something like:
``` Download and setup **freemarker.jar** into a directory.  The example commands use `/root` to be consistent with the Docker instructions.  If you aren't using Docker, it's better to store the freemarker.jar in your home directory.```

As putting files in /root isn't a great practice. ",
73204514,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following command:
+```
+ln -s g++ /usr/bin/c++ \
+  && ln -s g++-4.8 /usr/bin/g++ \
+  && ln -s gcc /usr/bin/cc \
+  && ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into the /root directory:
+```
+cd /root \
+  && wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz \
+  && tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2 \
+  && rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script.",Is there an issue (either on OpenJ9 or the extensions repo) to fix this?  If so we should link to it.,
73204514,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following command:
+```
+ln -s g++ /usr/bin/c++ \
+  && ln -s g++-4.8 /usr/bin/g++ \
+  && ln -s gcc /usr/bin/cc \
+  && ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into the /root directory:
+```
+cd /root \
+  && wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz \
+  && tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2 \
+  && rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script.
+
+Two Java builds are produced: a full developer kit (jdk) and a runtime environment (jre)
+- **build/linux-x86_64-normal-server-release/images/jdk**
+- **build/linux-x86_64-normal-server-release/images/jre**
+
+    :whale: If you built your binaries in a Docker container, copy the binaries to the containers **/root/hostdir** directory so that you can access them on your local system. You'll find them in the directory you set for `<host_directory>` when you started your Docker container. See [Setting up your build environment with Docker](#setting-up-your-build-environment-with-docker).
+
+    :pencil: On other architectures the **/jdk** and **/jre** directories are in **build/linux-ppc64le-normal-server-release/images** (Linux on 64-bit Power systems) and **build/linux-s390x-normal-server-release/images** (Linux on 64-bit z Systems)
+
+### 5. Test
+:penguin:
+For a simple test, try running the `java -version` command.
+Change to the /jre directory:
+```
+cd build/linux-x86_64-normal-server-release/images/jre
+```
+Run:
+```
+./bin/java -version
+```
+
+Here is some sample output:
+
+```
+openjdk version ""9-internal""
+OpenJDK Runtime Environment (build 9-internal+0-adhoc.openj9-openjdk-jdk9)
+Eclipse OpenJ9 VM (build 2.9, JRE 9 Linux amd64-64 Compressed References 20171030_000000 (JIT enabled, AOT enabled)
+OpenJ9   - 731f323
+OMR      - 7c3d3d7
+OpenJDK  - 1983043 based on jdk-9+181)
+```
+:penguin: *Congratulations!* :tada:
+
+----------------------------------
+
+## AIX
+:blue_book:
+
+:construction:
+This section is still under construction. Further contributions expected.
+
+The following instructions guide you through the process of building an OpenJDK V9 binary that contains Eclipse OpenJ9 on AIX 7.2.
+
+### 1. Prepare your system
+:blue_book:
+You must install the following AIX Licensed Program Products (LPPs):
+
+- [Java8_64](https://adoptopenjdk.net/releases.html?variant=openjdk8#ppc64_aix)
+- [xlc/C++ 13.1.3](https://www.ibm.com/developerworks/downloads/r/xlcplusaix/)
+- x11.adt.ext
+
+A number of RPM packages are also required. The easiest method for installing these packages is to use `yum`, because `yum` takes care of any additional dependent packages for you.
+
+Download the following file: [yum_install_aix-ppc64.txt](aix/jdk9/yum_install_aix-ppc64.txt)
+
+This file contains a list of required RPM packages that you can install by specifying the following command:
+```
+yum shell yum_install_aix-ppc64.txt
+```
+
+It is important to take the list of package dependencies from this file because it is kept right up to date by our developers. However, if you want to understand the additional packages that `yum` installs, the list looks something like this:","Please remove this section - this will be stale the first time the `yum_install_aix-ppc64.txt` file is updated.  Also, we don't list the additional packages pulled in when doing an `apt-get` so we don't need to do this here either.",
73248573,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,True,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.","I did try to make this a link initially but gave up. The normal link notation for headers doesn't seem to work [Section title](#section-title), possibly because there is a ""2."" in there. I can continue to work on this later. Solution is probably to embed some HTML tags, although not terribly nice.",
73248616,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,True,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*",Removed.,
73248649,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,True,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.",Fixed - thanks.,
73248672,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,True,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following command:
+```
+ln -s g++ /usr/bin/c++ \
+  && ln -s g++-4.8 /usr/bin/g++ \
+  && ln -s gcc /usr/bin/cc \
+  && ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into the /root directory:",Agreed. I've made these changes.,
73248702,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,True,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following command:
+```
+ln -s g++ /usr/bin/c++ \
+  && ln -s g++-4.8 /usr/bin/g++ \
+  && ln -s gcc /usr/bin/cc \
+  && ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into the /root directory:
+```
+cd /root \
+  && wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz \
+  && tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2 \
+  && rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script.","This section was suggested by @mgaudet in issue 23 of the eclipse/openj9-website repo.  I don't know that there is a related issue, but perhaps Matthew can chip in?",
73248737,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,True,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following command:
+```
+ln -s g++ /usr/bin/c++ \
+  && ln -s g++-4.8 /usr/bin/g++ \
+  && ln -s gcc /usr/bin/cc \
+  && ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into the /root directory:
+```
+cd /root \
+  && wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz \
+  && tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2 \
+  && rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script.
+
+Two Java builds are produced: a full developer kit (jdk) and a runtime environment (jre)
+- **build/linux-x86_64-normal-server-release/images/jdk**
+- **build/linux-x86_64-normal-server-release/images/jre**
+
+    :whale: If you built your binaries in a Docker container, copy the binaries to the containers **/root/hostdir** directory so that you can access them on your local system. You'll find them in the directory you set for `<host_directory>` when you started your Docker container. See [Setting up your build environment with Docker](#setting-up-your-build-environment-with-docker).
+
+    :pencil: On other architectures the **/jdk** and **/jre** directories are in **build/linux-ppc64le-normal-server-release/images** (Linux on 64-bit Power systems) and **build/linux-s390x-normal-server-release/images** (Linux on 64-bit z Systems)
+
+### 5. Test
+:penguin:
+For a simple test, try running the `java -version` command.
+Change to the /jre directory:
+```
+cd build/linux-x86_64-normal-server-release/images/jre
+```
+Run:
+```
+./bin/java -version
+```
+
+Here is some sample output:
+
+```
+openjdk version ""9-internal""
+OpenJDK Runtime Environment (build 9-internal+0-adhoc.openj9-openjdk-jdk9)
+Eclipse OpenJ9 VM (build 2.9, JRE 9 Linux amd64-64 Compressed References 20171030_000000 (JIT enabled, AOT enabled)
+OpenJ9   - 731f323
+OMR      - 7c3d3d7
+OpenJDK  - 1983043 based on jdk-9+181)
+```
+:penguin: *Congratulations!* :tada:
+
+----------------------------------
+
+## AIX
+:blue_book:
+
+:construction:
+This section is still under construction. Further contributions expected.
+
+The following instructions guide you through the process of building an OpenJDK V9 binary that contains Eclipse OpenJ9 on AIX 7.2.
+
+### 1. Prepare your system
+:blue_book:
+You must install the following AIX Licensed Program Products (LPPs):
+
+- [Java8_64](https://adoptopenjdk.net/releases.html?variant=openjdk8#ppc64_aix)
+- [xlc/C++ 13.1.3](https://www.ibm.com/developerworks/downloads/r/xlcplusaix/)
+- x11.adt.ext
+
+A number of RPM packages are also required. The easiest method for installing these packages is to use `yum`, because `yum` takes care of any additional dependent packages for you.
+
+Download the following file: [yum_install_aix-ppc64.txt](aix/jdk9/yum_install_aix-ppc64.txt)
+
+This file contains a list of required RPM packages that you can install by specifying the following command:
+```
+yum shell yum_install_aix-ppc64.txt
+```
+
+It is important to take the list of package dependencies from this file because it is kept right up to date by our developers. However, if you want to understand the additional packages that `yum` installs, the list looks something like this:",Done,
73260897,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.","Use the following: `[Get the source](#2-get-the-source)` to link.

The rules for converting to a label are in https://stackoverflow.com/a/45508928/5029186",
73263616,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following command:
+```
+ln -s g++ /usr/bin/c++ \
+  && ln -s g++-4.8 /usr/bin/g++ \
+  && ln -s gcc /usr/bin/cc \
+  && ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into the /root directory:
+```
+cd /root \
+  && wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz \
+  && tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2 \
+  && rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script.",Issue is https://github.com/ibmruntimes/openj9-openjdk-jdk9/issues/34,
73419693,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,True,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the dependencies that can be obtained with the `apt-get` command. Copy
+and paste the following command section from the Dockerfile to your command prompt.
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+    ...
+    ...
+  && rm -rf /var/lib/apt/lists/*
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contain a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following command:
+```
+ln -s g++ /usr/bin/c++ \
+  && ln -s g++-4.8 /usr/bin/g++ \
+  && ln -s gcc /usr/bin/cc \
+  && ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into the /root directory:
+```
+cd /root \
+  && wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz \
+  && tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2 \
+  && rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script.",Thanks @mgaudet. Issue number added.,
73419814,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,True,"@@ -0,0 +1,375 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, **Get the source**.",Thanks for finding the solution @DanHeidinga. Link now added.,
73474009,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,322 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, [Get the source](#2-get-the-source).
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the list of dependencies that can be obtained with the `apt-get` command from the following section of the Dockerfile:
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contains a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following commands:
+```
+ln -s g++ /usr/bin/c++
+ln -s g++-4.8 /usr/bin/g++
+ln -s gcc /usr/bin/cc
+ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into a directory. The example commands use `/root` to be consistent with the Docker instructions. If you aren't
+using Docker, you probably want to store the **freemarker.jar** in your home directory.
+```
+cd /root
+wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script. For more information, read this [issue](ibmruntimes/openj9-openjdk-jdk9#34).","The issue link sent me to a ""page not found"" error page.  Did it work for you?",
73475341,a52f6df0c4433c35e10c8043739b7334e2cb4923,buildenv/Build_Instructions_V9.md,False,"@@ -0,0 +1,322 @@
+<!--
+Copyright (c) 2017, 2017 IBM Corp. and others
+
+This program and the accompanying materials are made available under
+the terms of the Eclipse Public License 2.0 which accompanies this
+distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+or the Apache License, Version 2.0 which accompanies this distribution and
+is available at https://www.apache.org/licenses/LICENSE-2.0.
+
+This Source Code is also Distributed under one or more Secondary Licenses,
+as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+General Public License, version 2 with the GNU Classpath Exception [1]
+and GNU General Public License, version 2 with the OpenJDK Assembly
+Exception [2].
+
+[1] https://www.gnu.org/software/classpath/license.html
+[2] http://openjdk.java.net/legal/assembly-exception.html
+-->
+
+Building OpenJDK Version 9 with OpenJ9
+======================================
+
+Our website describes a simple [build process](http://www.eclipse.org/openj9/oj9_build.html)
+that uses Docker and Dockerfiles to create a build environment that contains everything
+you need to easily build a Linux binary of OpenJDK V9 with the Eclipse OpenJ9 virtual machine.
+A more complete set of build instructions are included here for multiple platforms:
+
+- [Linux :penguin:](#linux)
+- [AIX :blue_book:](#aix)
+- [Windows :ledger:](#windows)
+- [MacOS :apple:](#macos)
+- [ARM :iphone:](#arm)
+
+
+----------------------------------
+
+## Linux
+:penguin:
+This build process provides detailed instructions for building a Linux x86-64 binary of OpenJDK V9 with OpenJ9 on Ubuntu 16.04. The binary can be built directly on your system, in a virtual
+machine, or in a Docker container :whale:.
+
+If you are using a different Linux distribution, you might have to review the list of libraries that are bundled with your distribution and/or modify the instructions to use equivalent commands to the Advanced Packaging Tool (APT). For example, for Centos, substitute the `apt-get` command with `yum`.
+
+If you want to build a binary for Linux on a different architecture, such as Power Systems&trade; or z Systems&trade;, the process is very similar and any additional information for those architectures are included as Notes :pencil: as we go along.
+
+
+### 1. Prepare your system
+:penguin:
+Instructions are provided for preparing your system with and without the use of Docker technology.
+
+Skip to [Setting up your build environment without Docker](#setting-up-your-build-environment-without-docker).
+
+#### Setting up your build environment with Docker :whale:
+If you want to build a binary by using a Docker container, follow these steps to prepare your system:
+
+1. The first thing you need to do is install Docker. You can download the free Community edition from [here](https://docs.docker.com/engine/installation/), which also contains instructions for installing Docker on your system.  You should also read the [Getting started](https://docs.docker.com/get-started/) guide to familiarise yourself with the basic Docker concepts and terminology.
+
+2. Obtain the [Linux on 64-bit x86 systems Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) to build and run a container that has all the correct software pre-requisites.
+
+    :pencil: Dockerfiles are also available for the following Linux architectures: [Linux on 64-bit Power systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on 64-bit z Systems&trade;](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile)
+
+    Either download one of these Dockerfiles to your local system or copy and paste one of the following commands:
+
+  - For Linux on 64-bit x86 systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit Power systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile
+```
+
+  - For Linux on 64-bit z Systems, run:
+```
+wget https://raw.githubusercontent.com/eclipse/openj9/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile
+```
+
+3. Next, run the following command to build a Docker image, called **openj9**:
+```
+docker build -t openj9 Dockerfile .
+```
+
+4. Start a Docker container from the **openj9** image with the following command, where `-v` maps any directory, `<host_directory>`,
+on your local system to the containers `/root/hostdir` directory so that you can store the binaries, once they are built:
+```
+docker run -v <host_directory>:/root/hostdir -it openj9
+```
+
+:pencil: Depending on your [Docker system configuration](https://docs.docker.com/engine/reference/commandline/cli/#description), you might need to prefix the `docker` commands with `sudo`.
+
+Now that you have the Docker image running, you are ready to move to the next step, [Get the source](#2-get-the-source).
+
+#### Setting up your build environment without Docker
+
+If you don't want to user Docker, you can still build an OpenJDK V9 with OpenJ9 directly on your Ubuntu system or in a Ubuntu virtual machine. Use the
+[Linux on x86 Dockerfile](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/x86_64/ubuntu16/Dockerfile) like a recipe card to determine the software dependencies
+that must be installed on the system, plus a few configuration steps.
+
+:pencil:
+Not on x86? We also have Dockerfiles for the following Linux architectures: [Linux on Power systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/ppc64le/ubuntu16/Dockerfile) and [Linux on z Systems](https://github.com/eclipse/openj9/blob/master/buildenv/docker/jdk9/s390x/ubuntu16/Dockerfile).
+
+
+1. Install the list of dependencies that can be obtained with the `apt-get` command from the following section of the Dockerfile:
+```
+apt-get update \
+  && apt-get install -qq -y --no-install-recommends \
+    autoconf \
+    ca-certificates \
+    ...
+    ...
+```
+
+:pencil: For Linux on z Systems, we specify the [IBM SDK for Java 8](https://developer.ibm.com/javasdk/downloads/sdk8/) in the Dockerfile rather than the `openjdk-8-jdk` package because the IBM version contains a JIT compiler that will significantly accelerate compile time.
+
+2. This build uses the same gcc and g++ compiler levels as OpenJDK, which might be
+backlevel compared with the versions you use on your system. Create links for
+the compilers with the following commands:
+```
+ln -s g++ /usr/bin/c++
+ln -s g++-4.8 /usr/bin/g++
+ln -s gcc /usr/bin/cc
+ln -s gcc-4.8 /usr/bin/gcc
+```
+
+3. Download and setup **freemarker.jar** into a directory. The example commands use `/root` to be consistent with the Docker instructions. If you aren't
+using Docker, you probably want to store the **freemarker.jar** in your home directory.
+```
+cd /root
+wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
+tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2
+rm -f freemarker.tgz
+```
+
+### 2. Get the source
+:penguin:
+First you need to clone the Extensions for OpenJDK for OpenJ9 project. This repository is a git mirror of OpenJDK without the HotSpot JVM, but with an **openj9** branch that contains a few necessary patches. Run the following command:
+```
+git clone https://github.com/ibmruntimes/openj9-openjdk-jdk9
+```
+Cloning this repository can take a while because OpenJDK is a large project! When the process is complete, change directory into the cloned repository:
+```
+cd openj9-openjdk-jdk9
+```
+Now fetch additional sources from the Eclipse OpenJ9 project and its clone of Eclipse OMR:
+```
+bash ./get_source.sh
+```
+
+### 3. Configure
+:penguin:
+When you have all the source files that you need, run the configure script, which detects how to build in the current build environment.
+```
+bash ./configure --with-freemarker-jar=/root/freemarker.jar
+```
+:warning: You must give an absolute path to freemarker.jar
+
+### 4. Build
+:penguin:
+Now you're ready to build OpenJDK V9 with OpenJ9:
+```
+make all
+```
+:warning: If you just type `make`, rather than `make all` your build will fail, because the default `make` target is `exploded-image`. If you want to specify `make` instead of `make all`, you must add `--default-make-target=images` when you run the configure script. For more information, read this [issue](ibmruntimes/openj9-openjdk-jdk9#34).","Right -- the link has to be `https://github.com/ibmruntimes/openj9-openjdk-jdk9/issues/34` 

(Github collapses internal links into identifiers that are easier to read, but do not function within markdown documents)",
73576937,fceee51a2fca10a229974d358ae1c33fac55ddb6,test/TestConfig/extraSettings,False,"@@ -48,34 +48,30 @@ ifneq (,$(findstring cmprssptrs,$(SPEC)))
 VM_SUBDIR=compressedrefs
 endif
 
-ifneq (,$(findstring win,$(SPEC)))
-JAVA_SHARED_LIBRARIES_DIR:=$(JAVA_BIN)$(D)$(VM_SUBDIR)
-ADD_JVM_LIB_DIR_TO_LIBPATH:=export LIBPATH=$(Q)$(JAVA_SHARED_LIBRARIES_DIR)$(P)$(JAVA_BIN)$(D)j9vm$(P)$(LIBPATH)$(Q);
-else ifneq (,$(findstring le,$(SPEC)))
-JAVA_SHARED_LIBRARIES_DIR:=$(JAVA_LIB_DIR)$(D)ppc64le$(D)$(VM_SUBDIR)
-ADD_JVM_LIB_DIR_TO_LIBPATH:=export LIBPATH=$(Q)$(JAVA_SHARED_LIBRARIES_DIR)$(P)$(JAVA_BIN)$(D)j9vm$(P)$(LIBPATH)$(Q);
+ifneq (,$(findstring le,$(SPEC)))
+ARCH_DIR=ppc64le",should we use `ppc-64_le` instead of `le`?,
73591758,fceee51a2fca10a229974d358ae1c33fac55ddb6,test/TestConfig/extraSettings,False,"@@ -48,34 +48,30 @@ ifneq (,$(findstring cmprssptrs,$(SPEC)))
 VM_SUBDIR=compressedrefs
 endif
 
-ifneq (,$(findstring win,$(SPEC)))
-JAVA_SHARED_LIBRARIES_DIR:=$(JAVA_BIN)$(D)$(VM_SUBDIR)
-ADD_JVM_LIB_DIR_TO_LIBPATH:=export LIBPATH=$(Q)$(JAVA_SHARED_LIBRARIES_DIR)$(P)$(JAVA_BIN)$(D)j9vm$(P)$(LIBPATH)$(Q);
-else ifneq (,$(findstring le,$(SPEC)))
-JAVA_SHARED_LIBRARIES_DIR:=$(JAVA_LIB_DIR)$(D)ppc64le$(D)$(VM_SUBDIR)
-ADD_JVM_LIB_DIR_TO_LIBPATH:=export LIBPATH=$(Q)$(JAVA_SHARED_LIBRARIES_DIR)$(P)$(JAVA_BIN)$(D)j9vm$(P)$(LIBPATH)$(Q);
+ifneq (,$(findstring le,$(SPEC)))
+ARCH_DIR=ppc64le","Ignore my comment, I forget compressref case.",
70342609,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,False,"@@ -553,6 +553,18 @@ static int J9THREAD_PROC FinalizeSlaveThread(void *arg)
 
 fns->internalEnterVMFromJNI(env);
 
+#if defined(J9VM_GC_DYNAMIC_CLASS_UNLOADING)
+if(slaveData->mode != FINALIZE_SLAVE_MODE_CL_UNLOAD) {","you can move opening ""{"" down outside ""if defined"". With this you can avoid ""if defined"" on closing bracket.",
70343425,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,False,"@@ -869,6 +898,23 @@ int j9gc_finalizer_startup(J9JavaVM * vm)
 }
 
 /**
+ *
+ */
+UDATA j9gc_wait_for_reference_processing(J9JavaVM * vm)",please remove extra space (J9JavaVM *vm),
70344058,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/jcl/common/java_lang_ref_Reference.cpp,False,"@@ -54,4 +54,22 @@ Java_java_lang_ref_Reference_reprocess(JNIEnv *env, jobject recv)
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Java_java_lang_ref_Reference_waitForReferenceProcessingImpl(JNIEnv *env, jclass recv)
+{
+#if defined(J9VM_GC_FINALIZATION)
+J9VMThread* currentThread = (J9VMThread*)env;",J9VMThread *currentThread,
70344194,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/jcl/common/java_lang_ref_Reference.cpp,False,"@@ -54,4 +54,22 @@ Java_java_lang_ref_Reference_reprocess(JNIEnv *env, jobject recv)
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Java_java_lang_ref_Reference_waitForReferenceProcessingImpl(JNIEnv *env, jclass recv)
+{
+#if defined(J9VM_GC_FINALIZATION)
+J9VMThread* currentThread = (J9VMThread*)env;
+J9JavaVM* vm = currentThread->javaVM;",J9JavaVM *vm,
70344372,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/jcl/common/java_lang_ref_Reference.cpp,False,"@@ -54,4 +54,22 @@ Java_java_lang_ref_Reference_reprocess(JNIEnv *env, jobject recv)
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Java_java_lang_ref_Reference_waitForReferenceProcessingImpl(JNIEnv *env, jclass recv)
+{
+#if defined(J9VM_GC_FINALIZATION)
+J9VMThread* currentThread = (J9VMThread*)env;
+J9JavaVM* vm = currentThread->javaVM;
+J9MemoryManagerFunctions* mmFuncs = vm->memoryManagerFunctions;",J9MemoryManagerFunctions *mmFuncs,
70347665,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/vm/vmthinit.c,False,"@@ -80,6 +82,13 @@ UDATA initializeVMThreading(J9JavaVM *vm)
 initializeMonitorTable(vm)
 )
 {
+#ifdef J9VM_GC_FINALIZATION
+/* processReferenceMonitor is only used for Java 9 and later */",Monitor should be initialized for Java 9 only. Destroying it for java 8 looks ugly,
72341306,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/jcl/common/java_lang_ref_Reference.cpp,False,"@@ -54,4 +54,22 @@ Java_java_lang_ref_Reference_reprocess(JNIEnv *env, jobject recv)
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Java_java_lang_ref_Reference_waitForReferenceProcessingImpl(JNIEnv *env, jclass recv)
+{
+#if defined(J9VM_GC_FINALIZATION)
+J9VMThread *currentThread = (J9VMThread*)env;",Note this variable isn't really needed.,
72342164,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,False,"@@ -869,6 +887,23 @@ int j9gc_finalizer_startup(J9JavaVM * vm)
 }
 
 /**
+ * check if processing reference is active",Please document parameters and the return value.,
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,jcl/src/java.base/share/classes/java/lang/ref/Reference.java,False,"@@ -50,10 +50,13 @@
 static {
 SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
 public boolean waitForReferenceProcessing() throws InterruptedException {
-return false;
+return waitForReferenceProcessingImpl();
 }
 });
 }
+
+static private native boolean waitForReferenceProcessingImpl();",Can you add javadoc to this function?,
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,False,"@@ -553,6 +553,17 @@ static int J9THREAD_PROC FinalizeSlaveThread(void *arg)
 
 fns->internalEnterVMFromJNI(env);
 
+#if defined(J9VM_GC_DYNAMIC_CLASS_UNLOADING)
+if(slaveData->mode != FINALIZE_SLAVE_MODE_CL_UNLOAD)
+#endif /* J9VM_GC_DYNAMIC_CLASS_UNLOADING */
+{
+if (vm->processReferenceMonitor && (0 != finalizeListManager->getReferenceCount())) {",Can you explicitly test for null? i.e. `if ((NULL != vm->processReferenceMonitor) && (0 != ....)`,
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,False,"@@ -592,9 +603,17 @@ static int J9THREAD_PROC FinalizeSlaveThread(void *arg)
 }
 #endif /* J9VM_GC_DYNAMIC_CLASS_UNLOADING */
 
-// processing will release/acquire VM access
+/* processing will release/acquire VM access */
 process(env, finalizeJob, j9VMInternalsClass, runFinalizeMID, referenceEnqueueImplMID);
 
+if (vm->processReferenceMonitor && (0 != vm->processReferenceActive)) {",Same comment for the null check on `vm->processReferenceMonitor`,
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,False,"@@ -592,9 +603,17 @@ static int J9THREAD_PROC FinalizeSlaveThread(void *arg)
 }
 #endif /* J9VM_GC_DYNAMIC_CLASS_UNLOADING */
 
-// processing will release/acquire VM access
+/* processing will release/acquire VM access */
 process(env, finalizeJob, j9VMInternalsClass, runFinalizeMID, referenceEnqueueImplMID);
 
+if (vm->processReferenceMonitor && (0 != vm->processReferenceActive)) {
+omrthread_monitor_enter(vm->processReferenceMonitor);
+if (0 == finalizeListManager->getReferenceCount()) {
+vm->processReferenceActive = 0;
+}
+omrthread_monitor_notify_all(vm->processReferenceMonitor);",Can you add a comment here to describe why this is the correct behaviour?,
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,False,"@@ -869,6 +887,23 @@ int j9gc_finalizer_startup(J9JavaVM * vm)
 }
 
 /**
+ * check if processing reference is active",Nitpick: `check` -> `Check`,
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,False,"@@ -869,6 +887,26 @@ int j9gc_finalizer_startup(J9JavaVM * vm)
 }
 
 /**
+ * check if processing reference is active
+ *
+ * @param vm  Pointer to the Java VM
+ * @return 1 if processing reference is active, otherwise return 0.
+ */
+UDATA j9gc_wait_for_reference_processing(J9JavaVM *vm)
+{
+UDATA ret = 0;
+if (vm->processReferenceMonitor) {",Please explicitly test for null,
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/jcl/common/java_lang_ref_Reference.cpp,False,"@@ -54,4 +54,21 @@ Java_java_lang_ref_Reference_reprocess(JNIEnv *env, jobject recv)
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Java_java_lang_ref_Reference_waitForReferenceProcessingImpl(JNIEnv *env, jclass recv)
+{","Can you write this with a single return point - i.e.:
```
 + jboolean result = JNI_FALSE;
 + #if defined(J9VM_GC_FINALIZATION)
 +J9JavaVM *vm = ((J9VMThread*)env)->javaVM;
 +J9MemoryManagerFunctions *mmFuncs = vm->memoryManagerFunctions;
 +if (0 != mmFuncs->j9gc_wait_for_reference_processing(vm)) {
 +result = JNI_TRUE;
 +}
 +#endif
 +  return result;
 +}
```",
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/vm/FastJNI_java_lang_ref_Reference.cpp,False,"@@ -51,12 +51,33 @@ Fast_java_lang_ref_Reference_reprocess(J9VMThread *currentThread, j9object_t rec
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl(J9VMThread *currentThread, j9object_t classObject)
+{",Can you modify this to be a single return point as well?,
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/vm/FastJNI_java_lang_ref_Reference.cpp,False,"@@ -51,12 +51,33 @@ Fast_java_lang_ref_Reference_reprocess(J9VMThread *currentThread, j9object_t rec
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl(J9VMThread *currentThread, j9object_t classObject)",Is this performance critical?  Does it need to be a fast JNI method?,
73209185,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/vm/FastJNI_java_lang_ref_Reference.cpp,False,"@@ -51,12 +51,33 @@ Fast_java_lang_ref_Reference_reprocess(J9VMThread *currentThread, j9object_t rec
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl(J9VMThread *currentThread, j9object_t classObject)
+{
+#if defined(J9VM_GC_FINALIZATION)
+J9JavaVM *javaVM = currentThread->javaVM;
+J9MemoryManagerFunctions *mmFuncs = javaVM->memoryManagerFunctions;
+if (0 == mmFuncs->j9gc_wait_for_reference_processing(javaVM)) {
+return JNI_FALSE;
+} else {
+return JNI_TRUE;
+}
+#else
+return JNI_FALSE;
+#endif
+}
+
+
 J9_FAST_JNI_METHOD_TABLE(java_lang_ref_Reference)
 J9_FAST_JNI_METHOD(""getImpl"", ""()Ljava/lang/Object;"", Fast_java_lang_ref_Reference_getImpl,
 J9_FAST_JNI_RETAIN_VM_ACCESS | J9_FAST_JNI_NOT_GC_POINT | J9_FAST_JNI_NO_NATIVE_METHOD_FRAME | J9_FAST_JNI_NO_EXCEPTION_THROW |
 J9_FAST_JNI_NO_SPECIAL_TEAR_DOWN | J9_FAST_JNI_DO_NOT_WRAP_OBJECTS)
 J9_FAST_JNI_METHOD(""reprocess"", ""()V"", Fast_java_lang_ref_Reference_reprocess,
 J9_FAST_JNI_RETAIN_VM_ACCESS | J9_FAST_JNI_NOT_GC_POINT | J9_FAST_JNI_NO_NATIVE_METHOD_FRAME | J9_FAST_JNI_NO_EXCEPTION_THROW |
 J9_FAST_JNI_NO_SPECIAL_TEAR_DOWN | J9_FAST_JNI_DO_NOT_WRAP_OBJECTS)
+J9_FAST_JNI_METHOD(""waitForReferenceProcessingImpl"", ""()Z"", Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl,
+J9_FAST_JNI_RETAIN_VM_ACCESS | J9_FAST_JNI_NOT_GC_POINT | J9_FAST_JNI_NO_NATIVE_METHOD_FRAME | J9_FAST_JNI_NO_EXCEPTION_THROW |","Does this ever need to wait for a GC to complete?  If so, we can deadlock as this method doesn't give up vm access",
73275153,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/vm/FastJNI_java_lang_ref_Reference.cpp,True,"@@ -51,12 +51,33 @@ Fast_java_lang_ref_Reference_reprocess(J9VMThread *currentThread, j9object_t rec
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl(J9VMThread *currentThread, j9object_t classObject)
+{
+#if defined(J9VM_GC_FINALIZATION)
+J9JavaVM *javaVM = currentThread->javaVM;
+J9MemoryManagerFunctions *mmFuncs = javaVM->memoryManagerFunctions;
+if (0 == mmFuncs->j9gc_wait_for_reference_processing(javaVM)) {
+return JNI_FALSE;
+} else {
+return JNI_TRUE;
+}
+#else
+return JNI_FALSE;
+#endif
+}
+
+
 J9_FAST_JNI_METHOD_TABLE(java_lang_ref_Reference)
 J9_FAST_JNI_METHOD(""getImpl"", ""()Ljava/lang/Object;"", Fast_java_lang_ref_Reference_getImpl,
 J9_FAST_JNI_RETAIN_VM_ACCESS | J9_FAST_JNI_NOT_GC_POINT | J9_FAST_JNI_NO_NATIVE_METHOD_FRAME | J9_FAST_JNI_NO_EXCEPTION_THROW |
 J9_FAST_JNI_NO_SPECIAL_TEAR_DOWN | J9_FAST_JNI_DO_NOT_WRAP_OBJECTS)
 J9_FAST_JNI_METHOD(""reprocess"", ""()V"", Fast_java_lang_ref_Reference_reprocess,
 J9_FAST_JNI_RETAIN_VM_ACCESS | J9_FAST_JNI_NOT_GC_POINT | J9_FAST_JNI_NO_NATIVE_METHOD_FRAME | J9_FAST_JNI_NO_EXCEPTION_THROW |
 J9_FAST_JNI_NO_SPECIAL_TEAR_DOWN | J9_FAST_JNI_DO_NOT_WRAP_OBJECTS)
+J9_FAST_JNI_METHOD(""waitForReferenceProcessingImpl"", ""()Z"", Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl,
+J9_FAST_JNI_RETAIN_VM_ACCESS | J9_FAST_JNI_NOT_GC_POINT | J9_FAST_JNI_NO_NATIVE_METHOD_FRAME | J9_FAST_JNI_NO_EXCEPTION_THROW |","no, it only waits for processing one reference in slave finalization thread(outside GC cycle), if currently the thread is clearing the reference.",
73277653,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/vm/FastJNI_java_lang_ref_Reference.cpp,True,"@@ -51,12 +51,33 @@ Fast_java_lang_ref_Reference_reprocess(J9VMThread *currentThread, j9object_t rec
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl(J9VMThread *currentThread, j9object_t classObject)","Currently it only is called in nio.Bits.reserveMemory() for java9, but it could be called from 10 times to the maximum as many as the pending reference number in the reference queue if currently the processing references is active. ",
73279971,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/vm/FastJNI_java_lang_ref_Reference.cpp,True,"@@ -51,12 +51,33 @@ Fast_java_lang_ref_Reference_reprocess(J9VMThread *currentThread, j9object_t rec
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl(J9VMThread *currentThread, j9object_t classObject)
+{",updated,
73280080,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/jcl/common/java_lang_ref_Reference.cpp,True,"@@ -54,4 +54,21 @@ Java_java_lang_ref_Reference_reprocess(JNIEnv *env, jobject recv)
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Java_java_lang_ref_Reference_waitForReferenceProcessingImpl(JNIEnv *env, jclass recv)
+{",updated,
73280152,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,True,"@@ -869,6 +887,26 @@ int j9gc_finalizer_startup(J9JavaVM * vm)
 }
 
 /**
+ * check if processing reference is active
+ *
+ * @param vm  Pointer to the Java VM
+ * @return 1 if processing reference is active, otherwise return 0.
+ */
+UDATA j9gc_wait_for_reference_processing(J9JavaVM *vm)
+{
+UDATA ret = 0;
+if (vm->processReferenceMonitor) {",updated,
73280255,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,True,"@@ -592,9 +603,17 @@ static int J9THREAD_PROC FinalizeSlaveThread(void *arg)
 }
 #endif /* J9VM_GC_DYNAMIC_CLASS_UNLOADING */
 
-// processing will release/acquire VM access
+/* processing will release/acquire VM access */
 process(env, finalizeJob, j9VMInternalsClass, runFinalizeMID, referenceEnqueueImplMID);
 
+if (vm->processReferenceMonitor && (0 != vm->processReferenceActive)) {
+omrthread_monitor_enter(vm->processReferenceMonitor);
+if (0 == finalizeListManager->getReferenceCount()) {
+vm->processReferenceActive = 0;
+}
+omrthread_monitor_notify_all(vm->processReferenceMonitor);",updated,
73280352,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,True,"@@ -592,9 +603,17 @@ static int J9THREAD_PROC FinalizeSlaveThread(void *arg)
 }
 #endif /* J9VM_GC_DYNAMIC_CLASS_UNLOADING */
 
-// processing will release/acquire VM access
+/* processing will release/acquire VM access */
 process(env, finalizeJob, j9VMInternalsClass, runFinalizeMID, referenceEnqueueImplMID);
 
+if (vm->processReferenceMonitor && (0 != vm->processReferenceActive)) {",updated,
73280383,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,True,"@@ -553,6 +553,17 @@ static int J9THREAD_PROC FinalizeSlaveThread(void *arg)
 
 fns->internalEnterVMFromJNI(env);
 
+#if defined(J9VM_GC_DYNAMIC_CLASS_UNLOADING)
+if(slaveData->mode != FINALIZE_SLAVE_MODE_CL_UNLOAD)
+#endif /* J9VM_GC_DYNAMIC_CLASS_UNLOADING */
+{
+if (vm->processReferenceMonitor && (0 != finalizeListManager->getReferenceCount())) {",updated,
73280443,c6aed54d86da1f3418ac7429338d857af99422b5,jcl/src/java.base/share/classes/java/lang/ref/Reference.java,True,"@@ -50,10 +50,13 @@
 static {
 SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
 public boolean waitForReferenceProcessing() throws InterruptedException {
-return false;
+return waitForReferenceProcessingImpl();
 }
 });
 }
+
+static private native boolean waitForReferenceProcessingImpl();",updated,
73287728,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/vm/FastJNI_java_lang_ref_Reference.cpp,True,"@@ -51,12 +51,33 @@ Fast_java_lang_ref_Reference_reprocess(J9VMThread *currentThread, j9object_t rec
 }
 }
 
+/* java.lang.ref.Reference: static private native boolean waitForReferenceProcessingImpl(); */
+jboolean JNICALL
+Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl(J9VMThread *currentThread, j9object_t classObject)
+{
+#if defined(J9VM_GC_FINALIZATION)
+J9JavaVM *javaVM = currentThread->javaVM;
+J9MemoryManagerFunctions *mmFuncs = javaVM->memoryManagerFunctions;
+if (0 == mmFuncs->j9gc_wait_for_reference_processing(javaVM)) {
+return JNI_FALSE;
+} else {
+return JNI_TRUE;
+}
+#else
+return JNI_FALSE;
+#endif
+}
+
+
 J9_FAST_JNI_METHOD_TABLE(java_lang_ref_Reference)
 J9_FAST_JNI_METHOD(""getImpl"", ""()Ljava/lang/Object;"", Fast_java_lang_ref_Reference_getImpl,
 J9_FAST_JNI_RETAIN_VM_ACCESS | J9_FAST_JNI_NOT_GC_POINT | J9_FAST_JNI_NO_NATIVE_METHOD_FRAME | J9_FAST_JNI_NO_EXCEPTION_THROW |
 J9_FAST_JNI_NO_SPECIAL_TEAR_DOWN | J9_FAST_JNI_DO_NOT_WRAP_OBJECTS)
 J9_FAST_JNI_METHOD(""reprocess"", ""()V"", Fast_java_lang_ref_Reference_reprocess,
 J9_FAST_JNI_RETAIN_VM_ACCESS | J9_FAST_JNI_NOT_GC_POINT | J9_FAST_JNI_NO_NATIVE_METHOD_FRAME | J9_FAST_JNI_NO_EXCEPTION_THROW |
 J9_FAST_JNI_NO_SPECIAL_TEAR_DOWN | J9_FAST_JNI_DO_NOT_WRAP_OBJECTS)
+J9_FAST_JNI_METHOD(""waitForReferenceProcessingImpl"", ""()Z"", Fast_java_lang_ref_Reference_waitForReferenceProcessingImpl,
+J9_FAST_JNI_RETAIN_VM_ACCESS | J9_FAST_JNI_NOT_GC_POINT | J9_FAST_JNI_NO_NATIVE_METHOD_FRAME | J9_FAST_JNI_NO_EXCEPTION_THROW |","can not 100% guarantee that the reference processing does not trigger the GC, so remove Fast JNI for waitForReferenceProcessingImpl",
73491348,c6aed54d86da1f3418ac7429338d857af99422b5,runtime/gc_base/FinalizerSupport.cpp,False,"@@ -592,9 +603,23 @@ static int J9THREAD_PROC FinalizeSlaveThread(void *arg)
 }
 #endif /* J9VM_GC_DYNAMIC_CLASS_UNLOADING */
 
-// processing will release/acquire VM access
+/* processing will release/acquire VM access */
 process(env, finalizeJob, j9VMInternalsClass, runFinalizeMID, referenceEnqueueImplMID);
 
+if ((NULL != vm->processReferenceMonitor) && (0 != vm->processReferenceActive)) {
+omrthread_monitor_enter(vm->processReferenceMonitor);
+if (0 == finalizeListManager->getReferenceCount()) {
+/* There is no more pending reference. */
+vm->processReferenceActive = 0;
+}
+                /*",This comment mixes tabs and space together.  Can you replace the spaces with tabs so the formatting is consistent?,
73825643,15a8dfa69c801810686b8862366f7daa2eccb1a9,jcl/src/java.base/share/classes/java/lang/StackWalker.java,False,"@@ -181,7 +182,11 @@ public void forEach(Consumer<? super StackFrame> action) {
 s -> s.limit(2).collect(Collectors.toList()));
 if (result.size() < 2) {
 /*[MSG ""K0640"", ""getCallerClass() called from method with no caller""]*/
+/*[IF Sidecar19-SE-B165]
+throw new IllegalCallerException(com.ibm.oti.util.Msg.getString(""K0640"")); //$NON-NLS-1$
+/*[ELSE]*/
 throw new IllegalStateException(com.ibm.oti.util.Msg.getString(""K0640"")); //$NON-NLS-1$",Why do we need to retain this old behavior?,
73828614,15a8dfa69c801810686b8862366f7daa2eccb1a9,jcl/src/java.base/share/classes/java/lang/StackWalker.java,True,"@@ -181,7 +182,11 @@ public void forEach(Consumer<? super StackFrame> action) {
 s -> s.limit(2).collect(Collectors.toList()));
 if (result.size() < 2) {
 /*[MSG ""K0640"", ""getCallerClass() called from method with no caller""]*/
+/*[IF Sidecar19-SE-B165]
+throw new IllegalCallerException(com.ibm.oti.util.Msg.getString(""K0640"")); //$NON-NLS-1$
+/*[ELSE]*/
 throw new IllegalStateException(com.ibm.oti.util.Msg.getString(""K0640"")); //$NON-NLS-1$",Build 148 (i.e. vmfarm builds) doesn't have the new exception.,
73969334,e350b418e53d32dca99311c6f5346056fc1acfd5,runtime/tr.source/trj9/codegen/J9CodeGenerator.cpp,False,"@@ -4616,3 +4616,33 @@ J9::CodeGenerator::needRelocationsForStatics()
    {
    return self()->fej9()->needRelocationsForStatics();
    }
+
+
+bool
+J9::CodeGenerator::isMethodInAtomicLongGroup(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::java_util_concurrent_atomic_AtomicLong_addAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_addAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_decrementAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_getAndAdd:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_getAndDecrement:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_getAndIncrement:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_getAndSet:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_incrementAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLong_decrementAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLong_getAndAdd:
+      case TR::java_util_concurrent_atomic_AtomicLong_getAndDecrement:
+      case TR::java_util_concurrent_atomic_AtomicLong_getAndIncrement:
+      case TR::java_util_concurrent_atomic_AtomicLong_getAndSet:
+      case TR::java_util_concurrent_atomic_AtomicLong_incrementAndGet:
+         return true;
+
+      default:
+         return false;
+      }
+
+   return false;",This return seems redundant.,
74069831,e350b418e53d32dca99311c6f5346056fc1acfd5,runtime/tr.source/trj9/codegen/J9CodeGenerator.cpp,True,"@@ -4616,3 +4616,33 @@ J9::CodeGenerator::needRelocationsForStatics()
    {
    return self()->fej9()->needRelocationsForStatics();
    }
+
+
+bool
+J9::CodeGenerator::isMethodInAtomicLongGroup(TR::RecognizedMethod rm)
+   {
+   switch (rm)
+      {
+      case TR::java_util_concurrent_atomic_AtomicLong_addAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_addAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_decrementAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_getAndAdd:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_getAndDecrement:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_getAndIncrement:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_getAndSet:
+      case TR::java_util_concurrent_atomic_AtomicLongArray_incrementAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLong_decrementAndGet:
+      case TR::java_util_concurrent_atomic_AtomicLong_getAndAdd:
+      case TR::java_util_concurrent_atomic_AtomicLong_getAndDecrement:
+      case TR::java_util_concurrent_atomic_AtomicLong_getAndIncrement:
+      case TR::java_util_concurrent_atomic_AtomicLong_getAndSet:
+      case TR::java_util_concurrent_atomic_AtomicLong_incrementAndGet:
+         return true;
+
+      default:
+         return false;
+      }
+
+   return false;",Agreed.  Fixed.,
74143399,2078d4187388f47250070e42775f227b40c85c9a,test/Java8andUp/src/org/openj9/test/support/Support_Exec.java,False,"@@ -153,7 +153,7 @@ public static void checkStderr(Object[] execArgs) {
 execArgs = new String[baseArgsArray.length + args.length];
 System.arraycopy(baseArgsArray, 0, execArgs, 0,
 baseArgsArray.length);
-} else if (vendor.indexOf(""IBM"") != -1) {
+} else if (vendor.indexOf(""IBM"") != -1 || vendor.indexOf(""OpenJ9"") != -1) {
 String full = System.getProperty(""java.fullversion"");
 logger.debug(""***"" + full + ""***"");",would also change logger.debug to logger.info - as that information is useful to print to console (where INFO level is our default),
74145538,2078d4187388f47250070e42775f227b40c85c9a,test/Java8andUp/src/org/openj9/test/support/Support_Exec.java,True,"@@ -153,7 +153,7 @@ public static void checkStderr(Object[] execArgs) {
 execArgs = new String[baseArgsArray.length + args.length];
 System.arraycopy(baseArgsArray, 0, execArgs, 0,
 baseArgsArray.length);
-} else if (vendor.indexOf(""IBM"") != -1) {
+} else if (vendor.indexOf(""IBM"") != -1 || vendor.indexOf(""OpenJ9"") != -1) {
 String full = System.getProperty(""java.fullversion"");
 logger.debug(""***"" + full + ""***"");","ok will add that
",
73835322,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src/org/openj9/test/reflect/GetMethodsTests.java,False,"@@ -73,6 +75,15 @@ public void testGetMethods() {
 
 }
 
+private static String concatenateStrings(String message, Iterable<String> stringList) {
+StringBuilder nameBuffer = new StringBuilder(message);
+for (String s: stringList) {
+nameBuffer.append(""\n""); //$NON-NLS-1$",Using \t would be better.,
73835603,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src/org/openj9/test/reflect/GetMethodsTests.java,False,"@@ -99,36 +110,35 @@ private static String methToString(Method m) {
 return methName.toString();
 }
 
-HashMap<String, String[]> methodLists = new HashMap<>();
-
 static HashMap<String, String[]> makeMethodLists() {
-HashMap<String, String[]> methodLists = new HashMap<>();
-methodLists.put(""org.openj9.test.reflect.C_CSuperA_SuperDuper"", concatenateObjectMethods(new String[] {
+/* 
+ * Class.getMethods() erroneously included methods in superinterfaces which are
+ * overridden in subinterfaces.  This has been corrected in Java 9.
+ */
+String[] methodList_C_I_SupDuperSupA = isJava8? new String[] {
 ""org.openj9.test.reflect.SuperA.abstractInSuperA_abstractInSuperDuper()void"",
 ""org.openj9.test.reflect.SuperA.abstractInSuperA_defaultInSuperDuper()void"",
 ""org.openj9.test.reflect.SuperA.defaultInSuperA_abstractInSuperDuper()void"",
 ""org.openj9.test.reflect.SuperA.defaultInSuperA_defaultInSuperDuper()void"",
+/* include these because of a known issue in Java 8 */",What known issue?,
73836291,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src_90/org/openj9/test/java/lang/Test_Class.java,False,"@@ -299,10 +299,10 @@ public void test_getMethods_subtest1() {
 AssertJUnit.assertTrue(""Expected method "" + expected_IC[i] + "" not found."", match);
 }
 
+/* ask of Java 9, IC.method_L() masks IA.method_L() */","typo ""ask""",
73836347,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src_90/org/openj9/test/java/lang/Test_Class.java,False,"@@ -317,8 +317,8 @@ public void test_getMethods_subtest1() {
 AssertJUnit.assertTrue(""Expected method "" + expected_CD[i] + "" not found."", match);
 }
 
+/* ask of Java 9, IC.method_L() masks IA.method_L() */","typo ""ask""",
73837224,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src/org/openj9/test/reflect/GetMethodsTests.java,False,"@@ -37,8 +37,8 @@
 import java.util.List;
 
 public class GetMethodsTests {
-
 public static final Logger logger = Logger.getLogger(GetMethodsTests.class);
+private final static boolean isJava8 = System.getProperty(""java.specification.version"").equals(""8"");  //$NON-NLS-1$//$NON-NLS-2$","This test doesn't work, the java.specification.version is ""1.8""",
73854582,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src/org/openj9/test/reflect/GetMethodsTests.java,True,"@@ -73,6 +75,15 @@ public void testGetMethods() {
 
 }
 
+private static String concatenateStrings(String message, Iterable<String> stringList) {
+StringBuilder nameBuffer = new StringBuilder(message);
+for (String s: stringList) {
+nameBuffer.append(""\n""); //$NON-NLS-1$",Fixed,
73854631,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src/org/openj9/test/reflect/GetMethodsTests.java,True,"@@ -99,36 +110,35 @@ private static String methToString(Method m) {
 return methName.toString();
 }
 
-HashMap<String, String[]> methodLists = new HashMap<>();
-
 static HashMap<String, String[]> makeMethodLists() {
-HashMap<String, String[]> methodLists = new HashMap<>();
-methodLists.put(""org.openj9.test.reflect.C_CSuperA_SuperDuper"", concatenateObjectMethods(new String[] {
+/* 
+ * Class.getMethods() erroneously included methods in superinterfaces which are
+ * overridden in subinterfaces.  This has been corrected in Java 9.
+ */
+String[] methodList_C_I_SupDuperSupA = isJava8? new String[] {
 ""org.openj9.test.reflect.SuperA.abstractInSuperA_abstractInSuperDuper()void"",
 ""org.openj9.test.reflect.SuperA.abstractInSuperA_defaultInSuperDuper()void"",
 ""org.openj9.test.reflect.SuperA.defaultInSuperA_abstractInSuperDuper()void"",
 ""org.openj9.test.reflect.SuperA.defaultInSuperA_defaultInSuperDuper()void"",
+/* include these because of a known issue in Java 8 */",Updated comment.,
73855191,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src_90/org/openj9/test/java/lang/Test_Class.java,True,"@@ -299,10 +299,10 @@ public void test_getMethods_subtest1() {
 AssertJUnit.assertTrue(""Expected method "" + expected_IC[i] + "" not found."", match);
 }
 
+/* ask of Java 9, IC.method_L() masks IA.method_L() */",Fixed.,
73855477,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src_90/org/openj9/test/java/lang/Test_Class.java,True,"@@ -317,8 +317,8 @@ public void test_getMethods_subtest1() {
 AssertJUnit.assertTrue(""Expected method "" + expected_CD[i] + "" not found."", match);
 }
 
+/* ask of Java 9, IC.method_L() masks IA.method_L() */",Fixed.,
73855528,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/src/org/openj9/test/reflect/GetMethodsTests.java,True,"@@ -37,8 +37,8 @@
 import java.util.List;
 
 public class GetMethodsTests {
-
 public static final Logger logger = Logger.getLogger(GetMethodsTests.class);
+private final static boolean isJava8 = System.getProperty(""java.specification.version"").equals(""8"");  //$NON-NLS-1$//$NON-NLS-2$",Fixed.,
74163281,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/playlist.xml,False,"@@ -1256,7 +1256,7 @@
 -excludegroups $(DEFAULT_EXCLUDE); \
 $(TEST_STATUS)</command>
 <tags>
-<tag>extended</tag>
+<tag>sanity</tag>","To run testNG test in sanity, we need to update the test group annotation in java as well. `@Test(groups = { ""level.sanity"" })`",
74465342,80dbfd9e18f33ce4bb587afa9e247449280c4f80,test/Java8andUp/playlist.xml,True,"@@ -1256,7 +1256,7 @@
 -excludegroups $(DEFAULT_EXCLUDE); \
 $(TEST_STATUS)</command>
 <tags>
-<tag>extended</tag>
+<tag>sanity</tag>",Thanks.  Fixed.,
69050908,182899fe18fb2bf1e631f66800f6159500e5fb3d,test/Java8andUp/playlist.xml,False,"@@ -1532,5 +1532,25 @@
 <subset>SE90</subset>
 </subsets>
 </test>
+<test>
+<featureIds>
+<featureId>134091</featureId>","Is this ID an internal bug #?  If so, please replace it with an id that's meaningful in the open",
69050994,182899fe18fb2bf1e631f66800f6159500e5fb3d,test/Java9andUp/playlist.xml,False,"@@ -181,4 +181,22 @@
 <subset>SE90</subset>
 </subsets>
 </test>
+<test>
+<featureIds>
+<featureId>134092</featureId>",Same request re meaningful id,
69050994,182899fe18fb2bf1e631f66800f6159500e5fb3d,test/Java8andUp/src/org/openj9/test/constantPoolTags/ConstantPoolTagTests.java,False,"@@ -0,0 +1,154 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https:www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https:www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https:www.gnu.org/software/classpath/license.html
+ * [2] http:openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.constantPoolTags;
+
+import java.lang.reflect.Field;
+import java.util.*;
+
+import org.testng.annotations.*;
+import org.testng.log4testng.Logger;
+import org.testng.*;
+
+import sun.misc.Unsafe;
+
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.ModuleVisitor;
+import org.objectweb.asm.Opcodes;
+
+/**
+ * Validate that classes with Java 9 CONSTANT_Module and CONSTANT_Package
+ * constant pool tags cannot be loaded, while modules with these tags can.
+ * 
+ * @author Theresa Mammarella
+ */
+@Test(groups = { ""level.extended"" })
+public class ConstantPoolTagTests {
+
+private static Logger logger = Logger.getLogger(ConstantPoolTagTests.class);
+
+private static final String JAVA_VERSION = System.getProperty(""java.version"");
+
+private static final int classFileVersionJava8 = 52;
+private static final int classFileVersionJava9 = 53; 
+
+public static final int CONSTANT_Module = 19;
+public static final int CONSTANT_Package = 20; 
+
+private int getJavaVersion() {
+return isJava8() ? classFileVersionJava8 : classFileVersionJava9;
+}
+
+private boolean isJava8() {
+return JAVA_VERSION.startsWith(""1.8.0"");
+}
+
+private boolean isJava9() {
+return JAVA_VERSION.startsWith(""1.9.0"") || JAVA_VERSION.startsWith(""9-internal"");",Does this test pass with OpenJ9 builds?  I don't expect the `-internal` to be part of the version number long term.,
69269947,182899fe18fb2bf1e631f66800f6159500e5fb3d,test/Java8andUp/src/org/openj9/test/constantPoolTags/ConstantPoolTagTests.java,True,"@@ -0,0 +1,154 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https:www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https:www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https:www.gnu.org/software/classpath/license.html
+ * [2] http:openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.constantPoolTags;
+
+import java.lang.reflect.Field;
+import java.util.*;
+
+import org.testng.annotations.*;
+import org.testng.log4testng.Logger;
+import org.testng.*;
+
+import sun.misc.Unsafe;
+
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.ModuleVisitor;
+import org.objectweb.asm.Opcodes;
+
+/**
+ * Validate that classes with Java 9 CONSTANT_Module and CONSTANT_Package
+ * constant pool tags cannot be loaded, while modules with these tags can.
+ * 
+ * @author Theresa Mammarella
+ */
+@Test(groups = { ""level.extended"" })
+public class ConstantPoolTagTests {
+
+private static Logger logger = Logger.getLogger(ConstantPoolTagTests.class);
+
+private static final String JAVA_VERSION = System.getProperty(""java.version"");
+
+private static final int classFileVersionJava8 = 52;
+private static final int classFileVersionJava9 = 53; 
+
+public static final int CONSTANT_Module = 19;
+public static final int CONSTANT_Package = 20; 
+
+private int getJavaVersion() {
+return isJava8() ? classFileVersionJava8 : classFileVersionJava9;
+}
+
+private boolean isJava8() {
+return JAVA_VERSION.startsWith(""1.8.0"");
+}
+
+private boolean isJava9() {
+return JAVA_VERSION.startsWith(""1.9.0"") || JAVA_VERSION.startsWith(""9-internal"");",Yes it passes with OpenJ9 builds. There was a time when this wasn't passing without matching `9-internal` but just confirmed that is no longer the case.,
69270614,182899fe18fb2bf1e631f66800f6159500e5fb3d,test/Java8andUp/playlist.xml,True,"@@ -1532,5 +1532,25 @@
 <subset>SE90</subset>
 </subsets>
 </test>
+<test>
+<featureIds>
+<featureId>134091</featureId>","Okay. Talking to @renfeiw about what this should be. There are many other similar <featureIds> in the test code.
Update: I'm just going to remove them since there is no issue created for this PR.",
69454711,182899fe18fb2bf1e631f66800f6159500e5fb3d,test/Java8andUp/src/org/openj9/test/constantPoolTags/ConstantPoolTagTests.java,False,"@@ -0,0 +1,154 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https:www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https:www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https:www.gnu.org/software/classpath/license.html
+ * [2] http:openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.constantPoolTags;
+
+import java.lang.reflect.Field;
+import java.util.*;
+
+import org.testng.annotations.*;
+import org.testng.log4testng.Logger;
+import org.testng.*;
+
+import sun.misc.Unsafe;
+
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.ModuleVisitor;
+import org.objectweb.asm.Opcodes;
+
+/**
+ * Validate that classes with Java 9 CONSTANT_Module and CONSTANT_Package
+ * constant pool tags cannot be loaded, while modules with these tags can.
+ * 
+ * @author Theresa Mammarella
+ */
+@Test(groups = { ""level.extended"" })
+public class ConstantPoolTagTests {
+
+private static Logger logger = Logger.getLogger(ConstantPoolTagTests.class);
+
+private static final String JAVA_VERSION = System.getProperty(""java.version"");
+
+private static final int classFileVersionJava8 = 52;
+private static final int classFileVersionJava9 = 53; 
+
+public static final int CONSTANT_Module = 19;
+public static final int CONSTANT_Package = 20; 
+
+private int getJavaVersion() {
+return isJava8() ? classFileVersionJava8 : classFileVersionJava9;
+}
+
+private boolean isJava8() {
+return JAVA_VERSION.startsWith(""1.8.0"");
+}
+
+private boolean isJava9() {
+return JAVA_VERSION.startsWith(""1.9.0"") || JAVA_VERSION.startsWith(""9-internal"");",Can we drop the `-internal`?  This is a temporary artifact that will disappear when 9 is complete and will lead to unexpected test failures.,
69571022,182899fe18fb2bf1e631f66800f6159500e5fb3d,test/Java8andUp/src/org/openj9/test/constantPoolTags/ConstantPoolTagTests.java,True,"@@ -0,0 +1,154 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https:www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https:www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https:www.gnu.org/software/classpath/license.html
+ * [2] http:openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.constantPoolTags;
+
+import java.lang.reflect.Field;
+import java.util.*;
+
+import org.testng.annotations.*;
+import org.testng.log4testng.Logger;
+import org.testng.*;
+
+import sun.misc.Unsafe;
+
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.ModuleVisitor;
+import org.objectweb.asm.Opcodes;
+
+/**
+ * Validate that classes with Java 9 CONSTANT_Module and CONSTANT_Package
+ * constant pool tags cannot be loaded, while modules with these tags can.
+ * 
+ * @author Theresa Mammarella
+ */
+@Test(groups = { ""level.extended"" })
+public class ConstantPoolTagTests {
+
+private static Logger logger = Logger.getLogger(ConstantPoolTagTests.class);
+
+private static final String JAVA_VERSION = System.getProperty(""java.version"");
+
+private static final int classFileVersionJava8 = 52;
+private static final int classFileVersionJava9 = 53; 
+
+public static final int CONSTANT_Module = 19;
+public static final int CONSTANT_Package = 20; 
+
+private int getJavaVersion() {
+return isJava8() ? classFileVersionJava8 : classFileVersionJava9;
+}
+
+private boolean isJava8() {
+return JAVA_VERSION.startsWith(""1.8.0"");
+}
+
+private boolean isJava9() {
+return JAVA_VERSION.startsWith(""1.9.0"") || JAVA_VERSION.startsWith(""9-internal"");",Yes. It is gone.,
70309047,182899fe18fb2bf1e631f66800f6159500e5fb3d,test/Java8andUp/src/org/openj9/test/constantPoolTags/ConstantPoolTagTests.java,False,"@@ -0,0 +1,154 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https:www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https:www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code is also Distributed under one or more Secondary Licenses,
+ * as those terms are defined by the Eclipse Public License, v. 2.0: GNU
+ * General Public License, version 2 with the GNU Classpath Exception [1]
+ * and GNU General Public License, version 2 with the OpenJDK Assembly
+ * Exception [2].
+ *
+ * [1] https:www.gnu.org/software/classpath/license.html
+ * [2] http:openjdk.java.net/legal/assembly-exception.html
+ *******************************************************************************/
+package org.openj9.test.constantPoolTags;
+
+import java.lang.reflect.Field;
+import java.util.*;
+
+import org.testng.annotations.*;
+import org.testng.log4testng.Logger;
+import org.testng.*;
+
+import sun.misc.Unsafe;
+
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.ModuleVisitor;
+import org.objectweb.asm.Opcodes;
+
+/**
+ * Validate that classes with Java 9 CONSTANT_Module and CONSTANT_Package
+ * constant pool tags cannot be loaded, while modules with these tags can.
+ * 
+ * @author Theresa Mammarella
+ */
+@Test(groups = { ""level.extended"" })
+public class ConstantPoolTagTests {
+
+private static Logger logger = Logger.getLogger(ConstantPoolTagTests.class);
+
+private static final String JAVA_VERSION = System.getProperty(""java.version"");
+
+private static final int classFileVersionJava8 = 52;
+private static final int classFileVersionJava9 = 53; 
+
+public static final int CONSTANT_Module = 19;
+public static final int CONSTANT_Package = 20; 
+
+private int getJavaVersion() {
+return isJava8() ? classFileVersionJava8 : classFileVersionJava9;
+}
+
+private boolean isJava8() {
+return JAVA_VERSION.startsWith(""1.8.0"");
+}
+
+private boolean isJava9() {
+return JAVA_VERSION.startsWith(""1.9.0"");","```
$ java -XshowSettings:properties
....
    java.version = 9-internal
....
```
This check will return false on current openj9 builds as version is temporarily `9-internal`.  Eventually, this the version will be `9` so the check here should be  `startsWith(""1.9.0"" || startsWith(""9"")`. 

Sorry, I wasn't clear earlier.",
74562272,d51c41c77de1bef34a82412adc64fbdaba43354b,runtime/sunvmi/sunvmi.c,False,"@@ -716,7 +716,16 @@ JVM_GetSystemPackages_Impl(JNIEnv* env)
 
 funcs->internalEnterVMFromJNI(vmThread);
 packageName = getPackageName(packageIDList[i], &packageNameLength);
+/*
+ * java.lang.Package.getSystemPackages() expects a trailing slash in Java 8
+ * but no trailing slash in Java 9.
+ */
+#if JAVA_SPEC_VERSION==8","Please use a runtime check instead, i.e. like the following
```
if (J2SE_VERSION(vm) >= J2SE_19) {
```",
74790151,d51c41c77de1bef34a82412adc64fbdaba43354b,runtime/sunvmi/sunvmi.c,False,"@@ -716,7 +716,16 @@ JVM_GetSystemPackages_Impl(JNIEnv* env)
 
 funcs->internalEnterVMFromJNI(vmThread);
 packageName = getPackageName(packageIDList[i], &packageNameLength);
-packageString = funcs->catUtfToString4(vmThread, packageName, packageNameLength, (U_8*)""/"", 1, NULL, 0, NULL, 0);
+/*
+ * java.lang.Package.getSystemPackages() expects a trailing slash in Java 8
+ * but no trailing slash in Java 9.
+ */
+if (J2SE_VERSION(vm) >= J2SE_19) {
+packageString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread,",Might as well use vm instead of vmThread->javaVM since vm is available.,
74821283,d51c41c77de1bef34a82412adc64fbdaba43354b,runtime/sunvmi/sunvmi.c,True,"@@ -716,7 +716,16 @@ JVM_GetSystemPackages_Impl(JNIEnv* env)
 
 funcs->internalEnterVMFromJNI(vmThread);
 packageName = getPackageName(packageIDList[i], &packageNameLength);
-packageString = funcs->catUtfToString4(vmThread, packageName, packageNameLength, (U_8*)""/"", 1, NULL, 0, NULL, 0);
+/*
+ * java.lang.Package.getSystemPackages() expects a trailing slash in Java 8
+ * but no trailing slash in Java 9.
+ */
+if (J2SE_VERSION(vm) >= J2SE_19) {
+packageString = vmThread->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmThread,",Done.,
75112319,e2a00e60a1311cf0438215244a4f2b3b50c0644b,runtime/oti/cfr.h,False,"@@ -865,7 +865,11 @@ typedef struct J9CfrClassFile {
 #define CFR_MAJOR_VERSION  45
 #define CFR_MINOR_VERSION  3
 #define CFR_PUBLIC_PRIVATE_PROTECTED_MASK(CFR_ACC_PUBLIC | CFR_ACC_PRIVATE | CFR_ACC_PROTECTED)
-#define CFR_CLASS_ACCESS_MASK(CFR_ACC_PUBLIC | CFR_ACC_FINAL | CFR_ACC_SUPER | CFR_ACC_INTERFACE | CFR_ACC_ABSTRACT | CFR_ACC_SYNTHETIC | CFR_ACC_ANNOTATION | CFR_ACC_ENUM | CFR_ACC_MODULE)
+#if JAVA_SPEC_VERSION >= 9",We're not using compile time checks yet.  Please do this with a runtime check at the relevant callsites.,
75112319,e2a00e60a1311cf0438215244a4f2b3b50c0644b,runtime/bcutil/cfreader.c,False,"@@ -1168,25 +1168,28 @@ readPool(J9CfrClassFile* classfile, U_8* data, U_8* dataEnd, U_8* segment, U_8*
 
 case CFR_CONSTANT_Module:
 case CFR_CONSTANT_Package:
-if (classfile->majorVersion < 53) {
-errorCode = J9NLS_CFR_ERR_CP_ENTRY_INVALID_BEFORE_V53__ID;
-offset = (U_32)(index - data - 1);
-goto _errorFound;
-}
+if (vmVersionShifted >= BCT_Java9MajorVersionShifted) {",This version check shouldn't be necessary - an unknown constant should result in a ClassFormatError.  This would just give it a different message.,
75112319,e2a00e60a1311cf0438215244a4f2b3b50c0644b,runtime/bcutil/cfreader.c,False,"@@ -2361,7 +2367,7 @@ j9bcutil_readClassFileBytes(J9PortLibrary *portLib,
 UDATA i;
 I_32 hasRET = 0;
 UDATA syntheticFound = FALSE;
-U_32 vmVersionShifted = 0;
+U_32 vmVersionShifted = flags & BCT_MajorClassFileVersionMask;;",nitpick: extra `;`,
75115547,e2a00e60a1311cf0438215244a4f2b3b50c0644b,runtime/bcutil/cfreader.c,True,"@@ -2434,7 +2440,8 @@ j9bcutil_readClassFileBytes(J9PortLibrary *portLib,
 classfile->accessFlags |= CFR_ACC_ABSTRACT;
 }
 
-if (J9_ARE_ALL_BITS_SET(classfile->accessFlags, CFR_ACC_MODULE)) {
+if ((vmVersionShifted >= BCT_Java9MajorVersionShifted)",This check was throwing an error in the Java 8 builds. The change to CFR_CLASS_ACCESS_MASK was also causing failures.,
75119503,e2a00e60a1311cf0438215244a4f2b3b50c0644b,runtime/bcutil/cfreader.c,True,"@@ -2167,11 +2167,15 @@ checkClass(J9PortLibrary *portLib, J9CfrClassFile* classfile, U_8* segment, U_32
 U_32 i;
 I_32 maxBootstrapMethodIndex = -1;
 
-if(checkPool(classfile, segment, (U_8*)10, &maxBootstrapMethodIndex, flags)) {
+if(checkPool(classfile, segment, (U_8*)10, &maxBootstrapMethodIndex, vmVersionShifted, flags)) {
 return -1;
 }
 
-value = classfile->accessFlags & CFR_CLASS_ACCESS_MASK;
+if (vmVersionShifted >= BCT_Java9MajorVersionShifted) {",@DanHeidinga is this what you meant for the runtime check?,
75127287,e2a00e60a1311cf0438215244a4f2b3b50c0644b,runtime/bcutil/cfreader.c,False,"@@ -2167,11 +2167,15 @@ checkClass(J9PortLibrary *portLib, J9CfrClassFile* classfile, U_8* segment, U_32
 U_32 i;
 I_32 maxBootstrapMethodIndex = -1;
 
-if(checkPool(classfile, segment, (U_8*)10, &maxBootstrapMethodIndex, flags)) {
+if(checkPool(classfile, segment, (U_8*)10, &maxBootstrapMethodIndex, vmVersionShifted, flags)) {
 return -1;
 }
 
-value = classfile->accessFlags & CFR_CLASS_ACCESS_MASK;
+if (vmVersionShifted >= BCT_Java9MajorVersionShifted) {",yes,
75442341,908ae900de9659c8495a3fa2ba5712b383ee5e4f,runtime/tr.source/trj9/env/CpuUtilization.hpp,False,"@@ -189,7 +189,15 @@ struct TR_CpuEntitlement
    // sure te portlib is up and running
    void init(J9JITConfig *jitConfig)
       {
-      _hypervisorPresent = TR_maybe;
+      /* Couple of issues were discovered when the support for hypervisor was enabled.
+       * When JVM ran on VMWare, then the port library loaded libvmGuestLib.so which
+       * interferes with implementation of some of j.l.Math methods.
+       * The library also causes JVM to core dump when an application is using libjsig.so
+       * for signal chaining.
+       * For these reasons, support for hypervisor is being disabled until the issues with
+       * VMWare library are resolved.
+       */",Can this comment link to an issue tracking this problem? ,
75445998,908ae900de9659c8495a3fa2ba5712b383ee5e4f,runtime/tr.source/trj9/env/CpuUtilization.hpp,True,"@@ -189,7 +189,15 @@ struct TR_CpuEntitlement
    // sure te portlib is up and running
    void init(J9JITConfig *jitConfig)
       {
-      _hypervisorPresent = TR_maybe;
+      /* Couple of issues were discovered when the support for hypervisor was enabled.
+       * When JVM ran on VMWare, then the port library loaded libvmGuestLib.so which
+       * interferes with implementation of some of j.l.Math methods.
+       * The library also causes JVM to core dump when an application is using libjsig.so
+       * for signal chaining.
+       * For these reasons, support for hypervisor is being disabled until the issues with
+       * VMWare library are resolved.
+       */","We don't have an issue as the problems were reported in IBM internal builds which make use of the VMWare library mentioned in the comment. The problem, as such, is not present with OpenJ9 build.",
75320799,1175df1705ee27bb7bf122e25fa55801598e32e6,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java,False,"@@ -1299,6 +1295,10 @@ BoundMethodHandle rebind() {
 }
 
 /*[IF Sidecar19-SE-OpenJ9]*/
+protected MethodHandle getTarget() {",Does this need to be protected or can it be package private?,
75323737,1175df1705ee27bb7bf122e25fa55801598e32e6,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java,True,"@@ -1299,6 +1295,10 @@ BoundMethodHandle rebind() {
 }
 
 /*[IF Sidecar19-SE-OpenJ9]*/
+protected MethodHandle getTarget() {","`protected` seems needed by `DelegatingMethodHandle`
```
abstract class java.lang.invoke.DelegatingMethodHandle extends java.lang.invoke.MethodHandle {
  protected abstract java.lang.invoke.MethodHandle getTarget();
}
```",
75328978,1175df1705ee27bb7bf122e25fa55801598e32e6,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java,False,"@@ -1299,6 +1295,10 @@ BoundMethodHandle rebind() {
 }
 
 /*[IF Sidecar19-SE-OpenJ9]*/
+protected MethodHandle getTarget() {","a subclass can increase the visibility of a method from package to protected.  As DelegatingMH isn't API, it's free to have a protected method.",
75524877,1175df1705ee27bb7bf122e25fa55801598e32e6,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandle.java,True,"@@ -1299,6 +1295,10 @@ BoundMethodHandle rebind() {
 }
 
 /*[IF Sidecar19-SE-OpenJ9]*/
+protected MethodHandle getTarget() {","Agreed. `getTarget()` can be made to package private which can pass signature tests for `java.lang.invoke.MethodHandle`.

Looked again the initial compilation failure due to removal of this method as following:
```
/tmp/bld_369599/openjdk/jdk/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java:510: error: method does not override or implement a method from a supertype
        @Override
```
But `MethodHandleImpl` doesn't inherit from `MethodHandle`. 
```
abstract class java.lang.invoke.MethodHandleImpl {
}
```
It is the inner classes of `MethodHandleImpl` that attempt to override `getTarget()`
```
Compiled from ""MethodHandleImpl.java""
final class java.lang.invoke.MethodHandleImpl$AsVarargsCollector extends java.lang.invoke.DelegatingMethodHandle {
protected java.lang.invoke.MethodHandle getTarget();
}
....
final class java.lang.invoke.MethodHandleImpl$WrappedMember extends java.lang.invoke.DelegatingMethodHandle {
protected java.lang.invoke.MethodHandle getTarget();
}
```
I just realized that J9 has a stub class `DelegatingMethodHandle` which doesn't have `getTarget()`, and inherits it from `MethodHandle` instead.",
72843744,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,False,"@@ -321,6 +321,343 @@ static BOOLEAN librariesLoaded(void);
 #define LD_ENV_PATH ""LIBPATH""
 #endif /* defined(J9ZTPF) */
 
+#define J9_SIG_ERR -1
+
+#if defined(SIGHUP)
+#define J9_SIGHUP SIGHUP
+#else /* defined(SIGHUP) */
+#define J9_SIGHUP J9_SIG_ERR
+#endif /* defined(SIGHUP) */
+
+#if defined(SIGINT)
+#define J9_SIGINT SIGINT
+#else /* defined(SIGINT) */
+#define J9_SIGINT J9_SIG_ERR
+#endif /* defined(SIGINT) */
+
+#if defined(SIGQUIT)
+#define J9_SIGQUIT SIGQUIT
+#else /* defined(SIGQUIT) */
+#define J9_SIGQUIT J9_SIG_ERR
+#endif /* defined(SIGQUIT) */
+
+#if defined(SIGILL)
+#define J9_SIGILL SIGILL
+#else /* defined(SIGILL) */
+#define J9_SIGILL J9_SIG_ERR
+#endif /* defined(SIGILL) */
+
+#if defined(SIGTRAP)
+#define J9_SIGTRAP SIGTRAP
+#else /* defined(SIGTRAP) */
+#define J9_SIGTRAP J9_SIG_ERR
+#endif /* defined(SIGTRAP) */
+
+#if defined(SIGABRT)
+#define J9_SIGABRT SIGABRT
+#else /* defined(SIGABRT) */
+#define J9_SIGABRT J9_SIG_ERR
+#endif /* defined(SIGABRT) */
+
+#if defined(SIGEMT)
+#define J9_SIGEMT SIGEMT
+#else /* defined(SIGEMT) */
+#define J9_SIGEMT J9_SIG_ERR
+#endif /* defined(SIGEMT) */
+
+#if defined(SIGFPE)
+#define J9_SIGFPE SIGFPE
+#else /* defined(SIGFPE) */
+#define J9_SIGFPE J9_SIG_ERR
+#endif /* defined(SIGFPE) */
+
+#if defined(SIGKILL)
+#define J9_SIGKILL SIGKILL
+#else /* defined(SIGKILL) */
+#define J9_SIGKILL J9_SIG_ERR
+#endif /* defined(SIGKILL) */
+
+#if defined(SIGBUS)
+#define J9_SIGBUS SIGBUS
+#else /* defined(SIGBUS) */
+#define J9_SIGBUS J9_SIG_ERR
+#endif /* defined(SIGBUS) */
+
+#if defined(SIGSEGV)
+#define J9_SIGSEGV SIGSEGV
+#else /* defined(SIGSEGV) */
+#define J9_SIGSEGV J9_SIG_ERR
+#endif /* defined(SIGSEGV) */
+
+#if defined(SIGSYS)
+#define J9_SIGSYS SIGSYS
+#else /* defined(SIGSYS) */
+#define J9_SIGSYS J9_SIG_ERR
+#endif /* defined(SIGSYS) */
+
+#if defined(SIGPIPE)
+#define J9_SIGPIPE SIGPIPE
+#else /* defined(SIGPIPE) */
+#define J9_SIGPIPE J9_SIG_ERR
+#endif /* defined(SIGPIPE) */
+
+#if defined(SIGALRM)
+#define J9_SIGALRM SIGALRM
+#else /* defined(SIGALRM) */
+#define J9_SIGALRM J9_SIG_ERR
+#endif /* defined(SIGALRM) */
+
+#if defined(SIGTERM)
+#define J9_SIGTERM SIGTERM
+#else /* defined(SIGTERM) */
+#define J9_SIGTERM J9_SIG_ERR
+#endif /* defined(SIGTERM) */
+
+#if defined(SIGURG)
+#define J9_SIGURG SIGURG
+#else /* defined(SIGURG) */
+#define J9_SIGURG J9_SIG_ERR
+#endif /* defined(SIGURG) */
+
+#if defined(SIGSTOP)
+#define J9_SIGSTOP SIGSTOP
+#else /* defined(SIGSTOP) */
+#define J9_SIGSTOP J9_SIG_ERR
+#endif /* defined(SIGSTOP) */
+
+#if defined(SIGTSTP)
+#define J9_SIGTSTP SIGTSTP
+#else /* defined(SIGTSTP) */
+#define J9_SIGTSTP J9_SIG_ERR
+#endif /* defined(SIGTSTP) */
+
+#if defined(SIGCONT)
+#define J9_SIGCONT SIGCONT
+#else /* defined(SIGCONT) */
+#define J9_SIGCONT J9_SIG_ERR
+#endif /* defined(SIGCONT) */
+
+#if defined(SIGCHLD)
+#define J9_SIGCHLD SIGCHLD
+#else /* defined(SIGCHLD) */
+#define J9_SIGCHLD J9_SIG_ERR
+#endif /* defined(SIGCHLD) */
+
+#if defined(SIGTTIN)
+#define J9_SIGTTIN SIGTTIN
+#else /* defined(SIGTTIN) */
+#define J9_SIGTTIN J9_SIG_ERR
+#endif /* defined(SIGTTIN) */
+
+#if defined(SIGTTOU)
+#define J9_SIGTTOU SIGTTOU
+#else /* defined(SIGTTOU) */
+#define J9_SIGTTOU J9_SIG_ERR
+#endif /* defined(SIGTTOU) */
+
+#if defined(SIGIO)
+#define J9_SIGIO SIGIO
+#else /* defined(SIGIO) */
+#define J9_SIGIO J9_SIG_ERR
+#endif /* defined(SIGIO) */
+
+#if defined(SIGXCPU)
+#define J9_SIGXCPU SIGXCPU
+#else /* defined(SIGXCPU) */
+#define J9_SIGXCPU J9_SIG_ERR
+#endif /* defined(SIGXCPU) */
+
+#if defined(SIGXFSZ)
+#define J9_SIGXFSZ SIGXFSZ
+#else /* defined(SIGXFSZ) */
+#define J9_SIGXFSZ J9_SIG_ERR
+#endif /* defined(SIGXFSZ) */
+
+#if defined(SIGMSG)
+#define J9_SIGMSG SIGMSG
+#else /* defined(SIGMSG) */
+#define J9_SIGMSG J9_SIG_ERR
+#endif /* defined(SIGMSG) */
+
+#if defined(SIGWINCH)
+#define J9_SIGWINCH SIGWINCH
+#else /* defined(SIGWINCH) */
+#define J9_SIGWINCH J9_SIG_ERR
+#endif /* defined(SIGWINCH) */
+
+#if defined(SIGPWR)
+#define J9_SIGPWR SIGPWR
+#else /* defined(SIGPWR) */
+#define J9_SIGPWR J9_SIG_ERR
+#endif /* defined(SIGPWR) */
+
+#if defined(SIGUSR1)
+#define J9_SIGUSR1 SIGUSR1
+#else /* defined(SIGUSR1) */
+#define J9_SIGUSR1 J9_SIG_ERR
+#endif /* defined(SIGUSR1) */
+
+#if defined(SIGUSR2)
+#define J9_SIGUSR2 SIGUSR2
+#else /* defined(SIGUSR2) */
+#define J9_SIGUSR2 J9_SIG_ERR
+#endif /* defined(SIGUSR2) */
+
+#if defined(SIGPROF)
+#define J9_SIGPROF SIGPROF
+#else /* defined(SIGPROF) */
+#define J9_SIGPROF J9_SIG_ERR
+#endif /* defined(SIGPROF) */
+
+#if defined(SIGDANGER)
+#define J9_SIGDANGER SIGDANGER
+#else /* defined(SIGDANGER) */
+#define J9_SIGDANGER J9_SIG_ERR
+#endif /* defined(SIGDANGER) */
+
+#if defined(SIGVTALRM)
+#define J9_SIGVTALRM SIGVTALRM
+#else /* defined(SIGVTALRM) */
+#define J9_SIGVTALRM J9_SIG_ERR
+#endif /* defined(SIGVTALRM) */
+
+#if defined(SIGMIGRATE)
+#define J9_SIGMIGRATE SIGMIGRATE
+#else /* defined(SIGMIGRATE) */
+#define J9_SIGMIGRATE J9_SIG_ERR
+#endif /* defined(SIGMIGRATE) */
+
+#if defined(SIGPRE)
+#define J9_SIGPRE SIGPRE
+#else /* defined(SIGPRE) */
+#define J9_SIGPRE J9_SIG_ERR
+#endif /* defined(SIGPRE) */
+
+#if defined(SIGCPUFAIL)
+#define J9_SIGCPUFAIL SIGCPUFAIL
+#else /* defined(SIGCPUFAIL) */
+#define J9_SIGCPUFAIL J9_SIG_ERR
+#endif /* defined(SIGCPUFAIL) */
+
+#if defined(SIGGRANT)
+#define J9_SIGGRANT SIGGRANT
+#else /* defined(SIGGRANT) */
+#define J9_SIGGRANT J9_SIG_ERR
+#endif /* defined(SIGGRANT) */
+
+#if defined(SIGRETRACT)
+#define J9_SIGRETRACT SIGRETRACT
+#else /* defined(SIGRETRACT) */
+#define J9_SIGRETRACT J9_SIG_ERR
+#endif /* defined(SIGRETRACT) */
+
+#if defined(SIGSOUND)
+#define J9_SIGSOUND SIGSOUND
+#else /* defined(SIGSOUND) */
+#define J9_SIGSOUND J9_SIG_ERR
+#endif /* defined(SIGSOUND) */
+
+#if defined(SIGSAK)
+#define J9_SIGSAK SIGSAK
+#else /* defined(SIGSAK) */
+#define J9_SIGSAK J9_SIG_ERR
+#endif /* defined(SIGSAK) */
+
+#if defined(SIGPOLL)
+#define J9_SIGPOLL SIGPOLL
+#else /* defined(SIGPOLL) */
+#define J9_SIGPOLL J9_SIG_ERR
+#endif /* defined(SIGPOLL) */
+
+#if defined(SIGINFO)
+#define J9_SIGINFO SIGINFO
+#else /* defined(SIGINFO) */
+#define J9_SIGINFO J9_SIG_ERR
+#endif /* defined(SIGINFO) */
+
+#if defined(SIGSTKFLT)
+#define J9_SIGSTKFLT SIGSTKFLT
+#else /* defined(SIGSTKFLT) */
+#define J9_SIGSTKFLT J9_SIG_ERR
+#endif /* defined(SIGSTKFLT) */
+
+#if defined(SIGBREAK)
+#define J9_SIGBREAK SIGBREAK
+#else /* defined(SIGBREAK) */
+#define J9_SIGBREAK J9_SIG_ERR
+#endif /* defined(SIGBREAK) */
+
+#if defined(SIGUNUSED)
+#define J9_SIGUNUSED SIGUNUSED
+#else /* defined(SIGUNUSED) */
+#define J9_SIGUNUSED J9_SIG_ERR
+#endif /* defined(SIGUNUSED) */
+
+#define J9_IS_SIGNAL_SPECIAL(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGQUIT) || (SIG_NUM == J9_SIGHUP) || (SIG_NUM == J9_SIGINT) || (SIG_NUM == J9_SIGTERM)))
+#define J9_IS_SIGNAL_USED_BY_VM(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGFPE) || (SIG_NUM == J9_SIGILL) || (SIG_NUM == J9_SIGSEGV)))
+
+#define J9_PRE_DEFINED_HANDLER_CHECK 2
+#define J9_OLDHANDLER_SAME_AS_NEWHANDLER 2
+
+#define J9_SIG_PREFIX ""SIG""
+#define J9_SIG_PREFIX_LENGTH 3
+
+static void dummySignalHandler(jint sigNum);
+
+typedef struct {
+char *signalName;
+int signalValue;
+} J9SignalMapping;
+
+static J9SignalMapping signalMap[] = {",This object should be `const`.,
72843791,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,False,"@@ -321,6 +321,343 @@ static BOOLEAN librariesLoaded(void);
 #define LD_ENV_PATH ""LIBPATH""
 #endif /* defined(J9ZTPF) */
 
+#define J9_SIG_ERR -1
+
+#if defined(SIGHUP)
+#define J9_SIGHUP SIGHUP
+#else /* defined(SIGHUP) */
+#define J9_SIGHUP J9_SIG_ERR
+#endif /* defined(SIGHUP) */
+
+#if defined(SIGINT)
+#define J9_SIGINT SIGINT
+#else /* defined(SIGINT) */
+#define J9_SIGINT J9_SIG_ERR
+#endif /* defined(SIGINT) */
+
+#if defined(SIGQUIT)
+#define J9_SIGQUIT SIGQUIT
+#else /* defined(SIGQUIT) */
+#define J9_SIGQUIT J9_SIG_ERR
+#endif /* defined(SIGQUIT) */
+
+#if defined(SIGILL)
+#define J9_SIGILL SIGILL
+#else /* defined(SIGILL) */
+#define J9_SIGILL J9_SIG_ERR
+#endif /* defined(SIGILL) */
+
+#if defined(SIGTRAP)
+#define J9_SIGTRAP SIGTRAP
+#else /* defined(SIGTRAP) */
+#define J9_SIGTRAP J9_SIG_ERR
+#endif /* defined(SIGTRAP) */
+
+#if defined(SIGABRT)
+#define J9_SIGABRT SIGABRT
+#else /* defined(SIGABRT) */
+#define J9_SIGABRT J9_SIG_ERR
+#endif /* defined(SIGABRT) */
+
+#if defined(SIGEMT)
+#define J9_SIGEMT SIGEMT
+#else /* defined(SIGEMT) */
+#define J9_SIGEMT J9_SIG_ERR
+#endif /* defined(SIGEMT) */
+
+#if defined(SIGFPE)
+#define J9_SIGFPE SIGFPE
+#else /* defined(SIGFPE) */
+#define J9_SIGFPE J9_SIG_ERR
+#endif /* defined(SIGFPE) */
+
+#if defined(SIGKILL)
+#define J9_SIGKILL SIGKILL
+#else /* defined(SIGKILL) */
+#define J9_SIGKILL J9_SIG_ERR
+#endif /* defined(SIGKILL) */
+
+#if defined(SIGBUS)
+#define J9_SIGBUS SIGBUS
+#else /* defined(SIGBUS) */
+#define J9_SIGBUS J9_SIG_ERR
+#endif /* defined(SIGBUS) */
+
+#if defined(SIGSEGV)
+#define J9_SIGSEGV SIGSEGV
+#else /* defined(SIGSEGV) */
+#define J9_SIGSEGV J9_SIG_ERR
+#endif /* defined(SIGSEGV) */
+
+#if defined(SIGSYS)
+#define J9_SIGSYS SIGSYS
+#else /* defined(SIGSYS) */
+#define J9_SIGSYS J9_SIG_ERR
+#endif /* defined(SIGSYS) */
+
+#if defined(SIGPIPE)
+#define J9_SIGPIPE SIGPIPE
+#else /* defined(SIGPIPE) */
+#define J9_SIGPIPE J9_SIG_ERR
+#endif /* defined(SIGPIPE) */
+
+#if defined(SIGALRM)
+#define J9_SIGALRM SIGALRM
+#else /* defined(SIGALRM) */
+#define J9_SIGALRM J9_SIG_ERR
+#endif /* defined(SIGALRM) */
+
+#if defined(SIGTERM)
+#define J9_SIGTERM SIGTERM
+#else /* defined(SIGTERM) */
+#define J9_SIGTERM J9_SIG_ERR
+#endif /* defined(SIGTERM) */
+
+#if defined(SIGURG)
+#define J9_SIGURG SIGURG
+#else /* defined(SIGURG) */
+#define J9_SIGURG J9_SIG_ERR
+#endif /* defined(SIGURG) */
+
+#if defined(SIGSTOP)
+#define J9_SIGSTOP SIGSTOP
+#else /* defined(SIGSTOP) */
+#define J9_SIGSTOP J9_SIG_ERR
+#endif /* defined(SIGSTOP) */
+
+#if defined(SIGTSTP)
+#define J9_SIGTSTP SIGTSTP
+#else /* defined(SIGTSTP) */
+#define J9_SIGTSTP J9_SIG_ERR
+#endif /* defined(SIGTSTP) */
+
+#if defined(SIGCONT)
+#define J9_SIGCONT SIGCONT
+#else /* defined(SIGCONT) */
+#define J9_SIGCONT J9_SIG_ERR
+#endif /* defined(SIGCONT) */
+
+#if defined(SIGCHLD)
+#define J9_SIGCHLD SIGCHLD
+#else /* defined(SIGCHLD) */
+#define J9_SIGCHLD J9_SIG_ERR
+#endif /* defined(SIGCHLD) */
+
+#if defined(SIGTTIN)
+#define J9_SIGTTIN SIGTTIN
+#else /* defined(SIGTTIN) */
+#define J9_SIGTTIN J9_SIG_ERR
+#endif /* defined(SIGTTIN) */
+
+#if defined(SIGTTOU)
+#define J9_SIGTTOU SIGTTOU
+#else /* defined(SIGTTOU) */
+#define J9_SIGTTOU J9_SIG_ERR
+#endif /* defined(SIGTTOU) */
+
+#if defined(SIGIO)
+#define J9_SIGIO SIGIO
+#else /* defined(SIGIO) */
+#define J9_SIGIO J9_SIG_ERR
+#endif /* defined(SIGIO) */
+
+#if defined(SIGXCPU)
+#define J9_SIGXCPU SIGXCPU
+#else /* defined(SIGXCPU) */
+#define J9_SIGXCPU J9_SIG_ERR
+#endif /* defined(SIGXCPU) */
+
+#if defined(SIGXFSZ)
+#define J9_SIGXFSZ SIGXFSZ
+#else /* defined(SIGXFSZ) */
+#define J9_SIGXFSZ J9_SIG_ERR
+#endif /* defined(SIGXFSZ) */
+
+#if defined(SIGMSG)
+#define J9_SIGMSG SIGMSG
+#else /* defined(SIGMSG) */
+#define J9_SIGMSG J9_SIG_ERR
+#endif /* defined(SIGMSG) */
+
+#if defined(SIGWINCH)
+#define J9_SIGWINCH SIGWINCH
+#else /* defined(SIGWINCH) */
+#define J9_SIGWINCH J9_SIG_ERR
+#endif /* defined(SIGWINCH) */
+
+#if defined(SIGPWR)
+#define J9_SIGPWR SIGPWR
+#else /* defined(SIGPWR) */
+#define J9_SIGPWR J9_SIG_ERR
+#endif /* defined(SIGPWR) */
+
+#if defined(SIGUSR1)
+#define J9_SIGUSR1 SIGUSR1
+#else /* defined(SIGUSR1) */
+#define J9_SIGUSR1 J9_SIG_ERR
+#endif /* defined(SIGUSR1) */
+
+#if defined(SIGUSR2)
+#define J9_SIGUSR2 SIGUSR2
+#else /* defined(SIGUSR2) */
+#define J9_SIGUSR2 J9_SIG_ERR
+#endif /* defined(SIGUSR2) */
+
+#if defined(SIGPROF)
+#define J9_SIGPROF SIGPROF
+#else /* defined(SIGPROF) */
+#define J9_SIGPROF J9_SIG_ERR
+#endif /* defined(SIGPROF) */
+
+#if defined(SIGDANGER)
+#define J9_SIGDANGER SIGDANGER
+#else /* defined(SIGDANGER) */
+#define J9_SIGDANGER J9_SIG_ERR
+#endif /* defined(SIGDANGER) */
+
+#if defined(SIGVTALRM)
+#define J9_SIGVTALRM SIGVTALRM
+#else /* defined(SIGVTALRM) */
+#define J9_SIGVTALRM J9_SIG_ERR
+#endif /* defined(SIGVTALRM) */
+
+#if defined(SIGMIGRATE)
+#define J9_SIGMIGRATE SIGMIGRATE
+#else /* defined(SIGMIGRATE) */
+#define J9_SIGMIGRATE J9_SIG_ERR
+#endif /* defined(SIGMIGRATE) */
+
+#if defined(SIGPRE)
+#define J9_SIGPRE SIGPRE
+#else /* defined(SIGPRE) */
+#define J9_SIGPRE J9_SIG_ERR
+#endif /* defined(SIGPRE) */
+
+#if defined(SIGCPUFAIL)
+#define J9_SIGCPUFAIL SIGCPUFAIL
+#else /* defined(SIGCPUFAIL) */
+#define J9_SIGCPUFAIL J9_SIG_ERR
+#endif /* defined(SIGCPUFAIL) */
+
+#if defined(SIGGRANT)
+#define J9_SIGGRANT SIGGRANT
+#else /* defined(SIGGRANT) */
+#define J9_SIGGRANT J9_SIG_ERR
+#endif /* defined(SIGGRANT) */
+
+#if defined(SIGRETRACT)
+#define J9_SIGRETRACT SIGRETRACT
+#else /* defined(SIGRETRACT) */
+#define J9_SIGRETRACT J9_SIG_ERR
+#endif /* defined(SIGRETRACT) */
+
+#if defined(SIGSOUND)
+#define J9_SIGSOUND SIGSOUND
+#else /* defined(SIGSOUND) */
+#define J9_SIGSOUND J9_SIG_ERR
+#endif /* defined(SIGSOUND) */
+
+#if defined(SIGSAK)
+#define J9_SIGSAK SIGSAK
+#else /* defined(SIGSAK) */
+#define J9_SIGSAK J9_SIG_ERR
+#endif /* defined(SIGSAK) */
+
+#if defined(SIGPOLL)
+#define J9_SIGPOLL SIGPOLL
+#else /* defined(SIGPOLL) */
+#define J9_SIGPOLL J9_SIG_ERR
+#endif /* defined(SIGPOLL) */
+
+#if defined(SIGINFO)
+#define J9_SIGINFO SIGINFO
+#else /* defined(SIGINFO) */
+#define J9_SIGINFO J9_SIG_ERR
+#endif /* defined(SIGINFO) */
+
+#if defined(SIGSTKFLT)
+#define J9_SIGSTKFLT SIGSTKFLT
+#else /* defined(SIGSTKFLT) */
+#define J9_SIGSTKFLT J9_SIG_ERR
+#endif /* defined(SIGSTKFLT) */
+
+#if defined(SIGBREAK)
+#define J9_SIGBREAK SIGBREAK
+#else /* defined(SIGBREAK) */
+#define J9_SIGBREAK J9_SIG_ERR
+#endif /* defined(SIGBREAK) */
+
+#if defined(SIGUNUSED)
+#define J9_SIGUNUSED SIGUNUSED
+#else /* defined(SIGUNUSED) */
+#define J9_SIGUNUSED J9_SIG_ERR
+#endif /* defined(SIGUNUSED) */
+
+#define J9_IS_SIGNAL_SPECIAL(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGQUIT) || (SIG_NUM == J9_SIGHUP) || (SIG_NUM == J9_SIGINT) || (SIG_NUM == J9_SIGTERM)))
+#define J9_IS_SIGNAL_USED_BY_VM(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGFPE) || (SIG_NUM == J9_SIGILL) || (SIG_NUM == J9_SIGSEGV)))
+
+#define J9_PRE_DEFINED_HANDLER_CHECK 2
+#define J9_OLDHANDLER_SAME_AS_NEWHANDLER 2
+
+#define J9_SIG_PREFIX ""SIG""
+#define J9_SIG_PREFIX_LENGTH 3
+
+static void dummySignalHandler(jint sigNum);
+
+typedef struct {
+char *signalName;",The type should be `const char *`.,
73230819,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,True,"@@ -321,6 +321,343 @@ static BOOLEAN librariesLoaded(void);
 #define LD_ENV_PATH ""LIBPATH""
 #endif /* defined(J9ZTPF) */
 
+#define J9_SIG_ERR -1
+
+#if defined(SIGHUP)
+#define J9_SIGHUP SIGHUP
+#else /* defined(SIGHUP) */
+#define J9_SIGHUP J9_SIG_ERR
+#endif /* defined(SIGHUP) */
+
+#if defined(SIGINT)
+#define J9_SIGINT SIGINT
+#else /* defined(SIGINT) */
+#define J9_SIGINT J9_SIG_ERR
+#endif /* defined(SIGINT) */
+
+#if defined(SIGQUIT)
+#define J9_SIGQUIT SIGQUIT
+#else /* defined(SIGQUIT) */
+#define J9_SIGQUIT J9_SIG_ERR
+#endif /* defined(SIGQUIT) */
+
+#if defined(SIGILL)
+#define J9_SIGILL SIGILL
+#else /* defined(SIGILL) */
+#define J9_SIGILL J9_SIG_ERR
+#endif /* defined(SIGILL) */
+
+#if defined(SIGTRAP)
+#define J9_SIGTRAP SIGTRAP
+#else /* defined(SIGTRAP) */
+#define J9_SIGTRAP J9_SIG_ERR
+#endif /* defined(SIGTRAP) */
+
+#if defined(SIGABRT)
+#define J9_SIGABRT SIGABRT
+#else /* defined(SIGABRT) */
+#define J9_SIGABRT J9_SIG_ERR
+#endif /* defined(SIGABRT) */
+
+#if defined(SIGEMT)
+#define J9_SIGEMT SIGEMT
+#else /* defined(SIGEMT) */
+#define J9_SIGEMT J9_SIG_ERR
+#endif /* defined(SIGEMT) */
+
+#if defined(SIGFPE)
+#define J9_SIGFPE SIGFPE
+#else /* defined(SIGFPE) */
+#define J9_SIGFPE J9_SIG_ERR
+#endif /* defined(SIGFPE) */
+
+#if defined(SIGKILL)
+#define J9_SIGKILL SIGKILL
+#else /* defined(SIGKILL) */
+#define J9_SIGKILL J9_SIG_ERR
+#endif /* defined(SIGKILL) */
+
+#if defined(SIGBUS)
+#define J9_SIGBUS SIGBUS
+#else /* defined(SIGBUS) */
+#define J9_SIGBUS J9_SIG_ERR
+#endif /* defined(SIGBUS) */
+
+#if defined(SIGSEGV)
+#define J9_SIGSEGV SIGSEGV
+#else /* defined(SIGSEGV) */
+#define J9_SIGSEGV J9_SIG_ERR
+#endif /* defined(SIGSEGV) */
+
+#if defined(SIGSYS)
+#define J9_SIGSYS SIGSYS
+#else /* defined(SIGSYS) */
+#define J9_SIGSYS J9_SIG_ERR
+#endif /* defined(SIGSYS) */
+
+#if defined(SIGPIPE)
+#define J9_SIGPIPE SIGPIPE
+#else /* defined(SIGPIPE) */
+#define J9_SIGPIPE J9_SIG_ERR
+#endif /* defined(SIGPIPE) */
+
+#if defined(SIGALRM)
+#define J9_SIGALRM SIGALRM
+#else /* defined(SIGALRM) */
+#define J9_SIGALRM J9_SIG_ERR
+#endif /* defined(SIGALRM) */
+
+#if defined(SIGTERM)
+#define J9_SIGTERM SIGTERM
+#else /* defined(SIGTERM) */
+#define J9_SIGTERM J9_SIG_ERR
+#endif /* defined(SIGTERM) */
+
+#if defined(SIGURG)
+#define J9_SIGURG SIGURG
+#else /* defined(SIGURG) */
+#define J9_SIGURG J9_SIG_ERR
+#endif /* defined(SIGURG) */
+
+#if defined(SIGSTOP)
+#define J9_SIGSTOP SIGSTOP
+#else /* defined(SIGSTOP) */
+#define J9_SIGSTOP J9_SIG_ERR
+#endif /* defined(SIGSTOP) */
+
+#if defined(SIGTSTP)
+#define J9_SIGTSTP SIGTSTP
+#else /* defined(SIGTSTP) */
+#define J9_SIGTSTP J9_SIG_ERR
+#endif /* defined(SIGTSTP) */
+
+#if defined(SIGCONT)
+#define J9_SIGCONT SIGCONT
+#else /* defined(SIGCONT) */
+#define J9_SIGCONT J9_SIG_ERR
+#endif /* defined(SIGCONT) */
+
+#if defined(SIGCHLD)
+#define J9_SIGCHLD SIGCHLD
+#else /* defined(SIGCHLD) */
+#define J9_SIGCHLD J9_SIG_ERR
+#endif /* defined(SIGCHLD) */
+
+#if defined(SIGTTIN)
+#define J9_SIGTTIN SIGTTIN
+#else /* defined(SIGTTIN) */
+#define J9_SIGTTIN J9_SIG_ERR
+#endif /* defined(SIGTTIN) */
+
+#if defined(SIGTTOU)
+#define J9_SIGTTOU SIGTTOU
+#else /* defined(SIGTTOU) */
+#define J9_SIGTTOU J9_SIG_ERR
+#endif /* defined(SIGTTOU) */
+
+#if defined(SIGIO)
+#define J9_SIGIO SIGIO
+#else /* defined(SIGIO) */
+#define J9_SIGIO J9_SIG_ERR
+#endif /* defined(SIGIO) */
+
+#if defined(SIGXCPU)
+#define J9_SIGXCPU SIGXCPU
+#else /* defined(SIGXCPU) */
+#define J9_SIGXCPU J9_SIG_ERR
+#endif /* defined(SIGXCPU) */
+
+#if defined(SIGXFSZ)
+#define J9_SIGXFSZ SIGXFSZ
+#else /* defined(SIGXFSZ) */
+#define J9_SIGXFSZ J9_SIG_ERR
+#endif /* defined(SIGXFSZ) */
+
+#if defined(SIGMSG)
+#define J9_SIGMSG SIGMSG
+#else /* defined(SIGMSG) */
+#define J9_SIGMSG J9_SIG_ERR
+#endif /* defined(SIGMSG) */
+
+#if defined(SIGWINCH)
+#define J9_SIGWINCH SIGWINCH
+#else /* defined(SIGWINCH) */
+#define J9_SIGWINCH J9_SIG_ERR
+#endif /* defined(SIGWINCH) */
+
+#if defined(SIGPWR)
+#define J9_SIGPWR SIGPWR
+#else /* defined(SIGPWR) */
+#define J9_SIGPWR J9_SIG_ERR
+#endif /* defined(SIGPWR) */
+
+#if defined(SIGUSR1)
+#define J9_SIGUSR1 SIGUSR1
+#else /* defined(SIGUSR1) */
+#define J9_SIGUSR1 J9_SIG_ERR
+#endif /* defined(SIGUSR1) */
+
+#if defined(SIGUSR2)
+#define J9_SIGUSR2 SIGUSR2
+#else /* defined(SIGUSR2) */
+#define J9_SIGUSR2 J9_SIG_ERR
+#endif /* defined(SIGUSR2) */
+
+#if defined(SIGPROF)
+#define J9_SIGPROF SIGPROF
+#else /* defined(SIGPROF) */
+#define J9_SIGPROF J9_SIG_ERR
+#endif /* defined(SIGPROF) */
+
+#if defined(SIGDANGER)
+#define J9_SIGDANGER SIGDANGER
+#else /* defined(SIGDANGER) */
+#define J9_SIGDANGER J9_SIG_ERR
+#endif /* defined(SIGDANGER) */
+
+#if defined(SIGVTALRM)
+#define J9_SIGVTALRM SIGVTALRM
+#else /* defined(SIGVTALRM) */
+#define J9_SIGVTALRM J9_SIG_ERR
+#endif /* defined(SIGVTALRM) */
+
+#if defined(SIGMIGRATE)
+#define J9_SIGMIGRATE SIGMIGRATE
+#else /* defined(SIGMIGRATE) */
+#define J9_SIGMIGRATE J9_SIG_ERR
+#endif /* defined(SIGMIGRATE) */
+
+#if defined(SIGPRE)
+#define J9_SIGPRE SIGPRE
+#else /* defined(SIGPRE) */
+#define J9_SIGPRE J9_SIG_ERR
+#endif /* defined(SIGPRE) */
+
+#if defined(SIGCPUFAIL)
+#define J9_SIGCPUFAIL SIGCPUFAIL
+#else /* defined(SIGCPUFAIL) */
+#define J9_SIGCPUFAIL J9_SIG_ERR
+#endif /* defined(SIGCPUFAIL) */
+
+#if defined(SIGGRANT)
+#define J9_SIGGRANT SIGGRANT
+#else /* defined(SIGGRANT) */
+#define J9_SIGGRANT J9_SIG_ERR
+#endif /* defined(SIGGRANT) */
+
+#if defined(SIGRETRACT)
+#define J9_SIGRETRACT SIGRETRACT
+#else /* defined(SIGRETRACT) */
+#define J9_SIGRETRACT J9_SIG_ERR
+#endif /* defined(SIGRETRACT) */
+
+#if defined(SIGSOUND)
+#define J9_SIGSOUND SIGSOUND
+#else /* defined(SIGSOUND) */
+#define J9_SIGSOUND J9_SIG_ERR
+#endif /* defined(SIGSOUND) */
+
+#if defined(SIGSAK)
+#define J9_SIGSAK SIGSAK
+#else /* defined(SIGSAK) */
+#define J9_SIGSAK J9_SIG_ERR
+#endif /* defined(SIGSAK) */
+
+#if defined(SIGPOLL)
+#define J9_SIGPOLL SIGPOLL
+#else /* defined(SIGPOLL) */
+#define J9_SIGPOLL J9_SIG_ERR
+#endif /* defined(SIGPOLL) */
+
+#if defined(SIGINFO)
+#define J9_SIGINFO SIGINFO
+#else /* defined(SIGINFO) */
+#define J9_SIGINFO J9_SIG_ERR
+#endif /* defined(SIGINFO) */
+
+#if defined(SIGSTKFLT)
+#define J9_SIGSTKFLT SIGSTKFLT
+#else /* defined(SIGSTKFLT) */
+#define J9_SIGSTKFLT J9_SIG_ERR
+#endif /* defined(SIGSTKFLT) */
+
+#if defined(SIGBREAK)
+#define J9_SIGBREAK SIGBREAK
+#else /* defined(SIGBREAK) */
+#define J9_SIGBREAK J9_SIG_ERR
+#endif /* defined(SIGBREAK) */
+
+#if defined(SIGUNUSED)
+#define J9_SIGUNUSED SIGUNUSED
+#else /* defined(SIGUNUSED) */
+#define J9_SIGUNUSED J9_SIG_ERR
+#endif /* defined(SIGUNUSED) */
+
+#define J9_IS_SIGNAL_SPECIAL(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGQUIT) || (SIG_NUM == J9_SIGHUP) || (SIG_NUM == J9_SIGINT) || (SIG_NUM == J9_SIGTERM)))
+#define J9_IS_SIGNAL_USED_BY_VM(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGFPE) || (SIG_NUM == J9_SIGILL) || (SIG_NUM == J9_SIGSEGV)))
+
+#define J9_PRE_DEFINED_HANDLER_CHECK 2
+#define J9_OLDHANDLER_SAME_AS_NEWHANDLER 2
+
+#define J9_SIG_PREFIX ""SIG""
+#define J9_SIG_PREFIX_LENGTH 3
+
+static void dummySignalHandler(jint sigNum);
+
+typedef struct {
+char *signalName;
+int signalValue;
+} J9SignalMapping;
+
+static J9SignalMapping signalMap[] = {",fixed.,
73230861,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,True,"@@ -321,6 +321,343 @@ static BOOLEAN librariesLoaded(void);
 #define LD_ENV_PATH ""LIBPATH""
 #endif /* defined(J9ZTPF) */
 
+#define J9_SIG_ERR -1
+
+#if defined(SIGHUP)
+#define J9_SIGHUP SIGHUP
+#else /* defined(SIGHUP) */
+#define J9_SIGHUP J9_SIG_ERR
+#endif /* defined(SIGHUP) */
+
+#if defined(SIGINT)
+#define J9_SIGINT SIGINT
+#else /* defined(SIGINT) */
+#define J9_SIGINT J9_SIG_ERR
+#endif /* defined(SIGINT) */
+
+#if defined(SIGQUIT)
+#define J9_SIGQUIT SIGQUIT
+#else /* defined(SIGQUIT) */
+#define J9_SIGQUIT J9_SIG_ERR
+#endif /* defined(SIGQUIT) */
+
+#if defined(SIGILL)
+#define J9_SIGILL SIGILL
+#else /* defined(SIGILL) */
+#define J9_SIGILL J9_SIG_ERR
+#endif /* defined(SIGILL) */
+
+#if defined(SIGTRAP)
+#define J9_SIGTRAP SIGTRAP
+#else /* defined(SIGTRAP) */
+#define J9_SIGTRAP J9_SIG_ERR
+#endif /* defined(SIGTRAP) */
+
+#if defined(SIGABRT)
+#define J9_SIGABRT SIGABRT
+#else /* defined(SIGABRT) */
+#define J9_SIGABRT J9_SIG_ERR
+#endif /* defined(SIGABRT) */
+
+#if defined(SIGEMT)
+#define J9_SIGEMT SIGEMT
+#else /* defined(SIGEMT) */
+#define J9_SIGEMT J9_SIG_ERR
+#endif /* defined(SIGEMT) */
+
+#if defined(SIGFPE)
+#define J9_SIGFPE SIGFPE
+#else /* defined(SIGFPE) */
+#define J9_SIGFPE J9_SIG_ERR
+#endif /* defined(SIGFPE) */
+
+#if defined(SIGKILL)
+#define J9_SIGKILL SIGKILL
+#else /* defined(SIGKILL) */
+#define J9_SIGKILL J9_SIG_ERR
+#endif /* defined(SIGKILL) */
+
+#if defined(SIGBUS)
+#define J9_SIGBUS SIGBUS
+#else /* defined(SIGBUS) */
+#define J9_SIGBUS J9_SIG_ERR
+#endif /* defined(SIGBUS) */
+
+#if defined(SIGSEGV)
+#define J9_SIGSEGV SIGSEGV
+#else /* defined(SIGSEGV) */
+#define J9_SIGSEGV J9_SIG_ERR
+#endif /* defined(SIGSEGV) */
+
+#if defined(SIGSYS)
+#define J9_SIGSYS SIGSYS
+#else /* defined(SIGSYS) */
+#define J9_SIGSYS J9_SIG_ERR
+#endif /* defined(SIGSYS) */
+
+#if defined(SIGPIPE)
+#define J9_SIGPIPE SIGPIPE
+#else /* defined(SIGPIPE) */
+#define J9_SIGPIPE J9_SIG_ERR
+#endif /* defined(SIGPIPE) */
+
+#if defined(SIGALRM)
+#define J9_SIGALRM SIGALRM
+#else /* defined(SIGALRM) */
+#define J9_SIGALRM J9_SIG_ERR
+#endif /* defined(SIGALRM) */
+
+#if defined(SIGTERM)
+#define J9_SIGTERM SIGTERM
+#else /* defined(SIGTERM) */
+#define J9_SIGTERM J9_SIG_ERR
+#endif /* defined(SIGTERM) */
+
+#if defined(SIGURG)
+#define J9_SIGURG SIGURG
+#else /* defined(SIGURG) */
+#define J9_SIGURG J9_SIG_ERR
+#endif /* defined(SIGURG) */
+
+#if defined(SIGSTOP)
+#define J9_SIGSTOP SIGSTOP
+#else /* defined(SIGSTOP) */
+#define J9_SIGSTOP J9_SIG_ERR
+#endif /* defined(SIGSTOP) */
+
+#if defined(SIGTSTP)
+#define J9_SIGTSTP SIGTSTP
+#else /* defined(SIGTSTP) */
+#define J9_SIGTSTP J9_SIG_ERR
+#endif /* defined(SIGTSTP) */
+
+#if defined(SIGCONT)
+#define J9_SIGCONT SIGCONT
+#else /* defined(SIGCONT) */
+#define J9_SIGCONT J9_SIG_ERR
+#endif /* defined(SIGCONT) */
+
+#if defined(SIGCHLD)
+#define J9_SIGCHLD SIGCHLD
+#else /* defined(SIGCHLD) */
+#define J9_SIGCHLD J9_SIG_ERR
+#endif /* defined(SIGCHLD) */
+
+#if defined(SIGTTIN)
+#define J9_SIGTTIN SIGTTIN
+#else /* defined(SIGTTIN) */
+#define J9_SIGTTIN J9_SIG_ERR
+#endif /* defined(SIGTTIN) */
+
+#if defined(SIGTTOU)
+#define J9_SIGTTOU SIGTTOU
+#else /* defined(SIGTTOU) */
+#define J9_SIGTTOU J9_SIG_ERR
+#endif /* defined(SIGTTOU) */
+
+#if defined(SIGIO)
+#define J9_SIGIO SIGIO
+#else /* defined(SIGIO) */
+#define J9_SIGIO J9_SIG_ERR
+#endif /* defined(SIGIO) */
+
+#if defined(SIGXCPU)
+#define J9_SIGXCPU SIGXCPU
+#else /* defined(SIGXCPU) */
+#define J9_SIGXCPU J9_SIG_ERR
+#endif /* defined(SIGXCPU) */
+
+#if defined(SIGXFSZ)
+#define J9_SIGXFSZ SIGXFSZ
+#else /* defined(SIGXFSZ) */
+#define J9_SIGXFSZ J9_SIG_ERR
+#endif /* defined(SIGXFSZ) */
+
+#if defined(SIGMSG)
+#define J9_SIGMSG SIGMSG
+#else /* defined(SIGMSG) */
+#define J9_SIGMSG J9_SIG_ERR
+#endif /* defined(SIGMSG) */
+
+#if defined(SIGWINCH)
+#define J9_SIGWINCH SIGWINCH
+#else /* defined(SIGWINCH) */
+#define J9_SIGWINCH J9_SIG_ERR
+#endif /* defined(SIGWINCH) */
+
+#if defined(SIGPWR)
+#define J9_SIGPWR SIGPWR
+#else /* defined(SIGPWR) */
+#define J9_SIGPWR J9_SIG_ERR
+#endif /* defined(SIGPWR) */
+
+#if defined(SIGUSR1)
+#define J9_SIGUSR1 SIGUSR1
+#else /* defined(SIGUSR1) */
+#define J9_SIGUSR1 J9_SIG_ERR
+#endif /* defined(SIGUSR1) */
+
+#if defined(SIGUSR2)
+#define J9_SIGUSR2 SIGUSR2
+#else /* defined(SIGUSR2) */
+#define J9_SIGUSR2 J9_SIG_ERR
+#endif /* defined(SIGUSR2) */
+
+#if defined(SIGPROF)
+#define J9_SIGPROF SIGPROF
+#else /* defined(SIGPROF) */
+#define J9_SIGPROF J9_SIG_ERR
+#endif /* defined(SIGPROF) */
+
+#if defined(SIGDANGER)
+#define J9_SIGDANGER SIGDANGER
+#else /* defined(SIGDANGER) */
+#define J9_SIGDANGER J9_SIG_ERR
+#endif /* defined(SIGDANGER) */
+
+#if defined(SIGVTALRM)
+#define J9_SIGVTALRM SIGVTALRM
+#else /* defined(SIGVTALRM) */
+#define J9_SIGVTALRM J9_SIG_ERR
+#endif /* defined(SIGVTALRM) */
+
+#if defined(SIGMIGRATE)
+#define J9_SIGMIGRATE SIGMIGRATE
+#else /* defined(SIGMIGRATE) */
+#define J9_SIGMIGRATE J9_SIG_ERR
+#endif /* defined(SIGMIGRATE) */
+
+#if defined(SIGPRE)
+#define J9_SIGPRE SIGPRE
+#else /* defined(SIGPRE) */
+#define J9_SIGPRE J9_SIG_ERR
+#endif /* defined(SIGPRE) */
+
+#if defined(SIGCPUFAIL)
+#define J9_SIGCPUFAIL SIGCPUFAIL
+#else /* defined(SIGCPUFAIL) */
+#define J9_SIGCPUFAIL J9_SIG_ERR
+#endif /* defined(SIGCPUFAIL) */
+
+#if defined(SIGGRANT)
+#define J9_SIGGRANT SIGGRANT
+#else /* defined(SIGGRANT) */
+#define J9_SIGGRANT J9_SIG_ERR
+#endif /* defined(SIGGRANT) */
+
+#if defined(SIGRETRACT)
+#define J9_SIGRETRACT SIGRETRACT
+#else /* defined(SIGRETRACT) */
+#define J9_SIGRETRACT J9_SIG_ERR
+#endif /* defined(SIGRETRACT) */
+
+#if defined(SIGSOUND)
+#define J9_SIGSOUND SIGSOUND
+#else /* defined(SIGSOUND) */
+#define J9_SIGSOUND J9_SIG_ERR
+#endif /* defined(SIGSOUND) */
+
+#if defined(SIGSAK)
+#define J9_SIGSAK SIGSAK
+#else /* defined(SIGSAK) */
+#define J9_SIGSAK J9_SIG_ERR
+#endif /* defined(SIGSAK) */
+
+#if defined(SIGPOLL)
+#define J9_SIGPOLL SIGPOLL
+#else /* defined(SIGPOLL) */
+#define J9_SIGPOLL J9_SIG_ERR
+#endif /* defined(SIGPOLL) */
+
+#if defined(SIGINFO)
+#define J9_SIGINFO SIGINFO
+#else /* defined(SIGINFO) */
+#define J9_SIGINFO J9_SIG_ERR
+#endif /* defined(SIGINFO) */
+
+#if defined(SIGSTKFLT)
+#define J9_SIGSTKFLT SIGSTKFLT
+#else /* defined(SIGSTKFLT) */
+#define J9_SIGSTKFLT J9_SIG_ERR
+#endif /* defined(SIGSTKFLT) */
+
+#if defined(SIGBREAK)
+#define J9_SIGBREAK SIGBREAK
+#else /* defined(SIGBREAK) */
+#define J9_SIGBREAK J9_SIG_ERR
+#endif /* defined(SIGBREAK) */
+
+#if defined(SIGUNUSED)
+#define J9_SIGUNUSED SIGUNUSED
+#else /* defined(SIGUNUSED) */
+#define J9_SIGUNUSED J9_SIG_ERR
+#endif /* defined(SIGUNUSED) */
+
+#define J9_IS_SIGNAL_SPECIAL(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGQUIT) || (SIG_NUM == J9_SIGHUP) || (SIG_NUM == J9_SIGINT) || (SIG_NUM == J9_SIGTERM)))
+#define J9_IS_SIGNAL_USED_BY_VM(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGFPE) || (SIG_NUM == J9_SIGILL) || (SIG_NUM == J9_SIGSEGV)))
+
+#define J9_PRE_DEFINED_HANDLER_CHECK 2
+#define J9_OLDHANDLER_SAME_AS_NEWHANDLER 2
+
+#define J9_SIG_PREFIX ""SIG""
+#define J9_SIG_PREFIX_LENGTH 3
+
+static void dummySignalHandler(jint sigNum);
+
+typedef struct {
+char *signalName;",fixed.,
73240462,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,False,"@@ -4234,95 +4571,201 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_NO_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+/* Register the signal */
+#if defined(WIN32)
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+handler = (void *)dummySignalHandler;
+}
+oldHandler = OMRSIG_SIGNAL(sigNum, handler);
+#else /* defined(WIN32) */
+sigemptyset(&newSignalAction.sa_mask);
+#if !defined(J9ZTPF)
+newSignalAction.sa_flags = SA_RESTART;
+#else /* !defined(J9ZTPF) */
+newSignalAction.sa_flags = 0;
+#endif /* !defined(J9ZTPF) */
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+newSignalAction.sa_handler = (void (*)(int))dummySignalHandler;
+} else {
+newSignalAction.sa_handler = (void (*)(int))handler;
+}
+OMRSIG_SIGACTION(sigNum, &newSignalAction, &oldSignalAction);
+#endif /* defined(WIN32) */
+}
+}
+
+#if defined(WIN32)
+if (((void *)J9_SIG_ERR != oldHandler) && (handler == oldHandler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldHandler;
+}
+#else /* defined(WIN32) */
+if ((NULL != oldSignalAction.sa_handler)
+&& (newSignalAction.sa_handler == oldSignalAction.sa_handler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldSignalAction.sa_handler;
+}
+#endif /* defined(WIN32) */
+
+return oldHandler;
 }
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Return the integer value of the signal given the name of the
+ *  signal.
+ *
+ *  @param  sigName Name of the signal
+ *
+ *  @returns Integer value of the signal on success
+ *           J9_SIG_ERR (-1) on failure
+ *
+ *DLL: jvm
  */
 jint JNICALL
 JVM_FindSignal(const char* sigName)
 {
+const J9SignalMapping *mapping = NULL;
+jint signalValue = J9_SIG_ERR;
+BOOLEAN nameHasSigPrefix = FALSE;
+char nameWithSIGPrefix[64] = {0};
 
 Trc_SC_FindSignal_Entry(sigName);
 
-#define J9_MAP_SIGNAL(ID) ID##U
-#define J9_RETURN_SIGNAL(ID) \
-const int ID##U = -1; Trc_SC_FindSignal_Exit(J9_MAP_SIGNAL(ID)); return J9_MAP_SIGNAL(ID);
-#define J9_MATCH_SIGNAL(ID) \
-if (strcmp(sigName, #ID) == 0) {J9_RETURN_SIGNAL(SIG##ID)}
-
-/* POSIX */
-J9_MATCH_SIGNAL(HUP)
-J9_MATCH_SIGNAL(INT)
-J9_MATCH_SIGNAL(QUIT)
-J9_MATCH_SIGNAL(ABRT)
-J9_MATCH_SIGNAL(KILL)
-J9_MATCH_SIGNAL(ALRM)
-J9_MATCH_SIGNAL(TERM)
-
-/* POSIX 1003.1-2001 */
-J9_MATCH_SIGNAL(BUS)
-J9_MATCH_SIGNAL(CHLD)
-J9_MATCH_SIGNAL(CONT)
-J9_MATCH_SIGNAL(FPE)
-J9_MATCH_SIGNAL(ILL)
-J9_MATCH_SIGNAL(PIPE)
-J9_MATCH_SIGNAL(SEGV)
-J9_MATCH_SIGNAL(STOP)
-J9_MATCH_SIGNAL(TSTP)
-J9_MATCH_SIGNAL(TTIN)
-J9_MATCH_SIGNAL(TTOU)
-J9_MATCH_SIGNAL(URG)
-J9_MATCH_SIGNAL(USR1)
-J9_MATCH_SIGNAL(USR2)
-
-/* POSIX 1003.1-2001 with XSI */
-J9_MATCH_SIGNAL(POLL)
-J9_MATCH_SIGNAL(PROF)
-J9_MATCH_SIGNAL(SYS)
-J9_MATCH_SIGNAL(TRAP)
-J9_MATCH_SIGNAL(VTALRM)
-J9_MATCH_SIGNAL(XCPU)
-J9_MATCH_SIGNAL(XFSZ)
-
-/* Miscellaneous */
-J9_MATCH_SIGNAL(IO)
-J9_MATCH_SIGNAL(WINCH)
-J9_MATCH_SIGNAL(PWR)
-J9_MATCH_SIGNAL(UNUSED)
-J9_MATCH_SIGNAL(BREAK)
-
-Trc_SC_FindSignal_Exit(-1);
-return -1;
+if (NULL != sigName) {
+mapping = signalMap;
+
+if (0 == strncmp(sigName, J9_SIG_PREFIX, J9_SIG_PREFIX_LENGTH)) {
+nameHasSigPrefix = TRUE;
+} else {
+strcpy(nameWithSIGPrefix, J9_SIG_PREFIX);
+strcat(nameWithSIGPrefix, sigName);",This needs bounds checking to make sure we don't write outside the array `nameWithSIGPrefix`.,
73275772,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,True,"@@ -4234,95 +4571,201 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_NO_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+/* Register the signal */
+#if defined(WIN32)
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+handler = (void *)dummySignalHandler;
+}
+oldHandler = OMRSIG_SIGNAL(sigNum, handler);
+#else /* defined(WIN32) */
+sigemptyset(&newSignalAction.sa_mask);
+#if !defined(J9ZTPF)
+newSignalAction.sa_flags = SA_RESTART;
+#else /* !defined(J9ZTPF) */
+newSignalAction.sa_flags = 0;
+#endif /* !defined(J9ZTPF) */
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+newSignalAction.sa_handler = (void (*)(int))dummySignalHandler;
+} else {
+newSignalAction.sa_handler = (void (*)(int))handler;
+}
+OMRSIG_SIGACTION(sigNum, &newSignalAction, &oldSignalAction);
+#endif /* defined(WIN32) */
+}
+}
+
+#if defined(WIN32)
+if (((void *)J9_SIG_ERR != oldHandler) && (handler == oldHandler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldHandler;
+}
+#else /* defined(WIN32) */
+if ((NULL != oldSignalAction.sa_handler)
+&& (newSignalAction.sa_handler == oldSignalAction.sa_handler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldSignalAction.sa_handler;
+}
+#endif /* defined(WIN32) */
+
+return oldHandler;
 }
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Return the integer value of the signal given the name of the
+ *  signal.
+ *
+ *  @param  sigName Name of the signal
+ *
+ *  @returns Integer value of the signal on success
+ *           J9_SIG_ERR (-1) on failure
+ *
+ *DLL: jvm
  */
 jint JNICALL
 JVM_FindSignal(const char* sigName)
 {
+const J9SignalMapping *mapping = NULL;
+jint signalValue = J9_SIG_ERR;
+BOOLEAN nameHasSigPrefix = FALSE;
+char nameWithSIGPrefix[64] = {0};
 
 Trc_SC_FindSignal_Entry(sigName);
 
-#define J9_MAP_SIGNAL(ID) ID##U
-#define J9_RETURN_SIGNAL(ID) \
-const int ID##U = -1; Trc_SC_FindSignal_Exit(J9_MAP_SIGNAL(ID)); return J9_MAP_SIGNAL(ID);
-#define J9_MATCH_SIGNAL(ID) \
-if (strcmp(sigName, #ID) == 0) {J9_RETURN_SIGNAL(SIG##ID)}
-
-/* POSIX */
-J9_MATCH_SIGNAL(HUP)
-J9_MATCH_SIGNAL(INT)
-J9_MATCH_SIGNAL(QUIT)
-J9_MATCH_SIGNAL(ABRT)
-J9_MATCH_SIGNAL(KILL)
-J9_MATCH_SIGNAL(ALRM)
-J9_MATCH_SIGNAL(TERM)
-
-/* POSIX 1003.1-2001 */
-J9_MATCH_SIGNAL(BUS)
-J9_MATCH_SIGNAL(CHLD)
-J9_MATCH_SIGNAL(CONT)
-J9_MATCH_SIGNAL(FPE)
-J9_MATCH_SIGNAL(ILL)
-J9_MATCH_SIGNAL(PIPE)
-J9_MATCH_SIGNAL(SEGV)
-J9_MATCH_SIGNAL(STOP)
-J9_MATCH_SIGNAL(TSTP)
-J9_MATCH_SIGNAL(TTIN)
-J9_MATCH_SIGNAL(TTOU)
-J9_MATCH_SIGNAL(URG)
-J9_MATCH_SIGNAL(USR1)
-J9_MATCH_SIGNAL(USR2)
-
-/* POSIX 1003.1-2001 with XSI */
-J9_MATCH_SIGNAL(POLL)
-J9_MATCH_SIGNAL(PROF)
-J9_MATCH_SIGNAL(SYS)
-J9_MATCH_SIGNAL(TRAP)
-J9_MATCH_SIGNAL(VTALRM)
-J9_MATCH_SIGNAL(XCPU)
-J9_MATCH_SIGNAL(XFSZ)
-
-/* Miscellaneous */
-J9_MATCH_SIGNAL(IO)
-J9_MATCH_SIGNAL(WINCH)
-J9_MATCH_SIGNAL(PWR)
-J9_MATCH_SIGNAL(UNUSED)
-J9_MATCH_SIGNAL(BREAK)
-
-Trc_SC_FindSignal_Exit(-1);
-return -1;
+if (NULL != sigName) {
+mapping = signalMap;
+
+if (0 == strncmp(sigName, J9_SIG_PREFIX, J9_SIG_PREFIX_LENGTH)) {
+nameHasSigPrefix = TRUE;
+} else {
+strcpy(nameWithSIGPrefix, J9_SIG_PREFIX);
+strcat(nameWithSIGPrefix, sigName);",fixed.,
73323910,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,False,"@@ -4234,95 +4579,208 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_NO_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+/* Register the signal */
+#if defined(WIN32)
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+handler = (void *)dummySignalHandler;
+}
+oldHandler = OMRSIG_SIGNAL(sigNum, handler);
+#else /* defined(WIN32) */
+sigemptyset(&newSignalAction.sa_mask);
+#if !defined(J9ZTPF)
+newSignalAction.sa_flags = SA_RESTART;
+#else /* !defined(J9ZTPF) */
+newSignalAction.sa_flags = 0;
+#endif /* !defined(J9ZTPF) */
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+newSignalAction.sa_handler = (void (*)(int))dummySignalHandler;
+} else {
+newSignalAction.sa_handler = (void (*)(int))handler;
+}
+OMRSIG_SIGACTION(sigNum, &newSignalAction, &oldSignalAction);
+#endif /* defined(WIN32) */
+}
+}
+
+#if defined(WIN32)
+if (((void *)J9_SIG_ERR != oldHandler) && (handler == oldHandler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldHandler;
+}
+#else /* defined(WIN32) */
+if ((NULL != oldSignalAction.sa_handler)
+&& (newSignalAction.sa_handler == oldSignalAction.sa_handler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldSignalAction.sa_handler;
+}
+#endif /* defined(WIN32) */
+
+return oldHandler;
 }
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Return the integer value of the signal given the name of the
+ *  signal.
+ *
+ *  @param  sigName Name of the signal
+ *
+ *  @returns Integer value of the signal on success
+ *           J9_SIG_ERR (-1) on failure
+ *
+ *DLL: jvm
  */
 jint JNICALL
-JVM_FindSignal(const char* sigName)
+JVM_FindSignal(const char *sigName)
 {
+const J9SignalMapping *mapping = NULL;
+jint signalValue = J9_SIG_ERR;
+BOOLEAN nameHasSigPrefix = FALSE;
+const char *fullSigName = sigName;
+#if !defined(WIN32)
+char nameWithSIGPrefix[J9_SIGNAME_BUFFER_LENGTH] = {0};
+#endif /* !defined(WIN32) */
 
 Trc_SC_FindSignal_Entry(sigName);
 
-#define J9_MAP_SIGNAL(ID) ID##U
-#define J9_RETURN_SIGNAL(ID) \
-const int ID##U = -1; Trc_SC_FindSignal_Exit(J9_MAP_SIGNAL(ID)); return J9_MAP_SIGNAL(ID);
-#define J9_MATCH_SIGNAL(ID) \
-if (strcmp(sigName, #ID) == 0) {J9_RETURN_SIGNAL(SIG##ID)}
-
-/* POSIX */
-J9_MATCH_SIGNAL(HUP)
-J9_MATCH_SIGNAL(INT)
-J9_MATCH_SIGNAL(QUIT)
-J9_MATCH_SIGNAL(ABRT)
-J9_MATCH_SIGNAL(KILL)
-J9_MATCH_SIGNAL(ALRM)
-J9_MATCH_SIGNAL(TERM)
-
-/* POSIX 1003.1-2001 */
-J9_MATCH_SIGNAL(BUS)
-J9_MATCH_SIGNAL(CHLD)
-J9_MATCH_SIGNAL(CONT)
-J9_MATCH_SIGNAL(FPE)
-J9_MATCH_SIGNAL(ILL)
-J9_MATCH_SIGNAL(PIPE)
-J9_MATCH_SIGNAL(SEGV)
-J9_MATCH_SIGNAL(STOP)
-J9_MATCH_SIGNAL(TSTP)
-J9_MATCH_SIGNAL(TTIN)
-J9_MATCH_SIGNAL(TTOU)
-J9_MATCH_SIGNAL(URG)
-J9_MATCH_SIGNAL(USR1)
-J9_MATCH_SIGNAL(USR2)
-
-/* POSIX 1003.1-2001 with XSI */
-J9_MATCH_SIGNAL(POLL)
-J9_MATCH_SIGNAL(PROF)
-J9_MATCH_SIGNAL(SYS)
-J9_MATCH_SIGNAL(TRAP)
-J9_MATCH_SIGNAL(VTALRM)
-J9_MATCH_SIGNAL(XCPU)
-J9_MATCH_SIGNAL(XFSZ)
-
-/* Miscellaneous */
-J9_MATCH_SIGNAL(IO)
-J9_MATCH_SIGNAL(WINCH)
-J9_MATCH_SIGNAL(PWR)
-J9_MATCH_SIGNAL(UNUSED)
-J9_MATCH_SIGNAL(BREAK)
-
-Trc_SC_FindSignal_Exit(-1);
-return -1;
+if (NULL != fullSigName) {
+mapping = signalMap;
+size_t sigPrefixLength = strlen(J9_SIG_PREFIX);","This isn't valid C code: declarations must be at beginning of the block.
(the assignment could move into the initializer of a `for` loop replacing the `while` loop below.)",
73324231,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,False,"@@ -4234,95 +4579,208 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_NO_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+/* Register the signal */
+#if defined(WIN32)
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+handler = (void *)dummySignalHandler;
+}
+oldHandler = OMRSIG_SIGNAL(sigNum, handler);
+#else /* defined(WIN32) */
+sigemptyset(&newSignalAction.sa_mask);
+#if !defined(J9ZTPF)
+newSignalAction.sa_flags = SA_RESTART;
+#else /* !defined(J9ZTPF) */
+newSignalAction.sa_flags = 0;
+#endif /* !defined(J9ZTPF) */
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+newSignalAction.sa_handler = (void (*)(int))dummySignalHandler;
+} else {
+newSignalAction.sa_handler = (void (*)(int))handler;
+}
+OMRSIG_SIGACTION(sigNum, &newSignalAction, &oldSignalAction);
+#endif /* defined(WIN32) */
+}
+}
+
+#if defined(WIN32)
+if (((void *)J9_SIG_ERR != oldHandler) && (handler == oldHandler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldHandler;
+}
+#else /* defined(WIN32) */
+if ((NULL != oldSignalAction.sa_handler)
+&& (newSignalAction.sa_handler == oldSignalAction.sa_handler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldSignalAction.sa_handler;
+}
+#endif /* defined(WIN32) */
+
+return oldHandler;
 }
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Return the integer value of the signal given the name of the
+ *  signal.
+ *
+ *  @param  sigName Name of the signal
+ *
+ *  @returns Integer value of the signal on success
+ *           J9_SIG_ERR (-1) on failure
+ *
+ *DLL: jvm
  */
 jint JNICALL
-JVM_FindSignal(const char* sigName)
+JVM_FindSignal(const char *sigName)
 {
+const J9SignalMapping *mapping = NULL;
+jint signalValue = J9_SIG_ERR;
+BOOLEAN nameHasSigPrefix = FALSE;
+const char *fullSigName = sigName;
+#if !defined(WIN32)
+char nameWithSIGPrefix[J9_SIGNAME_BUFFER_LENGTH] = {0};
+#endif /* !defined(WIN32) */
 
 Trc_SC_FindSignal_Entry(sigName);
 
-#define J9_MAP_SIGNAL(ID) ID##U
-#define J9_RETURN_SIGNAL(ID) \
-const int ID##U = -1; Trc_SC_FindSignal_Exit(J9_MAP_SIGNAL(ID)); return J9_MAP_SIGNAL(ID);
-#define J9_MATCH_SIGNAL(ID) \
-if (strcmp(sigName, #ID) == 0) {J9_RETURN_SIGNAL(SIG##ID)}
-
-/* POSIX */
-J9_MATCH_SIGNAL(HUP)
-J9_MATCH_SIGNAL(INT)
-J9_MATCH_SIGNAL(QUIT)
-J9_MATCH_SIGNAL(ABRT)
-J9_MATCH_SIGNAL(KILL)
-J9_MATCH_SIGNAL(ALRM)
-J9_MATCH_SIGNAL(TERM)
-
-/* POSIX 1003.1-2001 */
-J9_MATCH_SIGNAL(BUS)
-J9_MATCH_SIGNAL(CHLD)
-J9_MATCH_SIGNAL(CONT)
-J9_MATCH_SIGNAL(FPE)
-J9_MATCH_SIGNAL(ILL)
-J9_MATCH_SIGNAL(PIPE)
-J9_MATCH_SIGNAL(SEGV)
-J9_MATCH_SIGNAL(STOP)
-J9_MATCH_SIGNAL(TSTP)
-J9_MATCH_SIGNAL(TTIN)
-J9_MATCH_SIGNAL(TTOU)
-J9_MATCH_SIGNAL(URG)
-J9_MATCH_SIGNAL(USR1)
-J9_MATCH_SIGNAL(USR2)
-
-/* POSIX 1003.1-2001 with XSI */
-J9_MATCH_SIGNAL(POLL)
-J9_MATCH_SIGNAL(PROF)
-J9_MATCH_SIGNAL(SYS)
-J9_MATCH_SIGNAL(TRAP)
-J9_MATCH_SIGNAL(VTALRM)
-J9_MATCH_SIGNAL(XCPU)
-J9_MATCH_SIGNAL(XFSZ)
-
-/* Miscellaneous */
-J9_MATCH_SIGNAL(IO)
-J9_MATCH_SIGNAL(WINCH)
-J9_MATCH_SIGNAL(PWR)
-J9_MATCH_SIGNAL(UNUSED)
-J9_MATCH_SIGNAL(BREAK)
-
-Trc_SC_FindSignal_Exit(-1);
-return -1;
+if (NULL != fullSigName) {",I think this would be clearer if it used `sigName`.,
73381693,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,True,"@@ -4234,95 +4579,208 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_NO_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+/* Register the signal */
+#if defined(WIN32)
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+handler = (void *)dummySignalHandler;
+}
+oldHandler = OMRSIG_SIGNAL(sigNum, handler);
+#else /* defined(WIN32) */
+sigemptyset(&newSignalAction.sa_mask);
+#if !defined(J9ZTPF)
+newSignalAction.sa_flags = SA_RESTART;
+#else /* !defined(J9ZTPF) */
+newSignalAction.sa_flags = 0;
+#endif /* !defined(J9ZTPF) */
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+newSignalAction.sa_handler = (void (*)(int))dummySignalHandler;
+} else {
+newSignalAction.sa_handler = (void (*)(int))handler;
+}
+OMRSIG_SIGACTION(sigNum, &newSignalAction, &oldSignalAction);
+#endif /* defined(WIN32) */
+}
+}
+
+#if defined(WIN32)
+if (((void *)J9_SIG_ERR != oldHandler) && (handler == oldHandler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldHandler;
+}
+#else /* defined(WIN32) */
+if ((NULL != oldSignalAction.sa_handler)
+&& (newSignalAction.sa_handler == oldSignalAction.sa_handler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldSignalAction.sa_handler;
+}
+#endif /* defined(WIN32) */
+
+return oldHandler;
 }
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Return the integer value of the signal given the name of the
+ *  signal.
+ *
+ *  @param  sigName Name of the signal
+ *
+ *  @returns Integer value of the signal on success
+ *           J9_SIG_ERR (-1) on failure
+ *
+ *DLL: jvm
  */
 jint JNICALL
-JVM_FindSignal(const char* sigName)
+JVM_FindSignal(const char *sigName)
 {
+const J9SignalMapping *mapping = NULL;
+jint signalValue = J9_SIG_ERR;
+BOOLEAN nameHasSigPrefix = FALSE;
+const char *fullSigName = sigName;
+#if !defined(WIN32)
+char nameWithSIGPrefix[J9_SIGNAME_BUFFER_LENGTH] = {0};
+#endif /* !defined(WIN32) */
 
 Trc_SC_FindSignal_Entry(sigName);
 
-#define J9_MAP_SIGNAL(ID) ID##U
-#define J9_RETURN_SIGNAL(ID) \
-const int ID##U = -1; Trc_SC_FindSignal_Exit(J9_MAP_SIGNAL(ID)); return J9_MAP_SIGNAL(ID);
-#define J9_MATCH_SIGNAL(ID) \
-if (strcmp(sigName, #ID) == 0) {J9_RETURN_SIGNAL(SIG##ID)}
-
-/* POSIX */
-J9_MATCH_SIGNAL(HUP)
-J9_MATCH_SIGNAL(INT)
-J9_MATCH_SIGNAL(QUIT)
-J9_MATCH_SIGNAL(ABRT)
-J9_MATCH_SIGNAL(KILL)
-J9_MATCH_SIGNAL(ALRM)
-J9_MATCH_SIGNAL(TERM)
-
-/* POSIX 1003.1-2001 */
-J9_MATCH_SIGNAL(BUS)
-J9_MATCH_SIGNAL(CHLD)
-J9_MATCH_SIGNAL(CONT)
-J9_MATCH_SIGNAL(FPE)
-J9_MATCH_SIGNAL(ILL)
-J9_MATCH_SIGNAL(PIPE)
-J9_MATCH_SIGNAL(SEGV)
-J9_MATCH_SIGNAL(STOP)
-J9_MATCH_SIGNAL(TSTP)
-J9_MATCH_SIGNAL(TTIN)
-J9_MATCH_SIGNAL(TTOU)
-J9_MATCH_SIGNAL(URG)
-J9_MATCH_SIGNAL(USR1)
-J9_MATCH_SIGNAL(USR2)
-
-/* POSIX 1003.1-2001 with XSI */
-J9_MATCH_SIGNAL(POLL)
-J9_MATCH_SIGNAL(PROF)
-J9_MATCH_SIGNAL(SYS)
-J9_MATCH_SIGNAL(TRAP)
-J9_MATCH_SIGNAL(VTALRM)
-J9_MATCH_SIGNAL(XCPU)
-J9_MATCH_SIGNAL(XFSZ)
-
-/* Miscellaneous */
-J9_MATCH_SIGNAL(IO)
-J9_MATCH_SIGNAL(WINCH)
-J9_MATCH_SIGNAL(PWR)
-J9_MATCH_SIGNAL(UNUSED)
-J9_MATCH_SIGNAL(BREAK)
-
-Trc_SC_FindSignal_Exit(-1);
-return -1;
+if (NULL != fullSigName) {
+mapping = signalMap;
+size_t sigPrefixLength = strlen(J9_SIG_PREFIX);",fixed.,
73381696,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,True,"@@ -4234,95 +4579,208 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_NO_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+/* Register the signal */
+#if defined(WIN32)
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+handler = (void *)dummySignalHandler;
+}
+oldHandler = OMRSIG_SIGNAL(sigNum, handler);
+#else /* defined(WIN32) */
+sigemptyset(&newSignalAction.sa_mask);
+#if !defined(J9ZTPF)
+newSignalAction.sa_flags = SA_RESTART;
+#else /* !defined(J9ZTPF) */
+newSignalAction.sa_flags = 0;
+#endif /* !defined(J9ZTPF) */
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+newSignalAction.sa_handler = (void (*)(int))dummySignalHandler;
+} else {
+newSignalAction.sa_handler = (void (*)(int))handler;
+}
+OMRSIG_SIGACTION(sigNum, &newSignalAction, &oldSignalAction);
+#endif /* defined(WIN32) */
+}
+}
+
+#if defined(WIN32)
+if (((void *)J9_SIG_ERR != oldHandler) && (handler == oldHandler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldHandler;
+}
+#else /* defined(WIN32) */
+if ((NULL != oldSignalAction.sa_handler)
+&& (newSignalAction.sa_handler == oldSignalAction.sa_handler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldSignalAction.sa_handler;
+}
+#endif /* defined(WIN32) */
+
+return oldHandler;
 }
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Return the integer value of the signal given the name of the
+ *  signal.
+ *
+ *  @param  sigName Name of the signal
+ *
+ *  @returns Integer value of the signal on success
+ *           J9_SIG_ERR (-1) on failure
+ *
+ *DLL: jvm
  */
 jint JNICALL
-JVM_FindSignal(const char* sigName)
+JVM_FindSignal(const char *sigName)
 {
+const J9SignalMapping *mapping = NULL;
+jint signalValue = J9_SIG_ERR;
+BOOLEAN nameHasSigPrefix = FALSE;
+const char *fullSigName = sigName;
+#if !defined(WIN32)
+char nameWithSIGPrefix[J9_SIGNAME_BUFFER_LENGTH] = {0};
+#endif /* !defined(WIN32) */
 
 Trc_SC_FindSignal_Entry(sigName);
 
-#define J9_MAP_SIGNAL(ID) ID##U
-#define J9_RETURN_SIGNAL(ID) \
-const int ID##U = -1; Trc_SC_FindSignal_Exit(J9_MAP_SIGNAL(ID)); return J9_MAP_SIGNAL(ID);
-#define J9_MATCH_SIGNAL(ID) \
-if (strcmp(sigName, #ID) == 0) {J9_RETURN_SIGNAL(SIG##ID)}
-
-/* POSIX */
-J9_MATCH_SIGNAL(HUP)
-J9_MATCH_SIGNAL(INT)
-J9_MATCH_SIGNAL(QUIT)
-J9_MATCH_SIGNAL(ABRT)
-J9_MATCH_SIGNAL(KILL)
-J9_MATCH_SIGNAL(ALRM)
-J9_MATCH_SIGNAL(TERM)
-
-/* POSIX 1003.1-2001 */
-J9_MATCH_SIGNAL(BUS)
-J9_MATCH_SIGNAL(CHLD)
-J9_MATCH_SIGNAL(CONT)
-J9_MATCH_SIGNAL(FPE)
-J9_MATCH_SIGNAL(ILL)
-J9_MATCH_SIGNAL(PIPE)
-J9_MATCH_SIGNAL(SEGV)
-J9_MATCH_SIGNAL(STOP)
-J9_MATCH_SIGNAL(TSTP)
-J9_MATCH_SIGNAL(TTIN)
-J9_MATCH_SIGNAL(TTOU)
-J9_MATCH_SIGNAL(URG)
-J9_MATCH_SIGNAL(USR1)
-J9_MATCH_SIGNAL(USR2)
-
-/* POSIX 1003.1-2001 with XSI */
-J9_MATCH_SIGNAL(POLL)
-J9_MATCH_SIGNAL(PROF)
-J9_MATCH_SIGNAL(SYS)
-J9_MATCH_SIGNAL(TRAP)
-J9_MATCH_SIGNAL(VTALRM)
-J9_MATCH_SIGNAL(XCPU)
-J9_MATCH_SIGNAL(XFSZ)
-
-/* Miscellaneous */
-J9_MATCH_SIGNAL(IO)
-J9_MATCH_SIGNAL(WINCH)
-J9_MATCH_SIGNAL(PWR)
-J9_MATCH_SIGNAL(UNUSED)
-J9_MATCH_SIGNAL(BREAK)
-
-Trc_SC_FindSignal_Exit(-1);
-return -1;
+if (NULL != fullSigName) {",fixed.,
73484119,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,False,"@@ -322,6 +322,351 @@ static BOOLEAN librariesLoaded(void);
 #define LD_ENV_PATH ""LIBPATH""
 #endif /* defined(J9ZTPF) */
 
+#define J9_SIG_ERR -1
+
+#if defined(SIGHUP)
+#define J9_SIGHUP SIGHUP
+#else /* defined(SIGHUP) */
+#define J9_SIGHUP J9_SIG_ERR
+#endif /* defined(SIGHUP) */
+
+#if defined(SIGINT)
+#define J9_SIGINT SIGINT
+#else /* defined(SIGINT) */
+#define J9_SIGINT J9_SIG_ERR
+#endif /* defined(SIGINT) */","Rather than defining all these `J9_SIG*` macros, I suggest the entries in the table below should be conditional on whether the corresponding signal macro is defined (mapping strings to `J9_SIG_ERR` is not helpful).",
73485055,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,False,"@@ -322,6 +322,351 @@ static BOOLEAN librariesLoaded(void);
 #define LD_ENV_PATH ""LIBPATH""
 #endif /* defined(J9ZTPF) */
 
+#define J9_SIG_ERR -1
+
+#if defined(SIGHUP)
+#define J9_SIGHUP SIGHUP
+#else /* defined(SIGHUP) */
+#define J9_SIGHUP J9_SIG_ERR
+#endif /* defined(SIGHUP) */
+
+#if defined(SIGINT)
+#define J9_SIGINT SIGINT
+#else /* defined(SIGINT) */
+#define J9_SIGINT J9_SIG_ERR
+#endif /* defined(SIGINT) */
+
+#if defined(SIGQUIT)
+#define J9_SIGQUIT SIGQUIT
+#else /* defined(SIGQUIT) */
+#define J9_SIGQUIT J9_SIG_ERR
+#endif /* defined(SIGQUIT) */
+
+#if defined(SIGILL)
+#define J9_SIGILL SIGILL
+#else /* defined(SIGILL) */
+#define J9_SIGILL J9_SIG_ERR
+#endif /* defined(SIGILL) */
+
+#if defined(SIGTRAP)
+#define J9_SIGTRAP SIGTRAP
+#else /* defined(SIGTRAP) */
+#define J9_SIGTRAP J9_SIG_ERR
+#endif /* defined(SIGTRAP) */
+
+#if defined(SIGABRT)
+#define J9_SIGABRT SIGABRT
+#else /* defined(SIGABRT) */
+#define J9_SIGABRT J9_SIG_ERR
+#endif /* defined(SIGABRT) */
+
+#if defined(SIGEMT)
+#define J9_SIGEMT SIGEMT
+#else /* defined(SIGEMT) */
+#define J9_SIGEMT J9_SIG_ERR
+#endif /* defined(SIGEMT) */
+
+#if defined(SIGFPE)
+#define J9_SIGFPE SIGFPE
+#else /* defined(SIGFPE) */
+#define J9_SIGFPE J9_SIG_ERR
+#endif /* defined(SIGFPE) */
+
+#if defined(SIGKILL)
+#define J9_SIGKILL SIGKILL
+#else /* defined(SIGKILL) */
+#define J9_SIGKILL J9_SIG_ERR
+#endif /* defined(SIGKILL) */
+
+#if defined(SIGBUS)
+#define J9_SIGBUS SIGBUS
+#else /* defined(SIGBUS) */
+#define J9_SIGBUS J9_SIG_ERR
+#endif /* defined(SIGBUS) */
+
+#if defined(SIGSEGV)
+#define J9_SIGSEGV SIGSEGV
+#else /* defined(SIGSEGV) */
+#define J9_SIGSEGV J9_SIG_ERR
+#endif /* defined(SIGSEGV) */
+
+#if defined(SIGSYS)
+#define J9_SIGSYS SIGSYS
+#else /* defined(SIGSYS) */
+#define J9_SIGSYS J9_SIG_ERR
+#endif /* defined(SIGSYS) */
+
+#if defined(SIGPIPE)
+#define J9_SIGPIPE SIGPIPE
+#else /* defined(SIGPIPE) */
+#define J9_SIGPIPE J9_SIG_ERR
+#endif /* defined(SIGPIPE) */
+
+#if defined(SIGALRM)
+#define J9_SIGALRM SIGALRM
+#else /* defined(SIGALRM) */
+#define J9_SIGALRM J9_SIG_ERR
+#endif /* defined(SIGALRM) */
+
+#if defined(SIGTERM)
+#define J9_SIGTERM SIGTERM
+#else /* defined(SIGTERM) */
+#define J9_SIGTERM J9_SIG_ERR
+#endif /* defined(SIGTERM) */
+
+#if defined(SIGURG)
+#define J9_SIGURG SIGURG
+#else /* defined(SIGURG) */
+#define J9_SIGURG J9_SIG_ERR
+#endif /* defined(SIGURG) */
+
+#if defined(SIGSTOP)
+#define J9_SIGSTOP SIGSTOP
+#else /* defined(SIGSTOP) */
+#define J9_SIGSTOP J9_SIG_ERR
+#endif /* defined(SIGSTOP) */
+
+#if defined(SIGTSTP)
+#define J9_SIGTSTP SIGTSTP
+#else /* defined(SIGTSTP) */
+#define J9_SIGTSTP J9_SIG_ERR
+#endif /* defined(SIGTSTP) */
+
+#if defined(SIGCONT)
+#define J9_SIGCONT SIGCONT
+#else /* defined(SIGCONT) */
+#define J9_SIGCONT J9_SIG_ERR
+#endif /* defined(SIGCONT) */
+
+#if defined(SIGCHLD)
+#define J9_SIGCHLD SIGCHLD
+#else /* defined(SIGCHLD) */
+#define J9_SIGCHLD J9_SIG_ERR
+#endif /* defined(SIGCHLD) */
+
+#if defined(SIGTTIN)
+#define J9_SIGTTIN SIGTTIN
+#else /* defined(SIGTTIN) */
+#define J9_SIGTTIN J9_SIG_ERR
+#endif /* defined(SIGTTIN) */
+
+#if defined(SIGTTOU)
+#define J9_SIGTTOU SIGTTOU
+#else /* defined(SIGTTOU) */
+#define J9_SIGTTOU J9_SIG_ERR
+#endif /* defined(SIGTTOU) */
+
+#if defined(SIGIO)
+#define J9_SIGIO SIGIO
+#else /* defined(SIGIO) */
+#define J9_SIGIO J9_SIG_ERR
+#endif /* defined(SIGIO) */
+
+#if defined(SIGXCPU)
+#define J9_SIGXCPU SIGXCPU
+#else /* defined(SIGXCPU) */
+#define J9_SIGXCPU J9_SIG_ERR
+#endif /* defined(SIGXCPU) */
+
+#if defined(SIGXFSZ)
+#define J9_SIGXFSZ SIGXFSZ
+#else /* defined(SIGXFSZ) */
+#define J9_SIGXFSZ J9_SIG_ERR
+#endif /* defined(SIGXFSZ) */
+
+#if defined(SIGMSG)
+#define J9_SIGMSG SIGMSG
+#else /* defined(SIGMSG) */
+#define J9_SIGMSG J9_SIG_ERR
+#endif /* defined(SIGMSG) */
+
+#if defined(SIGWINCH)
+#define J9_SIGWINCH SIGWINCH
+#else /* defined(SIGWINCH) */
+#define J9_SIGWINCH J9_SIG_ERR
+#endif /* defined(SIGWINCH) */
+
+#if defined(SIGPWR)
+#define J9_SIGPWR SIGPWR
+#else /* defined(SIGPWR) */
+#define J9_SIGPWR J9_SIG_ERR
+#endif /* defined(SIGPWR) */
+
+#if defined(SIGUSR1)
+#define J9_SIGUSR1 SIGUSR1
+#else /* defined(SIGUSR1) */
+#define J9_SIGUSR1 J9_SIG_ERR
+#endif /* defined(SIGUSR1) */
+
+#if defined(SIGUSR2)
+#define J9_SIGUSR2 SIGUSR2
+#else /* defined(SIGUSR2) */
+#define J9_SIGUSR2 J9_SIG_ERR
+#endif /* defined(SIGUSR2) */
+
+#if defined(SIGPROF)
+#define J9_SIGPROF SIGPROF
+#else /* defined(SIGPROF) */
+#define J9_SIGPROF J9_SIG_ERR
+#endif /* defined(SIGPROF) */
+
+#if defined(SIGDANGER)
+#define J9_SIGDANGER SIGDANGER
+#else /* defined(SIGDANGER) */
+#define J9_SIGDANGER J9_SIG_ERR
+#endif /* defined(SIGDANGER) */
+
+#if defined(SIGVTALRM)
+#define J9_SIGVTALRM SIGVTALRM
+#else /* defined(SIGVTALRM) */
+#define J9_SIGVTALRM J9_SIG_ERR
+#endif /* defined(SIGVTALRM) */
+
+#if defined(SIGMIGRATE)
+#define J9_SIGMIGRATE SIGMIGRATE
+#else /* defined(SIGMIGRATE) */
+#define J9_SIGMIGRATE J9_SIG_ERR
+#endif /* defined(SIGMIGRATE) */
+
+#if defined(SIGPRE)
+#define J9_SIGPRE SIGPRE
+#else /* defined(SIGPRE) */
+#define J9_SIGPRE J9_SIG_ERR
+#endif /* defined(SIGPRE) */
+
+#if defined(SIGCPUFAIL)
+#define J9_SIGCPUFAIL SIGCPUFAIL
+#else /* defined(SIGCPUFAIL) */
+#define J9_SIGCPUFAIL J9_SIG_ERR
+#endif /* defined(SIGCPUFAIL) */
+
+#if defined(SIGGRANT)
+#define J9_SIGGRANT SIGGRANT
+#else /* defined(SIGGRANT) */
+#define J9_SIGGRANT J9_SIG_ERR
+#endif /* defined(SIGGRANT) */
+
+#if defined(SIGRETRACT)
+#define J9_SIGRETRACT SIGRETRACT
+#else /* defined(SIGRETRACT) */
+#define J9_SIGRETRACT J9_SIG_ERR
+#endif /* defined(SIGRETRACT) */
+
+#if defined(SIGSOUND)
+#define J9_SIGSOUND SIGSOUND
+#else /* defined(SIGSOUND) */
+#define J9_SIGSOUND J9_SIG_ERR
+#endif /* defined(SIGSOUND) */
+
+#if defined(SIGSAK)
+#define J9_SIGSAK SIGSAK
+#else /* defined(SIGSAK) */
+#define J9_SIGSAK J9_SIG_ERR
+#endif /* defined(SIGSAK) */
+
+#if defined(SIGPOLL)
+#define J9_SIGPOLL SIGPOLL
+#else /* defined(SIGPOLL) */
+#define J9_SIGPOLL J9_SIG_ERR
+#endif /* defined(SIGPOLL) */
+
+#if defined(SIGINFO)
+#define J9_SIGINFO SIGINFO
+#else /* defined(SIGINFO) */
+#define J9_SIGINFO J9_SIG_ERR
+#endif /* defined(SIGINFO) */
+
+#if defined(SIGSTKFLT)
+#define J9_SIGSTKFLT SIGSTKFLT
+#else /* defined(SIGSTKFLT) */
+#define J9_SIGSTKFLT J9_SIG_ERR
+#endif /* defined(SIGSTKFLT) */
+
+#if defined(SIGBREAK)
+#define J9_SIGBREAK SIGBREAK
+#else /* defined(SIGBREAK) */
+#define J9_SIGBREAK J9_SIG_ERR
+#endif /* defined(SIGBREAK) */
+
+#if defined(SIGUNUSED)
+#define J9_SIGUNUSED SIGUNUSED
+#else /* defined(SIGUNUSED) */
+#define J9_SIGUNUSED J9_SIG_ERR
+#endif /* defined(SIGUNUSED) */
+
+#define J9_IS_SIGNAL_SPECIAL(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGQUIT) || (SIG_NUM == J9_SIGHUP) || (SIG_NUM == J9_SIGINT) || (SIG_NUM == J9_SIGTERM)))
+#define J9_IS_SIGNAL_USED_BY_VM(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGFPE) || (SIG_NUM == J9_SIGILL) || (SIG_NUM == J9_SIGSEGV)))","The uses of `SIG_NUM` in the expansion of the macro should be enclosed in parentheses.
It may make sense to convert these macros to static helper functions so the tests for signals can be conditional on whether the corresponding signal is defined.",
73485407,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,False,"@@ -4234,95 +4579,206 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)",`elseif` can be used here to reduce indentation,
73485662,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,False,"@@ -4234,95 +4579,206 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_NO_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+/* Register the signal */
+#if defined(WIN32)
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+handler = (void *)dummySignalHandler;
+}
+oldHandler = OMRSIG_SIGNAL(sigNum, handler);
+#else /* defined(WIN32) */
+sigemptyset(&newSignalAction.sa_mask);
+#if !defined(J9ZTPF)
+newSignalAction.sa_flags = SA_RESTART;
+#else /* !defined(J9ZTPF) */
+newSignalAction.sa_flags = 0;
+#endif /* !defined(J9ZTPF) */
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+newSignalAction.sa_handler = (void (*)(int))dummySignalHandler;
+} else {
+newSignalAction.sa_handler = (void (*)(int))handler;
+}
+OMRSIG_SIGACTION(sigNum, &newSignalAction, &oldSignalAction);
+#endif /* defined(WIN32) */
+}
+}
+
+#if defined(WIN32)
+if (((void *)J9_SIG_ERR != oldHandler) && (handler == oldHandler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldHandler;
+}
+#else /* defined(WIN32) */
+if ((NULL != oldSignalAction.sa_handler)
+&& (newSignalAction.sa_handler == oldSignalAction.sa_handler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldSignalAction.sa_handler;
+}
+#endif /* defined(WIN32) */
+
+return oldHandler;
 }
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Return the integer value of the signal given the name of the
+ *  signal.
+ *
+ *  @param  sigName Name of the signal
+ *
+ *  @returns Integer value of the signal on success
+ *           J9_SIG_ERR (-1) on failure
+ *
+ *DLL: jvm
  */
 jint JNICALL
-JVM_FindSignal(const char* sigName)
+JVM_FindSignal(const char *sigName)
 {
+const J9SignalMapping *mapping = NULL;
+jint signalValue = J9_SIG_ERR;
+BOOLEAN nameHasSigPrefix = FALSE;
+const char *fullSigName = sigName;
+#if !defined(WIN32)
+char nameWithSIGPrefix[J9_SIGNAME_BUFFER_LENGTH] = {0};
+#endif /* !defined(WIN32) */
 
 Trc_SC_FindSignal_Entry(sigName);
 
-#define J9_MAP_SIGNAL(ID) ID##U
-#define J9_RETURN_SIGNAL(ID) \
-const int ID##U = -1; Trc_SC_FindSignal_Exit(J9_MAP_SIGNAL(ID)); return J9_MAP_SIGNAL(ID);
-#define J9_MATCH_SIGNAL(ID) \
-if (strcmp(sigName, #ID) == 0) {J9_RETURN_SIGNAL(SIG##ID)}
-
-/* POSIX */
-J9_MATCH_SIGNAL(HUP)
-J9_MATCH_SIGNAL(INT)
-J9_MATCH_SIGNAL(QUIT)
-J9_MATCH_SIGNAL(ABRT)
-J9_MATCH_SIGNAL(KILL)
-J9_MATCH_SIGNAL(ALRM)
-J9_MATCH_SIGNAL(TERM)
-
-/* POSIX 1003.1-2001 */
-J9_MATCH_SIGNAL(BUS)
-J9_MATCH_SIGNAL(CHLD)
-J9_MATCH_SIGNAL(CONT)
-J9_MATCH_SIGNAL(FPE)
-J9_MATCH_SIGNAL(ILL)
-J9_MATCH_SIGNAL(PIPE)
-J9_MATCH_SIGNAL(SEGV)
-J9_MATCH_SIGNAL(STOP)
-J9_MATCH_SIGNAL(TSTP)
-J9_MATCH_SIGNAL(TTIN)
-J9_MATCH_SIGNAL(TTOU)
-J9_MATCH_SIGNAL(URG)
-J9_MATCH_SIGNAL(USR1)
-J9_MATCH_SIGNAL(USR2)
-
-/* POSIX 1003.1-2001 with XSI */
-J9_MATCH_SIGNAL(POLL)
-J9_MATCH_SIGNAL(PROF)
-J9_MATCH_SIGNAL(SYS)
-J9_MATCH_SIGNAL(TRAP)
-J9_MATCH_SIGNAL(VTALRM)
-J9_MATCH_SIGNAL(XCPU)
-J9_MATCH_SIGNAL(XFSZ)
-
-/* Miscellaneous */
-J9_MATCH_SIGNAL(IO)
-J9_MATCH_SIGNAL(WINCH)
-J9_MATCH_SIGNAL(PWR)
-J9_MATCH_SIGNAL(UNUSED)
-J9_MATCH_SIGNAL(BREAK)
-
-Trc_SC_FindSignal_Exit(-1);
-return -1;
+if (NULL != sigName) {
+size_t sigPrefixLength = strlen(J9_SIG_PREFIX);",`sizeof(J9_SIG_PREFIX) - 1` is preferred over a call to `strlen`.,
73547416,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,True,"@@ -322,6 +322,351 @@ static BOOLEAN librariesLoaded(void);
 #define LD_ENV_PATH ""LIBPATH""
 #endif /* defined(J9ZTPF) */
 
+#define J9_SIG_ERR -1
+
+#if defined(SIGHUP)
+#define J9_SIGHUP SIGHUP
+#else /* defined(SIGHUP) */
+#define J9_SIGHUP J9_SIG_ERR
+#endif /* defined(SIGHUP) */
+
+#if defined(SIGINT)
+#define J9_SIGINT SIGINT
+#else /* defined(SIGINT) */
+#define J9_SIGINT J9_SIG_ERR
+#endif /* defined(SIGINT) */",fixed.,
73547568,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,True,"@@ -322,6 +322,351 @@ static BOOLEAN librariesLoaded(void);
 #define LD_ENV_PATH ""LIBPATH""
 #endif /* defined(J9ZTPF) */
 
+#define J9_SIG_ERR -1
+
+#if defined(SIGHUP)
+#define J9_SIGHUP SIGHUP
+#else /* defined(SIGHUP) */
+#define J9_SIGHUP J9_SIG_ERR
+#endif /* defined(SIGHUP) */
+
+#if defined(SIGINT)
+#define J9_SIGINT SIGINT
+#else /* defined(SIGINT) */
+#define J9_SIGINT J9_SIG_ERR
+#endif /* defined(SIGINT) */
+
+#if defined(SIGQUIT)
+#define J9_SIGQUIT SIGQUIT
+#else /* defined(SIGQUIT) */
+#define J9_SIGQUIT J9_SIG_ERR
+#endif /* defined(SIGQUIT) */
+
+#if defined(SIGILL)
+#define J9_SIGILL SIGILL
+#else /* defined(SIGILL) */
+#define J9_SIGILL J9_SIG_ERR
+#endif /* defined(SIGILL) */
+
+#if defined(SIGTRAP)
+#define J9_SIGTRAP SIGTRAP
+#else /* defined(SIGTRAP) */
+#define J9_SIGTRAP J9_SIG_ERR
+#endif /* defined(SIGTRAP) */
+
+#if defined(SIGABRT)
+#define J9_SIGABRT SIGABRT
+#else /* defined(SIGABRT) */
+#define J9_SIGABRT J9_SIG_ERR
+#endif /* defined(SIGABRT) */
+
+#if defined(SIGEMT)
+#define J9_SIGEMT SIGEMT
+#else /* defined(SIGEMT) */
+#define J9_SIGEMT J9_SIG_ERR
+#endif /* defined(SIGEMT) */
+
+#if defined(SIGFPE)
+#define J9_SIGFPE SIGFPE
+#else /* defined(SIGFPE) */
+#define J9_SIGFPE J9_SIG_ERR
+#endif /* defined(SIGFPE) */
+
+#if defined(SIGKILL)
+#define J9_SIGKILL SIGKILL
+#else /* defined(SIGKILL) */
+#define J9_SIGKILL J9_SIG_ERR
+#endif /* defined(SIGKILL) */
+
+#if defined(SIGBUS)
+#define J9_SIGBUS SIGBUS
+#else /* defined(SIGBUS) */
+#define J9_SIGBUS J9_SIG_ERR
+#endif /* defined(SIGBUS) */
+
+#if defined(SIGSEGV)
+#define J9_SIGSEGV SIGSEGV
+#else /* defined(SIGSEGV) */
+#define J9_SIGSEGV J9_SIG_ERR
+#endif /* defined(SIGSEGV) */
+
+#if defined(SIGSYS)
+#define J9_SIGSYS SIGSYS
+#else /* defined(SIGSYS) */
+#define J9_SIGSYS J9_SIG_ERR
+#endif /* defined(SIGSYS) */
+
+#if defined(SIGPIPE)
+#define J9_SIGPIPE SIGPIPE
+#else /* defined(SIGPIPE) */
+#define J9_SIGPIPE J9_SIG_ERR
+#endif /* defined(SIGPIPE) */
+
+#if defined(SIGALRM)
+#define J9_SIGALRM SIGALRM
+#else /* defined(SIGALRM) */
+#define J9_SIGALRM J9_SIG_ERR
+#endif /* defined(SIGALRM) */
+
+#if defined(SIGTERM)
+#define J9_SIGTERM SIGTERM
+#else /* defined(SIGTERM) */
+#define J9_SIGTERM J9_SIG_ERR
+#endif /* defined(SIGTERM) */
+
+#if defined(SIGURG)
+#define J9_SIGURG SIGURG
+#else /* defined(SIGURG) */
+#define J9_SIGURG J9_SIG_ERR
+#endif /* defined(SIGURG) */
+
+#if defined(SIGSTOP)
+#define J9_SIGSTOP SIGSTOP
+#else /* defined(SIGSTOP) */
+#define J9_SIGSTOP J9_SIG_ERR
+#endif /* defined(SIGSTOP) */
+
+#if defined(SIGTSTP)
+#define J9_SIGTSTP SIGTSTP
+#else /* defined(SIGTSTP) */
+#define J9_SIGTSTP J9_SIG_ERR
+#endif /* defined(SIGTSTP) */
+
+#if defined(SIGCONT)
+#define J9_SIGCONT SIGCONT
+#else /* defined(SIGCONT) */
+#define J9_SIGCONT J9_SIG_ERR
+#endif /* defined(SIGCONT) */
+
+#if defined(SIGCHLD)
+#define J9_SIGCHLD SIGCHLD
+#else /* defined(SIGCHLD) */
+#define J9_SIGCHLD J9_SIG_ERR
+#endif /* defined(SIGCHLD) */
+
+#if defined(SIGTTIN)
+#define J9_SIGTTIN SIGTTIN
+#else /* defined(SIGTTIN) */
+#define J9_SIGTTIN J9_SIG_ERR
+#endif /* defined(SIGTTIN) */
+
+#if defined(SIGTTOU)
+#define J9_SIGTTOU SIGTTOU
+#else /* defined(SIGTTOU) */
+#define J9_SIGTTOU J9_SIG_ERR
+#endif /* defined(SIGTTOU) */
+
+#if defined(SIGIO)
+#define J9_SIGIO SIGIO
+#else /* defined(SIGIO) */
+#define J9_SIGIO J9_SIG_ERR
+#endif /* defined(SIGIO) */
+
+#if defined(SIGXCPU)
+#define J9_SIGXCPU SIGXCPU
+#else /* defined(SIGXCPU) */
+#define J9_SIGXCPU J9_SIG_ERR
+#endif /* defined(SIGXCPU) */
+
+#if defined(SIGXFSZ)
+#define J9_SIGXFSZ SIGXFSZ
+#else /* defined(SIGXFSZ) */
+#define J9_SIGXFSZ J9_SIG_ERR
+#endif /* defined(SIGXFSZ) */
+
+#if defined(SIGMSG)
+#define J9_SIGMSG SIGMSG
+#else /* defined(SIGMSG) */
+#define J9_SIGMSG J9_SIG_ERR
+#endif /* defined(SIGMSG) */
+
+#if defined(SIGWINCH)
+#define J9_SIGWINCH SIGWINCH
+#else /* defined(SIGWINCH) */
+#define J9_SIGWINCH J9_SIG_ERR
+#endif /* defined(SIGWINCH) */
+
+#if defined(SIGPWR)
+#define J9_SIGPWR SIGPWR
+#else /* defined(SIGPWR) */
+#define J9_SIGPWR J9_SIG_ERR
+#endif /* defined(SIGPWR) */
+
+#if defined(SIGUSR1)
+#define J9_SIGUSR1 SIGUSR1
+#else /* defined(SIGUSR1) */
+#define J9_SIGUSR1 J9_SIG_ERR
+#endif /* defined(SIGUSR1) */
+
+#if defined(SIGUSR2)
+#define J9_SIGUSR2 SIGUSR2
+#else /* defined(SIGUSR2) */
+#define J9_SIGUSR2 J9_SIG_ERR
+#endif /* defined(SIGUSR2) */
+
+#if defined(SIGPROF)
+#define J9_SIGPROF SIGPROF
+#else /* defined(SIGPROF) */
+#define J9_SIGPROF J9_SIG_ERR
+#endif /* defined(SIGPROF) */
+
+#if defined(SIGDANGER)
+#define J9_SIGDANGER SIGDANGER
+#else /* defined(SIGDANGER) */
+#define J9_SIGDANGER J9_SIG_ERR
+#endif /* defined(SIGDANGER) */
+
+#if defined(SIGVTALRM)
+#define J9_SIGVTALRM SIGVTALRM
+#else /* defined(SIGVTALRM) */
+#define J9_SIGVTALRM J9_SIG_ERR
+#endif /* defined(SIGVTALRM) */
+
+#if defined(SIGMIGRATE)
+#define J9_SIGMIGRATE SIGMIGRATE
+#else /* defined(SIGMIGRATE) */
+#define J9_SIGMIGRATE J9_SIG_ERR
+#endif /* defined(SIGMIGRATE) */
+
+#if defined(SIGPRE)
+#define J9_SIGPRE SIGPRE
+#else /* defined(SIGPRE) */
+#define J9_SIGPRE J9_SIG_ERR
+#endif /* defined(SIGPRE) */
+
+#if defined(SIGCPUFAIL)
+#define J9_SIGCPUFAIL SIGCPUFAIL
+#else /* defined(SIGCPUFAIL) */
+#define J9_SIGCPUFAIL J9_SIG_ERR
+#endif /* defined(SIGCPUFAIL) */
+
+#if defined(SIGGRANT)
+#define J9_SIGGRANT SIGGRANT
+#else /* defined(SIGGRANT) */
+#define J9_SIGGRANT J9_SIG_ERR
+#endif /* defined(SIGGRANT) */
+
+#if defined(SIGRETRACT)
+#define J9_SIGRETRACT SIGRETRACT
+#else /* defined(SIGRETRACT) */
+#define J9_SIGRETRACT J9_SIG_ERR
+#endif /* defined(SIGRETRACT) */
+
+#if defined(SIGSOUND)
+#define J9_SIGSOUND SIGSOUND
+#else /* defined(SIGSOUND) */
+#define J9_SIGSOUND J9_SIG_ERR
+#endif /* defined(SIGSOUND) */
+
+#if defined(SIGSAK)
+#define J9_SIGSAK SIGSAK
+#else /* defined(SIGSAK) */
+#define J9_SIGSAK J9_SIG_ERR
+#endif /* defined(SIGSAK) */
+
+#if defined(SIGPOLL)
+#define J9_SIGPOLL SIGPOLL
+#else /* defined(SIGPOLL) */
+#define J9_SIGPOLL J9_SIG_ERR
+#endif /* defined(SIGPOLL) */
+
+#if defined(SIGINFO)
+#define J9_SIGINFO SIGINFO
+#else /* defined(SIGINFO) */
+#define J9_SIGINFO J9_SIG_ERR
+#endif /* defined(SIGINFO) */
+
+#if defined(SIGSTKFLT)
+#define J9_SIGSTKFLT SIGSTKFLT
+#else /* defined(SIGSTKFLT) */
+#define J9_SIGSTKFLT J9_SIG_ERR
+#endif /* defined(SIGSTKFLT) */
+
+#if defined(SIGBREAK)
+#define J9_SIGBREAK SIGBREAK
+#else /* defined(SIGBREAK) */
+#define J9_SIGBREAK J9_SIG_ERR
+#endif /* defined(SIGBREAK) */
+
+#if defined(SIGUNUSED)
+#define J9_SIGUNUSED SIGUNUSED
+#else /* defined(SIGUNUSED) */
+#define J9_SIGUNUSED J9_SIG_ERR
+#endif /* defined(SIGUNUSED) */
+
+#define J9_IS_SIGNAL_SPECIAL(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGQUIT) || (SIG_NUM == J9_SIGHUP) || (SIG_NUM == J9_SIGINT) || (SIG_NUM == J9_SIGTERM)))
+#define J9_IS_SIGNAL_USED_BY_VM(SIG_NUM) ((SIG_NUM != J9_SIG_ERR) && ((SIG_NUM == J9_SIGFPE) || (SIG_NUM == J9_SIGILL) || (SIG_NUM == J9_SIGSEGV)))",fixed - converted to static helper functions.,
73547617,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,True,"@@ -4234,95 +4579,206 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)",fixed.,
73547661,1022a217b196a3c0629b4505ca85eb8776945ced,runtime/j9vm/jvm.c,True,"@@ -4234,95 +4579,206 @@ JVM_NativePath(char* path)
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Send a signal to the calling process or thread. If ""-Xrs""
+ *  commandline option is specified, then signals such as SIGQUIT,
+ *  SIGHUP, SIGINT and SIGTERM are ignored.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+
+ *  @returns JNI_TRUE if the signal is successfully raised/sent
+ *           JNI_FALSE if the signal is not sent
+ *
+ *DLL: jvm
  */
 jboolean JNICALL
 JVM_RaiseSignal(jint sigNum)
 {
+jboolean rc = JNI_FALSE;
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
 
 Trc_SC_RaiseSignal_Entry(sigNum);
 
-/**** TBD :: ignore certain signals when -Xrs is on ****/
-raise(sigNum);
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_ALL_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Ignore signal */
+} else {
+raise(sigNum);
+rc = JNI_TRUE;
+}
 
-Trc_SC_RaiseSignal_Exit(JNI_TRUE);
+Trc_SC_RaiseSignal_Exit(rc);
 
-return JNI_TRUE;
+return rc;
 }
 
+/**
+ *  This is a stub for the pre-defined handler. The pre-defined
+ *  handler is supposed to be used in JVM_RegisterSignal when
+ *  the special value of J9_PRE_DEFINED_HANDLER_CHECK (2) is specified
+ *  in the handler. It hasn't been implemented since its functionality
+ *  is not known.
+ *
+ *  TODO: Implement the pre-defined handler.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *
+ *  @returns void
+ *
+ *DLL: jvm
+ */
+static void
+dummySignalHandler(int sigNum) {
+
+}
 
 /**
- * Method stub for method not yet implemented.
+ *  Register a signal handler for a signal. Signals such as SIGFPE,
+ *  SIGILL and SIGSEGV are used by the VM; so, we don't register
+ *  a signal handler for these signals. If ""-Xrs"" commandline option
+ *  is specified, then signals such as SIGQUIT, SIGHUP, SIGINT
+ *  and SIGTERM are also ignored; thus, we don't register a signal
+ *  handler for these signals. If handler has the special value of
+ *  J9_PRE_DEFINED_HANDLER_CHECK (2), then handler is changed to
+ *  dummySignalHandler before it is registered. If the old handler
+ *  is same as the new handler, then a special value,
+ *  J9_OLDHANDLER_SAME_AS_NEWHANDLER (2) is returned.
+ *
+ *  @param  sigNum  Integer value of the signal to be sent to the
+ *                  calling process or thread
+ *  @param  handler New handler to be associated to the signal
+ *
+ *  @returns address of the old signal handler on success
+ *           J9_SIG_ERR (-1) in case of error
+ *
+ *DLL: jvm
  */
 void* JNICALL
 JVM_RegisterSignal(jint sigNum, void* handler)
 {
+J9JavaVM *javaVM = (J9JavaVM *)BFUjavaVM;
+void *oldHandler = (void *)J9_SIG_ERR;
+
+#if !defined(WIN32)
+struct sigaction newSignalAction = {{0}};
+struct sigaction oldSignalAction = {{0}};
+#endif /* !defined(WIN32) */
 
 Trc_SC_RegisterSignal();
 
-/**** TBD :: allow signal handler registration (thru portlib?) ****/
-return (void *) -1;
+if (J9_IS_SIGNAL_USED_BY_VM(sigNum)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+if (J9_IS_SIGNAL_SPECIAL(sigNum)
+&& J9_ARE_NO_BITS_SET(javaVM->sigFlags, J9_SIG_XRS)) {
+/* Don't allow user to register a native handler since
+ * the signal is already used by the VM.
+ */
+} else {
+/* Register the signal */
+#if defined(WIN32)
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+handler = (void *)dummySignalHandler;
+}
+oldHandler = OMRSIG_SIGNAL(sigNum, handler);
+#else /* defined(WIN32) */
+sigemptyset(&newSignalAction.sa_mask);
+#if !defined(J9ZTPF)
+newSignalAction.sa_flags = SA_RESTART;
+#else /* !defined(J9ZTPF) */
+newSignalAction.sa_flags = 0;
+#endif /* !defined(J9ZTPF) */
+if ((void *)J9_PRE_DEFINED_HANDLER_CHECK == handler) {
+newSignalAction.sa_handler = (void (*)(int))dummySignalHandler;
+} else {
+newSignalAction.sa_handler = (void (*)(int))handler;
+}
+OMRSIG_SIGACTION(sigNum, &newSignalAction, &oldSignalAction);
+#endif /* defined(WIN32) */
+}
+}
+
+#if defined(WIN32)
+if (((void *)J9_SIG_ERR != oldHandler) && (handler == oldHandler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldHandler;
+}
+#else /* defined(WIN32) */
+if ((NULL != oldSignalAction.sa_handler)
+&& (newSignalAction.sa_handler == oldSignalAction.sa_handler)) {
+oldHandler = (void *)J9_OLDHANDLER_SAME_AS_NEWHANDLER;
+} else {
+oldHandler = (void *)oldSignalAction.sa_handler;
+}
+#endif /* defined(WIN32) */
+
+return oldHandler;
 }
 
 
 /**
- * Method stub for method not yet implemented.
+ *  Return the integer value of the signal given the name of the
+ *  signal.
+ *
+ *  @param  sigName Name of the signal
+ *
+ *  @returns Integer value of the signal on success
+ *           J9_SIG_ERR (-1) on failure
+ *
+ *DLL: jvm
  */
 jint JNICALL
-JVM_FindSignal(const char* sigName)
+JVM_FindSignal(const char *sigName)
 {
+const J9SignalMapping *mapping = NULL;
+jint signalValue = J9_SIG_ERR;
+BOOLEAN nameHasSigPrefix = FALSE;
+const char *fullSigName = sigName;
+#if !defined(WIN32)
+char nameWithSIGPrefix[J9_SIGNAME_BUFFER_LENGTH] = {0};
+#endif /* !defined(WIN32) */
 
 Trc_SC_FindSignal_Entry(sigName);
 
-#define J9_MAP_SIGNAL(ID) ID##U
-#define J9_RETURN_SIGNAL(ID) \
-const int ID##U = -1; Trc_SC_FindSignal_Exit(J9_MAP_SIGNAL(ID)); return J9_MAP_SIGNAL(ID);
-#define J9_MATCH_SIGNAL(ID) \
-if (strcmp(sigName, #ID) == 0) {J9_RETURN_SIGNAL(SIG##ID)}
-
-/* POSIX */
-J9_MATCH_SIGNAL(HUP)
-J9_MATCH_SIGNAL(INT)
-J9_MATCH_SIGNAL(QUIT)
-J9_MATCH_SIGNAL(ABRT)
-J9_MATCH_SIGNAL(KILL)
-J9_MATCH_SIGNAL(ALRM)
-J9_MATCH_SIGNAL(TERM)
-
-/* POSIX 1003.1-2001 */
-J9_MATCH_SIGNAL(BUS)
-J9_MATCH_SIGNAL(CHLD)
-J9_MATCH_SIGNAL(CONT)
-J9_MATCH_SIGNAL(FPE)
-J9_MATCH_SIGNAL(ILL)
-J9_MATCH_SIGNAL(PIPE)
-J9_MATCH_SIGNAL(SEGV)
-J9_MATCH_SIGNAL(STOP)
-J9_MATCH_SIGNAL(TSTP)
-J9_MATCH_SIGNAL(TTIN)
-J9_MATCH_SIGNAL(TTOU)
-J9_MATCH_SIGNAL(URG)
-J9_MATCH_SIGNAL(USR1)
-J9_MATCH_SIGNAL(USR2)
-
-/* POSIX 1003.1-2001 with XSI */
-J9_MATCH_SIGNAL(POLL)
-J9_MATCH_SIGNAL(PROF)
-J9_MATCH_SIGNAL(SYS)
-J9_MATCH_SIGNAL(TRAP)
-J9_MATCH_SIGNAL(VTALRM)
-J9_MATCH_SIGNAL(XCPU)
-J9_MATCH_SIGNAL(XFSZ)
-
-/* Miscellaneous */
-J9_MATCH_SIGNAL(IO)
-J9_MATCH_SIGNAL(WINCH)
-J9_MATCH_SIGNAL(PWR)
-J9_MATCH_SIGNAL(UNUSED)
-J9_MATCH_SIGNAL(BREAK)
-
-Trc_SC_FindSignal_Exit(-1);
-return -1;
+if (NULL != sigName) {
+size_t sigPrefixLength = strlen(J9_SIG_PREFIX);",fixed.,
75859940,92f69c74efe2c5a8d2b892fa2dfdc766a5e350e3,runtime/tr.source/trj9/z/codegen/J9S390PrivateLinkage.cpp,False,"@@ -2282,7 +2282,7 @@ TR::S390PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDe
             generateRXInstruction(cg(), TR::InstOpCode::getLoadOpCode(), callNode, RegRA, generateS390MemoryReference(classReg, offset, cg()));
          cursor = generateRIInstruction(cg(), TR::InstOpCode::getLoadHalfWordImmOpCode(), callNode, RegZero, offset);
          }
-      else if (offset > -524288)
+      else","For cases where offset is <= -524288, are we relying on long displacement support to generate the correct memory reference offset?  Have we tested that it works for this case?",
75867067,92f69c74efe2c5a8d2b892fa2dfdc766a5e350e3,runtime/tr.source/trj9/z/codegen/J9S390PrivateLinkage.cpp,True,"@@ -2282,7 +2282,7 @@ TR::S390PrivateLinkage::buildVirtualDispatch(TR::Node * callNode, TR::RegisterDe
             generateRXInstruction(cg(), TR::InstOpCode::getLoadOpCode(), callNode, RegRA, generateS390MemoryReference(classReg, offset, cg()));
          cursor = generateRIInstruction(cg(), TR::InstOpCode::getLoadHalfWordImmOpCode(), callNode, RegZero, offset);
          }
-      else if (offset > -524288)
+      else",Yes that is precisely what we're relying on. The long displacement logic will effectively generate what we have in the (now deleted) `else` path. This is just code duplication. I've tested on internal builds that this does indeed function as expected.,
75890067,106f17d55b50d7dab03364e04437fd9204d60cba,runtime/jcl/common/jclcinit.c,False,"@@ -66,87 +67,85 @@ jint computeFullVersionString(J9JavaVM* vm)
 {
 VMI_ACCESS_FROM_JAVAVM((JavaVM*)vm);
 PORT_ACCESS_FROM_JAVAVM(vm);
+OMRPORT_ACCESS_FROM_J9PORT(vm->portLibrary);
 const char *osarch;
 const char *osname;
 const char *vmVersion = NULL;
 const char *gcVersion = NULL;
-char fullversion[512];
 char vminfo[512];
+        char fullversion[512];
+        int buflen = 0;
+        int vmlen = 0;  
 #ifdef J9VM_INTERP_NATIVE_SUPPORT
 J9JITConfig *jitConfig;
 #endif
 #if defined(J9VM_INTERP_NATIVE_SUPPORT)
 UDATA jitEnabled = 0;
 UDATA aotEnabled = 0;
 #endif
-
-strcpy(fullversion, ""JRE "");
-strcpy(vminfo, ""JRE "");
+        buflen = omrstr_printf(fullversion, sizeof(fullversion), ""JRE "");
+        vmlen = omrstr_printf(vminfo, sizeof(vminfo), ""JRE "");
 switch(J2SE_VERSION(vm) & J2SE_VERSION_MASK) {
 case J2SE_17:
 if ((J2SE_VERSION(vm) & J2SE_RELEASE_MASK) == J2SE_17) {
-strcat(fullversion, ""1.7.0 "");
-strcat(vminfo, ""1.7.0 "");
+        buflen += omrstr_printf(fullversion+buflen, sizeof(fullversion), ""1.7.0 "");",Please remove the whitespace which was added at the end of all of the omrstr_printf(fullversion ...) lines.,
75890626,106f17d55b50d7dab03364e04437fd9204d60cba,runtime/jcl/common/jclcinit.c,False,"@@ -66,87 +67,85 @@ jint computeFullVersionString(J9JavaVM* vm)
 {
 VMI_ACCESS_FROM_JAVAVM((JavaVM*)vm);
 PORT_ACCESS_FROM_JAVAVM(vm);
+OMRPORT_ACCESS_FROM_J9PORT(vm->portLibrary);
 const char *osarch;
 const char *osname;
 const char *vmVersion = NULL;
 const char *gcVersion = NULL;
-char fullversion[512];
 char vminfo[512];
+        char fullversion[512];","Please use tabs in all the modified code, to be consistent with the rest of the file.",
75890842,106f17d55b50d7dab03364e04437fd9204d60cba,runtime/jcl/common/jclcinit.c,False,"@@ -66,87 +67,85 @@ jint computeFullVersionString(J9JavaVM* vm)
 {
 VMI_ACCESS_FROM_JAVAVM((JavaVM*)vm);
 PORT_ACCESS_FROM_JAVAVM(vm);
+OMRPORT_ACCESS_FROM_J9PORT(vm->portLibrary);
 const char *osarch;
 const char *osname;
 const char *vmVersion = NULL;
 const char *gcVersion = NULL;
-char fullversion[512];
 char vminfo[512];
+        char fullversion[512];
+        int buflen = 0;
+        int vmlen = 0;  
 #ifdef J9VM_INTERP_NATIVE_SUPPORT
 J9JITConfig *jitConfig;
 #endif
 #if defined(J9VM_INTERP_NATIVE_SUPPORT)
 UDATA jitEnabled = 0;
 UDATA aotEnabled = 0;
 #endif
-
-strcpy(fullversion, ""JRE "");
-strcpy(vminfo, ""JRE "");
+        buflen = omrstr_printf(fullversion, sizeof(fullversion), ""JRE "");
+        vmlen = omrstr_printf(vminfo, sizeof(vminfo), ""JRE "");
 switch(J2SE_VERSION(vm) & J2SE_VERSION_MASK) {
 case J2SE_17:
 if ((J2SE_VERSION(vm) & J2SE_RELEASE_MASK) == J2SE_17) {
-strcat(fullversion, ""1.7.0 "");
-strcat(vminfo, ""1.7.0 "");
+        buflen += omrstr_printf(fullversion+buflen, sizeof(fullversion), ""1.7.0 "");",The correct length is sizeof(fullversion)-buflen. Similarly for vminfo.,
75550361,59d5e14043e08b0fd8fc42e48792ffc93a1ecfcd,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -3404,9 +3404,13 @@ private static MethodHandle validateArgumentsOfWhileLoop(MethodHandle predHandle
 Class<?> bodyReturnType = bodyType.returnType;
 
 /* The signature of the body handle must be either (V, A...)V or (A...)void */
-if ((void.class != bodyReturnType) && (bodyReturnType != bodyType.arguments[0])) {
+if ((void.class != bodyReturnType) 
+&& ((0 == bodyType.arguments.length) ","```((0 == bodyType.arguments.length) ```
This seems like a good candidate for a package private method.  Maybe `MethodType.isNoArgs()` or `hasNoArguments()`?",
75550361,59d5e14043e08b0fd8fc42e48792ffc93a1ecfcd,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -3404,9 +3404,13 @@ private static MethodHandle validateArgumentsOfWhileLoop(MethodHandle predHandle
 Class<?> bodyReturnType = bodyType.returnType;
 
 /* The signature of the body handle must be either (V, A...)V or (A...)void */
-if ((void.class != bodyReturnType) && (bodyReturnType != bodyType.arguments[0])) {
+if ((void.class != bodyReturnType) 
+&& ((0 == bodyType.arguments.length) 
+|| (bodyReturnType != bodyType.arguments[0]))) {
+String argList = (0 == bodyType.arguments.length) ? ""void"" : bodyType.arguments[0].getName();","We generally try to avoid single line if statements as they make it difficult to set breakpoints that only fire if the if is true.  Code like:
```
String argList = ""void"";
if (bodyType.arguments.length > 0) {
    argList = bodyType.arguments[0].getName();
}
```
is as clear and allows setting a breakpoint on the code in the if.",
75550361,59d5e14043e08b0fd8fc42e48792ffc93a1ecfcd,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -3534,18 +3538,19 @@ private static final void validateArgumentsOfCountedLoop(MethodHandle startHandl
 MethodType bodyType = bodyHandle.type;
 Class<?> bodyReturnType = bodyType.returnType;
 Class<?>[] bodyParamTypes = bodyType.arguments;
-Class<?> bodyParamType1 = bodyParamTypes[0];
 
 /* The signature of the body handle must be either (V,I,A...)V or (I,A...)void */
 if (void.class == bodyReturnType) {
-if (int.class != bodyParamType1) {
+if ((0 == bodyParamTypes.length) || (int.class != bodyParamTypes[0])) {",`(0 == bodyParamTypes.length)` is used on both sides of the if.  Can you pull it out into a local so it's only executed once?,
75550361,59d5e14043e08b0fd8fc42e48792ffc93a1ecfcd,jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java,False,"@@ -3534,18 +3538,19 @@ private static final void validateArgumentsOfCountedLoop(MethodHandle startHandl
 MethodType bodyType = bodyHandle.type;
 Class<?> bodyReturnType = bodyType.returnType;
 Class<?>[] bodyParamTypes = bodyType.arguments;
-Class<?> bodyParamType1 = bodyParamTypes[0];
 
 /* The signature of the body handle must be either (V,I,A...)V or (I,A...)void */
 if (void.class == bodyReturnType) {
-if (int.class != bodyParamType1) {
+if ((0 == bodyParamTypes.length) || (int.class != bodyParamTypes[0])) {
 /*[MSG ""K065G"", ""The 1st parameter type of the body handle with a void return type must be int: {0}""]*/
 throw new IllegalArgumentException(com.ibm.oti.util.Msg.getString(""K065G"", bodyType.toMethodDescriptorString())); //$NON-NLS-1$
 }
 } else {
-if (bodyReturnType != bodyParamType1) {
+if ((0 == bodyParamTypes.length) || (bodyReturnType != bodyParamTypes[0])) {
+String argType = (0 == bodyParamTypes.length) ? ""void"" : bodyParamTypes[0].getName();",Same comment about single line if,
75610490,e3f9f0ce2175a8f4bc734e398bada92dbfe52eef,sourcetools/j9nls/com/ibm/oti/NLSTool/J9NLS.java,False,"@@ -106,6 +107,16 @@ else if (!(args[i + 1].endsWith("".html"") || args[i + 1].endsWith("".htm""))) {
 failure(""Output file name is not in correct format: "" + args[i + 1]);
 } else
 htmlFileName = args[++i];
+} else if (arg.compareToIgnoreCase(""-source"") == 0) {
+if ((i + 1) >= args.length || args[i + 1].startsWith(""-""))
+failure(""Source directory not specified"");
+File srcDir = new File(args[++i]);
+if (!srcDir.exists() || ! srcDir.isDirectory())
+failure(""Source directory does not exist"");",Might be worth including the srcDir in the error message.,
75612039,e3f9f0ce2175a8f4bc734e398bada92dbfe52eef,sourcetools/j9nls/com/ibm/oti/NLSTool/J9NLS.java,False,"@@ -138,6 +153,13 @@ private void generatePropertiesFiles(String outFileName, boolean palmMode) throw
 Vector defaultNLSFiles = (Vector) localeHashtable.get(DEFAULT_LOCALE);
 StringBuffer buffer = new StringBuffer();
 
+// Create the output directory if it doesnt exist",Does the nls directory always exist with the old usage of the tool?,
75622886,e3f9f0ce2175a8f4bc734e398bada92dbfe52eef,sourcetools/j9nls/com/ibm/oti/NLSTool/J9NLS.java,True,"@@ -138,6 +153,13 @@ private void generatePropertiesFiles(String outFileName, boolean palmMode) throw
 Vector defaultNLSFiles = (Vector) localeHashtable.get(DEFAULT_LOCALE);
 StringBuffer buffer = new StringBuffer();
 
+// Create the output directory if it doesnt exist","Yes since the input dir == output dir. If it doesnt exist, you will fail earlier when you are scanning for input files in `searchNLSFiles()`",
75154451,20558378356995b1c6deec0ae044fefb99a11179,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,False,"@@ -282,292 +265,191 @@ ReduceSynchronizedFieldLoad::performOnTreeTops(TR::TreeTop* startTreeTop, TR::Tr
    {
    bool transformed = false;
 
-   TR::list<TR::TreeTop*> treeTopsToRemove (getTypedAllocator<TR::TreeTop*>(cg->comp()->allocator()));
-
    for (TR::TreeTopIterator iter(startTreeTop, cg->comp()); iter != endTreeTop; ++iter)
       {
-      treeTopsToRemove.clear();
-
-      if (iter.currentNode()->getOpCodeValue() == TR::monent)
+      if (iter.currentNode()->getOpCodeValue() == TR::monent ||
+          iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monent)
          {
-         treeTopsToRemove.push_back(iter.currentTree());
-
-         TR::Node* monentNode = iter.currentNode();
+         TR::TreeTop* monentTreeTop = iter.currentTree();
+         TR::Node* monentNode = iter.currentNode()->getOpCodeValue() == TR::monent ?
+            iter.currentNode() :
+            iter.currentNode()->getFirstChild();
 
          if (cg->comp()->getOption(TR_TraceCG))
             {
-            traceMsg(cg->comp(), ""Examining monent [%p]\n"", monentNode);
-            }
-
-         // Save the current iterator location for tree replacement should the pattern matching succeed
-         TR::TreeTopIterator savedIter = iter;
-
-         if (!advanceIterator(iter, endTreeTop))
-            {
-            continue;
+            traceMsg(cg->comp(), ""Found monent [%p]\n"", monentNode);
             }
 
-         TR::Node* lookaheadChildNode = iter.currentNode();
-
-         if (lookaheadChildNode->getOpCodeValue() == TR::treetop || lookaheadChildNode->getOpCodeValue() == TR::compressedRefs)
+         for (++iter; iter != endTreeTop; ++iter)
             {
-            TR::Node* loadNode = lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-            // When concurrent scavenge is enabled we need to load the object reference using a read barrier however
-            // there is no guarded load alternative for the LPD instruction. As such this optimization cannot be carried
-            // out for object reference loads under concurrent scavenge.
-            if (TR::Compiler->om.shouldGenerateReadBarriersForFieldLoads() && loadNode->getDataType().isAddress())
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/read-barrier/%s"", cg->comp()->signature()));
-
-               continue;
-               }
-
-            if (lookaheadChildNode->getOpCodeValue() == TR::l2a)
+            if (iter.currentNode()->getOpCodeValue() == TR::monexit ||
+                iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monexit)
                {
-               TR::Node* l2aChildNode = lookaheadChildNode->getChild(0);
-
-               if (l2aChildNode->isUnneededConversion())
-                  {
-                  lookaheadChildNode = l2aChildNode->getChild(0);
-
-                  // There may or may not be a compression sequence at this point
-                  if (lookaheadChildNode->getOpCodeValue() == TR::lshl && lookaheadChildNode->containsCompressionSequence())
-                     {
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-                     if (lookaheadChildNode->getOpCodeValue() == TR::iu2l && lookaheadChildNode->isUnneededConversion())
-                        {
-                        lookaheadChildNode = lookaheadChildNode->getChild(0);
-                        }
-                     }
-                  }
-               }
+               TR::TreeTop* monexitTreeTop = iter.currentTree();
+               TR::Node* monexitNode = iter.currentNode()->getOpCodeValue() == TR::monexit ?
+                  iter.currentNode() :
+                  iter.currentNode()->getFirstChild();
 
-            if (lookaheadChildNode->getOpCode().isLoadIndirect())
-               {
-               // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
-               if (TR::Compiler->target.is32Bit() && lookaheadChildNode->getSymbolReference()->getSymbol()->getSize() == 8)
+               if (cg->comp()->getOption(TR_TraceCG))
                   {
-                  continue;
+                  traceMsg(cg->comp(), ""Found monexit [%p]\n"", monexitNode);
                   }
 
-               TR::Node* synchronizedObjectNode = monentNode->getChild(0);
+               TR::Node* synchronizedObjectNode = monentNode->getFirstChild();
 
-               // Make sure the object we are synchronizing on is the same object we are loading from
-               if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
+               if (synchronizedObjectNode == monexitNode->getFirstChild())
                   {
-                  treeTopsToRemove.push_back(iter.currentTree());
-
                   if (cg->comp()->getOption(TR_TraceCG))
                      {
-                     traceMsg(cg->comp(), ""Found load [%p] from synchronized object [%p]\n"", loadNode, synchronizedObjectNode);
-                     }
-
-                  if (!advanceIterator(iter, endTreeTop))
-                     {
-                     continue;
+                     traceMsg(cg->comp(), ""Children of monent and monexit are synchronizing on the same object\n"", monexitNode);
                      }
 
-                  lookaheadChildNode = iter.currentNode();
+                  TR::Node* loadNode = findLoadInSynchornizedRegion(startTreeTop, endTreeTop, monentTreeTop, monexitTreeTop, synchronizedObjectNode);
 
-                  // Skip monexit fences
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexitfence)
+                  if (loadNode != NULL)
                      {
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
+                     if (TR::Compiler->target.is32Bit() && J9::DataType::getSize(loadNode->getDataType()) == 8)
                         {
-                        traceMsg(cg->comp(), ""Skipping monexitfence [%p]\n"", lookaheadChildNode);
-                        }
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/31-bit-register-pairs/%s"", cg->comp()->signature()));
 
-                     // Note that we cannot actually eliminate these monexit fences. They are used during instruction
-                     // selection as barriers for the live monitor stacks. When we encounter astores which hold monitor
-                     // objects (i.e. holdsMonitoredObject returns true) we push the object onto a live monitor stack.
-                     // We pop off this stack when a monexitfence is encountered. This stack dictates the live monitor
-                     // data that gets assigned to every instruction and subsequently gets filled out if we request
-                     // a GC map to be generated for a particular instruction.
-                     //
-                     // For more details please see J9::CodeGenerator::doInstructionSelection()
-                     if (!advanceIterator(iter, endTreeTop))
-                        {
-                        continue;
+                        break;
                         }
 
-                     lookaheadChildNode = iter.currentNode();
-                     }
+                     int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
 
-                  // Skip global register stores of the loaded value since this is a NOP at codegen time
-                  if (lookaheadChildNode->getOpCodeValue() == TR::aRegStore || lookaheadChildNode->getOpCodeValue() == TR::iRegStore || lookaheadChildNode->getOpCodeValue() == TR::lRegStore)
-                     {
-                     if (lookaheadChildNode->getChild(0) == loadNode)
-                        {
-                        if (cg->comp()->getOption(TR_TraceCG))
-                           {
-                           traceMsg(cg->comp(), ""Skipping (a|i|l)regStore [%p]\n"", lookaheadChildNode);
-                           }
-
-                        if (!advanceIterator(iter, endTreeTop))
-                           {
-                           continue;
-                           }
-
-                        lookaheadChildNode = iter.currentNode();
-                        }
-                     }
-
-                  // Skip treetop nodes (in case there is a treetop on top of a monexit)
-                  if (lookaheadChildNode->getOpCodeValue() == TR::treetop)
-                     {
                      if (cg->comp()->getOption(TR_TraceCG))
                         {
-                        traceMsg(cg->comp(), ""Skipping treetop [%p] and looking at its child instead\n"", lookaheadChildNode);
+                        traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
                         }
 
-                     // TODO: Figure out why this happens
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-                     }
-
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexit)
-                     {
-                     treeTopsToRemove.push_back(iter.currentTree());
-
-                     TR::Node* monexitNode = lookaheadChildNode;
-
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // LPD(G) is an SSF instruction with a 12-bit displacement
+                     if (lockWordOffset > 0 && lockWordOffset < 4096)
                         {
-                        traceMsg(cg->comp(), ""Examining monexit [%p]\n"", monexitNode);
-                        }
-
-                     // Make sure the object we are synchronizing on is the same object
-                     if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
-                        {
-                        int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
-
-                        if (cg->comp()->getOption(TR_TraceCG))
+                        if (performTransformation(cg->comp(), ""%sReplacing monent [%p] - monexit [%p] synchronized region on load [%p] with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode, loadNode))
                            {
-                           traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
-                           }
+                           transformed = true;
 
-                        // LPD(G) is an SSF instruction with a 12-bit displacement
-                        if (lockWordOffset > 0 && lockWordOffset < 4096)
-                           {
-                           if (performTransformation(cg->comp(), ""%sReplacing monent [%p] monexit [%p] synchronized region with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode))
-                              {
-                              transformed = true;
-
-                              // Fabricate a special codegen inlined method call symbol reference
-                              TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
+                           // Fabricate a special codegen inlined method call symbol reference
+                           TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
 
-                              TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
+                           TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
 
-                              callNode->setAndIncChild(0, synchronizedObjectNode);
-                              callNode->setAndIncChild(1, loadNode);
+                           callNode->setAndIncChild(0, synchronizedObjectNode);
+                           callNode->setAndIncChild(1, loadNode);
 
-                              TR::Node* lockWordOffsetNode = TR::Node::iconst (loadNode, lockWordOffset);
+                           TR::Node* lockWordOffsetNode = TR::Node::iconst(loadNode, lockWordOffset);
 
-                              callNode->setAndIncChild(2, lockWordOffsetNode);
+                           callNode->setAndIncChild(2, lockWordOffsetNode);
 
-                              TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
-                              TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
+                           TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
+                           TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
 
-                              callNode->setAndIncChild(3, monentSymbolReferenceNode);
-                              callNode->setAndIncChild(4, monexitSymbolReferenceNode);
+                           callNode->setAndIncChild(3, monentSymbolReferenceNode);
+                           callNode->setAndIncChild(4, monexitSymbolReferenceNode);
 
-                              TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
+                           TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
 
-                              TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
+                           TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
 
-                              // Insert fabricated call treetop
-                              savedIter.currentTree()->insertBefore(callTreeTop);
+                           // Insert fabricated call treetop
+                           monentTreeTop->insertBefore(callTreeTop);
 
-                              // Remove pattern matched intermediate treetops
-                              for (auto i = treeTopsToRemove.begin(); i != treeTopsToRemove.end(); ++i)
-                                 {
-                                 (*i)->unlink(true);
-                                 }
+                           // Remove the monitor region
+                           monentTreeTop->unlink(true);
+                           monexitTreeTop->unlink(true);
 
-                              TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
-                              }
-                           }
-                        else
-                           {
-                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
+                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
                            }
                         }
                      else
                         {
-                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
                         }
                      }
                   else
                      {
-                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-not-found/%s"", cg->comp()->signature()));
+                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
                      }
                   }
                else
                   {
-                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
                   }
-               }
-            else
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
+
+               break;
                }
             }
-         else
+
+         if (iter == endTreeTop)
             {
-            TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/treetop-or-compressedRefs-not-found/%s"", cg->comp()->signature()));
+            break;
             }
          }
       }
 
    return transformed;
    }
 
-bool
-ReduceSynchronizedFieldLoad::advanceIterator(TR::TreeTopIterator& iter, TR::TreeTop* endTreeTop)
+TR::Node*
+ReduceSynchronizedFieldLoad::findLoadInSynchornizedRegion(TR::TreeTop* startTreeTop, TR::TreeTop* endTreeTop, TR::TreeTop* monentTreeTop, TR::TreeTop* monexitTreeTop, TR::Node* synchronizedObjectNode)
    {
-   ++iter;
-
-   if (iter == endTreeTop)
+   TR::PreorderNodeIterator iter(startTreeTop, cg->comp());
+
+   // First iterate though all the nodes from the start treetop until we reach the monitor provided so that all nodes","I think there is a typo here, should be `through` ",
75154451,20558378356995b1c6deec0ae044fefb99a11179,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,False,"@@ -282,292 +265,191 @@ ReduceSynchronizedFieldLoad::performOnTreeTops(TR::TreeTop* startTreeTop, TR::Tr
    {
    bool transformed = false;
 
-   TR::list<TR::TreeTop*> treeTopsToRemove (getTypedAllocator<TR::TreeTop*>(cg->comp()->allocator()));
-
    for (TR::TreeTopIterator iter(startTreeTop, cg->comp()); iter != endTreeTop; ++iter)
       {
-      treeTopsToRemove.clear();
-
-      if (iter.currentNode()->getOpCodeValue() == TR::monent)
+      if (iter.currentNode()->getOpCodeValue() == TR::monent ||
+          iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monent)
          {
-         treeTopsToRemove.push_back(iter.currentTree());
-
-         TR::Node* monentNode = iter.currentNode();
+         TR::TreeTop* monentTreeTop = iter.currentTree();
+         TR::Node* monentNode = iter.currentNode()->getOpCodeValue() == TR::monent ?
+            iter.currentNode() :
+            iter.currentNode()->getFirstChild();
 
          if (cg->comp()->getOption(TR_TraceCG))
             {
-            traceMsg(cg->comp(), ""Examining monent [%p]\n"", monentNode);
-            }
-
-         // Save the current iterator location for tree replacement should the pattern matching succeed
-         TR::TreeTopIterator savedIter = iter;
-
-         if (!advanceIterator(iter, endTreeTop))
-            {
-            continue;
+            traceMsg(cg->comp(), ""Found monent [%p]\n"", monentNode);
             }
 
-         TR::Node* lookaheadChildNode = iter.currentNode();
-
-         if (lookaheadChildNode->getOpCodeValue() == TR::treetop || lookaheadChildNode->getOpCodeValue() == TR::compressedRefs)
+         for (++iter; iter != endTreeTop; ++iter)
             {
-            TR::Node* loadNode = lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-            // When concurrent scavenge is enabled we need to load the object reference using a read barrier however
-            // there is no guarded load alternative for the LPD instruction. As such this optimization cannot be carried
-            // out for object reference loads under concurrent scavenge.
-            if (TR::Compiler->om.shouldGenerateReadBarriersForFieldLoads() && loadNode->getDataType().isAddress())
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/read-barrier/%s"", cg->comp()->signature()));
-
-               continue;
-               }
-
-            if (lookaheadChildNode->getOpCodeValue() == TR::l2a)
+            if (iter.currentNode()->getOpCodeValue() == TR::monexit ||
+                iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monexit)
                {
-               TR::Node* l2aChildNode = lookaheadChildNode->getChild(0);
-
-               if (l2aChildNode->isUnneededConversion())
-                  {
-                  lookaheadChildNode = l2aChildNode->getChild(0);
-
-                  // There may or may not be a compression sequence at this point
-                  if (lookaheadChildNode->getOpCodeValue() == TR::lshl && lookaheadChildNode->containsCompressionSequence())
-                     {
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-                     if (lookaheadChildNode->getOpCodeValue() == TR::iu2l && lookaheadChildNode->isUnneededConversion())
-                        {
-                        lookaheadChildNode = lookaheadChildNode->getChild(0);
-                        }
-                     }
-                  }
-               }
+               TR::TreeTop* monexitTreeTop = iter.currentTree();
+               TR::Node* monexitNode = iter.currentNode()->getOpCodeValue() == TR::monexit ?
+                  iter.currentNode() :
+                  iter.currentNode()->getFirstChild();
 
-            if (lookaheadChildNode->getOpCode().isLoadIndirect())
-               {
-               // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
-               if (TR::Compiler->target.is32Bit() && lookaheadChildNode->getSymbolReference()->getSymbol()->getSize() == 8)
+               if (cg->comp()->getOption(TR_TraceCG))
                   {
-                  continue;
+                  traceMsg(cg->comp(), ""Found monexit [%p]\n"", monexitNode);
                   }
 
-               TR::Node* synchronizedObjectNode = monentNode->getChild(0);
+               TR::Node* synchronizedObjectNode = monentNode->getFirstChild();
 
-               // Make sure the object we are synchronizing on is the same object we are loading from
-               if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
+               if (synchronizedObjectNode == monexitNode->getFirstChild())
                   {
-                  treeTopsToRemove.push_back(iter.currentTree());
-
                   if (cg->comp()->getOption(TR_TraceCG))
                      {
-                     traceMsg(cg->comp(), ""Found load [%p] from synchronized object [%p]\n"", loadNode, synchronizedObjectNode);
-                     }
-
-                  if (!advanceIterator(iter, endTreeTop))
-                     {
-                     continue;
+                     traceMsg(cg->comp(), ""Children of monent and monexit are synchronizing on the same object\n"", monexitNode);
                      }
 
-                  lookaheadChildNode = iter.currentNode();
+                  TR::Node* loadNode = findLoadInSynchornizedRegion(startTreeTop, endTreeTop, monentTreeTop, monexitTreeTop, synchronizedObjectNode);
 
-                  // Skip monexit fences
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexitfence)
+                  if (loadNode != NULL)
                      {
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
+                     if (TR::Compiler->target.is32Bit() && J9::DataType::getSize(loadNode->getDataType()) == 8)
                         {
-                        traceMsg(cg->comp(), ""Skipping monexitfence [%p]\n"", lookaheadChildNode);
-                        }
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/31-bit-register-pairs/%s"", cg->comp()->signature()));
 
-                     // Note that we cannot actually eliminate these monexit fences. They are used during instruction
-                     // selection as barriers for the live monitor stacks. When we encounter astores which hold monitor
-                     // objects (i.e. holdsMonitoredObject returns true) we push the object onto a live monitor stack.
-                     // We pop off this stack when a monexitfence is encountered. This stack dictates the live monitor
-                     // data that gets assigned to every instruction and subsequently gets filled out if we request
-                     // a GC map to be generated for a particular instruction.
-                     //
-                     // For more details please see J9::CodeGenerator::doInstructionSelection()
-                     if (!advanceIterator(iter, endTreeTop))
-                        {
-                        continue;
+                        break;
                         }
 
-                     lookaheadChildNode = iter.currentNode();
-                     }
+                     int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
 
-                  // Skip global register stores of the loaded value since this is a NOP at codegen time
-                  if (lookaheadChildNode->getOpCodeValue() == TR::aRegStore || lookaheadChildNode->getOpCodeValue() == TR::iRegStore || lookaheadChildNode->getOpCodeValue() == TR::lRegStore)
-                     {
-                     if (lookaheadChildNode->getChild(0) == loadNode)
-                        {
-                        if (cg->comp()->getOption(TR_TraceCG))
-                           {
-                           traceMsg(cg->comp(), ""Skipping (a|i|l)regStore [%p]\n"", lookaheadChildNode);
-                           }
-
-                        if (!advanceIterator(iter, endTreeTop))
-                           {
-                           continue;
-                           }
-
-                        lookaheadChildNode = iter.currentNode();
-                        }
-                     }
-
-                  // Skip treetop nodes (in case there is a treetop on top of a monexit)
-                  if (lookaheadChildNode->getOpCodeValue() == TR::treetop)
-                     {
                      if (cg->comp()->getOption(TR_TraceCG))
                         {
-                        traceMsg(cg->comp(), ""Skipping treetop [%p] and looking at its child instead\n"", lookaheadChildNode);
+                        traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
                         }
 
-                     // TODO: Figure out why this happens
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-                     }
-
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexit)
-                     {
-                     treeTopsToRemove.push_back(iter.currentTree());
-
-                     TR::Node* monexitNode = lookaheadChildNode;
-
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // LPD(G) is an SSF instruction with a 12-bit displacement
+                     if (lockWordOffset > 0 && lockWordOffset < 4096)
                         {
-                        traceMsg(cg->comp(), ""Examining monexit [%p]\n"", monexitNode);
-                        }
-
-                     // Make sure the object we are synchronizing on is the same object
-                     if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
-                        {
-                        int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
-
-                        if (cg->comp()->getOption(TR_TraceCG))
+                        if (performTransformation(cg->comp(), ""%sReplacing monent [%p] - monexit [%p] synchronized region on load [%p] with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode, loadNode))
                            {
-                           traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
-                           }
+                           transformed = true;
 
-                        // LPD(G) is an SSF instruction with a 12-bit displacement
-                        if (lockWordOffset > 0 && lockWordOffset < 4096)
-                           {
-                           if (performTransformation(cg->comp(), ""%sReplacing monent [%p] monexit [%p] synchronized region with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode))
-                              {
-                              transformed = true;
-
-                              // Fabricate a special codegen inlined method call symbol reference
-                              TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
+                           // Fabricate a special codegen inlined method call symbol reference
+                           TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
 
-                              TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
+                           TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
 
-                              callNode->setAndIncChild(0, synchronizedObjectNode);
-                              callNode->setAndIncChild(1, loadNode);
+                           callNode->setAndIncChild(0, synchronizedObjectNode);
+                           callNode->setAndIncChild(1, loadNode);
 
-                              TR::Node* lockWordOffsetNode = TR::Node::iconst (loadNode, lockWordOffset);
+                           TR::Node* lockWordOffsetNode = TR::Node::iconst(loadNode, lockWordOffset);
 
-                              callNode->setAndIncChild(2, lockWordOffsetNode);
+                           callNode->setAndIncChild(2, lockWordOffsetNode);
 
-                              TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
-                              TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
+                           TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
+                           TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
 
-                              callNode->setAndIncChild(3, monentSymbolReferenceNode);
-                              callNode->setAndIncChild(4, monexitSymbolReferenceNode);
+                           callNode->setAndIncChild(3, monentSymbolReferenceNode);
+                           callNode->setAndIncChild(4, monexitSymbolReferenceNode);
 
-                              TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
+                           TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
 
-                              TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
+                           TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
 
-                              // Insert fabricated call treetop
-                              savedIter.currentTree()->insertBefore(callTreeTop);
+                           // Insert fabricated call treetop
+                           monentTreeTop->insertBefore(callTreeTop);
 
-                              // Remove pattern matched intermediate treetops
-                              for (auto i = treeTopsToRemove.begin(); i != treeTopsToRemove.end(); ++i)
-                                 {
-                                 (*i)->unlink(true);
-                                 }
+                           // Remove the monitor region
+                           monentTreeTop->unlink(true);
+                           monexitTreeTop->unlink(true);
 
-                              TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
-                              }
-                           }
-                        else
-                           {
-                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
+                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
                            }
                         }
                      else
                         {
-                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
                         }
                      }
                   else
                      {
-                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-not-found/%s"", cg->comp()->signature()));
+                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
                      }
                   }
                else
                   {
-                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
                   }
-               }
-            else
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
+
+               break;
                }
             }
-         else
+
+         if (iter == endTreeTop)
             {
-            TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/treetop-or-compressedRefs-not-found/%s"", cg->comp()->signature()));
+            break;
             }
          }
       }
 
    return transformed;
    }
 
-bool
-ReduceSynchronizedFieldLoad::advanceIterator(TR::TreeTopIterator& iter, TR::TreeTop* endTreeTop)
+TR::Node*
+ReduceSynchronizedFieldLoad::findLoadInSynchornizedRegion(TR::TreeTop* startTreeTop, TR::TreeTop* endTreeTop, TR::TreeTop* monentTreeTop, TR::TreeTop* monexitTreeTop, TR::Node* synchronizedObjectNode)
    {
-   ++iter;
-
-   if (iter == endTreeTop)
+   TR::PreorderNodeIterator iter(startTreeTop, cg->comp());
+
+   // First iterate though all the nodes from the start treetop until we reach the monitor provided so that all nodes
+   // seen thus far would have already been visited, and hence we will not recurse into them in the subsequent for loop
+   // since a reference was already seen. This enables us to carry out the reduce synchronized field load optimization
+   // even if there are sideeffect nodes within the monitored region - as long as those sideeffect nodes have been
+   // evaluated outside of the monitored region.
+   for (; iter != monentTreeTop->getNextTreeTop(); ++iter)
       {
-      --iter;
-
-      TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/advanceIterator/%s"", cg->comp()->signature()));
+      TR::Node* currentNode = iter.currentNode();
 
-      return false;
+      if (cg->comp()->getOption(TR_TraceCG))
+         {
+         traceMsg(cg->comp(), ""Iterating node [%p] outside the monitored region\n"", currentNode);
+         }
       }
 
-   if (cg->comp()->getOption(TR_TraceCG))
-      {
-      traceMsg(cg->comp(), ""Advancing iterator to [%p]\n"", iter.currentNode());
-      }
+   TR::Node* loadNode = NULL;
 
-   // Synchronized region may span multiple blocks
-   if (iter.currentNode()->getOpCodeValue() == TR::BBEnd)
+   for (; iter != monexitTreeTop; ++iter)
       {
-      TR::TreeTop* nextTreeTop = iter.currentTree()->getNextTreeTop();
+      TR::Node* currentNode = iter.currentNode();
 
-      if (nextTreeTop == NULL || nextTreeTop == endTreeTop || !nextTreeTop->getNode()->getBlock()->isExtensionOfPreviousBlock())
+      if (cg->comp()->getOption(TR_TraceCG))
          {
-         TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/advanceIterator/%s"", cg->comp()->signature()));
-
-         return false;
+         traceMsg(cg->comp(), ""Iterating node [%p] inside the monitored region\n"", currentNode);
          }
-      else
-         {
-         ++iter;
 
-         // Sanity check that a new block starts after the previous
-         TR_ASSERT(iter.currentNode()->getOpCodeValue() == TR::BBStart, ""Expecting a BBStart treetop but found %s\n"", iter.currentNode()->getOpCode().getName());
+      TR::ILOpCode opcode = currentNode->getOpCode();
 
-         ++iter;
+      if (opcode.hasSymbolReference() || opcode.isBranch())","I get that use of this function is to find a load node within synchronized region. Let me know if I am wrong here, but in the synchronized region, if a node is branch node or it has a symbol reference but is not a candidate for synchronized field load, for these kind of side effect nodes, this optimization will be disabled, right?",
75487960,20558378356995b1c6deec0ae044fefb99a11179,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,True,"@@ -282,292 +265,191 @@ ReduceSynchronizedFieldLoad::performOnTreeTops(TR::TreeTop* startTreeTop, TR::Tr
    {
    bool transformed = false;
 
-   TR::list<TR::TreeTop*> treeTopsToRemove (getTypedAllocator<TR::TreeTop*>(cg->comp()->allocator()));
-
    for (TR::TreeTopIterator iter(startTreeTop, cg->comp()); iter != endTreeTop; ++iter)
       {
-      treeTopsToRemove.clear();
-
-      if (iter.currentNode()->getOpCodeValue() == TR::monent)
+      if (iter.currentNode()->getOpCodeValue() == TR::monent ||
+          iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monent)
          {
-         treeTopsToRemove.push_back(iter.currentTree());
-
-         TR::Node* monentNode = iter.currentNode();
+         TR::TreeTop* monentTreeTop = iter.currentTree();
+         TR::Node* monentNode = iter.currentNode()->getOpCodeValue() == TR::monent ?
+            iter.currentNode() :
+            iter.currentNode()->getFirstChild();
 
          if (cg->comp()->getOption(TR_TraceCG))
             {
-            traceMsg(cg->comp(), ""Examining monent [%p]\n"", monentNode);
-            }
-
-         // Save the current iterator location for tree replacement should the pattern matching succeed
-         TR::TreeTopIterator savedIter = iter;
-
-         if (!advanceIterator(iter, endTreeTop))
-            {
-            continue;
+            traceMsg(cg->comp(), ""Found monent [%p]\n"", monentNode);
             }
 
-         TR::Node* lookaheadChildNode = iter.currentNode();
-
-         if (lookaheadChildNode->getOpCodeValue() == TR::treetop || lookaheadChildNode->getOpCodeValue() == TR::compressedRefs)
+         for (++iter; iter != endTreeTop; ++iter)
             {
-            TR::Node* loadNode = lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-            // When concurrent scavenge is enabled we need to load the object reference using a read barrier however
-            // there is no guarded load alternative for the LPD instruction. As such this optimization cannot be carried
-            // out for object reference loads under concurrent scavenge.
-            if (TR::Compiler->om.shouldGenerateReadBarriersForFieldLoads() && loadNode->getDataType().isAddress())
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/read-barrier/%s"", cg->comp()->signature()));
-
-               continue;
-               }
-
-            if (lookaheadChildNode->getOpCodeValue() == TR::l2a)
+            if (iter.currentNode()->getOpCodeValue() == TR::monexit ||
+                iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monexit)
                {
-               TR::Node* l2aChildNode = lookaheadChildNode->getChild(0);
-
-               if (l2aChildNode->isUnneededConversion())
-                  {
-                  lookaheadChildNode = l2aChildNode->getChild(0);
-
-                  // There may or may not be a compression sequence at this point
-                  if (lookaheadChildNode->getOpCodeValue() == TR::lshl && lookaheadChildNode->containsCompressionSequence())
-                     {
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-                     if (lookaheadChildNode->getOpCodeValue() == TR::iu2l && lookaheadChildNode->isUnneededConversion())
-                        {
-                        lookaheadChildNode = lookaheadChildNode->getChild(0);
-                        }
-                     }
-                  }
-               }
+               TR::TreeTop* monexitTreeTop = iter.currentTree();
+               TR::Node* monexitNode = iter.currentNode()->getOpCodeValue() == TR::monexit ?
+                  iter.currentNode() :
+                  iter.currentNode()->getFirstChild();
 
-            if (lookaheadChildNode->getOpCode().isLoadIndirect())
-               {
-               // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
-               if (TR::Compiler->target.is32Bit() && lookaheadChildNode->getSymbolReference()->getSymbol()->getSize() == 8)
+               if (cg->comp()->getOption(TR_TraceCG))
                   {
-                  continue;
+                  traceMsg(cg->comp(), ""Found monexit [%p]\n"", monexitNode);
                   }
 
-               TR::Node* synchronizedObjectNode = monentNode->getChild(0);
+               TR::Node* synchronizedObjectNode = monentNode->getFirstChild();
 
-               // Make sure the object we are synchronizing on is the same object we are loading from
-               if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
+               if (synchronizedObjectNode == monexitNode->getFirstChild())
                   {
-                  treeTopsToRemove.push_back(iter.currentTree());
-
                   if (cg->comp()->getOption(TR_TraceCG))
                      {
-                     traceMsg(cg->comp(), ""Found load [%p] from synchronized object [%p]\n"", loadNode, synchronizedObjectNode);
-                     }
-
-                  if (!advanceIterator(iter, endTreeTop))
-                     {
-                     continue;
+                     traceMsg(cg->comp(), ""Children of monent and monexit are synchronizing on the same object\n"", monexitNode);
                      }
 
-                  lookaheadChildNode = iter.currentNode();
+                  TR::Node* loadNode = findLoadInSynchornizedRegion(startTreeTop, endTreeTop, monentTreeTop, monexitTreeTop, synchronizedObjectNode);
 
-                  // Skip monexit fences
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexitfence)
+                  if (loadNode != NULL)
                      {
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
+                     if (TR::Compiler->target.is32Bit() && J9::DataType::getSize(loadNode->getDataType()) == 8)
                         {
-                        traceMsg(cg->comp(), ""Skipping monexitfence [%p]\n"", lookaheadChildNode);
-                        }
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/31-bit-register-pairs/%s"", cg->comp()->signature()));
 
-                     // Note that we cannot actually eliminate these monexit fences. They are used during instruction
-                     // selection as barriers for the live monitor stacks. When we encounter astores which hold monitor
-                     // objects (i.e. holdsMonitoredObject returns true) we push the object onto a live monitor stack.
-                     // We pop off this stack when a monexitfence is encountered. This stack dictates the live monitor
-                     // data that gets assigned to every instruction and subsequently gets filled out if we request
-                     // a GC map to be generated for a particular instruction.
-                     //
-                     // For more details please see J9::CodeGenerator::doInstructionSelection()
-                     if (!advanceIterator(iter, endTreeTop))
-                        {
-                        continue;
+                        break;
                         }
 
-                     lookaheadChildNode = iter.currentNode();
-                     }
+                     int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
 
-                  // Skip global register stores of the loaded value since this is a NOP at codegen time
-                  if (lookaheadChildNode->getOpCodeValue() == TR::aRegStore || lookaheadChildNode->getOpCodeValue() == TR::iRegStore || lookaheadChildNode->getOpCodeValue() == TR::lRegStore)
-                     {
-                     if (lookaheadChildNode->getChild(0) == loadNode)
-                        {
-                        if (cg->comp()->getOption(TR_TraceCG))
-                           {
-                           traceMsg(cg->comp(), ""Skipping (a|i|l)regStore [%p]\n"", lookaheadChildNode);
-                           }
-
-                        if (!advanceIterator(iter, endTreeTop))
-                           {
-                           continue;
-                           }
-
-                        lookaheadChildNode = iter.currentNode();
-                        }
-                     }
-
-                  // Skip treetop nodes (in case there is a treetop on top of a monexit)
-                  if (lookaheadChildNode->getOpCodeValue() == TR::treetop)
-                     {
                      if (cg->comp()->getOption(TR_TraceCG))
                         {
-                        traceMsg(cg->comp(), ""Skipping treetop [%p] and looking at its child instead\n"", lookaheadChildNode);
+                        traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
                         }
 
-                     // TODO: Figure out why this happens
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-                     }
-
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexit)
-                     {
-                     treeTopsToRemove.push_back(iter.currentTree());
-
-                     TR::Node* monexitNode = lookaheadChildNode;
-
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // LPD(G) is an SSF instruction with a 12-bit displacement
+                     if (lockWordOffset > 0 && lockWordOffset < 4096)
                         {
-                        traceMsg(cg->comp(), ""Examining monexit [%p]\n"", monexitNode);
-                        }
-
-                     // Make sure the object we are synchronizing on is the same object
-                     if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
-                        {
-                        int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
-
-                        if (cg->comp()->getOption(TR_TraceCG))
+                        if (performTransformation(cg->comp(), ""%sReplacing monent [%p] - monexit [%p] synchronized region on load [%p] with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode, loadNode))
                            {
-                           traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
-                           }
+                           transformed = true;
 
-                        // LPD(G) is an SSF instruction with a 12-bit displacement
-                        if (lockWordOffset > 0 && lockWordOffset < 4096)
-                           {
-                           if (performTransformation(cg->comp(), ""%sReplacing monent [%p] monexit [%p] synchronized region with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode))
-                              {
-                              transformed = true;
-
-                              // Fabricate a special codegen inlined method call symbol reference
-                              TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
+                           // Fabricate a special codegen inlined method call symbol reference
+                           TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
 
-                              TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
+                           TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
 
-                              callNode->setAndIncChild(0, synchronizedObjectNode);
-                              callNode->setAndIncChild(1, loadNode);
+                           callNode->setAndIncChild(0, synchronizedObjectNode);
+                           callNode->setAndIncChild(1, loadNode);
 
-                              TR::Node* lockWordOffsetNode = TR::Node::iconst (loadNode, lockWordOffset);
+                           TR::Node* lockWordOffsetNode = TR::Node::iconst(loadNode, lockWordOffset);
 
-                              callNode->setAndIncChild(2, lockWordOffsetNode);
+                           callNode->setAndIncChild(2, lockWordOffsetNode);
 
-                              TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
-                              TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
+                           TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
+                           TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
 
-                              callNode->setAndIncChild(3, monentSymbolReferenceNode);
-                              callNode->setAndIncChild(4, monexitSymbolReferenceNode);
+                           callNode->setAndIncChild(3, monentSymbolReferenceNode);
+                           callNode->setAndIncChild(4, monexitSymbolReferenceNode);
 
-                              TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
+                           TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
 
-                              TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
+                           TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
 
-                              // Insert fabricated call treetop
-                              savedIter.currentTree()->insertBefore(callTreeTop);
+                           // Insert fabricated call treetop
+                           monentTreeTop->insertBefore(callTreeTop);
 
-                              // Remove pattern matched intermediate treetops
-                              for (auto i = treeTopsToRemove.begin(); i != treeTopsToRemove.end(); ++i)
-                                 {
-                                 (*i)->unlink(true);
-                                 }
+                           // Remove the monitor region
+                           monentTreeTop->unlink(true);
+                           monexitTreeTop->unlink(true);
 
-                              TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
-                              }
-                           }
-                        else
-                           {
-                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
+                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
                            }
                         }
                      else
                         {
-                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
                         }
                      }
                   else
                      {
-                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-not-found/%s"", cg->comp()->signature()));
+                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
                      }
                   }
                else
                   {
-                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
                   }
-               }
-            else
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
+
+               break;
                }
             }
-         else
+
+         if (iter == endTreeTop)
             {
-            TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/treetop-or-compressedRefs-not-found/%s"", cg->comp()->signature()));
+            break;
             }
          }
       }
 
    return transformed;
    }
 
-bool
-ReduceSynchronizedFieldLoad::advanceIterator(TR::TreeTopIterator& iter, TR::TreeTop* endTreeTop)
+TR::Node*
+ReduceSynchronizedFieldLoad::findLoadInSynchornizedRegion(TR::TreeTop* startTreeTop, TR::TreeTop* endTreeTop, TR::TreeTop* monentTreeTop, TR::TreeTop* monexitTreeTop, TR::Node* synchronizedObjectNode)
    {
-   ++iter;
-
-   if (iter == endTreeTop)
+   TR::PreorderNodeIterator iter(startTreeTop, cg->comp());
+
+   // First iterate though all the nodes from the start treetop until we reach the monitor provided so that all nodes
+   // seen thus far would have already been visited, and hence we will not recurse into them in the subsequent for loop
+   // since a reference was already seen. This enables us to carry out the reduce synchronized field load optimization
+   // even if there are sideeffect nodes within the monitored region - as long as those sideeffect nodes have been
+   // evaluated outside of the monitored region.
+   for (; iter != monentTreeTop->getNextTreeTop(); ++iter)
       {
-      --iter;
-
-      TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/advanceIterator/%s"", cg->comp()->signature()));
+      TR::Node* currentNode = iter.currentNode();
 
-      return false;
+      if (cg->comp()->getOption(TR_TraceCG))
+         {
+         traceMsg(cg->comp(), ""Iterating node [%p] outside the monitored region\n"", currentNode);
+         }
       }
 
-   if (cg->comp()->getOption(TR_TraceCG))
-      {
-      traceMsg(cg->comp(), ""Advancing iterator to [%p]\n"", iter.currentNode());
-      }
+   TR::Node* loadNode = NULL;
 
-   // Synchronized region may span multiple blocks
-   if (iter.currentNode()->getOpCodeValue() == TR::BBEnd)
+   for (; iter != monexitTreeTop; ++iter)
       {
-      TR::TreeTop* nextTreeTop = iter.currentTree()->getNextTreeTop();
+      TR::Node* currentNode = iter.currentNode();
 
-      if (nextTreeTop == NULL || nextTreeTop == endTreeTop || !nextTreeTop->getNode()->getBlock()->isExtensionOfPreviousBlock())
+      if (cg->comp()->getOption(TR_TraceCG))
          {
-         TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/advanceIterator/%s"", cg->comp()->signature()));
-
-         return false;
+         traceMsg(cg->comp(), ""Iterating node [%p] inside the monitored region\n"", currentNode);
          }
-      else
-         {
-         ++iter;
 
-         // Sanity check that a new block starts after the previous
-         TR_ASSERT(iter.currentNode()->getOpCodeValue() == TR::BBStart, ""Expecting a BBStart treetop but found %s\n"", iter.currentNode()->getOpCode().getName());
+      TR::ILOpCode opcode = currentNode->getOpCode();
 
-         ++iter;
+      if (opcode.hasSymbolReference() || opcode.isBranch())","@r30shah yes that is correct. The only exit condition out of the for loop is the `break` statement towards the end (other than reaching the `monexit` that is). If you follow the logic to reach the `break` it reads in English as follows:

If there exists a node in the synchronized region that has a symbol reference or is a branch then unless this node is an indirect load off the synchronized object and no previous such load has been seen then terminate the for loop and return that no candidate has been found. Otherwise return the single load (if any) as the candidate.",
75491165,20558378356995b1c6deec0ae044fefb99a11179,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,True,"@@ -282,292 +265,191 @@ ReduceSynchronizedFieldLoad::performOnTreeTops(TR::TreeTop* startTreeTop, TR::Tr
    {
    bool transformed = false;
 
-   TR::list<TR::TreeTop*> treeTopsToRemove (getTypedAllocator<TR::TreeTop*>(cg->comp()->allocator()));
-
    for (TR::TreeTopIterator iter(startTreeTop, cg->comp()); iter != endTreeTop; ++iter)
       {
-      treeTopsToRemove.clear();
-
-      if (iter.currentNode()->getOpCodeValue() == TR::monent)
+      if (iter.currentNode()->getOpCodeValue() == TR::monent ||
+          iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monent)
          {
-         treeTopsToRemove.push_back(iter.currentTree());
-
-         TR::Node* monentNode = iter.currentNode();
+         TR::TreeTop* monentTreeTop = iter.currentTree();
+         TR::Node* monentNode = iter.currentNode()->getOpCodeValue() == TR::monent ?
+            iter.currentNode() :
+            iter.currentNode()->getFirstChild();
 
          if (cg->comp()->getOption(TR_TraceCG))
             {
-            traceMsg(cg->comp(), ""Examining monent [%p]\n"", monentNode);
-            }
-
-         // Save the current iterator location for tree replacement should the pattern matching succeed
-         TR::TreeTopIterator savedIter = iter;
-
-         if (!advanceIterator(iter, endTreeTop))
-            {
-            continue;
+            traceMsg(cg->comp(), ""Found monent [%p]\n"", monentNode);
             }
 
-         TR::Node* lookaheadChildNode = iter.currentNode();
-
-         if (lookaheadChildNode->getOpCodeValue() == TR::treetop || lookaheadChildNode->getOpCodeValue() == TR::compressedRefs)
+         for (++iter; iter != endTreeTop; ++iter)
             {
-            TR::Node* loadNode = lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-            // When concurrent scavenge is enabled we need to load the object reference using a read barrier however
-            // there is no guarded load alternative for the LPD instruction. As such this optimization cannot be carried
-            // out for object reference loads under concurrent scavenge.
-            if (TR::Compiler->om.shouldGenerateReadBarriersForFieldLoads() && loadNode->getDataType().isAddress())
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/read-barrier/%s"", cg->comp()->signature()));
-
-               continue;
-               }
-
-            if (lookaheadChildNode->getOpCodeValue() == TR::l2a)
+            if (iter.currentNode()->getOpCodeValue() == TR::monexit ||
+                iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monexit)
                {
-               TR::Node* l2aChildNode = lookaheadChildNode->getChild(0);
-
-               if (l2aChildNode->isUnneededConversion())
-                  {
-                  lookaheadChildNode = l2aChildNode->getChild(0);
-
-                  // There may or may not be a compression sequence at this point
-                  if (lookaheadChildNode->getOpCodeValue() == TR::lshl && lookaheadChildNode->containsCompressionSequence())
-                     {
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-                     if (lookaheadChildNode->getOpCodeValue() == TR::iu2l && lookaheadChildNode->isUnneededConversion())
-                        {
-                        lookaheadChildNode = lookaheadChildNode->getChild(0);
-                        }
-                     }
-                  }
-               }
+               TR::TreeTop* monexitTreeTop = iter.currentTree();
+               TR::Node* monexitNode = iter.currentNode()->getOpCodeValue() == TR::monexit ?
+                  iter.currentNode() :
+                  iter.currentNode()->getFirstChild();
 
-            if (lookaheadChildNode->getOpCode().isLoadIndirect())
-               {
-               // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
-               if (TR::Compiler->target.is32Bit() && lookaheadChildNode->getSymbolReference()->getSymbol()->getSize() == 8)
+               if (cg->comp()->getOption(TR_TraceCG))
                   {
-                  continue;
+                  traceMsg(cg->comp(), ""Found monexit [%p]\n"", monexitNode);
                   }
 
-               TR::Node* synchronizedObjectNode = monentNode->getChild(0);
+               TR::Node* synchronizedObjectNode = monentNode->getFirstChild();
 
-               // Make sure the object we are synchronizing on is the same object we are loading from
-               if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
+               if (synchronizedObjectNode == monexitNode->getFirstChild())
                   {
-                  treeTopsToRemove.push_back(iter.currentTree());
-
                   if (cg->comp()->getOption(TR_TraceCG))
                      {
-                     traceMsg(cg->comp(), ""Found load [%p] from synchronized object [%p]\n"", loadNode, synchronizedObjectNode);
-                     }
-
-                  if (!advanceIterator(iter, endTreeTop))
-                     {
-                     continue;
+                     traceMsg(cg->comp(), ""Children of monent and monexit are synchronizing on the same object\n"", monexitNode);
                      }
 
-                  lookaheadChildNode = iter.currentNode();
+                  TR::Node* loadNode = findLoadInSynchornizedRegion(startTreeTop, endTreeTop, monentTreeTop, monexitTreeTop, synchronizedObjectNode);
 
-                  // Skip monexit fences
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexitfence)
+                  if (loadNode != NULL)
                      {
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
+                     if (TR::Compiler->target.is32Bit() && J9::DataType::getSize(loadNode->getDataType()) == 8)
                         {
-                        traceMsg(cg->comp(), ""Skipping monexitfence [%p]\n"", lookaheadChildNode);
-                        }
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/31-bit-register-pairs/%s"", cg->comp()->signature()));
 
-                     // Note that we cannot actually eliminate these monexit fences. They are used during instruction
-                     // selection as barriers for the live monitor stacks. When we encounter astores which hold monitor
-                     // objects (i.e. holdsMonitoredObject returns true) we push the object onto a live monitor stack.
-                     // We pop off this stack when a monexitfence is encountered. This stack dictates the live monitor
-                     // data that gets assigned to every instruction and subsequently gets filled out if we request
-                     // a GC map to be generated for a particular instruction.
-                     //
-                     // For more details please see J9::CodeGenerator::doInstructionSelection()
-                     if (!advanceIterator(iter, endTreeTop))
-                        {
-                        continue;
+                        break;
                         }
 
-                     lookaheadChildNode = iter.currentNode();
-                     }
+                     int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
 
-                  // Skip global register stores of the loaded value since this is a NOP at codegen time
-                  if (lookaheadChildNode->getOpCodeValue() == TR::aRegStore || lookaheadChildNode->getOpCodeValue() == TR::iRegStore || lookaheadChildNode->getOpCodeValue() == TR::lRegStore)
-                     {
-                     if (lookaheadChildNode->getChild(0) == loadNode)
-                        {
-                        if (cg->comp()->getOption(TR_TraceCG))
-                           {
-                           traceMsg(cg->comp(), ""Skipping (a|i|l)regStore [%p]\n"", lookaheadChildNode);
-                           }
-
-                        if (!advanceIterator(iter, endTreeTop))
-                           {
-                           continue;
-                           }
-
-                        lookaheadChildNode = iter.currentNode();
-                        }
-                     }
-
-                  // Skip treetop nodes (in case there is a treetop on top of a monexit)
-                  if (lookaheadChildNode->getOpCodeValue() == TR::treetop)
-                     {
                      if (cg->comp()->getOption(TR_TraceCG))
                         {
-                        traceMsg(cg->comp(), ""Skipping treetop [%p] and looking at its child instead\n"", lookaheadChildNode);
+                        traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
                         }
 
-                     // TODO: Figure out why this happens
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-                     }
-
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexit)
-                     {
-                     treeTopsToRemove.push_back(iter.currentTree());
-
-                     TR::Node* monexitNode = lookaheadChildNode;
-
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // LPD(G) is an SSF instruction with a 12-bit displacement
+                     if (lockWordOffset > 0 && lockWordOffset < 4096)
                         {
-                        traceMsg(cg->comp(), ""Examining monexit [%p]\n"", monexitNode);
-                        }
-
-                     // Make sure the object we are synchronizing on is the same object
-                     if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
-                        {
-                        int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
-
-                        if (cg->comp()->getOption(TR_TraceCG))
+                        if (performTransformation(cg->comp(), ""%sReplacing monent [%p] - monexit [%p] synchronized region on load [%p] with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode, loadNode))
                            {
-                           traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
-                           }
+                           transformed = true;
 
-                        // LPD(G) is an SSF instruction with a 12-bit displacement
-                        if (lockWordOffset > 0 && lockWordOffset < 4096)
-                           {
-                           if (performTransformation(cg->comp(), ""%sReplacing monent [%p] monexit [%p] synchronized region with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode))
-                              {
-                              transformed = true;
-
-                              // Fabricate a special codegen inlined method call symbol reference
-                              TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
+                           // Fabricate a special codegen inlined method call symbol reference
+                           TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
 
-                              TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
+                           TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
 
-                              callNode->setAndIncChild(0, synchronizedObjectNode);
-                              callNode->setAndIncChild(1, loadNode);
+                           callNode->setAndIncChild(0, synchronizedObjectNode);
+                           callNode->setAndIncChild(1, loadNode);
 
-                              TR::Node* lockWordOffsetNode = TR::Node::iconst (loadNode, lockWordOffset);
+                           TR::Node* lockWordOffsetNode = TR::Node::iconst(loadNode, lockWordOffset);
 
-                              callNode->setAndIncChild(2, lockWordOffsetNode);
+                           callNode->setAndIncChild(2, lockWordOffsetNode);
 
-                              TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
-                              TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
+                           TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
+                           TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
 
-                              callNode->setAndIncChild(3, monentSymbolReferenceNode);
-                              callNode->setAndIncChild(4, monexitSymbolReferenceNode);
+                           callNode->setAndIncChild(3, monentSymbolReferenceNode);
+                           callNode->setAndIncChild(4, monexitSymbolReferenceNode);
 
-                              TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
+                           TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
 
-                              TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
+                           TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
 
-                              // Insert fabricated call treetop
-                              savedIter.currentTree()->insertBefore(callTreeTop);
+                           // Insert fabricated call treetop
+                           monentTreeTop->insertBefore(callTreeTop);
 
-                              // Remove pattern matched intermediate treetops
-                              for (auto i = treeTopsToRemove.begin(); i != treeTopsToRemove.end(); ++i)
-                                 {
-                                 (*i)->unlink(true);
-                                 }
+                           // Remove the monitor region
+                           monentTreeTop->unlink(true);
+                           monexitTreeTop->unlink(true);
 
-                              TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
-                              }
-                           }
-                        else
-                           {
-                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
+                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
                            }
                         }
                      else
                         {
-                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
                         }
                      }
                   else
                      {
-                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-not-found/%s"", cg->comp()->signature()));
+                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
                      }
                   }
                else
                   {
-                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
                   }
-               }
-            else
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
+
+               break;
                }
             }
-         else
+
+         if (iter == endTreeTop)
             {
-            TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/treetop-or-compressedRefs-not-found/%s"", cg->comp()->signature()));
+            break;
             }
          }
       }
 
    return transformed;
    }
 
-bool
-ReduceSynchronizedFieldLoad::advanceIterator(TR::TreeTopIterator& iter, TR::TreeTop* endTreeTop)
+TR::Node*
+ReduceSynchronizedFieldLoad::findLoadInSynchornizedRegion(TR::TreeTop* startTreeTop, TR::TreeTop* endTreeTop, TR::TreeTop* monentTreeTop, TR::TreeTop* monexitTreeTop, TR::Node* synchronizedObjectNode)
    {
-   ++iter;
-
-   if (iter == endTreeTop)
+   TR::PreorderNodeIterator iter(startTreeTop, cg->comp());
+
+   // First iterate though all the nodes from the start treetop until we reach the monitor provided so that all nodes",Fixed in https://github.com/eclipse/openj9/pull/537/commits/f0d6165d233d4ec5093534156a4182373c810679,
75493827,20558378356995b1c6deec0ae044fefb99a11179,runtime/tr.source/trj9/z/codegen/ReduceSynchronizedFieldLoad.cpp,False,"@@ -282,292 +265,191 @@ ReduceSynchronizedFieldLoad::performOnTreeTops(TR::TreeTop* startTreeTop, TR::Tr
    {
    bool transformed = false;
 
-   TR::list<TR::TreeTop*> treeTopsToRemove (getTypedAllocator<TR::TreeTop*>(cg->comp()->allocator()));
-
    for (TR::TreeTopIterator iter(startTreeTop, cg->comp()); iter != endTreeTop; ++iter)
       {
-      treeTopsToRemove.clear();
-
-      if (iter.currentNode()->getOpCodeValue() == TR::monent)
+      if (iter.currentNode()->getOpCodeValue() == TR::monent ||
+          iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monent)
          {
-         treeTopsToRemove.push_back(iter.currentTree());
-
-         TR::Node* monentNode = iter.currentNode();
+         TR::TreeTop* monentTreeTop = iter.currentTree();
+         TR::Node* monentNode = iter.currentNode()->getOpCodeValue() == TR::monent ?
+            iter.currentNode() :
+            iter.currentNode()->getFirstChild();
 
          if (cg->comp()->getOption(TR_TraceCG))
             {
-            traceMsg(cg->comp(), ""Examining monent [%p]\n"", monentNode);
-            }
-
-         // Save the current iterator location for tree replacement should the pattern matching succeed
-         TR::TreeTopIterator savedIter = iter;
-
-         if (!advanceIterator(iter, endTreeTop))
-            {
-            continue;
+            traceMsg(cg->comp(), ""Found monent [%p]\n"", monentNode);
             }
 
-         TR::Node* lookaheadChildNode = iter.currentNode();
-
-         if (lookaheadChildNode->getOpCodeValue() == TR::treetop || lookaheadChildNode->getOpCodeValue() == TR::compressedRefs)
+         for (++iter; iter != endTreeTop; ++iter)
             {
-            TR::Node* loadNode = lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-            // When concurrent scavenge is enabled we need to load the object reference using a read barrier however
-            // there is no guarded load alternative for the LPD instruction. As such this optimization cannot be carried
-            // out for object reference loads under concurrent scavenge.
-            if (TR::Compiler->om.shouldGenerateReadBarriersForFieldLoads() && loadNode->getDataType().isAddress())
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/read-barrier/%s"", cg->comp()->signature()));
-
-               continue;
-               }
-
-            if (lookaheadChildNode->getOpCodeValue() == TR::l2a)
+            if (iter.currentNode()->getOpCodeValue() == TR::monexit ||
+                iter.currentNode()->getOpCodeValue() == TR::treetop && iter.currentNode()->getFirstChild()->getOpCodeValue() == TR::monexit)
                {
-               TR::Node* l2aChildNode = lookaheadChildNode->getChild(0);
-
-               if (l2aChildNode->isUnneededConversion())
-                  {
-                  lookaheadChildNode = l2aChildNode->getChild(0);
-
-                  // There may or may not be a compression sequence at this point
-                  if (lookaheadChildNode->getOpCodeValue() == TR::lshl && lookaheadChildNode->containsCompressionSequence())
-                     {
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-
-                     if (lookaheadChildNode->getOpCodeValue() == TR::iu2l && lookaheadChildNode->isUnneededConversion())
-                        {
-                        lookaheadChildNode = lookaheadChildNode->getChild(0);
-                        }
-                     }
-                  }
-               }
+               TR::TreeTop* monexitTreeTop = iter.currentTree();
+               TR::Node* monexitNode = iter.currentNode()->getOpCodeValue() == TR::monexit ?
+                  iter.currentNode() :
+                  iter.currentNode()->getFirstChild();
 
-            if (lookaheadChildNode->getOpCode().isLoadIndirect())
-               {
-               // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
-               if (TR::Compiler->target.is32Bit() && lookaheadChildNode->getSymbolReference()->getSymbol()->getSize() == 8)
+               if (cg->comp()->getOption(TR_TraceCG))
                   {
-                  continue;
+                  traceMsg(cg->comp(), ""Found monexit [%p]\n"", monexitNode);
                   }
 
-               TR::Node* synchronizedObjectNode = monentNode->getChild(0);
+               TR::Node* synchronizedObjectNode = monentNode->getFirstChild();
 
-               // Make sure the object we are synchronizing on is the same object we are loading from
-               if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
+               if (synchronizedObjectNode == monexitNode->getFirstChild())
                   {
-                  treeTopsToRemove.push_back(iter.currentTree());
-
                   if (cg->comp()->getOption(TR_TraceCG))
                      {
-                     traceMsg(cg->comp(), ""Found load [%p] from synchronized object [%p]\n"", loadNode, synchronizedObjectNode);
-                     }
-
-                  if (!advanceIterator(iter, endTreeTop))
-                     {
-                     continue;
+                     traceMsg(cg->comp(), ""Children of monent and monexit are synchronizing on the same object\n"", monexitNode);
                      }
 
-                  lookaheadChildNode = iter.currentNode();
+                  TR::Node* loadNode = findLoadInSynchornizedRegion(startTreeTop, endTreeTop, monentTreeTop, monexitTreeTop, synchronizedObjectNode);
 
-                  // Skip monexit fences
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexitfence)
+                  if (loadNode != NULL)
                      {
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // Disallow this optimization for 64-bit loads on 31-bit JVM due to register pairs
+                     if (TR::Compiler->target.is32Bit() && J9::DataType::getSize(loadNode->getDataType()) == 8)
                         {
-                        traceMsg(cg->comp(), ""Skipping monexitfence [%p]\n"", lookaheadChildNode);
-                        }
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/31-bit-register-pairs/%s"", cg->comp()->signature()));
 
-                     // Note that we cannot actually eliminate these monexit fences. They are used during instruction
-                     // selection as barriers for the live monitor stacks. When we encounter astores which hold monitor
-                     // objects (i.e. holdsMonitoredObject returns true) we push the object onto a live monitor stack.
-                     // We pop off this stack when a monexitfence is encountered. This stack dictates the live monitor
-                     // data that gets assigned to every instruction and subsequently gets filled out if we request
-                     // a GC map to be generated for a particular instruction.
-                     //
-                     // For more details please see J9::CodeGenerator::doInstructionSelection()
-                     if (!advanceIterator(iter, endTreeTop))
-                        {
-                        continue;
+                        break;
                         }
 
-                     lookaheadChildNode = iter.currentNode();
-                     }
+                     int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
 
-                  // Skip global register stores of the loaded value since this is a NOP at codegen time
-                  if (lookaheadChildNode->getOpCodeValue() == TR::aRegStore || lookaheadChildNode->getOpCodeValue() == TR::iRegStore || lookaheadChildNode->getOpCodeValue() == TR::lRegStore)
-                     {
-                     if (lookaheadChildNode->getChild(0) == loadNode)
-                        {
-                        if (cg->comp()->getOption(TR_TraceCG))
-                           {
-                           traceMsg(cg->comp(), ""Skipping (a|i|l)regStore [%p]\n"", lookaheadChildNode);
-                           }
-
-                        if (!advanceIterator(iter, endTreeTop))
-                           {
-                           continue;
-                           }
-
-                        lookaheadChildNode = iter.currentNode();
-                        }
-                     }
-
-                  // Skip treetop nodes (in case there is a treetop on top of a monexit)
-                  if (lookaheadChildNode->getOpCodeValue() == TR::treetop)
-                     {
                      if (cg->comp()->getOption(TR_TraceCG))
                         {
-                        traceMsg(cg->comp(), ""Skipping treetop [%p] and looking at its child instead\n"", lookaheadChildNode);
+                        traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
                         }
 
-                     // TODO: Figure out why this happens
-                     lookaheadChildNode = lookaheadChildNode->getChild(0);
-                     }
-
-                  if (lookaheadChildNode->getOpCodeValue() == TR::monexit)
-                     {
-                     treeTopsToRemove.push_back(iter.currentTree());
-
-                     TR::Node* monexitNode = lookaheadChildNode;
-
-                     if (cg->comp()->getOption(TR_TraceCG))
+                     // LPD(G) is an SSF instruction with a 12-bit displacement
+                     if (lockWordOffset > 0 && lockWordOffset < 4096)
                         {
-                        traceMsg(cg->comp(), ""Examining monexit [%p]\n"", monexitNode);
-                        }
-
-                     // Make sure the object we are synchronizing on is the same object
-                     if (lookaheadChildNode->getChild(0) == synchronizedObjectNode)
-                        {
-                        int32_t lockWordOffset = static_cast<TR_J9VMBase*>(cg->comp()->fe())->getByteOffsetToLockword(static_cast<TR_OpaqueClassBlock*>(cg->getMonClass(monentNode)));
-
-                        if (cg->comp()->getOption(TR_TraceCG))
+                        if (performTransformation(cg->comp(), ""%sReplacing monent [%p] - monexit [%p] synchronized region on load [%p] with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode, loadNode))
                            {
-                           traceMsg(cg->comp(), ""Lock word offset = %d\n"", lockWordOffset);
-                           }
+                           transformed = true;
 
-                        // LPD(G) is an SSF instruction with a 12-bit displacement
-                        if (lockWordOffset > 0 && lockWordOffset < 4096)
-                           {
-                           if (performTransformation(cg->comp(), ""%sReplacing monent [%p] monexit [%p] synchronized region with fabricated call\n"", OPT_DETAILS, monentNode, monexitNode))
-                              {
-                              transformed = true;
-
-                              // Fabricate a special codegen inlined method call symbol reference
-                              TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
+                           // Fabricate a special codegen inlined method call symbol reference
+                           TR::SymbolReference* methodSymRef = cg->comp()->getSymRefTab()->findOrCreateCodeGenInlinedHelper(TR::SymbolReferenceTable::synchronizedFieldLoadSymbol);
 
-                              TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
+                           TR::Node* callNode = TR::Node::createWithSymRef(loadNode, TR::call, 5, methodSymRef);
 
-                              callNode->setAndIncChild(0, synchronizedObjectNode);
-                              callNode->setAndIncChild(1, loadNode);
+                           callNode->setAndIncChild(0, synchronizedObjectNode);
+                           callNode->setAndIncChild(1, loadNode);
 
-                              TR::Node* lockWordOffsetNode = TR::Node::iconst (loadNode, lockWordOffset);
+                           TR::Node* lockWordOffsetNode = TR::Node::iconst(loadNode, lockWordOffset);
 
-                              callNode->setAndIncChild(2, lockWordOffsetNode);
+                           callNode->setAndIncChild(2, lockWordOffsetNode);
 
-                              TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
-                              TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
+                           TR::Node* monentSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monentNode->getSymbolReference());
+                           TR::Node* monexitSymbolReferenceNode = TR::Node::createWithSymRef(loadNode, TR::call, 1, synchronizedObjectNode, monexitNode->getSymbolReference());
 
-                              callNode->setAndIncChild(3, monentSymbolReferenceNode);
-                              callNode->setAndIncChild(4, monexitSymbolReferenceNode);
+                           callNode->setAndIncChild(3, monentSymbolReferenceNode);
+                           callNode->setAndIncChild(4, monexitSymbolReferenceNode);
 
-                              TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
+                           TR::Node* treeTopNode = TR::Node::create(loadNode, TR::treetop, 1, callNode);
 
-                              TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
+                           TR::TreeTop* callTreeTop = TR::TreeTop::create(cg->comp(), treeTopNode);
 
-                              // Insert fabricated call treetop
-                              savedIter.currentTree()->insertBefore(callTreeTop);
+                           // Insert fabricated call treetop
+                           monentTreeTop->insertBefore(callTreeTop);
 
-                              // Remove pattern matched intermediate treetops
-                              for (auto i = treeTopsToRemove.begin(); i != treeTopsToRemove.end(); ++i)
-                                 {
-                                 (*i)->unlink(true);
-                                 }
+                           // Remove the monitor region
+                           monentTreeTop->unlink(true);
+                           monexitTreeTop->unlink(true);
 
-                              TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
-                              }
-                           }
-                        else
-                           {
-                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
+                           TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/success/%s"", cg->comp()->signature()));
                            }
                         }
                      else
                         {
-                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                        TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/lockword-out-of-bounds/%s"", cg->comp()->signature()));
                         }
                      }
                   else
                      {
-                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-not-found/%s"", cg->comp()->signature()));
+                     TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
                      }
                   }
                else
                   {
-                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-synchronized-object-mismatch/%s"", cg->comp()->signature()));
+                  TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/monexit-synchronized-object-mismatch/%s"", cg->comp()->signature()));
                   }
-               }
-            else
-               {
-               TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/load-not-found/%s"", cg->comp()->signature()));
+
+               break;
                }
             }
-         else
+
+         if (iter == endTreeTop)
             {
-            TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/treetop-or-compressedRefs-not-found/%s"", cg->comp()->signature()));
+            break;
             }
          }
       }
 
    return transformed;
    }
 
-bool
-ReduceSynchronizedFieldLoad::advanceIterator(TR::TreeTopIterator& iter, TR::TreeTop* endTreeTop)
+TR::Node*
+ReduceSynchronizedFieldLoad::findLoadInSynchornizedRegion(TR::TreeTop* startTreeTop, TR::TreeTop* endTreeTop, TR::TreeTop* monentTreeTop, TR::TreeTop* monexitTreeTop, TR::Node* synchronizedObjectNode)
    {
-   ++iter;
-
-   if (iter == endTreeTop)
+   TR::PreorderNodeIterator iter(startTreeTop, cg->comp());
+
+   // First iterate though all the nodes from the start treetop until we reach the monitor provided so that all nodes
+   // seen thus far would have already been visited, and hence we will not recurse into them in the subsequent for loop
+   // since a reference was already seen. This enables us to carry out the reduce synchronized field load optimization
+   // even if there are sideeffect nodes within the monitored region - as long as those sideeffect nodes have been
+   // evaluated outside of the monitored region.
+   for (; iter != monentTreeTop->getNextTreeTop(); ++iter)
       {
-      --iter;
-
-      TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/advanceIterator/%s"", cg->comp()->signature()));
+      TR::Node* currentNode = iter.currentNode();
 
-      return false;
+      if (cg->comp()->getOption(TR_TraceCG))
+         {
+         traceMsg(cg->comp(), ""Iterating node [%p] outside the monitored region\n"", currentNode);
+         }
       }
 
-   if (cg->comp()->getOption(TR_TraceCG))
-      {
-      traceMsg(cg->comp(), ""Advancing iterator to [%p]\n"", iter.currentNode());
-      }
+   TR::Node* loadNode = NULL;
 
-   // Synchronized region may span multiple blocks
-   if (iter.currentNode()->getOpCodeValue() == TR::BBEnd)
+   for (; iter != monexitTreeTop; ++iter)
       {
-      TR::TreeTop* nextTreeTop = iter.currentTree()->getNextTreeTop();
+      TR::Node* currentNode = iter.currentNode();
 
-      if (nextTreeTop == NULL || nextTreeTop == endTreeTop || !nextTreeTop->getNode()->getBlock()->isExtensionOfPreviousBlock())
+      if (cg->comp()->getOption(TR_TraceCG))
          {
-         TR::DebugCounter::incStaticDebugCounter(cg->comp(), TR::DebugCounter::debugCounterName(cg->comp(), ""codegen/z/ReduceSynchronizedFieldLoad/failure/advanceIterator/%s"", cg->comp()->signature()));
-
-         return false;
+         traceMsg(cg->comp(), ""Iterating node [%p] inside the monitored region\n"", currentNode);
          }
-      else
-         {
-         ++iter;
 
-         // Sanity check that a new block starts after the previous
-         TR_ASSERT(iter.currentNode()->getOpCodeValue() == TR::BBStart, ""Expecting a BBStart treetop but found %s\n"", iter.currentNode()->getOpCode().getName());
+      TR::ILOpCode opcode = currentNode->getOpCode();
 
-         ++iter;
+      if (opcode.hasSymbolReference() || opcode.isBranch())",@fjeremic Thanks for the explanation. Changes looks good to me. ,
74788509,2b370f3de0cb7f7cc40c0ee14135272fffba84d0,buildenv/Build_Instructions_V9.md,False,"@@ -302,8 +302,99 @@ OpenJDK  - 437530c based on jdk-9+181)
 ## Windows
 :ledger:
 
-:construction:
-We haven't created a full build process for Windows yet? Watch this space!
+The following instructions guide you through the process of building a Windows OpenJDK V9 binary that contains Eclipse OpenJ9. This process can be used to build binaries for Windows 7, 8, and 10.
+
+### 1. Prepare your system
+:ledger:
+You must install a number of software dependencies to create a suitable build environment on your system.
+
+- [Cygwin](https://cygwin.com/install.html), which provides a Unix-style command line interface.
+- [Microsoft Visual Studio 2013](https://msdn.microsoft.com/en-us/library/dd831853(v=vs.120)), which is the same compiler level used by OpenJDK. Later levels of this compiler are not supported.",Should we provide the actual download link: https://my.visualstudio.com/Downloads?q=visual%20studio%202013&wt.mc_id=o~msft~vscom~older-downloads,
76195811,2b370f3de0cb7f7cc40c0ee14135272fffba84d0,buildenv/Build_Instructions_V9.md,False,"@@ -302,8 +302,102 @@ OpenJDK  - 437530c based on jdk-9+181)
 ## Windows
 :ledger:
 
-:construction:
-We haven't created a full build process for Windows yet? Watch this space!
+The following instructions guide you through the process of building a Windows OpenJDK V9 binary that contains Eclipse OpenJ9. This process can be used to build binaries for Windows 7, 8, and 10.
+
+### 1. Prepare your system
+:ledger:
+You must install a number of software dependencies to create a suitable build environment on your system:
+
+- [Cygwin](https://cygwin.com/install.html), which provides a Unix-style command line interface. Install all packages in the `Devel` category. In the `Archive` category, install the packages `zip` and `unzip`. Install any further package dependencies that are identified by the installer. More information about using Cygwin can be found [here](https://cygwin.com/docs.html).
+- [Windows JDK 8](https://adoptopenjdk.net/releases.html#x64_win), which is used as the boot JDK.
+- [Microsoft Visual Studio 2013]( https://go.microsoft.com/fwlink/?LinkId=532495), which is the same compiler level used by OpenJDK. Later levels of this compiler are not supported.
+- [Freemarker V2.3.8](https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download)
+- [Freetype2 V2.3](https://www.freetype.org/download.html)
+
+
+   You can download Visual Studio, Freemarker, and Freetype manually or obtain them using the [wget](http://www.gnu.org/software/wget/faq.html#download) utility. If you choose to use `wget`, follow these steps:
+
+- Open a cygwin terminal and change to the `/temp` directory:
+```
+cd /cygdrive/c/temp
+```
+
+- Run the following commands:
+```
+wget https://go.microsoft.com/fwlink/?LinkId=532495 -O vs2013.exe
+wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker-2.3.8.tar.gz
+wget http://download.savannah.gnu.org/releases/freetype/freetype-2.5.3.tar.gz
+```
+- Before installing Visual Studio, change the permissions on the installation file by running `chmod u+x vs2013.exe`.
+- Install Visual Studio by running the file `vs2013.exe`. 
+
+- To unpack the Freemarker and Freetype compressed files, run:
+```
+tar --one-top-level=/cygdrive/c/temp/freemarker --strip-components=1 -xzf freemarker-2.3.8.tar.gz","Is this tar command intended to put the `freemarker.jar` into the /cygdrive/c/temp?  It doesn't seem to work and is different than the tar commands for the other platforms.

AIX: `tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2 \`
linux: `tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2`

Either this or the configure command below need to be updated",
76267752,2b370f3de0cb7f7cc40c0ee14135272fffba84d0,buildenv/Build_Instructions_V9.md,False,"@@ -302,8 +302,102 @@ OpenJDK  - 437530c based on jdk-9+181)
 ## Windows
 :ledger:
 
-:construction:
-We haven't created a full build process for Windows yet? Watch this space!
+The following instructions guide you through the process of building a Windows OpenJDK V9 binary that contains Eclipse OpenJ9. This process can be used to build binaries for Windows 7, 8, and 10.
+
+### 1. Prepare your system
+:ledger:
+You must install a number of software dependencies to create a suitable build environment on your system:
+
+- [Cygwin](https://cygwin.com/install.html), which provides a Unix-style command line interface. Install all packages in the `Devel` category. In the `Archive` category, install the packages `zip` and `unzip`. Install any further package dependencies that are identified by the installer. More information about using Cygwin can be found [here](https://cygwin.com/docs.html).
+- [Windows JDK 8](https://adoptopenjdk.net/releases.html#x64_win), which is used as the boot JDK.
+- [Microsoft Visual Studio 2013]( https://go.microsoft.com/fwlink/?LinkId=532495), which is the same compiler level used by OpenJDK. Later levels of this compiler are not supported.
+- [Freemarker V2.3.8](https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download)
+- [Freetype2 V2.3](https://www.freetype.org/download.html)
+
+
+   You can download Visual Studio, Freemarker, and Freetype manually or obtain them using the [wget](http://www.gnu.org/software/wget/faq.html#download) utility. If you choose to use `wget`, follow these steps:
+
+- Open a cygwin terminal and change to the `/temp` directory:
+```
+cd /cygdrive/c/temp
+```
+
+- Run the following commands:
+```
+wget https://go.microsoft.com/fwlink/?LinkId=532495 -O vs2013.exe
+wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker-2.3.8.tar.gz
+wget http://download.savannah.gnu.org/releases/freetype/freetype-2.5.3.tar.gz
+```
+- Before installing Visual Studio, change the permissions on the installation file by running `chmod u+x vs2013.exe`.
+- Install Visual Studio by running the file `vs2013.exe`. 
+
+- To unpack the Freemarker and Freetype compressed files, run:
+```
+tar --one-top-level=/cygdrive/c/temp/freemarker --strip-components=1 -xzf freemarker-2.3.8.tar.gz","To unpack freemarker:
`
tar -xzf freemarker-2.3.8.tar.gz freemarker-2.3.8/lib/freemarker.jar --strip=2
`

If we want the commands to be identical on all platforms than:
- to download freemarker:
`
wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker.tgz
`
@SueChaplain  note the output file `-O freemarker.tgz`

- to unpack:
`tar -xzf freemarker.tgz freemarker-2.3.8/lib/freemarker.jar --strip=2`
",
76315288,2b370f3de0cb7f7cc40c0ee14135272fffba84d0,buildenv/Build_Instructions_V9.md,False,"@@ -302,8 +302,102 @@ OpenJDK  - 437530c based on jdk-9+181)
 ## Windows
 :ledger:
 
-:construction:
-We haven't created a full build process for Windows yet? Watch this space!
+The following instructions guide you through the process of building a Windows OpenJDK V9 binary that contains Eclipse OpenJ9. This process can be used to build binaries for Windows 7, 8, and 10.
+
+### 1. Prepare your system
+:ledger:
+You must install a number of software dependencies to create a suitable build environment on your system:
+
+- [Cygwin](https://cygwin.com/install.html), which provides a Unix-style command line interface. Install all packages in the `Devel` category. In the `Archive` category, install the packages `zip` and `unzip`. Install any further package dependencies that are identified by the installer. More information about using Cygwin can be found [here](https://cygwin.com/docs.html).
+- [Windows JDK 8](https://adoptopenjdk.net/releases.html#x64_win), which is used as the boot JDK.
+- [Microsoft Visual Studio 2013]( https://go.microsoft.com/fwlink/?LinkId=532495), which is the same compiler level used by OpenJDK. Later levels of this compiler are not supported.
+- [Freemarker V2.3.8](https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download)
+- [Freetype2 V2.3](https://www.freetype.org/download.html)
+
+
+   You can download Visual Studio, Freemarker, and Freetype manually or obtain them using the [wget](http://www.gnu.org/software/wget/faq.html#download) utility. If you choose to use `wget`, follow these steps:
+
+- Open a cygwin terminal and change to the `/temp` directory:
+```
+cd /cygdrive/c/temp
+```
+
+- Run the following commands:
+```
+wget https://go.microsoft.com/fwlink/?LinkId=532495 -O vs2013.exe
+wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker-2.3.8.tar.gz
+wget http://download.savannah.gnu.org/releases/freetype/freetype-2.5.3.tar.gz
+```
+- Before installing Visual Studio, change the permissions on the installation file by running `chmod u+x vs2013.exe`.
+- Install Visual Studio by running the file `vs2013.exe`. 
+
+- To unpack the Freemarker and Freetype compressed files, run:
+```
+tar --one-top-level=/cygdrive/c/temp/freemarker --strip-components=1 -xzf freemarker-2.3.8.tar.gz","Where possible, the instructions should be the same across all platforms.  Longer term, it makes sense to have a single set of instructions with only the platform setup being different.",
76359319,2b370f3de0cb7f7cc40c0ee14135272fffba84d0,buildenv/Build_Instructions_V9.md,True,"@@ -302,8 +302,102 @@ OpenJDK  - 437530c based on jdk-9+181)
 ## Windows
 :ledger:
 
-:construction:
-We haven't created a full build process for Windows yet? Watch this space!
+The following instructions guide you through the process of building a Windows OpenJDK V9 binary that contains Eclipse OpenJ9. This process can be used to build binaries for Windows 7, 8, and 10.
+
+### 1. Prepare your system
+:ledger:
+You must install a number of software dependencies to create a suitable build environment on your system:
+
+- [Cygwin](https://cygwin.com/install.html), which provides a Unix-style command line interface. Install all packages in the `Devel` category. In the `Archive` category, install the packages `zip` and `unzip`. Install any further package dependencies that are identified by the installer. More information about using Cygwin can be found [here](https://cygwin.com/docs.html).
+- [Windows JDK 8](https://adoptopenjdk.net/releases.html#x64_win), which is used as the boot JDK.
+- [Microsoft Visual Studio 2013]( https://go.microsoft.com/fwlink/?LinkId=532495), which is the same compiler level used by OpenJDK. Later levels of this compiler are not supported.
+- [Freemarker V2.3.8](https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download)
+- [Freetype2 V2.3](https://www.freetype.org/download.html)
+
+
+   You can download Visual Studio, Freemarker, and Freetype manually or obtain them using the [wget](http://www.gnu.org/software/wget/faq.html#download) utility. If you choose to use `wget`, follow these steps:
+
+- Open a cygwin terminal and change to the `/temp` directory:
+```
+cd /cygdrive/c/temp
+```
+
+- Run the following commands:
+```
+wget https://go.microsoft.com/fwlink/?LinkId=532495 -O vs2013.exe
+wget https://sourceforge.net/projects/freemarker/files/freemarker/2.3.8/freemarker-2.3.8.tar.gz/download -O freemarker-2.3.8.tar.gz
+wget http://download.savannah.gnu.org/releases/freetype/freetype-2.5.3.tar.gz
+```
+- Before installing Visual Studio, change the permissions on the installation file by running `chmod u+x vs2013.exe`.
+- Install Visual Studio by running the file `vs2013.exe`. 
+
+- To unpack the Freemarker and Freetype compressed files, run:
+```
+tar --one-top-level=/cygdrive/c/temp/freemarker --strip-components=1 -xzf freemarker-2.3.8.tar.gz","I updated the wget command for freemarker, modified the tar command to put freemarker.jar in the root, and reverted the change I made to configure that previously fixed the path. 

It's a shame that we still have differences in the configure between platforms, but I agree that we should try and create platform specific sections for preparing your build environment and try to merge the other sections. Would be nice to see ARM and z/OS before doing this, but not sure what progress is being made for these.",
76779277,509484d46aa697ce25afdb979ceebfd052966af2,runtime/j9vm/jvm.c,False,"@@ -859,7 +859,7 @@ getj9bin()
 /* misnamed - returns the directory that the jvm DLL is found in, NOT the directory that the J9 VM itself is in. */
 
 J9StringBuffer *result = NULL;
-#if defined(LINUX) && !defined(J9ZTPF)
+#if defined(LINUX) || defined(OSX) && !defined(J9ZTPF)","I think parentheses are needed here, i.e. it should be
```
#if (defined(LINUX) || defined(OSX)) && !defined(J9ZTPF)
```",
76803218,e3e944b8b8a6117c4a4da3e2b905e926b7bb34ca,runtime/j9vm/jvm.c,False,"@@ -859,7 +859,7 @@ getj9bin()
 /* misnamed - returns the directory that the jvm DLL is found in, NOT the directory that the J9 VM itself is in. */
 
 J9StringBuffer *result = NULL;
-#if defined(LINUX) || defined(OSX) && !defined(J9ZTPF)
+#if (defined(LINUX) || defined(OSX)) && !defined(J9ZTPF)","Can you clarify how this is a `fix`?  A || B && !C is the same result with or without the bracket.

Further, ZTPF logically connects to LINUX, not to OSX.  If you were going to change this, it would be 
`#if ((defined(LINUX) && !defined(J9ZTPF)) || defined(OSX)`",
76823814,e3e944b8b8a6117c4a4da3e2b905e926b7bb34ca,runtime/j9vm/jvm.c,True,"@@ -859,7 +859,7 @@ getj9bin()
 /* misnamed - returns the directory that the jvm DLL is found in, NOT the directory that the J9 VM itself is in. */
 
 J9StringBuffer *result = NULL;
-#if defined(LINUX) || defined(OSX) && !defined(J9ZTPF)
+#if (defined(LINUX) || defined(OSX)) && !defined(J9ZTPF)","`&&` has higher precedence than `||` so the old condition was equivalent to
```
#if defined(LINUX) || (defined(OSX) && !defined(J9ZTPF))
```
@DanHeidinga If ZTPF is more closely related to LINUX, then your proposal would be better.",
76833371,e3e944b8b8a6117c4a4da3e2b905e926b7bb34ca,runtime/j9vm/jvm.c,False,"@@ -859,7 +859,7 @@ getj9bin()
 /* misnamed - returns the directory that the jvm DLL is found in, NOT the directory that the J9 VM itself is in. */
 
 J9StringBuffer *result = NULL;
-#if defined(LINUX) || defined(OSX) && !defined(J9ZTPF)
+#if (defined(LINUX) || defined(OSX)) && !defined(J9ZTPF)",Thanks for clarifying the precedence rules.  That's great info to include when creating this kind of PR in the future.  Thanks @keithc-ca ,
76916932,b714d0ac6d6d7364a69de2f2e65a9ac53842f0fa,test/Java9andUp/build.xml,False,"@@ -61,8 +62,9 @@
 <javac srcdir=""${src}"" destdir=""${build}"" debug=""true"" fork=""true"" executable=""${compiler.javac}"" includeAntRuntime=""false"" encoding=""ISO-8859-1"">
 <src path=""${src}""/>
 <src path=""${src_current}""/>
+<src path=""${TestUtilities}"" />","Does it make sense to just include the attachAPI related java files? TestUtilities will have utils for other projects in the future, so it is unnecessary to build entire TestUtilities project.",
76931881,b714d0ac6d6d7364a69de2f2e65a9ac53842f0fa,test/Java9andUp/build.xml,True,"@@ -61,8 +62,9 @@
 <javac srcdir=""${src}"" destdir=""${build}"" debug=""true"" fork=""true"" executable=""${compiler.javac}"" includeAntRuntime=""false"" encoding=""ISO-8859-1"">
 <src path=""${src}""/>
 <src path=""${src_current}""/>
+<src path=""${TestUtilities}"" />","Given that TestUtilities is small at present and should not grow quickly (compared to the test directories), I suggest including the whole thing in the interest of simplicity. We can refactor later if it becomes an issue.",
76928607,374e1422b51480fed63d6f975caf3d89e5734211,test/TestConfig/scripts/tools/getDependencies.pl,False,"@@ -136,19 +136,21 @@
 }
 }
 
-# TODO check samtools.jar file
+# TODO check asmtools.jar file
 if (index($jars_info[$i]{fname}, ""asmtools"") != -1) {
-my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
-if ($? != 0 ) {
-print $untar;
-die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+if (! -e ""$path/asmtools.jar""){
+my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;",Variable name and command does not match.,
76928807,374e1422b51480fed63d6f975caf3d89e5734211,test/TestConfig/scripts/tools/getDependencies.pl,False,"@@ -136,19 +136,21 @@
 }
 }
 
-# TODO check samtools.jar file
+# TODO check asmtools.jar file
 if (index($jars_info[$i]{fname}, ""asmtools"") != -1) {
-my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
-if ($? != 0 ) {
-print $untar;
-die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+if (! -e ""$path/asmtools.jar""){
+my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
+if ($? != 0 ) {
+print $untar;
+die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+}","Instead of writing detailed message, please use variable $untar.",
76929751,374e1422b51480fed63d6f975caf3d89e5734211,test/TestConfig/scripts/tools/getDependencies.pl,False,"@@ -136,19 +136,21 @@
 }
 }
 
-# TODO check samtools.jar file
+# TODO check asmtools.jar file
 if (index($jars_info[$i]{fname}, ""asmtools"") != -1) {
-my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
-if ($? != 0 ) {
-print $untar;
-die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+if (! -e ""$path/asmtools.jar""){
+my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
+if ($? != 0 ) {
+print $untar;
+die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+}
+my $unzip = `unzip -o $path/asmtools-6.0.zip -d $path`;
+if ($? != 0 ) {
+print $unzip;
+die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""","You can dong unzip, but message is untar. Instead of writing detailed message, please use variable. Otherwise, it is very easy to become out of sync.",
76938625,374e1422b51480fed63d6f975caf3d89e5734211,test/TestConfig/scripts/tools/getDependencies.pl,True,"@@ -136,19 +136,21 @@
 }
 }
 
-# TODO check samtools.jar file
+# TODO check asmtools.jar file
 if (index($jars_info[$i]{fname}, ""asmtools"") != -1) {
-my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
-if ($? != 0 ) {
-print $untar;
-die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+if (! -e ""$path/asmtools.jar""){
+my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;",all the uncompress process is for get the final asmtools.jar. The archived file is `asmtools-6.0.tar.gz` but the file we want is `asmtools.jar`,
76939175,374e1422b51480fed63d6f975caf3d89e5734211,test/TestConfig/scripts/tools/getDependencies.pl,True,"@@ -136,19 +136,21 @@
 }
 }
 
-# TODO check samtools.jar file
+# TODO check asmtools.jar file
 if (index($jars_info[$i]{fname}, ""asmtools"") != -1) {
-my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
-if ($? != 0 ) {
-print $untar;
-die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+if (! -e ""$path/asmtools.jar""){
+my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
+if ($? != 0 ) {
+print $untar;
+die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+}",updated,
76939184,374e1422b51480fed63d6f975caf3d89e5734211,test/TestConfig/scripts/tools/getDependencies.pl,True,"@@ -136,19 +136,21 @@
 }
 }
 
-# TODO check samtools.jar file
+# TODO check asmtools.jar file
 if (index($jars_info[$i]{fname}, ""asmtools"") != -1) {
-my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
-if ($? != 0 ) {
-print $untar;
-die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+if (! -e ""$path/asmtools.jar""){
+my $untar = `tar -zxvf $path/asmtools-6.0.tar.gz -C $path`;
+if ($? != 0 ) {
+print $untar;
+die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""
+}
+my $unzip = `unzip -o $path/asmtools-6.0.zip -d $path`;
+if ($? != 0 ) {
+print $unzip;
+die ""ERROR: untar $path/asmtools-6.0.tar.gz failed""",updated,
77170013,b714d0ac6d6d7364a69de2f2e65a9ac53842f0fa,test/Java9andUp/build.xml,False,"@@ -61,8 +62,9 @@
 <javac srcdir=""${src}"" destdir=""${build}"" debug=""true"" fork=""true"" executable=""${compiler.javac}"" includeAntRuntime=""false"" encoding=""ISO-8859-1"">
 <src path=""${src}""/>
 <src path=""${src_current}""/>
+<src path=""${TestUtilities}"" />","Personally, I think if we include the whole project, it will be harder for us to identify the reference between test projects and TestUtilities during refactoring time. However, if including attachAPI related java files will make the code too complicated, then I am ok with the change.",
77013881,a05cc32367bcc82d757659b5e3e04cb51dbd6581,test/Jsr292/testngSE90.xml,False,"@@ -30,7 +30,6 @@
 <test name=""jsr292Test"">
 <classes>
 <class name=""com.ibm.j9.jsr292.AdaptorTests""/>
-<class name=""com.ibm.j9.jsr292.LookupInTests""/>","Is this only invalid for Java 9?  If its invalid everywhere, should it be deleted?",
77151107,a05cc32367bcc82d757659b5e3e04cb51dbd6581,test/Jsr292/testngSE90.xml,True,"@@ -30,7 +30,6 @@
 <test name=""jsr292Test"">
 <classes>
 <class name=""com.ibm.j9.jsr292.AdaptorTests""/>
-<class name=""com.ibm.j9.jsr292.LookupInTests""/>","This test file `LookupInTests` in Jsr292 folder only applies to Java8 and Java9 lower than b148. There is another `LookupInTests` in OpenJ9_Jsr_292_API folder which has been updated for Openj9. 

As we don't care b148 anymore, once another PR (https://github.com/eclipse/openj9/pull/281) merged into OpenJ9_Jsr_292_API, I think these two project should be merged together by using src80 and src90 folders to separate codes for different versions.",
77185372,a05cc32367bcc82d757659b5e3e04cb51dbd6581,test/Jsr292/testngSE90.xml,False,"@@ -30,7 +30,6 @@
 <test name=""jsr292Test"">
 <classes>
 <class name=""com.ibm.j9.jsr292.AdaptorTests""/>
-<class name=""com.ibm.j9.jsr292.LookupInTests""/>",Thanks for the clarification on the planned approach @TianyuZuo!  Is there a overall issue tracking this plan and the follow-on work?,
77185543,b714d0ac6d6d7364a69de2f2e65a9ac53842f0fa,test/Java9andUp/build.xml,True,"@@ -61,8 +62,9 @@
 <javac srcdir=""${src}"" destdir=""${build}"" debug=""true"" fork=""true"" executable=""${compiler.javac}"" includeAntRuntime=""false"" encoding=""ISO-8859-1"">
 <src path=""${src}""/>
 <src path=""${src_current}""/>
+<src path=""${TestUtilities}"" />","Lan
 I�d like to hear more about how you would like to see the directory structured.
Have multiple source directories (e.g. AttachApi, StackWalker) in the TestUtilities project and add them selectively to the test projects (e.g. Java9AndUp)?  I could go for that.",
75894358,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/UmaFlagInfo.java,False,"@@ -0,0 +1,76 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.oti.VMCPTool;
+
+import java.util.HashSet;
+import java.util.Set;
+
+
+import com.ibm.j9tools.om.BuildSpec;
+import com.ibm.j9tools.om.ConfigDirectory;
+import com.ibm.j9tools.om.Flag;
+import com.ibm.j9tools.om.FlagDefinitions;
+import com.ibm.j9tools.om.ObjectFactory;
+
+class UmaFlagInfo  implements IFlagInfo{
+
+private BuildSpec buildSpec;
+private FlagDefinitions flagDefs;
+
+public UmaFlagInfo(String configDirectory, String buildSpecId) throws Throwable{
+ObjectFactory factory = new ObjectFactory(new ConfigDirectory(configDirectory));
+factory.initialize();
+buildSpec = factory.getBuildSpec(buildSpecId);
+flagDefs = factory.getFlagDefinitions();
+}
+
+public Set<String> getAllSetFlags() {
+HashSet<String> allSetFlags = new HashSet<String>();
+for( String flagId : buildSpec.getFlags().keySet() ) {
+if ( isFlagSet(flagId) ) { 
+allSetFlags.add(flagId);
+}
+}
+
+return allSetFlags;
+}
+
+public boolean isFlagValid(String flag){
+flag = Util.transformFlag(flag);
+if (flagDefs.getFlagDefinition(flag) == null ) {
+return false;
+}
+return true;
+}
+
+// Stolen from com.ibm.j9.uma.configuration.ConfigurationImpl","Lets remove this comment, it won't be relevant after uma is no longer in use, and it was already remove from the previous methods in this class.",
75894383,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/Util.java,False,"@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.oti.VMCPTool;
+
+public class Util {
+
+// Stolen from com.ibm.j9.uma.configuration.ConfigurationImpl","Lets remove this comment, it won't be relevant after uma is no longer in use.",
75894692,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/Main.java,False,"@@ -202,17 +204,52 @@ private static boolean parseOptions(String[] args) {
 buildSpecId = args[++i];
 } else if (arg.equalsIgnoreCase(optionOutputDir)) {
 outputDirectory = args[++i];
+} else if (arg.equalsIgnoreCase(optionCmakeCache)) {
+cmakeCache = args[++i];
+} else {
+System.err.printf(""Unrecognized option '%s'\n"", arg);
+return false;
 }
 }
 } catch (ArrayIndexOutOfBoundsException e) {
 return false;
 }
-
-return jcls != null && rootDirectory != null && configDirectory != null && buildSpecId != null;
+
+boolean isValid = true;
+if (jcls == null) {
+System.err.printf(""ERROR: required argument '%s' not given\n"", optionJcls);
+isValid = false;
+}
+
+if (rootDirectory == null) {
+System.err.printf(""ERROR: required argument '%s' not given\n"", optionRootDir);
+isValid = false;
+}
+
+if (cmakeCache == null ) {
+if (configDirectory == null){",Please add a space in `){`,
75894944,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/Main.java,False,"@@ -221,85 +258,23 @@ public static void main(String[] args) throws Throwable {
 System.exit(0);
 }
 
-ObjectFactory factory = new ObjectFactory(new ConfigDirectory(configDirectory));
-factory.initialize();
-buildSpec = factory.getBuildSpec(buildSpecId);
-flagDefs = factory.getFlagDefinitions();
-
-ConstantPool pool = parseConstantPool();
-
+if (cmakeCache != null){",Please add a space in `){`,
75895126,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/Main.java,False,"@@ -221,85 +258,23 @@ public static void main(String[] args) throws Throwable {
 System.exit(0);
 }
 
-ObjectFactory factory = new ObjectFactory(new ConfigDirectory(configDirectory));
-factory.initialize();
-buildSpec = factory.getBuildSpec(buildSpecId);
-flagDefs = factory.getFlagDefinitions();
-
-ConstantPool pool = parseConstantPool();
-
+if (cmakeCache != null){
+if (configDirectory != null)
+System.err.println(""Ignoring option "" + optionConfigDir);",its preferred to use {} brackets to avoid potential problems in the future if the code is modified.,
75895467,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/CmakeFlagInfo.java,False,"@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.oti.VMCPTool;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+
+
+class CmakeFlagInfo  implements IFlagInfo{
+private HashSet<String> seenFlags = new HashSet<String>();
+private HashSet<String> setFlags = new HashSet<String>();
+
+// Convert string  to  bool unsing same rules as cmake
+private static boolean strToBool(String str){",Please add a space in `){`,
75895496,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/CmakeFlagInfo.java,False,"@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.oti.VMCPTool;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+
+
+class CmakeFlagInfo  implements IFlagInfo{
+private HashSet<String> seenFlags = new HashSet<String>();
+private HashSet<String> setFlags = new HashSet<String>();
+
+// Convert string  to  bool unsing same rules as cmake
+private static boolean strToBool(String str){
+str = str.trim().toUpperCase();
+if(str.isEmpty() || str.equals(""NO"") || str.equals(""FALSE"") || str.equals(""OFF"") || str.endsWith(""-NOTFOUND""))
+return false;
+
+return true;
+}
+
+public CmakeFlagInfo(String cacheInfo) throws Throwable {
+// CMake cache file lines look like this:
+// <VariableName>:<Type>=<Value>
+
+// Pick out any lines Where <Type> == BOOL
+Pattern cacheVarPattern = Pattern.compile(""([a-zA-Z0-9_]+):BOOL=(.*)$"");
+BufferedReader reader = new BufferedReader(new FileReader(cacheInfo));
+String line;
+
+while (null != (line = reader.readLine())) {
+Matcher matcher = cacheVarPattern.matcher(line);
+if (matcher.matches()) {
+
+String flagName = matcher.group(1);
+boolean flagValue = strToBool(matcher.group(2));
+
+if (flagName.startsWith(""J9VM_"") ){
+flagName = Util.transformFlag(flagName);
+if (flagValue) {
+setFlags.add(flagName);
+} 
+seenFlags.add(flagName);
+
+}
+}
+}
+}
+
+public Set<String> getAllSetFlags() {
+return setFlags;
+}
+
+
+public boolean isFlagValid(String flagName){",Please add a space in `){`,
75895531,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/CmakeFlagInfo.java,False,"@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.oti.VMCPTool;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+
+
+class CmakeFlagInfo  implements IFlagInfo{
+private HashSet<String> seenFlags = new HashSet<String>();
+private HashSet<String> setFlags = new HashSet<String>();
+
+// Convert string  to  bool unsing same rules as cmake
+private static boolean strToBool(String str){
+str = str.trim().toUpperCase();
+if(str.isEmpty() || str.equals(""NO"") || str.equals(""FALSE"") || str.equals(""OFF"") || str.endsWith(""-NOTFOUND""))",Please add a space in `if(`,
75895575,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/CmakeFlagInfo.java,False,"@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.oti.VMCPTool;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+
+
+class CmakeFlagInfo  implements IFlagInfo{
+private HashSet<String> seenFlags = new HashSet<String>();
+private HashSet<String> setFlags = new HashSet<String>();
+
+// Convert string  to  bool unsing same rules as cmake
+private static boolean strToBool(String str){
+str = str.trim().toUpperCase();
+if(str.isEmpty() || str.equals(""NO"") || str.equals(""FALSE"") || str.equals(""OFF"") || str.endsWith(""-NOTFOUND""))",There is some extra whitespace after `if{`,
76953768,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/CmakeFlagInfo.java,False,"@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.oti.VMCPTool;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.regex.Pattern;
+import java.util.regex.Matcher;
+
+
+class CmakeFlagInfo implements IFlagInfo {
+private HashSet<String> seenFlags = new HashSet<String>();
+private HashSet<String> setFlags = new HashSet<String>();
+
+// Convert string  to  bool unsing same rules as cmake
+private static boolean strToBool(String str) {
+str = str.trim().toUpperCase();
+if (str.isEmpty() || str.equals(""NO"") || str.equals(""FALSE"") || str.equals(""OFF"") || str.endsWith(""-NOTFOUND"")) {
+return false;
+}
+return true;
+}
+
+public CmakeFlagInfo(String cacheInfo) throws Throwable {
+// CMake cache file lines look like this:
+// <VariableName>:<Type>=<Value>
+
+// Pick out any lines Where <Type> == BOOL
+Pattern cacheVarPattern = Pattern.compile(""([a-zA-Z0-9_]+):BOOL=(.*)$"");
+BufferedReader reader = new BufferedReader(new FileReader(cacheInfo));
+String line;
+
+while (null != (line = reader.readLine())) {
+Matcher matcher = cacheVarPattern.matcher(line);
+if (matcher.matches()) {
+
+String flagName = matcher.group(1);
+boolean flagValue = strToBool(matcher.group(2));
+
+if (flagName.startsWith(""J9VM_"") ){","Missing space in ""){""",
76953832,d98faaccd200ef4f5c6d92413ba2c115bd5380f2,sourcetools/j9constantpool/com/ibm/oti/VMCPTool/UmaFlagInfo.java,False,"@@ -0,0 +1,75 @@
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+package com.ibm.oti.VMCPTool;
+
+import java.util.HashSet;
+import java.util.Set;
+
+
+import com.ibm.j9tools.om.BuildSpec;
+import com.ibm.j9tools.om.ConfigDirectory;
+import com.ibm.j9tools.om.Flag;
+import com.ibm.j9tools.om.FlagDefinitions;
+import com.ibm.j9tools.om.ObjectFactory;
+
+class UmaFlagInfo  implements IFlagInfo{
+
+private BuildSpec buildSpec;
+private FlagDefinitions flagDefs;
+
+public UmaFlagInfo(String configDirectory, String buildSpecId) throws Throwable{
+ObjectFactory factory = new ObjectFactory(new ConfigDirectory(configDirectory));
+factory.initialize();
+buildSpec = factory.getBuildSpec(buildSpecId);
+flagDefs = factory.getFlagDefinitions();
+}
+
+public Set<String> getAllSetFlags() {
+HashSet<String> allSetFlags = new HashSet<String>();
+for ( String flagId : buildSpec.getFlags().keySet() ) {
+if ( isFlagSet(flagId) ) { 
+allSetFlags.add(flagId);
+}
+}
+
+return allSetFlags;
+}
+
+public boolean isFlagValid(String flag){","Missing space in ""){""",
75861341,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -1170,7 +1170,7 @@ static bool generateInlineTest(TR::CodeGenerator * cg, TR::Node * node, TR::Node
       if (cg->needClassAndMethodPointerRelocations())
          unloadableConstInstr[i] = generateRegLitRefInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, scratchReg,(uintptrj_t) guessClassArray[i], TR_ClassPointer, NULL, NULL, NULL);
       else
-         unloadableConstInstr[i] = generateRILInstruction(cg, TR::InstOpCode::LARL, node, scratchReg, (uintptrj_t)guessClassArray[i]);
+         unloadableConstInstr[i] = generateRILInstruction(cg, TR::InstOpCode::LARL, node, scratchReg, guessClassArray[i]);",Is this supposed to use the `void*` overload? Seems to be loading an address?,
75861341,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -1294,15 +1294,15 @@ VMnonNullSrcWrtBarCardCheckEvaluator(
       TR::InstOpCode::Mnemonic opSubtractReg = TR::InstOpCode::getSubstractRegOpCode();
       TR::InstOpCode::Mnemonic opSubtract = TR::InstOpCode::getSubstractOpCode();
       TR::InstOpCode::Mnemonic opCmpLog = TR::InstOpCode::getCmpLogicalOpCode();
-      uintptrj_t heapSize = (uintptrj_t) comp->getOptions()->getHeapSizeForBarrierRange0();
-      uintptrj_t heapBase = (uintptrj_t) comp->getOptions()->getHeapBaseForBarrierRange0();
+      uint32_t heapSize =  comp->getOptions()->getHeapSizeForBarrierRange0();
+      uint32_t heapBase =  comp->getOptions()->getHeapBaseForBarrierRange0();",This does not look correct. `uint32_t` is 32-bits. The return value of `getHeapSizeForBarrierRange0` on a 64-bit target will be 64-bit. Is this not a truncation operation?,
75861341,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -5814,7 +5814,7 @@ J9::Z::TreeEvaluator::VMgenCoreInstanceofEvaluator2(TR::Node * node, TR::CodeGen
                if (cg->needClassAndMethodPointerRelocations())
                   temp = generateRegLitRefInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, arbitraryClassReg1, (uintptrj_t) profiledClassesList[numPICs].profiledClass, TR_ClassPointer, NULL, NULL, NULL);
                else
-                  temp = generateRILInstruction(cg, TR::InstOpCode::LARL, node, arbitraryClassReg1, (uintptrj_t)profiledClassesList[numPICs].profiledClass);
+                  temp = generateRILInstruction(cg, TR::InstOpCode::LARL, node, arbitraryClassReg1, profiledClassesList[numPICs].profiledClass);",Is this supposed to use the `void*` overload? Seems to be loading an address? Similarly on the next change using `profiledClassesList`.,
75861341,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -7969,7 +7969,7 @@ genInitObjectHeader(TR::Node * node, TR::Instruction *& iCursor, TR_OpaqueClassB
             }
          if (canUseIIHF)
             {
-            iCursor = generateRILInstruction(cg, TR::InstOpCode::IIHF, node, enumReg, (intptr_t) classAddress | (intptrj_t)orFlag, iCursor);
+            iCursor = generateRILInstruction(cg, TR::InstOpCode::IIHF, node, enumReg, static_cast<uint32_t>(reinterpret_cast<uintptr_t>(classAddress)) | static_cast<uint32_t>(orFlag), iCursor);",Is there a typo here? Looks like we are mixing `uintptr_t` and `uint32_t` when doing the OR.,
76501584,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,True,"@@ -1170,7 +1170,7 @@ static bool generateInlineTest(TR::CodeGenerator * cg, TR::Node * node, TR::Node
       if (cg->needClassAndMethodPointerRelocations())
          unloadableConstInstr[i] = generateRegLitRefInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, scratchReg,(uintptrj_t) guessClassArray[i], TR_ClassPointer, NULL, NULL, NULL);
       else
-         unloadableConstInstr[i] = generateRILInstruction(cg, TR::InstOpCode::LARL, node, scratchReg, (uintptrj_t)guessClassArray[i]);
+         unloadableConstInstr[i] = generateRILInstruction(cg, TR::InstOpCode::LARL, node, scratchReg, guessClassArray[i]);","Yes, but I believe this is achieving that because `guessClassArray` is a `TR_OpaqueClassBlock*` so that maps to `void*`.",
76510202,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,True,"@@ -1294,15 +1294,15 @@ VMnonNullSrcWrtBarCardCheckEvaluator(
       TR::InstOpCode::Mnemonic opSubtractReg = TR::InstOpCode::getSubstractRegOpCode();
       TR::InstOpCode::Mnemonic opSubtract = TR::InstOpCode::getSubstractOpCode();
       TR::InstOpCode::Mnemonic opCmpLog = TR::InstOpCode::getCmpLogicalOpCode();
-      uintptrj_t heapSize = (uintptrj_t) comp->getOptions()->getHeapSizeForBarrierRange0();
-      uintptrj_t heapBase = (uintptrj_t) comp->getOptions()->getHeapBaseForBarrierRange0();
+      uint32_t heapSize =  comp->getOptions()->getHeapSizeForBarrierRange0();
+      uint32_t heapBase =  comp->getOptions()->getHeapBaseForBarrierRange0();","I do not believe my change here causes a functional change. Let me explain. We have 3 variables of interest:
`heapSize`
`heapBase`
`heapSum`

They are only used in:
`generateRILInstruction`
`generateS390CompareAndBranchInstruction`

Before my changes `generateRILInstruction` converted the `uintptrj_t` immediate to an `int32_t` in the `S390Instruction` constructor, so all my change does here is move that conversion further ""forward"".

`generateS390CompareAndBranchInstruction` takes an `int32_t` as well, so again I'm just moving the conversion ""forward"".

I agree this seems wrong, but perhaps this is a bug in the existing code? Do you have any suggestions?",
76513296,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,True,"@@ -5814,7 +5814,7 @@ J9::Z::TreeEvaluator::VMgenCoreInstanceofEvaluator2(TR::Node * node, TR::CodeGen
                if (cg->needClassAndMethodPointerRelocations())
                   temp = generateRegLitRefInstruction(cg, TR::InstOpCode::getLoadOpCode(), node, arbitraryClassReg1, (uintptrj_t) profiledClassesList[numPICs].profiledClass, TR_ClassPointer, NULL, NULL, NULL);
                else
-                  temp = generateRILInstruction(cg, TR::InstOpCode::LARL, node, arbitraryClassReg1, (uintptrj_t)profiledClassesList[numPICs].profiledClass);
+                  temp = generateRILInstruction(cg, TR::InstOpCode::LARL, node, arbitraryClassReg1, profiledClassesList[numPICs].profiledClass);",Similarly as above `profiledClass` is a  `TR_OpaqueClassBlock*` so this will call the `void*` overload as intended.,
76548490,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -1294,15 +1294,15 @@ VMnonNullSrcWrtBarCardCheckEvaluator(
       TR::InstOpCode::Mnemonic opSubtractReg = TR::InstOpCode::getSubstractRegOpCode();
       TR::InstOpCode::Mnemonic opSubtract = TR::InstOpCode::getSubstractOpCode();
       TR::InstOpCode::Mnemonic opCmpLog = TR::InstOpCode::getCmpLogicalOpCode();
-      uintptrj_t heapSize = (uintptrj_t) comp->getOptions()->getHeapSizeForBarrierRange0();
-      uintptrj_t heapBase = (uintptrj_t) comp->getOptions()->getHeapBaseForBarrierRange0();
+      uint32_t heapSize =  comp->getOptions()->getHeapSizeForBarrierRange0();
+      uint32_t heapBase =  comp->getOptions()->getHeapBaseForBarrierRange0();","Looks like `heapSize` and `heapBase` are only used withing the `if (constantHeapCase)` condition. This condition is defined as:

```
bool constantHeapCase = ((!comp->compileRelocatableCode()) && isConstantHeapBase && isConstantHeapSize && shiftAmount == 0 && (!is64Bit || TR::Compiler->om.generateCompressedObjectHeaders()));
```

Noteworthy here is `shiftAmount == 0` and the subsequent dual check for `!is64Bit`. This means we only enter this `if` condition if our heap fits within 32-bit. 

The only use of `generateRIL` is within the `if` condition so it would be incorrect to change the type of `heapSize` and `heapBase` to `uint32_t` since the variables are declared outside of the `if` condition.

We seem to have two choices (unless there are more?):

1. Lower the definition of `heapBase` and `heapSize` to be inside of `if (constantHeapCase)`, at which point their values are guaranteed to be 32-bit (we should probably note this via a comment)
2. Keep the definitions where they are, revert the type back to `uintptrj_t` and explicitly cast to `uint32_t` in the `if` where the variables are being used within `generateRILInstruction`

Do we agree?",
76551850,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,True,"@@ -7969,7 +7969,7 @@ genInitObjectHeader(TR::Node * node, TR::Instruction *& iCursor, TR_OpaqueClassB
             }
          if (canUseIIHF)
             {
-            iCursor = generateRILInstruction(cg, TR::InstOpCode::IIHF, node, enumReg, (intptr_t) classAddress | (intptrj_t)orFlag, iCursor);
+            iCursor = generateRILInstruction(cg, TR::InstOpCode::IIHF, node, enumReg, static_cast<uint32_t>(reinterpret_cast<uintptr_t>(classAddress)) | static_cast<uint32_t>(orFlag), iCursor);","Not a typo, although  see now the `static_cast` on the `orFlag` is unnecessary since it's declared as a `uint32_t`.

You can't use safe casting to cast `classAddress` to a `uint32_t`. It will complain:
`error: cast from 'TR_OpaqueClassBlock*' to 'uint32_t' loses precision`

The `OR` promotes the `orFlag` to a 64bit width so I needed to cast the result back down to `uint32_t` so it matches the overload.",
76556573,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,True,"@@ -1294,15 +1294,15 @@ VMnonNullSrcWrtBarCardCheckEvaluator(
       TR::InstOpCode::Mnemonic opSubtractReg = TR::InstOpCode::getSubstractRegOpCode();
       TR::InstOpCode::Mnemonic opSubtract = TR::InstOpCode::getSubstractOpCode();
       TR::InstOpCode::Mnemonic opCmpLog = TR::InstOpCode::getCmpLogicalOpCode();
-      uintptrj_t heapSize = (uintptrj_t) comp->getOptions()->getHeapSizeForBarrierRange0();
-      uintptrj_t heapBase = (uintptrj_t) comp->getOptions()->getHeapBaseForBarrierRange0();
+      uint32_t heapSize =  comp->getOptions()->getHeapSizeForBarrierRange0();
+      uint32_t heapBase =  comp->getOptions()->getHeapBaseForBarrierRange0();",Agreed. Going with option 1) with a comment.,
76557665,286845f0a19c45d6cffc7a87de974f70a14150d6,runtime/tr.source/trj9/z/codegen/J9TreeEvaluator.cpp,False,"@@ -7969,7 +7969,7 @@ genInitObjectHeader(TR::Node * node, TR::Instruction *& iCursor, TR_OpaqueClassB
             }
          if (canUseIIHF)
             {
-            iCursor = generateRILInstruction(cg, TR::InstOpCode::IIHF, node, enumReg, (intptr_t) classAddress | (intptrj_t)orFlag, iCursor);
+            iCursor = generateRILInstruction(cg, TR::InstOpCode::IIHF, node, enumReg, static_cast<uint32_t>(reinterpret_cast<uintptr_t>(classAddress)) | static_cast<uint32_t>(orFlag), iCursor);","Thanks, was just making sure this was well thought out and it is! Yes the cast on `orFlag` is unnecessary.",
75804711,144955a297c73fe2691c010b7eff20e88e68dc25,runtime/tr.source/trj9/optimizer/J9Optimizer.cpp,False,"@@ -665,6 +665,7 @@ static const OptimizationStrategy cheapWarmStrategyOpts[] =
    { OMR::blockShuffling                                                             },
    { OMR::idiomRecognition,                          OMR::IfLoopsAndNotProfiling     },",Is `idiomRecognition` intended to be duplicated on s390 or should it have been deleted from the #ifdef block?,
75806841,144955a297c73fe2691c010b7eff20e88e68dc25,runtime/tr.source/trj9/optimizer/J9Optimizer.cpp,False,"@@ -665,6 +665,7 @@ static const OptimizationStrategy cheapWarmStrategyOpts[] =
    { OMR::blockShuffling                                                             },
    { OMR::idiomRecognition,                          OMR::IfLoopsAndNotProfiling     },",This shouldn't be duplicated it should be pulled out of the ifdef,
76191384,144955a297c73fe2691c010b7eff20e88e68dc25,runtime/tr.source/trj9/optimizer/J9Optimizer.cpp,False,"@@ -665,6 +665,7 @@ static const OptimizationStrategy cheapWarmStrategyOpts[] =
    { OMR::blockShuffling                                                             },
    { OMR::idiomRecognition,                          OMR::IfLoopsAndNotProfiling     },",Good catch @DanHeidinga. It should **not** be duplicated.,
77200507,a05cc32367bcc82d757659b5e3e04cb51dbd6581,test/Jsr292/testngSE90.xml,True,"@@ -30,7 +30,6 @@
 <test name=""jsr292Test"">
 <classes>
 <class name=""com.ibm.j9.jsr292.AdaptorTests""/>
-<class name=""com.ibm.j9.jsr292.LookupInTests""/>",Created an issue to tracking this plan. https://github.com/eclipse/openj9/issues/607,
77201579,b714d0ac6d6d7364a69de2f2e65a9ac53842f0fa,test/Java9andUp/build.xml,True,"@@ -61,8 +62,9 @@
 <javac srcdir=""${src}"" destdir=""${build}"" debug=""true"" fork=""true"" executable=""${compiler.javac}"" includeAntRuntime=""false"" encoding=""ISO-8859-1"">
 <src path=""${src}""/>
 <src path=""${src_current}""/>
+<src path=""${TestUtilities}"" />","To clarify, TestUtilities is only for utility classes used by multiple test projects.  Utilities used be a single test project should live in that project.",
73380543,519b0d27e4b574528100a898b93864de499b0677,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,False,"@@ -1206,7 +1206,7 @@ public final Module getUnnamedModule()
 final Class<?> loadClass(Module module, String className) {
 Class<?> localClass = null;
 try {
-localClass = loadClassHelper(className, false, false, module);
+localClass = loadClassHelper(className, false, true, module);",The method comment needs updating to match.,
73559973,519b0d27e4b574528100a898b93864de499b0677,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,True,"@@ -1206,7 +1206,7 @@ public final Module getUnnamedModule()
 final Class<?> loadClass(Module module, String className) {
 Class<?> localClass = null;
 try {
-localClass = loadClassHelper(className, false, false, module);
+localClass = loadClassHelper(className, false, true, module);",Updated.,
76611018,519b0d27e4b574528100a898b93864de499b0677,test/Java9andUp/src_latest/org/openj9/test/java/lang/Test_Class.java,False,"@@ -0,0 +1,63 @@
+package org.openj9.test.java.lang;
+
+import java.lang.Class;
+import java.lang.ClassNotFoundException;
+import java.lang.Module;
+import java.security.AllPermission;
+
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+import org.testng.AssertJUnit;
+
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+@Test(groups = { ""level.extended"" })
+@SuppressWarnings(""nls"")
+public class Test_Class {
+
+public static AllPermissionALL_PERMISSION = new AllPermission();
+
+/**
+ * @tests java.lang.Class#forName(java.lang.String)
+ * @tests java.lang.Class#forName(java.lang.Module, java.lang.String)
+ */
+@Test
+public void test_forName() {
+try {
+Class<?> jrAccessExceptionClz = Class.forName(""java.rmi.AccessException"");
+AssertJUnit.assertNotNull(jrAccessExceptionClz);
+if (!jrAccessExceptionClz.getProtectionDomain().implies(ALL_PERMISSION)) {
+AssertJUnit.fail(""java.rmi.AccessException should have all permission!"");
+}
+
+Module  jrModule = jrAccessExceptionClz.getModule();
+Class<?> srrRegistryImplClz = Class.forName(jrModule, ""sun.rmi.registry.RegistryImpl"");",It would be better to load a class from an exported package to avoid export problems in the future when the default access controls are changed.,
76625511,519b0d27e4b574528100a898b93864de499b0677,test/Java9andUp/src_latest/org/openj9/test/java/lang/Test_Class.java,True,"@@ -0,0 +1,63 @@
+package org.openj9.test.java.lang;
+
+import java.lang.Class;
+import java.lang.ClassNotFoundException;
+import java.lang.Module;
+import java.security.AllPermission;
+
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+import org.testng.AssertJUnit;
+
+/*******************************************************************************
+ * Copyright (c) 2017, 2017 IBM Corp. and others
+ *
+ * This program and the accompanying materials are made available under
+ * the terms of the Eclipse Public License 2.0 which accompanies this
+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/
+ * or the Apache License, Version 2.0 which accompanies this distribution and
+ * is available at https://www.apache.org/licenses/LICENSE-2.0.
+ *
+ * This Source Code may also be made available under the following
+ * Secondary Licenses when the conditions for such availability set
+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU
+ * General Public License, version 2 with the GNU Classpath
+ * Exception [1] and GNU General Public License, version 2 with the
+ * OpenJDK Assembly Exception [2].
+ *
+ * [1] https://www.gnu.org/software/classpath/license.html
+ * [2] http://openjdk.java.net/legal/assembly-exception.html
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
+ *******************************************************************************/
+
+@Test(groups = { ""level.extended"" })
+@SuppressWarnings(""nls"")
+public class Test_Class {
+
+public static AllPermissionALL_PERMISSION = new AllPermission();
+
+/**
+ * @tests java.lang.Class#forName(java.lang.String)
+ * @tests java.lang.Class#forName(java.lang.Module, java.lang.String)
+ */
+@Test
+public void test_forName() {
+try {
+Class<?> jrAccessExceptionClz = Class.forName(""java.rmi.AccessException"");
+AssertJUnit.assertNotNull(jrAccessExceptionClz);
+if (!jrAccessExceptionClz.getProtectionDomain().implies(ALL_PERMISSION)) {
+AssertJUnit.fail(""java.rmi.AccessException should have all permission!"");
+}
+
+Module  jrModule = jrAccessExceptionClz.getModule();
+Class<?> srrRegistryImplClz = Class.forName(jrModule, ""sun.rmi.registry.RegistryImpl"");",Will replace it with `java.rmi.AlreadyBoundException` instead.,
76861279,519b0d27e4b574528100a898b93864de499b0677,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,False,"@@ -1205,10 +1205,15 @@ public final Module getUnnamedModule()
  */
 final Class<?> loadClass(Module module, String className) {
 Class<?> localClass = null;
-try {
-localClass = loadClassHelper(className, false, false, module);
-} catch (ClassNotFoundException e) {
-// returns null if the class can't be found
+
+if ((bootstrapClassLoader == null) || (this == bootstrapClassLoader)) {",Shouldn't the fix go into loadClassHelper() so other callers of loadClassHelper() get the same benefits?,
76866558,519b0d27e4b574528100a898b93864de499b0677,jcl/src/java.base/share/classes/java/lang/ClassLoader.java,True,"@@ -1205,10 +1205,15 @@ public final Module getUnnamedModule()
  */
 final Class<?> loadClass(Module module, String className) {
 Class<?> localClass = null;
-try {
-localClass = loadClassHelper(className, false, false, module);
-} catch (ClassNotFoundException e) {
-// returns null if the class can't be found
+
+if ((bootstrapClassLoader == null) || (this == bootstrapClassLoader)) {","Do you mean moving this code snippet from `loadClass (className)` and `loadClass(module, className)` into `loadClassHelper()`?
`BOOT_LOADER` extends `BuiltinClassLoader` which overrides `loadClass(className, resolveClass)`, hence `BOOT_LOADER.loadClass (className)` will invoke this overridden method and miss the check for bootstrap classloader within `loadClassHelper()` hence can't call `VMAccess.findClassOrNull(className, bootstrapClassLoader)` for bootstrap classes. I think this was the main reason we put this checking code snippet within `loadClass (className)`. This PR adds the check for `loadClass(module, className)` as well.
This is for bootstrap classloader class loading, other classloader use scenarios don't need this check.",
